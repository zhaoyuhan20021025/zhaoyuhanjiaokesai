"use strict";
/**
 * @file mapvgl可视化图层
 * @author hedongran
 * @email hdr01@126.com
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
// @ts-ignore
var mapvgl = tslib_1.__importStar(require("mapvgl"));
// @ts-ignore
var mapvglThree = tslib_1.__importStar(require("mapvgl/dist/mapvgl.threelayers.min"));
var common_1 = require("../common");
var MapvglView_1 = require("./MapvglView");
;
/**
 * 该组件将MapVGL的图层使用`react`进行了一层封装。具体关于MapVGL有哪些图层，以及图层的属性，请查阅[MapVGL文档](https://mapv.baidu.com/gl/docs/)
 * @visibleName MapvglLayer MapVGL图层
 */
var MapvglLayer = /** @class */ (function (_super) {
    tslib_1.__extends(MapvglLayer, _super);
    function MapvglLayer(props) {
        var _this = _super.call(this, props) || this;
        _this._createLayer = false;
        var self = _this;
        if (_this.props.getMethods) {
            _this.props.getMethods({
                setViewport: _this.setViewport.bind(self)
            });
        }
        return _this;
    }
    MapvglLayer.prototype.componentDidMount = function () {
        this.initialize();
    };
    MapvglLayer.prototype.componentWillUnmount = function () {
        this.destroy();
    };
    MapvglLayer.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, type = _a.type, data = _a.data, options = _a.options, autoViewport = _a.autoViewport;
        var preType = prevProps.type, preData = prevProps.data, preOptions = prevProps.options, preViewport = prevProps.autoViewport;
        if (!this.map || !this.layer) {
            this.initialize();
            return;
        }
        if (type !== preType) {
            this.destroy();
            this.initialize();
            return;
        }
        if (JSON.stringify(preOptions) !== JSON.stringify(options)) {
            this.layer.setOptions(options);
        }
        if (JSON.stringify(preData) !== JSON.stringify(data)) {
            this.layer.setData(data);
        }
        if (autoViewport && (JSON.stringify(preData) !== JSON.stringify(data) || autoViewport !== preViewport)) {
            this.setViewport();
        }
    };
    MapvglLayer.prototype.destroy = function () {
        if (this.layer && this.view) {
            this._createLayer = false;
            this.view.removeLayer(this.layer);
            this.layer.destroy();
            // @ts-ignore
            this.layer = null;
        }
    };
    MapvglLayer.prototype.initialize = function () {
        var map = this.map = this.getMap();
        var view = this.view = this.props.view || this.context.view;
        if (!map || !view) {
            return;
        }
        if (!this._createLayer) {
            this.createLayers();
        }
        this.layer.setData(this.props.data);
        if (this.props.autoViewport) {
            this.setViewport();
        }
    };
    MapvglLayer.prototype.setViewport = function () {
        var isMC = this.props.coordType === 'bd09mc';
        var getPoint = function (coordinate) {
            var p = new BMapGL.Point(coordinate[0], coordinate[1]);
            return isMC ? BMapGL.Projection.convertMC2LL(p) : p;
        };
        var points = [];
        this.props.data.forEach(function (data) {
            if (data.geometry.type === 'Point') {
                points.push(getPoint(data.geometry.coordinates));
            }
            else if (data.geometry.type === 'LineString') {
                data.geometry.coordinates.forEach(function (item) {
                    points.push(getPoint(item));
                });
            }
            else if (data.geometry.type === 'Polygon') {
                data.geometry.coordinates[0].forEach(function (item) {
                    points.push(getPoint(item));
                });
            }
            else if (data.geometry.type === 'MultiPolygon') {
                data.geometry.coordinates.forEach(function (polygon) {
                    polygon[0].forEach(function (item) {
                        points.push(getPoint(item));
                    });
                });
            }
        });
        if (points.length > 0) {
            this.map.setViewport(points, this.props.viewportOptions || {});
        }
    };
    MapvglLayer.prototype.createLayers = function () {
        if (mapvgl[this.props.type] || mapvglThree[this.props.type]) {
            this._createLayer = true;
            var Constructor = mapvgl[this.props.type] ? mapvgl : mapvglThree;
            this.layer = new Constructor[this.props.type](this.props.options);
            this.view.addLayer(this.layer);
        }
        else {
            console.error("mapvgl doesn't have layer " + this.props.type + "!");
        }
    };
    MapvglLayer.prototype.render = function () {
        return null;
    };
    MapvglLayer.contextType = MapvglView_1.ViewContext;
    return MapvglLayer;
}(common_1.Component));
exports.default = MapvglLayer;
