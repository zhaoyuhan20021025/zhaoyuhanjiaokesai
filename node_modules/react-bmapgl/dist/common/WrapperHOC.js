"use strict";
/**
 * @file 地图各子组件的高阶组件，用来处理绑定事件、属性等公共操作
 * @author hedongran
 * @email hdr01@126.com
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toggleMethods = exports.unregisterEvents = exports.registerEvents = void 0;
var tslib_1 = require("tslib");
var shallowequal_1 = tslib_1.__importDefault(require("shallowequal"));
function registerEvents(component, instance, eventsMap) {
    if (eventsMap && instance && instance.addEventListener) {
        component.registeredEvents = {};
        eventsMap.forEach(function (key) {
            var methodName = "on" + key.substr(0, 1).toUpperCase() + key.substr(1);
            if (component.props[methodName] && typeof component.props[methodName] === 'function') {
                instance.addEventListener(key, component.props[methodName]);
                component.registeredEvents[key] = component.props[methodName];
            }
        });
    }
}
exports.registerEvents = registerEvents;
function unregisterEvents(component, instance) {
    if (component.registeredEvents && instance && instance.removeEventListener) {
        Object.keys(component.registeredEvents).forEach(function (key) {
            instance.removeEventListener(key, component.registeredEvents[key]);
        });
        component.registeredEvents = null;
    }
}
exports.unregisterEvents = unregisterEvents;
function toggleMethods(component, instance, methodsMap, prevProps) {
    if (methodsMap && instance) {
        Object.keys(methodsMap).forEach(function (key) {
            // 当在 componentDidMount 和 componentDidUpdate 时分别执行
            if ((prevProps === undefined && component.props[key] !== undefined)
                || (prevProps !== undefined && !shallowequal_1.default(component.props[key], prevProps[key]))) {
                if (component.props[key]) {
                    instance && instance[methodsMap[key][0]]();
                }
                else {
                    instance && instance[methodsMap[key][1]]();
                }
            }
        });
    }
}
exports.toggleMethods = toggleMethods;
/**
 * 给子组件绑定需要切换的属性对应的方法
 * @param {Component} component 子组件
 * @param {Methods} methodsMap 属性和对应的2个切换方法
 * @return 修改过后的子组件
 */
function wrapMethods(component, methodsMap) {
    var getInstance = component['prototype'].getInstance;
    var componentDidMount = component['prototype'].componentDidMount;
    var componentDidUpdate = component['prototype'].componentDidUpdate;
    if (!getInstance) {
        return component;
    }
    if (methodsMap && Object.keys(methodsMap).length > 0) {
        component['prototype'].componentDidMount = function () {
            if (componentDidMount) {
                componentDidMount.call(this);
            }
            toggleMethods(this, getInstance(this), methodsMap);
        };
        component['prototype'].componentDidUpdate = function (prevProps, prevState) {
            toggleMethods(this, getInstance(this), methodsMap, prevProps);
            if (componentDidUpdate) {
                componentDidUpdate.call(this, prevProps, prevState);
            }
        };
    }
    return component;
}
/**
 * 给子组件绑定对应需要的事件
 * @param {Component} component 子组件
 * @param {Events} eventsMap 事件名数组
 * @return 修改过后的子组件
 */
function wrapEvents(component, eventsMap) {
    var getInstance = component['prototype'].getInstance;
    var componentDidUpdate = component['prototype'].componentDidUpdate;
    var componentDidMount = component['prototype'].componentDidMount;
    var componentWillUnmount = component['prototype'].componentWillUnmount;
    if (eventsMap && eventsMap.length > 0) {
        component['prototype'].componentDidMount = function () {
            if (componentDidMount) {
                componentDidMount.call(this);
            }
            registerEvents(this, getInstance(this), eventsMap);
        };
        component['prototype'].componentDidUpdate = function (prevProps, prevState) {
            if (!shallowequal_1.default(this.props, prevProps)) {
                unregisterEvents(this, getInstance(this));
            }
            if (componentDidUpdate) {
                componentDidUpdate.call(this, prevProps, prevState);
            }
            if (!shallowequal_1.default(this.props, prevProps)) {
                registerEvents(this, getInstance(this), eventsMap);
            }
        };
        component['prototype'].componentWillUnmount = function () {
            unregisterEvents(this, getInstance(this));
            if (componentWillUnmount) {
                componentWillUnmount.call(this);
            }
        };
    }
    return component;
}
function Wrapper(Component, eventsMap, methodsMap) {
    var component = wrapMethods(Component, methodsMap);
    component = wrapEvents(component, eventsMap);
    return component;
}
exports.default = Wrapper;
