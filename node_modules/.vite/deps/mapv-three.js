import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/mapv-three/dist/mapvthree.umd.js
var require_mapvthree_umd = __commonJS({
  "node_modules/mapv-three/dist/mapvthree.umd.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __defNormalProp = (e, t, i) => t in e ? __defProp(e, t, { enumerable: true, configurable: true, writable: true, value: i }) : e[t] = i;
    var __publicField = (e, t, i) => (__defNormalProp(e, "symbol" != typeof t ? t + "" : t, i), i);
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).mapvthree = {});
    }(exports, function(e) {
      "use strict";
      const t = "141dev", i = 100, n = 201, r = 301, s = 302, a = 303, o = 306, l = 1e3, h = 1001, c = 1002, u = 1003, d = 1004, p = 1005, m = 1006, f = 1008, g = 1009, _ = 1014, v = 1015, x = 1016, y = 1020, b = 1023, M = 1026, S = 1027, w = 33776, T = 33777, E = 33778, C = 33779, A = 2300, P = 2301, R = 2302, L = 2400, I = 2401, D = 2402, F = 2500, O = 3e3, U = 3001, z = "srgb", N = "srgb-linear", k = 7680, B = 35044, V = "300 es", G = 1035;
      class H {
        addEventListener(e2, t2) {
          void 0 === this._listeners && (this._listeners = {});
          const i2 = this._listeners;
          void 0 === i2[e2] && (i2[e2] = []), -1 === i2[e2].indexOf(t2) && i2[e2].push(t2);
        }
        hasEventListener(e2, t2) {
          if (void 0 === this._listeners)
            return false;
          const i2 = this._listeners;
          return void 0 !== i2[e2] && -1 !== i2[e2].indexOf(t2);
        }
        removeEventListener(e2, t2) {
          if (void 0 === this._listeners)
            return;
          const i2 = this._listeners[e2];
          if (void 0 !== i2) {
            const e3 = i2.indexOf(t2);
            -1 !== e3 && i2.splice(e3, 1);
          }
        }
        dispatchEvent(e2) {
          if (void 0 === this._listeners)
            return;
          const t2 = this._listeners[e2.type];
          if (void 0 !== t2) {
            e2.target = this;
            const i2 = t2.slice(0);
            for (let t3 = 0, n2 = i2.length; t3 < n2; t3++)
              i2[t3].call(this, e2);
            e2.target = null;
          }
        }
      }
      const j = [];
      for (let Yb = 0; Yb < 256; Yb++)
        j[Yb] = (Yb < 16 ? "0" : "") + Yb.toString(16);
      let W = 1234567;
      const X = Math.PI / 180, q = 180 / Math.PI;
      function Y() {
        const e2 = 4294967295 * Math.random() | 0, t2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
        return (j[255 & e2] + j[e2 >> 8 & 255] + j[e2 >> 16 & 255] + j[e2 >> 24 & 255] + "-" + j[255 & t2] + j[t2 >> 8 & 255] + "-" + j[t2 >> 16 & 15 | 64] + j[t2 >> 24 & 255] + "-" + j[63 & i2 | 128] + j[i2 >> 8 & 255] + "-" + j[i2 >> 16 & 255] + j[i2 >> 24 & 255] + j[255 & n2] + j[n2 >> 8 & 255] + j[n2 >> 16 & 255] + j[n2 >> 24 & 255]).toLowerCase();
      }
      function Z(e2, t2, i2) {
        return Math.max(t2, Math.min(i2, e2));
      }
      function J(e2, t2) {
        return (e2 % t2 + t2) % t2;
      }
      function K(e2, t2, i2) {
        return (1 - i2) * e2 + i2 * t2;
      }
      function Q(e2) {
        return 0 == (e2 & e2 - 1) && 0 !== e2;
      }
      function $(e2) {
        return Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
      }
      function ee(e2) {
        return Math.pow(2, Math.floor(Math.log(e2) / Math.LN2));
      }
      var te = Object.freeze({ __proto__: null, DEG2RAD: X, RAD2DEG: q, generateUUID: Y, clamp: Z, euclideanModulo: J, mapLinear: function(e2, t2, i2, n2, r2) {
        return n2 + (e2 - t2) * (r2 - n2) / (i2 - t2);
      }, inverseLerp: function(e2, t2, i2) {
        return e2 !== t2 ? (i2 - e2) / (t2 - e2) : 0;
      }, lerp: K, damp: function(e2, t2, i2, n2) {
        return K(e2, t2, 1 - Math.exp(-i2 * n2));
      }, pingpong: function(e2, t2 = 1) {
        return t2 - Math.abs(J(e2, 2 * t2) - t2);
      }, smoothstep: function(e2, t2, i2) {
        return e2 <= t2 ? 0 : e2 >= i2 ? 1 : (e2 = (e2 - t2) / (i2 - t2)) * e2 * (3 - 2 * e2);
      }, smootherstep: function(e2, t2, i2) {
        return e2 <= t2 ? 0 : e2 >= i2 ? 1 : (e2 = (e2 - t2) / (i2 - t2)) * e2 * e2 * (e2 * (6 * e2 - 15) + 10);
      }, randInt: function(e2, t2) {
        return e2 + Math.floor(Math.random() * (t2 - e2 + 1));
      }, randFloat: function(e2, t2) {
        return e2 + Math.random() * (t2 - e2);
      }, randFloatSpread: function(e2) {
        return e2 * (0.5 - Math.random());
      }, seededRandom: function(e2) {
        void 0 !== e2 && (W = e2);
        let t2 = W += 1831565813;
        return t2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2), t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, 61 | t2), ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
      }, degToRad: function(e2) {
        return e2 * X;
      }, radToDeg: function(e2) {
        return e2 * q;
      }, isPowerOfTwo: Q, ceilPowerOfTwo: $, floorPowerOfTwo: ee, setQuaternionFromProperEuler: function(e2, t2, i2, n2, r2) {
        const s2 = Math.cos, a2 = Math.sin, o2 = s2(i2 / 2), l2 = a2(i2 / 2), h2 = s2((t2 + n2) / 2), c2 = a2((t2 + n2) / 2), u2 = s2((t2 - n2) / 2), d2 = a2((t2 - n2) / 2), p2 = s2((n2 - t2) / 2), m2 = a2((n2 - t2) / 2);
        switch (r2) {
          case "XYX":
            e2.set(o2 * c2, l2 * u2, l2 * d2, o2 * h2);
            break;
          case "YZY":
            e2.set(l2 * d2, o2 * c2, l2 * u2, o2 * h2);
            break;
          case "ZXZ":
            e2.set(l2 * u2, l2 * d2, o2 * c2, o2 * h2);
            break;
          case "XZX":
            e2.set(o2 * c2, l2 * m2, l2 * p2, o2 * h2);
            break;
          case "YXY":
            e2.set(l2 * p2, o2 * c2, l2 * m2, o2 * h2);
            break;
          case "ZYZ":
            e2.set(l2 * m2, l2 * p2, o2 * c2, o2 * h2);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
        }
      }, normalize: function(e2, t2) {
        switch (t2.constructor) {
          case Float32Array:
            return e2;
          case Uint16Array:
            return Math.round(65535 * e2);
          case Uint8Array:
            return Math.round(255 * e2);
          case Int16Array:
            return Math.round(32767 * e2);
          case Int8Array:
            return Math.round(127 * e2);
          default:
            throw new Error("Invalid component type.");
        }
      }, denormalize: function(e2, t2) {
        switch (t2.constructor) {
          case Float32Array:
            return e2;
          case Uint16Array:
            return e2 / 65535;
          case Uint8Array:
            return e2 / 255;
          case Int16Array:
            return Math.max(e2 / 32767, -1);
          case Int8Array:
            return Math.max(e2 / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      } });
      class ie {
        constructor(e2 = 0, t2 = 0) {
          this.isVector2 = true, this.x = e2, this.y = t2;
        }
        get width() {
          return this.x;
        }
        set width(e2) {
          this.x = e2;
        }
        get height() {
          return this.y;
        }
        set height(e2) {
          this.y = e2;
        }
        set(e2, t2) {
          return this.x = e2, this.y = t2, this;
        }
        setScalar(e2) {
          return this.x = e2, this.y = e2, this;
        }
        setX(e2) {
          return this.x = e2, this;
        }
        setY(e2) {
          return this.y = e2, this;
        }
        setComponent(e2, t2) {
          switch (e2) {
            case 0:
              this.x = t2;
              break;
            case 1:
              this.y = t2;
              break;
            default:
              throw new Error("index is out of range: " + e2);
          }
          return this;
        }
        getComponent(e2) {
          switch (e2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e2) {
          return this.x = e2.x, this.y = e2.y, this;
        }
        add(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this);
        }
        addScalar(e2) {
          return this.x += e2, this.y += e2, this;
        }
        addVectors(e2, t2) {
          return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
        }
        addScaledVector(e2, t2) {
          return this.x += e2.x * t2, this.y += e2.y * t2, this;
        }
        sub(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this);
        }
        subScalar(e2) {
          return this.x -= e2, this.y -= e2, this;
        }
        subVectors(e2, t2) {
          return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
        }
        multiply(e2) {
          return this.x *= e2.x, this.y *= e2.y, this;
        }
        multiplyScalar(e2) {
          return this.x *= e2, this.y *= e2, this;
        }
        divide(e2) {
          return this.x /= e2.x, this.y /= e2.y, this;
        }
        divideScalar(e2) {
          return this.multiplyScalar(1 / e2);
        }
        applyMatrix3(e2) {
          const t2 = this.x, i2 = this.y, n2 = e2.elements;
          return this.x = n2[0] * t2 + n2[3] * i2 + n2[6], this.y = n2[1] * t2 + n2[4] * i2 + n2[7], this;
        }
        min(e2) {
          return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
        }
        max(e2) {
          return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
        }
        clamp(e2, t2) {
          return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
        }
        clampScalar(e2, t2) {
          return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
        }
        clampLength(e2, t2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e2) {
          return this.x * e2.x + this.y * e2.y;
        }
        cross(e2) {
          return this.x * e2.y - this.y * e2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e2) {
          return Math.sqrt(this.distanceToSquared(e2));
        }
        distanceToSquared(e2) {
          const t2 = this.x - e2.x, i2 = this.y - e2.y;
          return t2 * t2 + i2 * i2;
        }
        manhattanDistanceTo(e2) {
          return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
        }
        setLength(e2) {
          return this.normalize().multiplyScalar(e2);
        }
        lerp(e2, t2) {
          return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
        }
        lerpVectors(e2, t2, i2) {
          return this.x = e2.x + (t2.x - e2.x) * i2, this.y = e2.y + (t2.y - e2.y) * i2, this;
        }
        equals(e2) {
          return e2.x === this.x && e2.y === this.y;
        }
        fromArray(e2, t2 = 0) {
          return this.x = e2[t2], this.y = e2[t2 + 1], this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
        }
        fromBufferAttribute(e2, t2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this;
        }
        rotateAround(e2, t2) {
          const i2 = Math.cos(t2), n2 = Math.sin(t2), r2 = this.x - e2.x, s2 = this.y - e2.y;
          return this.x = r2 * i2 - s2 * n2 + e2.x, this.y = r2 * n2 + s2 * i2 + e2.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class ne {
        constructor() {
          this.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        set(e2, t2, i2, n2, r2, s2, a2, o2, l2) {
          const h2 = this.elements;
          return h2[0] = e2, h2[1] = n2, h2[2] = a2, h2[3] = t2, h2[4] = r2, h2[5] = o2, h2[6] = i2, h2[7] = s2, h2[8] = l2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e2) {
          const t2 = this.elements, i2 = e2.elements;
          return t2[0] = i2[0], t2[1] = i2[1], t2[2] = i2[2], t2[3] = i2[3], t2[4] = i2[4], t2[5] = i2[5], t2[6] = i2[6], t2[7] = i2[7], t2[8] = i2[8], this;
        }
        extractBasis(e2, t2, i2) {
          return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), i2.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e2) {
          const t2 = e2.elements;
          return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
        }
        multiply(e2) {
          return this.multiplyMatrices(this, e2);
        }
        premultiply(e2) {
          return this.multiplyMatrices(e2, this);
        }
        multiplyMatrices(e2, t2) {
          const i2 = e2.elements, n2 = t2.elements, r2 = this.elements, s2 = i2[0], a2 = i2[3], o2 = i2[6], l2 = i2[1], h2 = i2[4], c2 = i2[7], u2 = i2[2], d2 = i2[5], p2 = i2[8], m2 = n2[0], f2 = n2[3], g2 = n2[6], _2 = n2[1], v2 = n2[4], x2 = n2[7], y2 = n2[2], b2 = n2[5], M2 = n2[8];
          return r2[0] = s2 * m2 + a2 * _2 + o2 * y2, r2[3] = s2 * f2 + a2 * v2 + o2 * b2, r2[6] = s2 * g2 + a2 * x2 + o2 * M2, r2[1] = l2 * m2 + h2 * _2 + c2 * y2, r2[4] = l2 * f2 + h2 * v2 + c2 * b2, r2[7] = l2 * g2 + h2 * x2 + c2 * M2, r2[2] = u2 * m2 + d2 * _2 + p2 * y2, r2[5] = u2 * f2 + d2 * v2 + p2 * b2, r2[8] = u2 * g2 + d2 * x2 + p2 * M2, this;
        }
        multiplyScalar(e2) {
          const t2 = this.elements;
          return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
        }
        determinant() {
          const e2 = this.elements, t2 = e2[0], i2 = e2[1], n2 = e2[2], r2 = e2[3], s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], h2 = e2[8];
          return t2 * s2 * h2 - t2 * a2 * l2 - i2 * r2 * h2 + i2 * a2 * o2 + n2 * r2 * l2 - n2 * s2 * o2;
        }
        invert() {
          const e2 = this.elements, t2 = e2[0], i2 = e2[1], n2 = e2[2], r2 = e2[3], s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], h2 = e2[8], c2 = h2 * s2 - a2 * l2, u2 = a2 * o2 - h2 * r2, d2 = l2 * r2 - s2 * o2, p2 = t2 * c2 + i2 * u2 + n2 * d2;
          if (0 === p2)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m2 = 1 / p2;
          return e2[0] = c2 * m2, e2[1] = (n2 * l2 - h2 * i2) * m2, e2[2] = (a2 * i2 - n2 * s2) * m2, e2[3] = u2 * m2, e2[4] = (h2 * t2 - n2 * o2) * m2, e2[5] = (n2 * r2 - a2 * t2) * m2, e2[6] = d2 * m2, e2[7] = (i2 * o2 - l2 * t2) * m2, e2[8] = (s2 * t2 - i2 * r2) * m2, this;
        }
        transpose() {
          let e2;
          const t2 = this.elements;
          return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
        }
        getNormalMatrix(e2) {
          return this.setFromMatrix4(e2).invert().transpose();
        }
        transposeIntoArray(e2) {
          const t2 = this.elements;
          return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
        }
        setUvTransform(e2, t2, i2, n2, r2, s2, a2) {
          const o2 = Math.cos(r2), l2 = Math.sin(r2);
          return this.set(i2 * o2, i2 * l2, -i2 * (o2 * s2 + l2 * a2) + s2 + e2, -n2 * l2, n2 * o2, -n2 * (-l2 * s2 + o2 * a2) + a2 + t2, 0, 0, 1), this;
        }
        scale(e2, t2) {
          const i2 = this.elements;
          return i2[0] *= e2, i2[3] *= e2, i2[6] *= e2, i2[1] *= t2, i2[4] *= t2, i2[7] *= t2, this;
        }
        rotate(e2) {
          const t2 = Math.cos(e2), i2 = Math.sin(e2), n2 = this.elements, r2 = n2[0], s2 = n2[3], a2 = n2[6], o2 = n2[1], l2 = n2[4], h2 = n2[7];
          return n2[0] = t2 * r2 + i2 * o2, n2[3] = t2 * s2 + i2 * l2, n2[6] = t2 * a2 + i2 * h2, n2[1] = -i2 * r2 + t2 * o2, n2[4] = -i2 * s2 + t2 * l2, n2[7] = -i2 * a2 + t2 * h2, this;
        }
        translate(e2, t2) {
          const i2 = this.elements;
          return i2[0] += e2 * i2[2], i2[3] += e2 * i2[5], i2[6] += e2 * i2[8], i2[1] += t2 * i2[2], i2[4] += t2 * i2[5], i2[7] += t2 * i2[8], this;
        }
        equals(e2) {
          const t2 = this.elements, i2 = e2.elements;
          for (let n2 = 0; n2 < 9; n2++)
            if (t2[n2] !== i2[n2])
              return false;
          return true;
        }
        fromArray(e2, t2 = 0) {
          for (let i2 = 0; i2 < 9; i2++)
            this.elements[i2] = e2[i2 + t2];
          return this;
        }
        toArray(e2 = [], t2 = 0) {
          const i2 = this.elements;
          return e2[t2] = i2[0], e2[t2 + 1] = i2[1], e2[t2 + 2] = i2[2], e2[t2 + 3] = i2[3], e2[t2 + 4] = i2[4], e2[t2 + 5] = i2[5], e2[t2 + 6] = i2[6], e2[t2 + 7] = i2[7], e2[t2 + 8] = i2[8], e2;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function re(e2) {
        for (let t2 = e2.length - 1; t2 >= 0; --t2)
          if (e2[t2] > 65535)
            return true;
        return false;
      }
      function se(e2) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e2);
      }
      function ae(e2) {
        return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
      }
      function oe(e2) {
        return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
      }
      const le = { [z]: { [N]: ae }, [N]: { [z]: oe } }, he = { legacyMode: true, get workingColorSpace() {
        return N;
      }, set workingColorSpace(e2) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      }, convert: function(e2, t2, i2) {
        if (this.legacyMode || t2 === i2 || !t2 || !i2)
          return e2;
        if (le[t2] && void 0 !== le[t2][i2]) {
          const n2 = le[t2][i2];
          return e2.r = n2(e2.r), e2.g = n2(e2.g), e2.b = n2(e2.b), e2;
        }
        throw new Error("Unsupported color space conversion.");
      }, fromWorkingColorSpace: function(e2, t2) {
        return this.convert(e2, this.workingColorSpace, t2);
      }, toWorkingColorSpace: function(e2, t2) {
        return this.convert(e2, t2, this.workingColorSpace);
      } }, ce = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ue = { r: 0, g: 0, b: 0 }, de = { h: 0, s: 0, l: 0 }, pe = { h: 0, s: 0, l: 0 };
      function me(e2, t2, i2) {
        return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? e2 + 6 * (t2 - e2) * i2 : i2 < 0.5 ? t2 : i2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - i2) : e2;
      }
      function fe(e2, t2) {
        return t2.r = e2.r, t2.g = e2.g, t2.b = e2.b, t2;
      }
      class ge {
        constructor(e2, t2, i2) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === t2 && void 0 === i2 ? this.set(e2) : this.setRGB(e2, t2, i2);
        }
        set(e2) {
          return e2 && e2.isColor ? this.copy(e2) : "number" == typeof e2 ? this.setHex(e2) : "string" == typeof e2 && this.setStyle(e2), this;
        }
        setScalar(e2) {
          return this.r = e2, this.g = e2, this.b = e2, this;
        }
        setHex(e2, t2 = "srgb") {
          return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, he.toWorkingColorSpace(this, t2), this;
        }
        setRGB(e2, t2, i2, n2 = "srgb-linear") {
          return this.r = e2, this.g = t2, this.b = i2, he.toWorkingColorSpace(this, n2), this;
        }
        setHSL(e2, t2, i2, n2 = "srgb-linear") {
          if (e2 = J(e2, 1), t2 = Z(t2, 0, 1), i2 = Z(i2, 0, 1), 0 === t2)
            this.r = this.g = this.b = i2;
          else {
            const n3 = i2 <= 0.5 ? i2 * (1 + t2) : i2 + t2 - i2 * t2, r2 = 2 * i2 - n3;
            this.r = me(r2, n3, e2 + 1 / 3), this.g = me(r2, n3, e2), this.b = me(r2, n3, e2 - 1 / 3);
          }
          return he.toWorkingColorSpace(this, n2), this;
        }
        setStyle(e2, t2 = "srgb") {
          function i2(t3) {
            void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e2 + " will be ignored.");
          }
          let n2;
          if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e2)) {
            let e3;
            const r2 = n2[1], s2 = n2[2];
            switch (r2) {
              case "rgb":
              case "rgba":
                if (e3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
                  return this.r = Math.min(255, parseInt(e3[1], 10)) / 255, this.g = Math.min(255, parseInt(e3[2], 10)) / 255, this.b = Math.min(255, parseInt(e3[3], 10)) / 255, he.toWorkingColorSpace(this, t2), i2(e3[4]), this;
                if (e3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2))
                  return this.r = Math.min(100, parseInt(e3[1], 10)) / 100, this.g = Math.min(100, parseInt(e3[2], 10)) / 100, this.b = Math.min(100, parseInt(e3[3], 10)) / 100, he.toWorkingColorSpace(this, t2), i2(e3[4]), this;
                break;
              case "hsl":
              case "hsla":
                if (e3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) {
                  const n3 = parseFloat(e3[1]) / 360, r3 = parseInt(e3[2], 10) / 100, s3 = parseInt(e3[3], 10) / 100;
                  return i2(e3[4]), this.setHSL(n3, r3, s3, t2);
                }
            }
          } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(e2)) {
            const e3 = n2[1], i3 = e3.length;
            if (3 === i3)
              return this.r = parseInt(e3.charAt(0) + e3.charAt(0), 16) / 255, this.g = parseInt(e3.charAt(1) + e3.charAt(1), 16) / 255, this.b = parseInt(e3.charAt(2) + e3.charAt(2), 16) / 255, he.toWorkingColorSpace(this, t2), this;
            if (6 === i3)
              return this.r = parseInt(e3.charAt(0) + e3.charAt(1), 16) / 255, this.g = parseInt(e3.charAt(2) + e3.charAt(3), 16) / 255, this.b = parseInt(e3.charAt(4) + e3.charAt(5), 16) / 255, he.toWorkingColorSpace(this, t2), this;
          }
          return e2 && e2.length > 0 ? this.setColorName(e2, t2) : this;
        }
        setColorName(e2, t2 = "srgb") {
          const i2 = ce[e2.toLowerCase()];
          return void 0 !== i2 ? this.setHex(i2, t2) : console.warn("THREE.Color: Unknown color " + e2), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e2) {
          return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
        }
        copySRGBToLinear(e2) {
          return this.r = ae(e2.r), this.g = ae(e2.g), this.b = ae(e2.b), this;
        }
        copyLinearToSRGB(e2) {
          return this.r = oe(e2.r), this.g = oe(e2.g), this.b = oe(e2.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e2 = "srgb") {
          return he.fromWorkingColorSpace(fe(this, ue), e2), Z(255 * ue.r, 0, 255) << 16 ^ Z(255 * ue.g, 0, 255) << 8 ^ Z(255 * ue.b, 0, 255) << 0;
        }
        getHexString(e2 = "srgb") {
          return ("000000" + this.getHex(e2).toString(16)).slice(-6);
        }
        getHSL(e2, t2 = "srgb-linear") {
          he.fromWorkingColorSpace(fe(this, ue), t2);
          const i2 = ue.r, n2 = ue.g, r2 = ue.b, s2 = Math.max(i2, n2, r2), a2 = Math.min(i2, n2, r2);
          let o2, l2;
          const h2 = (a2 + s2) / 2;
          if (a2 === s2)
            o2 = 0, l2 = 0;
          else {
            const e3 = s2 - a2;
            switch (l2 = h2 <= 0.5 ? e3 / (s2 + a2) : e3 / (2 - s2 - a2), s2) {
              case i2:
                o2 = (n2 - r2) / e3 + (n2 < r2 ? 6 : 0);
                break;
              case n2:
                o2 = (r2 - i2) / e3 + 2;
                break;
              case r2:
                o2 = (i2 - n2) / e3 + 4;
            }
            o2 /= 6;
          }
          return e2.h = o2, e2.s = l2, e2.l = h2, e2;
        }
        getRGB(e2, t2 = "srgb-linear") {
          return he.fromWorkingColorSpace(fe(this, ue), t2), e2.r = ue.r, e2.g = ue.g, e2.b = ue.b, e2;
        }
        getStyle(e2 = "srgb") {
          return he.fromWorkingColorSpace(fe(this, ue), e2), e2 !== z ? `color(${e2} ${ue.r} ${ue.g} ${ue.b})` : `rgb(${255 * ue.r | 0},${255 * ue.g | 0},${255 * ue.b | 0})`;
        }
        offsetHSL(e2, t2, i2) {
          return this.getHSL(de), de.h += e2, de.s += t2, de.l += i2, this.setHSL(de.h, de.s, de.l), this;
        }
        add(e2) {
          return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
        }
        addColors(e2, t2) {
          return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
        }
        addScalar(e2) {
          return this.r += e2, this.g += e2, this.b += e2, this;
        }
        sub(e2) {
          return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
        }
        multiply(e2) {
          return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
        }
        multiplyScalar(e2) {
          return this.r *= e2, this.g *= e2, this.b *= e2, this;
        }
        lerp(e2, t2) {
          return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
        }
        lerpColors(e2, t2, i2) {
          return this.r = e2.r + (t2.r - e2.r) * i2, this.g = e2.g + (t2.g - e2.g) * i2, this.b = e2.b + (t2.b - e2.b) * i2, this;
        }
        lerpHSL(e2, t2) {
          this.getHSL(de), e2.getHSL(pe);
          const i2 = K(de.h, pe.h, t2), n2 = K(de.s, pe.s, t2), r2 = K(de.l, pe.l, t2);
          return this.setHSL(i2, n2, r2), this;
        }
        equals(e2) {
          return e2.r === this.r && e2.g === this.g && e2.b === this.b;
        }
        fromArray(e2, t2 = 0) {
          return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
        }
        fromBufferAttribute(e2, t2) {
          return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), true === e2.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      let _e;
      ge.NAMES = ce;
      class ve {
        static getDataURL(e2) {
          if (/^data:/i.test(e2.src))
            return e2.src;
          if ("undefined" == typeof HTMLCanvasElement)
            return e2.src;
          let t2;
          if (e2 instanceof HTMLCanvasElement)
            t2 = e2;
          else {
            void 0 === _e && (_e = se("canvas")), _e.width = e2.width, _e.height = e2.height;
            const i2 = _e.getContext("2d");
            e2 instanceof ImageData ? i2.putImageData(e2, 0, 0) : i2.drawImage(e2, 0, 0, e2.width, e2.height), t2 = _e;
          }
          return t2.width > 2048 || t2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e2), t2.toDataURL("image/jpeg", 0.6)) : t2.toDataURL("image/png");
        }
        static sRGBToLinear(e2) {
          if ("undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap) {
            const t2 = se("canvas");
            t2.width = e2.width, t2.height = e2.height;
            const i2 = t2.getContext("2d");
            i2.drawImage(e2, 0, 0, e2.width, e2.height);
            const n2 = i2.getImageData(0, 0, e2.width, e2.height), r2 = n2.data;
            for (let e3 = 0; e3 < r2.length; e3++)
              r2[e3] = 255 * ae(r2[e3] / 255);
            return i2.putImageData(n2, 0, 0), t2;
          }
          if (e2.data) {
            const t2 = e2.data.slice(0);
            for (let e3 = 0; e3 < t2.length; e3++)
              t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray ? t2[e3] = Math.floor(255 * ae(t2[e3] / 255)) : t2[e3] = ae(t2[e3]);
            return { data: t2, width: e2.width, height: e2.height };
          }
          return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e2;
        }
      }
      class xe {
        constructor(e2 = null) {
          this.isSource = true, this.uuid = Y(), this.data = e2, this.version = 0;
        }
        set needsUpdate(e2) {
          true === e2 && this.version++;
        }
        toJSON(e2) {
          const t2 = void 0 === e2 || "string" == typeof e2;
          if (!t2 && void 0 !== e2.images[this.uuid])
            return e2.images[this.uuid];
          const i2 = { uuid: this.uuid, url: "" }, n2 = this.data;
          if (null !== n2) {
            let e3;
            if (Array.isArray(n2)) {
              e3 = [];
              for (let t3 = 0, i3 = n2.length; t3 < i3; t3++)
                n2[t3].isDataTexture ? e3.push(ye(n2[t3].image)) : e3.push(ye(n2[t3]));
            } else
              e3 = ye(n2);
            i2.url = e3;
          }
          return t2 || (e2.images[this.uuid] = i2), i2;
        }
      }
      function ye(e2) {
        return "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap ? ve.getDataURL(e2) : e2.data ? { data: Array.prototype.slice.call(e2.data), width: e2.width, height: e2.height, type: e2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let be = 0;
      class Me extends H {
        constructor(e2 = Me.DEFAULT_IMAGE, t2 = Me.DEFAULT_MAPPING, i2 = 1001, n2 = 1001, r2 = 1006, s2 = 1008, a2 = 1023, o2 = 1009, l2 = 1, h2 = 3e3) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", { value: be++ }), this.uuid = Y(), this.name = "", this.source = new xe(e2), this.mipmaps = [], this.mapping = t2, this.wrapS = i2, this.wrapT = n2, this.magFilter = r2, this.minFilter = s2, this.anisotropy = l2, this.format = a2, this.internalFormat = null, this.type = o2, this.offset = new ie(0, 0), this.repeat = new ie(1, 1), this.center = new ie(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ne(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = h2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
        }
        get image() {
          return this.source.data;
        }
        set image(e2) {
          this.source.data = e2;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          return this.name = e2.name, this.source = e2.source, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.encoding = e2.encoding, this.userData = JSON.parse(JSON.stringify(e2.userData)), this.needsUpdate = true, this;
        }
        toJSON(e2) {
          const t2 = void 0 === e2 || "string" == typeof e2;
          if (!t2 && void 0 !== e2.textures[this.uuid])
            return e2.textures[this.uuid];
          const i2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e2).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
          return "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), t2 || (e2.textures[this.uuid] = i2), i2;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e2) {
          if (300 !== this.mapping)
            return e2;
          if (e2.applyMatrix3(this.matrix), e2.x < 0 || e2.x > 1)
            switch (this.wrapS) {
              case l:
                e2.x = e2.x - Math.floor(e2.x);
                break;
              case h:
                e2.x = e2.x < 0 ? 0 : 1;
                break;
              case c:
                1 === Math.abs(Math.floor(e2.x) % 2) ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
            }
          if (e2.y < 0 || e2.y > 1)
            switch (this.wrapT) {
              case l:
                e2.y = e2.y - Math.floor(e2.y);
                break;
              case h:
                e2.y = e2.y < 0 ? 0 : 1;
                break;
              case c:
                1 === Math.abs(Math.floor(e2.y) % 2) ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
            }
          return this.flipY && (e2.y = 1 - e2.y), e2;
        }
        set needsUpdate(e2) {
          true === e2 && (this.version++, this.source.needsUpdate = true);
        }
      }
      Me.DEFAULT_IMAGE = null, Me.DEFAULT_MAPPING = 300;
      class Se {
        constructor(e2 = 0, t2 = 0, i2 = 0, n2 = 1) {
          this.isVector4 = true, this.x = e2, this.y = t2, this.z = i2, this.w = n2;
        }
        get width() {
          return this.z;
        }
        set width(e2) {
          this.z = e2;
        }
        get height() {
          return this.w;
        }
        set height(e2) {
          this.w = e2;
        }
        set(e2, t2, i2, n2) {
          return this.x = e2, this.y = t2, this.z = i2, this.w = n2, this;
        }
        setScalar(e2) {
          return this.x = e2, this.y = e2, this.z = e2, this.w = e2, this;
        }
        setX(e2) {
          return this.x = e2, this;
        }
        setY(e2) {
          return this.y = e2, this;
        }
        setZ(e2) {
          return this.z = e2, this;
        }
        setW(e2) {
          return this.w = e2, this;
        }
        setComponent(e2, t2) {
          switch (e2) {
            case 0:
              this.x = t2;
              break;
            case 1:
              this.y = t2;
              break;
            case 2:
              this.z = t2;
              break;
            case 3:
              this.w = t2;
              break;
            default:
              throw new Error("index is out of range: " + e2);
          }
          return this;
        }
        getComponent(e2) {
          switch (e2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e2) {
          return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = void 0 !== e2.w ? e2.w : 1, this;
        }
        add(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this.w += e2.w, this);
        }
        addScalar(e2) {
          return this.x += e2, this.y += e2, this.z += e2, this.w += e2, this;
        }
        addVectors(e2, t2) {
          return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this.w = e2.w + t2.w, this;
        }
        addScaledVector(e2, t2) {
          return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this.w += e2.w * t2, this;
        }
        sub(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this.w -= e2.w, this);
        }
        subScalar(e2) {
          return this.x -= e2, this.y -= e2, this.z -= e2, this.w -= e2, this;
        }
        subVectors(e2, t2) {
          return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this.w = e2.w - t2.w, this;
        }
        multiply(e2) {
          return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this.w *= e2.w, this;
        }
        multiplyScalar(e2) {
          return this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2, this;
        }
        applyMatrix4(e2) {
          const t2 = this.x, i2 = this.y, n2 = this.z, r2 = this.w, s2 = e2.elements;
          return this.x = s2[0] * t2 + s2[4] * i2 + s2[8] * n2 + s2[12] * r2, this.y = s2[1] * t2 + s2[5] * i2 + s2[9] * n2 + s2[13] * r2, this.z = s2[2] * t2 + s2[6] * i2 + s2[10] * n2 + s2[14] * r2, this.w = s2[3] * t2 + s2[7] * i2 + s2[11] * n2 + s2[15] * r2, this;
        }
        divideScalar(e2) {
          return this.multiplyScalar(1 / e2);
        }
        setAxisAngleFromQuaternion(e2) {
          this.w = 2 * Math.acos(e2.w);
          const t2 = Math.sqrt(1 - e2.w * e2.w);
          return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e2.x / t2, this.y = e2.y / t2, this.z = e2.z / t2), this;
        }
        setAxisAngleFromRotationMatrix(e2) {
          let t2, i2, n2, r2;
          const s2 = 0.01, a2 = 0.1, o2 = e2.elements, l2 = o2[0], h2 = o2[4], c2 = o2[8], u2 = o2[1], d2 = o2[5], p2 = o2[9], m2 = o2[2], f2 = o2[6], g2 = o2[10];
          if (Math.abs(h2 - u2) < s2 && Math.abs(c2 - m2) < s2 && Math.abs(p2 - f2) < s2) {
            if (Math.abs(h2 + u2) < a2 && Math.abs(c2 + m2) < a2 && Math.abs(p2 + f2) < a2 && Math.abs(l2 + d2 + g2 - 3) < a2)
              return this.set(1, 0, 0, 0), this;
            t2 = Math.PI;
            const e3 = (l2 + 1) / 2, o3 = (d2 + 1) / 2, _3 = (g2 + 1) / 2, v2 = (h2 + u2) / 4, x2 = (c2 + m2) / 4, y2 = (p2 + f2) / 4;
            return e3 > o3 && e3 > _3 ? e3 < s2 ? (i2 = 0, n2 = 0.707106781, r2 = 0.707106781) : (i2 = Math.sqrt(e3), n2 = v2 / i2, r2 = x2 / i2) : o3 > _3 ? o3 < s2 ? (i2 = 0.707106781, n2 = 0, r2 = 0.707106781) : (n2 = Math.sqrt(o3), i2 = v2 / n2, r2 = y2 / n2) : _3 < s2 ? (i2 = 0.707106781, n2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(_3), i2 = x2 / r2, n2 = y2 / r2), this.set(i2, n2, r2, t2), this;
          }
          let _2 = Math.sqrt((f2 - p2) * (f2 - p2) + (c2 - m2) * (c2 - m2) + (u2 - h2) * (u2 - h2));
          return Math.abs(_2) < 1e-3 && (_2 = 1), this.x = (f2 - p2) / _2, this.y = (c2 - m2) / _2, this.z = (u2 - h2) / _2, this.w = Math.acos((l2 + d2 + g2 - 1) / 2), this;
        }
        min(e2) {
          return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this.w = Math.min(this.w, e2.w), this;
        }
        max(e2) {
          return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this.w = Math.max(this.w, e2.w), this;
        }
        clamp(e2, t2) {
          return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this.w = Math.max(e2.w, Math.min(t2.w, this.w)), this;
        }
        clampScalar(e2, t2) {
          return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this.w = Math.max(e2, Math.min(t2, this.w)), this;
        }
        clampLength(e2, t2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e2) {
          return this.x * e2.x + this.y * e2.y + this.z * e2.z + this.w * e2.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e2) {
          return this.normalize().multiplyScalar(e2);
        }
        lerp(e2, t2) {
          return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this.w += (e2.w - this.w) * t2, this;
        }
        lerpVectors(e2, t2, i2) {
          return this.x = e2.x + (t2.x - e2.x) * i2, this.y = e2.y + (t2.y - e2.y) * i2, this.z = e2.z + (t2.z - e2.z) * i2, this.w = e2.w + (t2.w - e2.w) * i2, this;
        }
        equals(e2) {
          return e2.x === this.x && e2.y === this.y && e2.z === this.z && e2.w === this.w;
        }
        fromArray(e2, t2 = 0) {
          return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this.w = e2[t2 + 3], this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2[t2 + 3] = this.w, e2;
        }
        fromBufferAttribute(e2, t2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this.w = e2.getW(t2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class we extends H {
        constructor(e2, t2, i2 = {}) {
          super(), this.isWebGLRenderTarget = true, this.width = e2, this.height = t2, this.depth = 1, this.scissor = new Se(0, 0, e2, t2), this.scissorTest = false, this.viewport = new Se(0, 0, e2, t2);
          const n2 = { width: e2, height: t2, depth: 1 };
          this.texture = new Me(n2, i2.mapping, i2.wrapS, i2.wrapT, i2.magFilter, i2.minFilter, i2.format, i2.type, i2.anisotropy, i2.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== i2.generateMipmaps && i2.generateMipmaps, this.texture.internalFormat = void 0 !== i2.internalFormat ? i2.internalFormat : null, this.texture.minFilter = void 0 !== i2.minFilter ? i2.minFilter : m, this.depthBuffer = void 0 === i2.depthBuffer || i2.depthBuffer, this.stencilBuffer = void 0 !== i2.stencilBuffer && i2.stencilBuffer, this.depthTexture = void 0 !== i2.depthTexture ? i2.depthTexture : null, this.samples = void 0 !== i2.samples ? i2.samples : 0;
        }
        setSize(e2, t2, i2 = 1) {
          this.width === e2 && this.height === t2 && this.depth === i2 || (this.width = e2, this.height = t2, this.depth = i2, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = i2, this.dispose()), this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.copy(e2.viewport), this.texture = e2.texture.clone(), this.texture.isRenderTargetTexture = true;
          const t2 = Object.assign({}, e2.texture.image);
          return this.texture.source = new xe(t2), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.samples = e2.samples, this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class Te extends Me {
        constructor(e2 = null, t2 = 1, i2 = 1, n2 = 1) {
          super(null), this.isDataArrayTexture = true, this.image = { data: e2, width: t2, height: i2, depth: n2 }, this.magFilter = u, this.minFilter = u, this.wrapR = h, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class Ee extends we {
        constructor(e2, t2, i2, n2 = {}) {
          super(e2, t2, n2), this.isWebGLMultipleRenderTargets = true;
          const r2 = this.texture;
          this.texture = [];
          for (let s2 = 0; s2 < i2; s2++)
            this.texture[s2] = r2.clone(), this.texture[s2].isRenderTargetTexture = true;
        }
        setSize(e2, t2, i2 = 1) {
          if (this.width !== e2 || this.height !== t2 || this.depth !== i2) {
            this.width = e2, this.height = t2, this.depth = i2;
            for (let n2 = 0, r2 = this.texture.length; n2 < r2; n2++)
              this.texture[n2].image.width = e2, this.texture[n2].image.height = t2, this.texture[n2].image.depth = i2;
            this.dispose();
          }
          return this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2), this;
        }
        copy(e2) {
          this.dispose(), this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, null !== e2.depthTexture && (this.depthTexture = e2.depthTexture.clone()), this.texture.length = 0;
          for (let t2 = 0, i2 = e2.texture.length; t2 < i2; t2++)
            this.texture[t2] = e2.texture[t2].clone(), this.texture[t2].isRenderTargetTexture = true;
          return this;
        }
      }
      class Ce {
        constructor(e2 = 0, t2 = 0, i2 = 0, n2 = 1) {
          this.isQuaternion = true, this._x = e2, this._y = t2, this._z = i2, this._w = n2;
        }
        static slerp(e2, t2, i2, n2) {
          return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i2.slerpQuaternions(e2, t2, n2);
        }
        static slerpFlat(e2, t2, i2, n2, r2, s2, a2) {
          let o2 = i2[n2 + 0], l2 = i2[n2 + 1], h2 = i2[n2 + 2], c2 = i2[n2 + 3];
          const u2 = r2[s2 + 0], d2 = r2[s2 + 1], p2 = r2[s2 + 2], m2 = r2[s2 + 3];
          if (0 === a2)
            return e2[t2 + 0] = o2, e2[t2 + 1] = l2, e2[t2 + 2] = h2, void (e2[t2 + 3] = c2);
          if (1 === a2)
            return e2[t2 + 0] = u2, e2[t2 + 1] = d2, e2[t2 + 2] = p2, void (e2[t2 + 3] = m2);
          if (c2 !== m2 || o2 !== u2 || l2 !== d2 || h2 !== p2) {
            let e3 = 1 - a2;
            const t3 = o2 * u2 + l2 * d2 + h2 * p2 + c2 * m2, i3 = t3 >= 0 ? 1 : -1, n3 = 1 - t3 * t3;
            if (n3 > Number.EPSILON) {
              const r4 = Math.sqrt(n3), s3 = Math.atan2(r4, t3 * i3);
              e3 = Math.sin(e3 * s3) / r4, a2 = Math.sin(a2 * s3) / r4;
            }
            const r3 = a2 * i3;
            if (o2 = o2 * e3 + u2 * r3, l2 = l2 * e3 + d2 * r3, h2 = h2 * e3 + p2 * r3, c2 = c2 * e3 + m2 * r3, e3 === 1 - a2) {
              const e4 = 1 / Math.sqrt(o2 * o2 + l2 * l2 + h2 * h2 + c2 * c2);
              o2 *= e4, l2 *= e4, h2 *= e4, c2 *= e4;
            }
          }
          e2[t2] = o2, e2[t2 + 1] = l2, e2[t2 + 2] = h2, e2[t2 + 3] = c2;
        }
        static multiplyQuaternionsFlat(e2, t2, i2, n2, r2, s2) {
          const a2 = i2[n2], o2 = i2[n2 + 1], l2 = i2[n2 + 2], h2 = i2[n2 + 3], c2 = r2[s2], u2 = r2[s2 + 1], d2 = r2[s2 + 2], p2 = r2[s2 + 3];
          return e2[t2] = a2 * p2 + h2 * c2 + o2 * d2 - l2 * u2, e2[t2 + 1] = o2 * p2 + h2 * u2 + l2 * c2 - a2 * d2, e2[t2 + 2] = l2 * p2 + h2 * d2 + a2 * u2 - o2 * c2, e2[t2 + 3] = h2 * p2 - a2 * c2 - o2 * u2 - l2 * d2, e2;
        }
        get x() {
          return this._x;
        }
        set x(e2) {
          this._x = e2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e2) {
          this._y = e2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e2) {
          this._z = e2, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e2) {
          this._w = e2, this._onChangeCallback();
        }
        set(e2, t2, i2, n2) {
          return this._x = e2, this._y = t2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e2) {
          return this._x = e2.x, this._y = e2.y, this._z = e2.z, this._w = e2.w, this._onChangeCallback(), this;
        }
        setFromEuler(e2, t2) {
          if (!e2 || !e2.isEuler)
            throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          const i2 = e2._x, n2 = e2._y, r2 = e2._z, s2 = e2._order, a2 = Math.cos, o2 = Math.sin, l2 = a2(i2 / 2), h2 = a2(n2 / 2), c2 = a2(r2 / 2), u2 = o2(i2 / 2), d2 = o2(n2 / 2), p2 = o2(r2 / 2);
          switch (s2) {
            case "XYZ":
              this._x = u2 * h2 * c2 + l2 * d2 * p2, this._y = l2 * d2 * c2 - u2 * h2 * p2, this._z = l2 * h2 * p2 + u2 * d2 * c2, this._w = l2 * h2 * c2 - u2 * d2 * p2;
              break;
            case "YXZ":
              this._x = u2 * h2 * c2 + l2 * d2 * p2, this._y = l2 * d2 * c2 - u2 * h2 * p2, this._z = l2 * h2 * p2 - u2 * d2 * c2, this._w = l2 * h2 * c2 + u2 * d2 * p2;
              break;
            case "ZXY":
              this._x = u2 * h2 * c2 - l2 * d2 * p2, this._y = l2 * d2 * c2 + u2 * h2 * p2, this._z = l2 * h2 * p2 + u2 * d2 * c2, this._w = l2 * h2 * c2 - u2 * d2 * p2;
              break;
            case "ZYX":
              this._x = u2 * h2 * c2 - l2 * d2 * p2, this._y = l2 * d2 * c2 + u2 * h2 * p2, this._z = l2 * h2 * p2 - u2 * d2 * c2, this._w = l2 * h2 * c2 + u2 * d2 * p2;
              break;
            case "YZX":
              this._x = u2 * h2 * c2 + l2 * d2 * p2, this._y = l2 * d2 * c2 + u2 * h2 * p2, this._z = l2 * h2 * p2 - u2 * d2 * c2, this._w = l2 * h2 * c2 - u2 * d2 * p2;
              break;
            case "XZY":
              this._x = u2 * h2 * c2 - l2 * d2 * p2, this._y = l2 * d2 * c2 - u2 * h2 * p2, this._z = l2 * h2 * p2 + u2 * d2 * c2, this._w = l2 * h2 * c2 + u2 * d2 * p2;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
          }
          return false !== t2 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e2, t2) {
          const i2 = t2 / 2, n2 = Math.sin(i2);
          return this._x = e2.x * n2, this._y = e2.y * n2, this._z = e2.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e2) {
          const t2 = e2.elements, i2 = t2[0], n2 = t2[4], r2 = t2[8], s2 = t2[1], a2 = t2[5], o2 = t2[9], l2 = t2[2], h2 = t2[6], c2 = t2[10], u2 = i2 + a2 + c2;
          if (u2 > 0) {
            const e3 = 0.5 / Math.sqrt(u2 + 1);
            this._w = 0.25 / e3, this._x = (h2 - o2) * e3, this._y = (r2 - l2) * e3, this._z = (s2 - n2) * e3;
          } else if (i2 > a2 && i2 > c2) {
            const e3 = 2 * Math.sqrt(1 + i2 - a2 - c2);
            this._w = (h2 - o2) / e3, this._x = 0.25 * e3, this._y = (n2 + s2) / e3, this._z = (r2 + l2) / e3;
          } else if (a2 > c2) {
            const e3 = 2 * Math.sqrt(1 + a2 - i2 - c2);
            this._w = (r2 - l2) / e3, this._x = (n2 + s2) / e3, this._y = 0.25 * e3, this._z = (o2 + h2) / e3;
          } else {
            const e3 = 2 * Math.sqrt(1 + c2 - i2 - a2);
            this._w = (s2 - n2) / e3, this._x = (r2 + l2) / e3, this._y = (o2 + h2) / e3, this._z = 0.25 * e3;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e2, t2) {
          let i2 = e2.dot(t2) + 1;
          return i2 < Number.EPSILON ? (i2 = 0, Math.abs(e2.x) > Math.abs(e2.z) ? (this._x = -e2.y, this._y = e2.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -e2.z, this._z = e2.y, this._w = i2)) : (this._x = e2.y * t2.z - e2.z * t2.y, this._y = e2.z * t2.x - e2.x * t2.z, this._z = e2.x * t2.y - e2.y * t2.x, this._w = i2), this.normalize();
        }
        angleTo(e2) {
          return 2 * Math.acos(Math.abs(Z(this.dot(e2), -1, 1)));
        }
        rotateTowards(e2, t2) {
          const i2 = this.angleTo(e2);
          if (0 === i2)
            return this;
          const n2 = Math.min(1, t2 / i2);
          return this.slerp(e2, n2), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e2) {
          return this._x * e2._x + this._y * e2._y + this._z * e2._z + this._w * e2._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e2 = this.length();
          return 0 === e2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e2 = 1 / e2, this._x = this._x * e2, this._y = this._y * e2, this._z = this._z * e2, this._w = this._w * e2), this._onChangeCallback(), this;
        }
        multiply(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e2, t2)) : this.multiplyQuaternions(this, e2);
        }
        premultiply(e2) {
          return this.multiplyQuaternions(e2, this);
        }
        multiplyQuaternions(e2, t2) {
          const i2 = e2._x, n2 = e2._y, r2 = e2._z, s2 = e2._w, a2 = t2._x, o2 = t2._y, l2 = t2._z, h2 = t2._w;
          return this._x = i2 * h2 + s2 * a2 + n2 * l2 - r2 * o2, this._y = n2 * h2 + s2 * o2 + r2 * a2 - i2 * l2, this._z = r2 * h2 + s2 * l2 + i2 * o2 - n2 * a2, this._w = s2 * h2 - i2 * a2 - n2 * o2 - r2 * l2, this._onChangeCallback(), this;
        }
        slerp(e2, t2) {
          if (0 === t2)
            return this;
          if (1 === t2)
            return this.copy(e2);
          const i2 = this._x, n2 = this._y, r2 = this._z, s2 = this._w;
          let a2 = s2 * e2._w + i2 * e2._x + n2 * e2._y + r2 * e2._z;
          if (a2 < 0 ? (this._w = -e2._w, this._x = -e2._x, this._y = -e2._y, this._z = -e2._z, a2 = -a2) : this.copy(e2), a2 >= 1)
            return this._w = s2, this._x = i2, this._y = n2, this._z = r2, this;
          const o2 = 1 - a2 * a2;
          if (o2 <= Number.EPSILON) {
            const e3 = 1 - t2;
            return this._w = e3 * s2 + t2 * this._w, this._x = e3 * i2 + t2 * this._x, this._y = e3 * n2 + t2 * this._y, this._z = e3 * r2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          const l2 = Math.sqrt(o2), h2 = Math.atan2(l2, a2), c2 = Math.sin((1 - t2) * h2) / l2, u2 = Math.sin(t2 * h2) / l2;
          return this._w = s2 * c2 + this._w * u2, this._x = i2 * c2 + this._x * u2, this._y = n2 * c2 + this._y * u2, this._z = r2 * c2 + this._z * u2, this._onChangeCallback(), this;
        }
        slerpQuaternions(e2, t2, i2) {
          return this.copy(e2).slerp(t2, i2);
        }
        random() {
          const e2 = Math.random(), t2 = Math.sqrt(1 - e2), i2 = Math.sqrt(e2), n2 = 2 * Math.PI * Math.random(), r2 = 2 * Math.PI * Math.random();
          return this.set(t2 * Math.cos(n2), i2 * Math.sin(r2), i2 * Math.cos(r2), t2 * Math.sin(n2));
        }
        equals(e2) {
          return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._w === this._w;
        }
        fromArray(e2, t2 = 0) {
          return this._x = e2[t2], this._y = e2[t2 + 1], this._z = e2[t2 + 2], this._w = e2[t2 + 3], this._onChangeCallback(), this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._w, e2;
        }
        fromBufferAttribute(e2, t2) {
          return this._x = e2.getX(t2), this._y = e2.getY(t2), this._z = e2.getZ(t2), this._w = e2.getW(t2), this;
        }
        _onChange(e2) {
          return this._onChangeCallback = e2, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class Ae {
        constructor(e2 = 0, t2 = 0, i2 = 0) {
          this.isVector3 = true, this.x = e2, this.y = t2, this.z = i2;
        }
        set(e2, t2, i2) {
          return void 0 === i2 && (i2 = this.z), this.x = e2, this.y = t2, this.z = i2, this;
        }
        setScalar(e2) {
          return this.x = e2, this.y = e2, this.z = e2, this;
        }
        setX(e2) {
          return this.x = e2, this;
        }
        setY(e2) {
          return this.y = e2, this;
        }
        setZ(e2) {
          return this.z = e2, this;
        }
        setComponent(e2, t2) {
          switch (e2) {
            case 0:
              this.x = t2;
              break;
            case 1:
              this.y = t2;
              break;
            case 2:
              this.z = t2;
              break;
            default:
              throw new Error("index is out of range: " + e2);
          }
          return this;
        }
        getComponent(e2) {
          switch (e2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e2) {
          return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
        }
        add(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this);
        }
        addScalar(e2) {
          return this.x += e2, this.y += e2, this.z += e2, this;
        }
        addVectors(e2, t2) {
          return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this;
        }
        addScaledVector(e2, t2) {
          return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this;
        }
        sub(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this);
        }
        subScalar(e2) {
          return this.x -= e2, this.y -= e2, this.z -= e2, this;
        }
        subVectors(e2, t2) {
          return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this;
        }
        multiply(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e2, t2)) : (this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this);
        }
        multiplyScalar(e2) {
          return this.x *= e2, this.y *= e2, this.z *= e2, this;
        }
        multiplyVectors(e2, t2) {
          return this.x = e2.x * t2.x, this.y = e2.y * t2.y, this.z = e2.z * t2.z, this;
        }
        applyEuler(e2) {
          return e2 && e2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Re.setFromEuler(e2));
        }
        applyAxisAngle(e2, t2) {
          return this.applyQuaternion(Re.setFromAxisAngle(e2, t2));
        }
        applyMatrix3(e2) {
          const t2 = this.x, i2 = this.y, n2 = this.z, r2 = e2.elements;
          return this.x = r2[0] * t2 + r2[3] * i2 + r2[6] * n2, this.y = r2[1] * t2 + r2[4] * i2 + r2[7] * n2, this.z = r2[2] * t2 + r2[5] * i2 + r2[8] * n2, this;
        }
        applyNormalMatrix(e2) {
          return this.applyMatrix3(e2).normalize();
        }
        applyMatrix4(e2) {
          const t2 = this.x, i2 = this.y, n2 = this.z, r2 = e2.elements, s2 = 1 / (r2[3] * t2 + r2[7] * i2 + r2[11] * n2 + r2[15]);
          return this.x = (r2[0] * t2 + r2[4] * i2 + r2[8] * n2 + r2[12]) * s2, this.y = (r2[1] * t2 + r2[5] * i2 + r2[9] * n2 + r2[13]) * s2, this.z = (r2[2] * t2 + r2[6] * i2 + r2[10] * n2 + r2[14]) * s2, this;
        }
        applyQuaternion(e2) {
          const t2 = this.x, i2 = this.y, n2 = this.z, r2 = e2.x, s2 = e2.y, a2 = e2.z, o2 = e2.w, l2 = o2 * t2 + s2 * n2 - a2 * i2, h2 = o2 * i2 + a2 * t2 - r2 * n2, c2 = o2 * n2 + r2 * i2 - s2 * t2, u2 = -r2 * t2 - s2 * i2 - a2 * n2;
          return this.x = l2 * o2 + u2 * -r2 + h2 * -a2 - c2 * -s2, this.y = h2 * o2 + u2 * -s2 + c2 * -r2 - l2 * -a2, this.z = c2 * o2 + u2 * -a2 + l2 * -s2 - h2 * -r2, this;
        }
        project(e2) {
          return this.applyMatrix4(e2.matrixWorldInverse).applyMatrix4(e2.projectionMatrix);
        }
        unproject(e2) {
          return this.applyMatrix4(e2.projectionMatrixInverse).applyMatrix4(e2.matrixWorld);
        }
        transformDirection(e2) {
          const t2 = this.x, i2 = this.y, n2 = this.z, r2 = e2.elements;
          return this.x = r2[0] * t2 + r2[4] * i2 + r2[8] * n2, this.y = r2[1] * t2 + r2[5] * i2 + r2[9] * n2, this.z = r2[2] * t2 + r2[6] * i2 + r2[10] * n2, this.normalize();
        }
        divide(e2) {
          return this.x /= e2.x, this.y /= e2.y, this.z /= e2.z, this;
        }
        divideScalar(e2) {
          return this.multiplyScalar(1 / e2);
        }
        min(e2) {
          return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this;
        }
        max(e2) {
          return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this;
        }
        clamp(e2, t2) {
          return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this;
        }
        clampScalar(e2, t2) {
          return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this;
        }
        clampLength(e2, t2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e2) {
          return this.x * e2.x + this.y * e2.y + this.z * e2.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e2) {
          return this.normalize().multiplyScalar(e2);
        }
        lerp(e2, t2) {
          return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this;
        }
        lerpVectors(e2, t2, i2) {
          return this.x = e2.x + (t2.x - e2.x) * i2, this.y = e2.y + (t2.y - e2.y) * i2, this.z = e2.z + (t2.z - e2.z) * i2, this;
        }
        cross(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e2, t2)) : this.crossVectors(this, e2);
        }
        crossVectors(e2, t2) {
          const i2 = e2.x, n2 = e2.y, r2 = e2.z, s2 = t2.x, a2 = t2.y, o2 = t2.z;
          return this.x = n2 * o2 - r2 * a2, this.y = r2 * s2 - i2 * o2, this.z = i2 * a2 - n2 * s2, this;
        }
        projectOnVector(e2) {
          const t2 = e2.lengthSq();
          if (0 === t2)
            return this.set(0, 0, 0);
          const i2 = e2.dot(this) / t2;
          return this.copy(e2).multiplyScalar(i2);
        }
        projectOnPlane(e2) {
          return Pe.copy(this).projectOnVector(e2), this.sub(Pe);
        }
        reflect(e2) {
          return this.sub(Pe.copy(e2).multiplyScalar(2 * this.dot(e2)));
        }
        angleTo(e2) {
          const t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
          if (0 === t2)
            return Math.PI / 2;
          const i2 = this.dot(e2) / t2;
          return Math.acos(Z(i2, -1, 1));
        }
        distanceTo(e2) {
          return Math.sqrt(this.distanceToSquared(e2));
        }
        distanceToSquared(e2) {
          const t2 = this.x - e2.x, i2 = this.y - e2.y, n2 = this.z - e2.z;
          return t2 * t2 + i2 * i2 + n2 * n2;
        }
        manhattanDistanceTo(e2) {
          return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y) + Math.abs(this.z - e2.z);
        }
        setFromSpherical(e2) {
          return this.setFromSphericalCoords(e2.radius, e2.phi, e2.theta);
        }
        setFromSphericalCoords(e2, t2, i2) {
          const n2 = Math.sin(t2) * e2;
          return this.x = n2 * Math.sin(i2), this.y = Math.cos(t2) * e2, this.z = n2 * Math.cos(i2), this;
        }
        setFromCylindrical(e2) {
          return this.setFromCylindricalCoords(e2.radius, e2.theta, e2.y);
        }
        setFromCylindricalCoords(e2, t2, i2) {
          return this.x = e2 * Math.sin(t2), this.y = i2, this.z = e2 * Math.cos(t2), this;
        }
        setFromMatrixPosition(e2) {
          const t2 = e2.elements;
          return this.x = t2[12], this.y = t2[13], this.z = t2[14], this;
        }
        setFromMatrixScale(e2) {
          const t2 = this.setFromMatrixColumn(e2, 0).length(), i2 = this.setFromMatrixColumn(e2, 1).length(), n2 = this.setFromMatrixColumn(e2, 2).length();
          return this.x = t2, this.y = i2, this.z = n2, this;
        }
        setFromMatrixColumn(e2, t2) {
          return this.fromArray(e2.elements, 4 * t2);
        }
        setFromMatrix3Column(e2, t2) {
          return this.fromArray(e2.elements, 3 * t2);
        }
        setFromEuler(e2) {
          return this.x = e2._x, this.y = e2._y, this.z = e2._z, this;
        }
        equals(e2) {
          return e2.x === this.x && e2.y === this.y && e2.z === this.z;
        }
        fromArray(e2, t2 = 0) {
          return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2;
        }
        fromBufferAttribute(e2, t2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const e2 = 2 * (Math.random() - 0.5), t2 = Math.random() * Math.PI * 2, i2 = Math.sqrt(1 - e2 ** 2);
          return this.x = i2 * Math.cos(t2), this.y = i2 * Math.sin(t2), this.z = e2, this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Pe = new Ae(), Re = new Ce();
      class Le {
        constructor(e2 = new Ae(1 / 0, 1 / 0, 1 / 0), t2 = new Ae(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = e2, this.max = t2;
        }
        set(e2, t2) {
          return this.min.copy(e2), this.max.copy(t2), this;
        }
        setFromArray(e2) {
          let t2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          for (let o2 = 0, l2 = e2.length; o2 < l2; o2 += 3) {
            const l3 = e2[o2], h2 = e2[o2 + 1], c2 = e2[o2 + 2];
            l3 < t2 && (t2 = l3), h2 < i2 && (i2 = h2), c2 < n2 && (n2 = c2), l3 > r2 && (r2 = l3), h2 > s2 && (s2 = h2), c2 > a2 && (a2 = c2);
          }
          return this.min.set(t2, i2, n2), this.max.set(r2, s2, a2), this;
        }
        setFromBufferAttribute(e2) {
          let t2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0;
          for (let o2 = 0, l2 = e2.count; o2 < l2; o2++) {
            const l3 = e2.getX(o2), h2 = e2.getY(o2), c2 = e2.getZ(o2);
            l3 < t2 && (t2 = l3), h2 < i2 && (i2 = h2), c2 < n2 && (n2 = c2), l3 > r2 && (r2 = l3), h2 > s2 && (s2 = h2), c2 > a2 && (a2 = c2);
          }
          return this.min.set(t2, i2, n2), this.max.set(r2, s2, a2), this;
        }
        setFromPoints(e2) {
          this.makeEmpty();
          for (let t2 = 0, i2 = e2.length; t2 < i2; t2++)
            this.expandByPoint(e2[t2]);
          return this;
        }
        setFromCenterAndSize(e2, t2) {
          const i2 = De.copy(t2).multiplyScalar(0.5);
          return this.min.copy(e2).sub(i2), this.max.copy(e2).add(i2), this;
        }
        setFromObject(e2, t2 = false) {
          return this.makeEmpty(), this.expandByObject(e2, t2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          return this.min.copy(e2.min), this.max.copy(e2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e2) {
          return this.isEmpty() ? e2.set(0, 0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e2) {
          return this.isEmpty() ? e2.set(0, 0, 0) : e2.subVectors(this.max, this.min);
        }
        expandByPoint(e2) {
          return this.min.min(e2), this.max.max(e2), this;
        }
        expandByVector(e2) {
          return this.min.sub(e2), this.max.add(e2), this;
        }
        expandByScalar(e2) {
          return this.min.addScalar(-e2), this.max.addScalar(e2), this;
        }
        expandByObject(e2, t2 = false) {
          e2.updateWorldMatrix(false, false);
          const i2 = e2.geometry;
          if (void 0 !== i2)
            if (t2 && null != i2.attributes && void 0 !== i2.attributes.position) {
              const t3 = i2.attributes.position;
              for (let i3 = 0, n3 = t3.count; i3 < n3; i3++)
                De.fromBufferAttribute(t3, i3).applyMatrix4(e2.matrixWorld), this.expandByPoint(De);
            } else
              null === i2.boundingBox && i2.computeBoundingBox(), Fe.copy(i2.boundingBox), Fe.applyMatrix4(e2.matrixWorld), this.union(Fe);
          const n2 = e2.children;
          for (let r2 = 0, s2 = n2.length; r2 < s2; r2++)
            this.expandByObject(n2[r2], t2);
          return this;
        }
        containsPoint(e2) {
          return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y || e2.z < this.min.z || e2.z > this.max.z);
        }
        containsBox(e2) {
          return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y && this.min.z <= e2.min.z && e2.max.z <= this.max.z;
        }
        getParameter(e2, t2) {
          return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y), (e2.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e2) {
          return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y || e2.max.z < this.min.z || e2.min.z > this.max.z);
        }
        intersectsSphere(e2) {
          return this.clampPoint(e2.center, De), De.distanceToSquared(e2.center) <= e2.radius * e2.radius;
        }
        intersectsPlane(e2) {
          let t2, i2;
          return e2.normal.x > 0 ? (t2 = e2.normal.x * this.min.x, i2 = e2.normal.x * this.max.x) : (t2 = e2.normal.x * this.max.x, i2 = e2.normal.x * this.min.x), e2.normal.y > 0 ? (t2 += e2.normal.y * this.min.y, i2 += e2.normal.y * this.max.y) : (t2 += e2.normal.y * this.max.y, i2 += e2.normal.y * this.min.y), e2.normal.z > 0 ? (t2 += e2.normal.z * this.min.z, i2 += e2.normal.z * this.max.z) : (t2 += e2.normal.z * this.max.z, i2 += e2.normal.z * this.min.z), t2 <= -e2.constant && i2 >= -e2.constant;
        }
        intersectsTriangle(e2) {
          if (this.isEmpty())
            return false;
          this.getCenter(Ve), Ge.subVectors(this.max, Ve), Oe.subVectors(e2.a, Ve), Ue.subVectors(e2.b, Ve), ze.subVectors(e2.c, Ve), Ne.subVectors(Ue, Oe), ke.subVectors(ze, Ue), Be.subVectors(Oe, ze);
          let t2 = [0, -Ne.z, Ne.y, 0, -ke.z, ke.y, 0, -Be.z, Be.y, Ne.z, 0, -Ne.x, ke.z, 0, -ke.x, Be.z, 0, -Be.x, -Ne.y, Ne.x, 0, -ke.y, ke.x, 0, -Be.y, Be.x, 0];
          return !!We(t2, Oe, Ue, ze, Ge) && (t2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!We(t2, Oe, Ue, ze, Ge) && (He.crossVectors(Ne, ke), t2 = [He.x, He.y, He.z], We(t2, Oe, Ue, ze, Ge)));
        }
        clampPoint(e2, t2) {
          return t2.copy(e2).clamp(this.min, this.max);
        }
        distanceToPoint(e2) {
          return De.copy(e2).clamp(this.min, this.max).sub(e2).length();
        }
        getBoundingSphere(e2) {
          return this.getCenter(e2.center), e2.radius = 0.5 * this.getSize(De).length(), e2;
        }
        intersect(e2) {
          return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e2) {
          return this.min.min(e2.min), this.max.max(e2.max), this;
        }
        applyMatrix4(e2) {
          return this.isEmpty() || (Ie[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e2), Ie[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e2), Ie[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e2), Ie[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e2), Ie[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e2), Ie[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e2), Ie[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e2), Ie[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e2), this.setFromPoints(Ie)), this;
        }
        translate(e2) {
          return this.min.add(e2), this.max.add(e2), this;
        }
        equals(e2) {
          return e2.min.equals(this.min) && e2.max.equals(this.max);
        }
      }
      const Ie = [new Ae(), new Ae(), new Ae(), new Ae(), new Ae(), new Ae(), new Ae(), new Ae()], De = new Ae(), Fe = new Le(), Oe = new Ae(), Ue = new Ae(), ze = new Ae(), Ne = new Ae(), ke = new Ae(), Be = new Ae(), Ve = new Ae(), Ge = new Ae(), He = new Ae(), je = new Ae();
      function We(e2, t2, i2, n2, r2) {
        for (let s2 = 0, a2 = e2.length - 3; s2 <= a2; s2 += 3) {
          je.fromArray(e2, s2);
          const a3 = r2.x * Math.abs(je.x) + r2.y * Math.abs(je.y) + r2.z * Math.abs(je.z), o2 = t2.dot(je), l2 = i2.dot(je), h2 = n2.dot(je);
          if (Math.max(-Math.max(o2, l2, h2), Math.min(o2, l2, h2)) > a3)
            return false;
        }
        return true;
      }
      const Xe = new Le(), qe = new Ae(), Ye = new Ae(), Ze = new Ae();
      class Je {
        constructor(e2 = new Ae(), t2 = -1) {
          this.center = e2, this.radius = t2;
        }
        set(e2, t2) {
          return this.center.copy(e2), this.radius = t2, this;
        }
        setFromPoints(e2, t2) {
          const i2 = this.center;
          void 0 !== t2 ? i2.copy(t2) : Xe.setFromPoints(e2).getCenter(i2);
          let n2 = 0;
          for (let r2 = 0, s2 = e2.length; r2 < s2; r2++)
            n2 = Math.max(n2, i2.distanceToSquared(e2[r2]));
          return this.radius = Math.sqrt(n2), this;
        }
        copy(e2) {
          return this.center.copy(e2.center), this.radius = e2.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e2) {
          return e2.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e2) {
          return e2.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e2) {
          const t2 = this.radius + e2.radius;
          return e2.center.distanceToSquared(this.center) <= t2 * t2;
        }
        intersectsBox(e2) {
          return e2.intersectsSphere(this);
        }
        intersectsPlane(e2) {
          return Math.abs(e2.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e2, t2) {
          const i2 = this.center.distanceToSquared(e2);
          return t2.copy(e2), i2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
        }
        getBoundingBox(e2) {
          return this.isEmpty() ? (e2.makeEmpty(), e2) : (e2.set(this.center, this.center), e2.expandByScalar(this.radius), e2);
        }
        applyMatrix4(e2) {
          return this.center.applyMatrix4(e2), this.radius = this.radius * e2.getMaxScaleOnAxis(), this;
        }
        translate(e2) {
          return this.center.add(e2), this;
        }
        expandByPoint(e2) {
          Ze.subVectors(e2, this.center);
          const t2 = Ze.lengthSq();
          if (t2 > this.radius * this.radius) {
            const e3 = Math.sqrt(t2), i2 = 0.5 * (e3 - this.radius);
            this.center.add(Ze.multiplyScalar(i2 / e3)), this.radius += i2;
          }
          return this;
        }
        union(e2) {
          return true === this.center.equals(e2.center) ? Ye.set(0, 0, 1).multiplyScalar(e2.radius) : Ye.subVectors(e2.center, this.center).normalize().multiplyScalar(e2.radius), this.expandByPoint(qe.copy(e2.center).add(Ye)), this.expandByPoint(qe.copy(e2.center).sub(Ye)), this;
        }
        equals(e2) {
          return e2.center.equals(this.center) && e2.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Ke = new Ae(), Qe = new Ae(), $e = new Ae(), et = new Ae(), tt = new Ae(), it = new Ae(), nt = new Ae();
      class rt {
        constructor(e2 = new Ae(), t2 = new Ae(0, 0, -1)) {
          this.origin = e2, this.direction = t2;
        }
        set(e2, t2) {
          return this.origin.copy(e2), this.direction.copy(t2), this;
        }
        copy(e2) {
          return this.origin.copy(e2.origin), this.direction.copy(e2.direction), this;
        }
        at(e2, t2) {
          return t2.copy(this.direction).multiplyScalar(e2).add(this.origin);
        }
        lookAt(e2) {
          return this.direction.copy(e2).sub(this.origin).normalize(), this;
        }
        recast(e2) {
          return this.origin.copy(this.at(e2, Ke)), this;
        }
        closestPointToPoint(e2, t2) {
          t2.subVectors(e2, this.origin);
          const i2 = t2.dot(this.direction);
          return i2 < 0 ? t2.copy(this.origin) : t2.copy(this.direction).multiplyScalar(i2).add(this.origin);
        }
        distanceToPoint(e2) {
          return Math.sqrt(this.distanceSqToPoint(e2));
        }
        distanceSqToPoint(e2) {
          const t2 = Ke.subVectors(e2, this.origin).dot(this.direction);
          return t2 < 0 ? this.origin.distanceToSquared(e2) : (Ke.copy(this.direction).multiplyScalar(t2).add(this.origin), Ke.distanceToSquared(e2));
        }
        distanceSqToSegment(e2, t2, i2, n2) {
          Qe.copy(e2).add(t2).multiplyScalar(0.5), $e.copy(t2).sub(e2).normalize(), et.copy(this.origin).sub(Qe);
          const r2 = 0.5 * e2.distanceTo(t2), s2 = -this.direction.dot($e), a2 = et.dot(this.direction), o2 = -et.dot($e), l2 = et.lengthSq(), h2 = Math.abs(1 - s2 * s2);
          let c2, u2, d2, p2;
          if (h2 > 0)
            if (c2 = s2 * o2 - a2, u2 = s2 * a2 - o2, p2 = r2 * h2, c2 >= 0)
              if (u2 >= -p2)
                if (u2 <= p2) {
                  const e3 = 1 / h2;
                  c2 *= e3, u2 *= e3, d2 = c2 * (c2 + s2 * u2 + 2 * a2) + u2 * (s2 * c2 + u2 + 2 * o2) + l2;
                } else
                  u2 = r2, c2 = Math.max(0, -(s2 * u2 + a2)), d2 = -c2 * c2 + u2 * (u2 + 2 * o2) + l2;
              else
                u2 = -r2, c2 = Math.max(0, -(s2 * u2 + a2)), d2 = -c2 * c2 + u2 * (u2 + 2 * o2) + l2;
            else
              u2 <= -p2 ? (c2 = Math.max(0, -(-s2 * r2 + a2)), u2 = c2 > 0 ? -r2 : Math.min(Math.max(-r2, -o2), r2), d2 = -c2 * c2 + u2 * (u2 + 2 * o2) + l2) : u2 <= p2 ? (c2 = 0, u2 = Math.min(Math.max(-r2, -o2), r2), d2 = u2 * (u2 + 2 * o2) + l2) : (c2 = Math.max(0, -(s2 * r2 + a2)), u2 = c2 > 0 ? r2 : Math.min(Math.max(-r2, -o2), r2), d2 = -c2 * c2 + u2 * (u2 + 2 * o2) + l2);
          else
            u2 = s2 > 0 ? -r2 : r2, c2 = Math.max(0, -(s2 * u2 + a2)), d2 = -c2 * c2 + u2 * (u2 + 2 * o2) + l2;
          return i2 && i2.copy(this.direction).multiplyScalar(c2).add(this.origin), n2 && n2.copy($e).multiplyScalar(u2).add(Qe), d2;
        }
        intersectSphere(e2, t2) {
          Ke.subVectors(e2.center, this.origin);
          const i2 = Ke.dot(this.direction), n2 = Ke.dot(Ke) - i2 * i2, r2 = e2.radius * e2.radius;
          if (n2 > r2)
            return null;
          const s2 = Math.sqrt(r2 - n2), a2 = i2 - s2, o2 = i2 + s2;
          return a2 < 0 && o2 < 0 ? null : a2 < 0 ? this.at(o2, t2) : this.at(a2, t2);
        }
        intersectsSphere(e2) {
          return this.distanceSqToPoint(e2.center) <= e2.radius * e2.radius;
        }
        distanceToPlane(e2) {
          const t2 = e2.normal.dot(this.direction);
          if (0 === t2)
            return 0 === e2.distanceToPoint(this.origin) ? 0 : null;
          const i2 = -(this.origin.dot(e2.normal) + e2.constant) / t2;
          return i2 >= 0 ? i2 : null;
        }
        intersectPlane(e2, t2) {
          const i2 = this.distanceToPlane(e2);
          return null === i2 ? null : this.at(i2, t2);
        }
        intersectsPlane(e2) {
          const t2 = e2.distanceToPoint(this.origin);
          if (0 === t2)
            return true;
          return e2.normal.dot(this.direction) * t2 < 0;
        }
        intersectBox(e2, t2) {
          let i2, n2, r2, s2, a2, o2;
          const l2 = 1 / this.direction.x, h2 = 1 / this.direction.y, c2 = 1 / this.direction.z, u2 = this.origin;
          return l2 >= 0 ? (i2 = (e2.min.x - u2.x) * l2, n2 = (e2.max.x - u2.x) * l2) : (i2 = (e2.max.x - u2.x) * l2, n2 = (e2.min.x - u2.x) * l2), h2 >= 0 ? (r2 = (e2.min.y - u2.y) * h2, s2 = (e2.max.y - u2.y) * h2) : (r2 = (e2.max.y - u2.y) * h2, s2 = (e2.min.y - u2.y) * h2), i2 > s2 || r2 > n2 ? null : ((r2 > i2 || i2 != i2) && (i2 = r2), (s2 < n2 || n2 != n2) && (n2 = s2), c2 >= 0 ? (a2 = (e2.min.z - u2.z) * c2, o2 = (e2.max.z - u2.z) * c2) : (a2 = (e2.max.z - u2.z) * c2, o2 = (e2.min.z - u2.z) * c2), i2 > o2 || a2 > n2 ? null : ((a2 > i2 || i2 != i2) && (i2 = a2), (o2 < n2 || n2 != n2) && (n2 = o2), n2 < 0 ? null : this.at(i2 >= 0 ? i2 : n2, t2)));
        }
        intersectsBox(e2) {
          return null !== this.intersectBox(e2, Ke);
        }
        intersectTriangle(e2, t2, i2, n2, r2) {
          tt.subVectors(t2, e2), it.subVectors(i2, e2), nt.crossVectors(tt, it);
          let s2, a2 = this.direction.dot(nt);
          if (a2 > 0) {
            if (n2)
              return null;
            s2 = 1;
          } else {
            if (!(a2 < 0))
              return null;
            s2 = -1, a2 = -a2;
          }
          et.subVectors(this.origin, e2);
          const o2 = s2 * this.direction.dot(it.crossVectors(et, it));
          if (o2 < 0)
            return null;
          const l2 = s2 * this.direction.dot(tt.cross(et));
          if (l2 < 0)
            return null;
          if (o2 + l2 > a2)
            return null;
          const h2 = -s2 * et.dot(nt);
          return h2 < 0 ? null : this.at(h2 / a2, r2);
        }
        applyMatrix4(e2) {
          return this.origin.applyMatrix4(e2), this.direction.transformDirection(e2), this;
        }
        equals(e2) {
          return e2.origin.equals(this.origin) && e2.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class st {
        constructor() {
          this.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        set(e2, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2, u2, d2, p2, m2, f2) {
          const g2 = this.elements;
          return g2[0] = e2, g2[4] = t2, g2[8] = i2, g2[12] = n2, g2[1] = r2, g2[5] = s2, g2[9] = a2, g2[13] = o2, g2[2] = l2, g2[6] = h2, g2[10] = c2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = m2, g2[15] = f2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new st().fromArray(this.elements);
        }
        copy(e2) {
          const t2 = this.elements, i2 = e2.elements;
          return t2[0] = i2[0], t2[1] = i2[1], t2[2] = i2[2], t2[3] = i2[3], t2[4] = i2[4], t2[5] = i2[5], t2[6] = i2[6], t2[7] = i2[7], t2[8] = i2[8], t2[9] = i2[9], t2[10] = i2[10], t2[11] = i2[11], t2[12] = i2[12], t2[13] = i2[13], t2[14] = i2[14], t2[15] = i2[15], this;
        }
        copyPosition(e2) {
          const t2 = this.elements, i2 = e2.elements;
          return t2[12] = i2[12], t2[13] = i2[13], t2[14] = i2[14], this;
        }
        setFromMatrix3(e2) {
          const t2 = e2.elements;
          return this.set(t2[0], t2[3], t2[6], 0, t2[1], t2[4], t2[7], 0, t2[2], t2[5], t2[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e2, t2, i2) {
          return e2.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e2, t2, i2) {
          return this.set(e2.x, t2.x, i2.x, 0, e2.y, t2.y, i2.y, 0, e2.z, t2.z, i2.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e2) {
          const t2 = this.elements, i2 = e2.elements, n2 = 1 / at.setFromMatrixColumn(e2, 0).length(), r2 = 1 / at.setFromMatrixColumn(e2, 1).length(), s2 = 1 / at.setFromMatrixColumn(e2, 2).length();
          return t2[0] = i2[0] * n2, t2[1] = i2[1] * n2, t2[2] = i2[2] * n2, t2[3] = 0, t2[4] = i2[4] * r2, t2[5] = i2[5] * r2, t2[6] = i2[6] * r2, t2[7] = 0, t2[8] = i2[8] * s2, t2[9] = i2[9] * s2, t2[10] = i2[10] * s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
        }
        makeRotationFromEuler(e2) {
          e2 && e2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          const t2 = this.elements, i2 = e2.x, n2 = e2.y, r2 = e2.z, s2 = Math.cos(i2), a2 = Math.sin(i2), o2 = Math.cos(n2), l2 = Math.sin(n2), h2 = Math.cos(r2), c2 = Math.sin(r2);
          if ("XYZ" === e2.order) {
            const e3 = s2 * h2, i3 = s2 * c2, n3 = a2 * h2, r3 = a2 * c2;
            t2[0] = o2 * h2, t2[4] = -o2 * c2, t2[8] = l2, t2[1] = i3 + n3 * l2, t2[5] = e3 - r3 * l2, t2[9] = -a2 * o2, t2[2] = r3 - e3 * l2, t2[6] = n3 + i3 * l2, t2[10] = s2 * o2;
          } else if ("YXZ" === e2.order) {
            const e3 = o2 * h2, i3 = o2 * c2, n3 = l2 * h2, r3 = l2 * c2;
            t2[0] = e3 + r3 * a2, t2[4] = n3 * a2 - i3, t2[8] = s2 * l2, t2[1] = s2 * c2, t2[5] = s2 * h2, t2[9] = -a2, t2[2] = i3 * a2 - n3, t2[6] = r3 + e3 * a2, t2[10] = s2 * o2;
          } else if ("ZXY" === e2.order) {
            const e3 = o2 * h2, i3 = o2 * c2, n3 = l2 * h2, r3 = l2 * c2;
            t2[0] = e3 - r3 * a2, t2[4] = -s2 * c2, t2[8] = n3 + i3 * a2, t2[1] = i3 + n3 * a2, t2[5] = s2 * h2, t2[9] = r3 - e3 * a2, t2[2] = -s2 * l2, t2[6] = a2, t2[10] = s2 * o2;
          } else if ("ZYX" === e2.order) {
            const e3 = s2 * h2, i3 = s2 * c2, n3 = a2 * h2, r3 = a2 * c2;
            t2[0] = o2 * h2, t2[4] = n3 * l2 - i3, t2[8] = e3 * l2 + r3, t2[1] = o2 * c2, t2[5] = r3 * l2 + e3, t2[9] = i3 * l2 - n3, t2[2] = -l2, t2[6] = a2 * o2, t2[10] = s2 * o2;
          } else if ("YZX" === e2.order) {
            const e3 = s2 * o2, i3 = s2 * l2, n3 = a2 * o2, r3 = a2 * l2;
            t2[0] = o2 * h2, t2[4] = r3 - e3 * c2, t2[8] = n3 * c2 + i3, t2[1] = c2, t2[5] = s2 * h2, t2[9] = -a2 * h2, t2[2] = -l2 * h2, t2[6] = i3 * c2 + n3, t2[10] = e3 - r3 * c2;
          } else if ("XZY" === e2.order) {
            const e3 = s2 * o2, i3 = s2 * l2, n3 = a2 * o2, r3 = a2 * l2;
            t2[0] = o2 * h2, t2[4] = -c2, t2[8] = l2 * h2, t2[1] = e3 * c2 + r3, t2[5] = s2 * h2, t2[9] = i3 * c2 - n3, t2[2] = n3 * c2 - i3, t2[6] = a2 * h2, t2[10] = r3 * c2 + e3;
          }
          return t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
        }
        makeRotationFromQuaternion(e2) {
          return this.compose(lt, e2, ht);
        }
        lookAt(e2, t2, i2) {
          const n2 = this.elements;
          return dt.subVectors(e2, t2), 0 === dt.lengthSq() && (dt.z = 1), dt.normalize(), ct.crossVectors(i2, dt), 0 === ct.lengthSq() && (1 === Math.abs(i2.z) ? dt.x += 1e-4 : dt.z += 1e-4, dt.normalize(), ct.crossVectors(i2, dt)), ct.normalize(), ut.crossVectors(dt, ct), n2[0] = ct.x, n2[4] = ut.x, n2[8] = dt.x, n2[1] = ct.y, n2[5] = ut.y, n2[9] = dt.y, n2[2] = ct.z, n2[6] = ut.z, n2[10] = dt.z, this;
        }
        multiply(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e2, t2)) : this.multiplyMatrices(this, e2);
        }
        premultiply(e2) {
          return this.multiplyMatrices(e2, this);
        }
        multiplyMatrices(e2, t2) {
          const i2 = e2.elements, n2 = t2.elements, r2 = this.elements, s2 = i2[0], a2 = i2[4], o2 = i2[8], l2 = i2[12], h2 = i2[1], c2 = i2[5], u2 = i2[9], d2 = i2[13], p2 = i2[2], m2 = i2[6], f2 = i2[10], g2 = i2[14], _2 = i2[3], v2 = i2[7], x2 = i2[11], y2 = i2[15], b2 = n2[0], M2 = n2[4], S2 = n2[8], w2 = n2[12], T2 = n2[1], E2 = n2[5], C2 = n2[9], A2 = n2[13], P2 = n2[2], R2 = n2[6], L2 = n2[10], I2 = n2[14], D2 = n2[3], F2 = n2[7], O2 = n2[11], U2 = n2[15];
          return r2[0] = s2 * b2 + a2 * T2 + o2 * P2 + l2 * D2, r2[4] = s2 * M2 + a2 * E2 + o2 * R2 + l2 * F2, r2[8] = s2 * S2 + a2 * C2 + o2 * L2 + l2 * O2, r2[12] = s2 * w2 + a2 * A2 + o2 * I2 + l2 * U2, r2[1] = h2 * b2 + c2 * T2 + u2 * P2 + d2 * D2, r2[5] = h2 * M2 + c2 * E2 + u2 * R2 + d2 * F2, r2[9] = h2 * S2 + c2 * C2 + u2 * L2 + d2 * O2, r2[13] = h2 * w2 + c2 * A2 + u2 * I2 + d2 * U2, r2[2] = p2 * b2 + m2 * T2 + f2 * P2 + g2 * D2, r2[6] = p2 * M2 + m2 * E2 + f2 * R2 + g2 * F2, r2[10] = p2 * S2 + m2 * C2 + f2 * L2 + g2 * O2, r2[14] = p2 * w2 + m2 * A2 + f2 * I2 + g2 * U2, r2[3] = _2 * b2 + v2 * T2 + x2 * P2 + y2 * D2, r2[7] = _2 * M2 + v2 * E2 + x2 * R2 + y2 * F2, r2[11] = _2 * S2 + v2 * C2 + x2 * L2 + y2 * O2, r2[15] = _2 * w2 + v2 * A2 + x2 * I2 + y2 * U2, this;
        }
        multiplyScalar(e2) {
          const t2 = this.elements;
          return t2[0] *= e2, t2[4] *= e2, t2[8] *= e2, t2[12] *= e2, t2[1] *= e2, t2[5] *= e2, t2[9] *= e2, t2[13] *= e2, t2[2] *= e2, t2[6] *= e2, t2[10] *= e2, t2[14] *= e2, t2[3] *= e2, t2[7] *= e2, t2[11] *= e2, t2[15] *= e2, this;
        }
        determinant() {
          const e2 = this.elements, t2 = e2[0], i2 = e2[4], n2 = e2[8], r2 = e2[12], s2 = e2[1], a2 = e2[5], o2 = e2[9], l2 = e2[13], h2 = e2[2], c2 = e2[6], u2 = e2[10], d2 = e2[14];
          return e2[3] * (+r2 * o2 * c2 - n2 * l2 * c2 - r2 * a2 * u2 + i2 * l2 * u2 + n2 * a2 * d2 - i2 * o2 * d2) + e2[7] * (+t2 * o2 * d2 - t2 * l2 * u2 + r2 * s2 * u2 - n2 * s2 * d2 + n2 * l2 * h2 - r2 * o2 * h2) + e2[11] * (+t2 * l2 * c2 - t2 * a2 * d2 - r2 * s2 * c2 + i2 * s2 * d2 + r2 * a2 * h2 - i2 * l2 * h2) + e2[15] * (-n2 * a2 * h2 - t2 * o2 * c2 + t2 * a2 * u2 + n2 * s2 * c2 - i2 * s2 * u2 + i2 * o2 * h2);
        }
        transpose() {
          const e2 = this.elements;
          let t2;
          return t2 = e2[1], e2[1] = e2[4], e2[4] = t2, t2 = e2[2], e2[2] = e2[8], e2[8] = t2, t2 = e2[6], e2[6] = e2[9], e2[9] = t2, t2 = e2[3], e2[3] = e2[12], e2[12] = t2, t2 = e2[7], e2[7] = e2[13], e2[13] = t2, t2 = e2[11], e2[11] = e2[14], e2[14] = t2, this;
        }
        setPosition(e2, t2, i2) {
          const n2 = this.elements;
          return e2.isVector3 ? (n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z) : (n2[12] = e2, n2[13] = t2, n2[14] = i2), this;
        }
        invert() {
          const e2 = this.elements, t2 = e2[0], i2 = e2[1], n2 = e2[2], r2 = e2[3], s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], h2 = e2[8], c2 = e2[9], u2 = e2[10], d2 = e2[11], p2 = e2[12], m2 = e2[13], f2 = e2[14], g2 = e2[15], _2 = c2 * f2 * l2 - m2 * u2 * l2 + m2 * o2 * d2 - a2 * f2 * d2 - c2 * o2 * g2 + a2 * u2 * g2, v2 = p2 * u2 * l2 - h2 * f2 * l2 - p2 * o2 * d2 + s2 * f2 * d2 + h2 * o2 * g2 - s2 * u2 * g2, x2 = h2 * m2 * l2 - p2 * c2 * l2 + p2 * a2 * d2 - s2 * m2 * d2 - h2 * a2 * g2 + s2 * c2 * g2, y2 = p2 * c2 * o2 - h2 * m2 * o2 - p2 * a2 * u2 + s2 * m2 * u2 + h2 * a2 * f2 - s2 * c2 * f2, b2 = t2 * _2 + i2 * v2 + n2 * x2 + r2 * y2;
          if (0 === b2)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const M2 = 1 / b2;
          return e2[0] = _2 * M2, e2[1] = (m2 * u2 * r2 - c2 * f2 * r2 - m2 * n2 * d2 + i2 * f2 * d2 + c2 * n2 * g2 - i2 * u2 * g2) * M2, e2[2] = (a2 * f2 * r2 - m2 * o2 * r2 + m2 * n2 * l2 - i2 * f2 * l2 - a2 * n2 * g2 + i2 * o2 * g2) * M2, e2[3] = (c2 * o2 * r2 - a2 * u2 * r2 - c2 * n2 * l2 + i2 * u2 * l2 + a2 * n2 * d2 - i2 * o2 * d2) * M2, e2[4] = v2 * M2, e2[5] = (h2 * f2 * r2 - p2 * u2 * r2 + p2 * n2 * d2 - t2 * f2 * d2 - h2 * n2 * g2 + t2 * u2 * g2) * M2, e2[6] = (p2 * o2 * r2 - s2 * f2 * r2 - p2 * n2 * l2 + t2 * f2 * l2 + s2 * n2 * g2 - t2 * o2 * g2) * M2, e2[7] = (s2 * u2 * r2 - h2 * o2 * r2 + h2 * n2 * l2 - t2 * u2 * l2 - s2 * n2 * d2 + t2 * o2 * d2) * M2, e2[8] = x2 * M2, e2[9] = (p2 * c2 * r2 - h2 * m2 * r2 - p2 * i2 * d2 + t2 * m2 * d2 + h2 * i2 * g2 - t2 * c2 * g2) * M2, e2[10] = (s2 * m2 * r2 - p2 * a2 * r2 + p2 * i2 * l2 - t2 * m2 * l2 - s2 * i2 * g2 + t2 * a2 * g2) * M2, e2[11] = (h2 * a2 * r2 - s2 * c2 * r2 - h2 * i2 * l2 + t2 * c2 * l2 + s2 * i2 * d2 - t2 * a2 * d2) * M2, e2[12] = y2 * M2, e2[13] = (h2 * m2 * n2 - p2 * c2 * n2 + p2 * i2 * u2 - t2 * m2 * u2 - h2 * i2 * f2 + t2 * c2 * f2) * M2, e2[14] = (p2 * a2 * n2 - s2 * m2 * n2 - p2 * i2 * o2 + t2 * m2 * o2 + s2 * i2 * f2 - t2 * a2 * f2) * M2, e2[15] = (s2 * c2 * n2 - h2 * a2 * n2 + h2 * i2 * o2 - t2 * c2 * o2 - s2 * i2 * u2 + t2 * a2 * u2) * M2, this;
        }
        scale(e2) {
          const t2 = this.elements, i2 = e2.x, n2 = e2.y, r2 = e2.z;
          return t2[0] *= i2, t2[4] *= n2, t2[8] *= r2, t2[1] *= i2, t2[5] *= n2, t2[9] *= r2, t2[2] *= i2, t2[6] *= n2, t2[10] *= r2, t2[3] *= i2, t2[7] *= n2, t2[11] *= r2, this;
        }
        getMaxScaleOnAxis() {
          const e2 = this.elements, t2 = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2], i2 = e2[4] * e2[4] + e2[5] * e2[5] + e2[6] * e2[6], n2 = e2[8] * e2[8] + e2[9] * e2[9] + e2[10] * e2[10];
          return Math.sqrt(Math.max(t2, i2, n2));
        }
        makeTranslation(e2, t2, i2) {
          return this.set(1, 0, 0, e2, 0, 1, 0, t2, 0, 0, 1, i2, 0, 0, 0, 1), this;
        }
        makeRotationX(e2) {
          const t2 = Math.cos(e2), i2 = Math.sin(e2);
          return this.set(1, 0, 0, 0, 0, t2, -i2, 0, 0, i2, t2, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e2) {
          const t2 = Math.cos(e2), i2 = Math.sin(e2);
          return this.set(t2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, t2, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e2) {
          const t2 = Math.cos(e2), i2 = Math.sin(e2);
          return this.set(t2, -i2, 0, 0, i2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e2, t2) {
          const i2 = Math.cos(t2), n2 = Math.sin(t2), r2 = 1 - i2, s2 = e2.x, a2 = e2.y, o2 = e2.z, l2 = r2 * s2, h2 = r2 * a2;
          return this.set(l2 * s2 + i2, l2 * a2 - n2 * o2, l2 * o2 + n2 * a2, 0, l2 * a2 + n2 * o2, h2 * a2 + i2, h2 * o2 - n2 * s2, 0, l2 * o2 - n2 * a2, h2 * o2 + n2 * s2, r2 * o2 * o2 + i2, 0, 0, 0, 0, 1), this;
        }
        makeScale(e2, t2, i2) {
          return this.set(e2, 0, 0, 0, 0, t2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
        }
        makeShear(e2, t2, i2, n2, r2, s2) {
          return this.set(1, i2, r2, 0, e2, 1, s2, 0, t2, n2, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e2, t2, i2) {
          const n2 = this.elements, r2 = t2._x, s2 = t2._y, a2 = t2._z, o2 = t2._w, l2 = r2 + r2, h2 = s2 + s2, c2 = a2 + a2, u2 = r2 * l2, d2 = r2 * h2, p2 = r2 * c2, m2 = s2 * h2, f2 = s2 * c2, g2 = a2 * c2, _2 = o2 * l2, v2 = o2 * h2, x2 = o2 * c2, y2 = i2.x, b2 = i2.y, M2 = i2.z;
          return n2[0] = (1 - (m2 + g2)) * y2, n2[1] = (d2 + x2) * y2, n2[2] = (p2 - v2) * y2, n2[3] = 0, n2[4] = (d2 - x2) * b2, n2[5] = (1 - (u2 + g2)) * b2, n2[6] = (f2 + _2) * b2, n2[7] = 0, n2[8] = (p2 + v2) * M2, n2[9] = (f2 - _2) * M2, n2[10] = (1 - (u2 + m2)) * M2, n2[11] = 0, n2[12] = e2.x, n2[13] = e2.y, n2[14] = e2.z, n2[15] = 1, this;
        }
        decompose(e2, t2, i2) {
          const n2 = this.elements;
          let r2 = at.set(n2[0], n2[1], n2[2]).length();
          const s2 = at.set(n2[4], n2[5], n2[6]).length(), a2 = at.set(n2[8], n2[9], n2[10]).length();
          this.determinant() < 0 && (r2 = -r2), e2.x = n2[12], e2.y = n2[13], e2.z = n2[14], ot.copy(this);
          const o2 = 1 / r2, l2 = 1 / s2, h2 = 1 / a2;
          return ot.elements[0] *= o2, ot.elements[1] *= o2, ot.elements[2] *= o2, ot.elements[4] *= l2, ot.elements[5] *= l2, ot.elements[6] *= l2, ot.elements[8] *= h2, ot.elements[9] *= h2, ot.elements[10] *= h2, t2.setFromRotationMatrix(ot), i2.x = r2, i2.y = s2, i2.z = a2, this;
        }
        makePerspective(e2, t2, i2, n2, r2, s2) {
          void 0 === s2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          const a2 = this.elements, o2 = 2 * r2 / (t2 - e2), l2 = 2 * r2 / (i2 - n2), h2 = (t2 + e2) / (t2 - e2), c2 = (i2 + n2) / (i2 - n2), u2 = -(s2 + r2) / (s2 - r2), d2 = -2 * s2 * r2 / (s2 - r2);
          return a2[0] = o2, a2[4] = 0, a2[8] = h2, a2[12] = 0, a2[1] = 0, a2[5] = l2, a2[9] = c2, a2[13] = 0, a2[2] = 0, a2[6] = 0, a2[10] = u2, a2[14] = d2, a2[3] = 0, a2[7] = 0, a2[11] = -1, a2[15] = 0, this;
        }
        makeOrthographic(e2, t2, i2, n2, r2, s2) {
          const a2 = this.elements, o2 = 1 / (t2 - e2), l2 = 1 / (i2 - n2), h2 = 1 / (s2 - r2), c2 = (t2 + e2) * o2, u2 = (i2 + n2) * l2, d2 = (s2 + r2) * h2;
          return a2[0] = 2 * o2, a2[4] = 0, a2[8] = 0, a2[12] = -c2, a2[1] = 0, a2[5] = 2 * l2, a2[9] = 0, a2[13] = -u2, a2[2] = 0, a2[6] = 0, a2[10] = -2 * h2, a2[14] = -d2, a2[3] = 0, a2[7] = 0, a2[11] = 0, a2[15] = 1, this;
        }
        equals(e2) {
          const t2 = this.elements, i2 = e2.elements;
          for (let n2 = 0; n2 < 16; n2++)
            if (t2[n2] !== i2[n2])
              return false;
          return true;
        }
        fromArray(e2, t2 = 0) {
          for (let i2 = 0; i2 < 16; i2++)
            this.elements[i2] = e2[i2 + t2];
          return this;
        }
        toArray(e2 = [], t2 = 0) {
          const i2 = this.elements;
          return e2[t2] = i2[0], e2[t2 + 1] = i2[1], e2[t2 + 2] = i2[2], e2[t2 + 3] = i2[3], e2[t2 + 4] = i2[4], e2[t2 + 5] = i2[5], e2[t2 + 6] = i2[6], e2[t2 + 7] = i2[7], e2[t2 + 8] = i2[8], e2[t2 + 9] = i2[9], e2[t2 + 10] = i2[10], e2[t2 + 11] = i2[11], e2[t2 + 12] = i2[12], e2[t2 + 13] = i2[13], e2[t2 + 14] = i2[14], e2[t2 + 15] = i2[15], e2;
        }
      }
      const at = new Ae(), ot = new st(), lt = new Ae(0, 0, 0), ht = new Ae(1, 1, 1), ct = new Ae(), ut = new Ae(), dt = new Ae(), pt = new st(), mt = new Ce();
      class ft {
        constructor(e2 = 0, t2 = 0, i2 = 0, n2 = ft.DefaultOrder) {
          this.isEuler = true, this._x = e2, this._y = t2, this._z = i2, this._order = n2;
        }
        get x() {
          return this._x;
        }
        set x(e2) {
          this._x = e2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e2) {
          this._y = e2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e2) {
          this._z = e2, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e2) {
          this._order = e2, this._onChangeCallback();
        }
        set(e2, t2, i2, n2 = this._order) {
          return this._x = e2, this._y = t2, this._z = i2, this._order = n2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e2) {
          return this._x = e2._x, this._y = e2._y, this._z = e2._z, this._order = e2._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e2, t2 = this._order, i2 = true) {
          const n2 = e2.elements, r2 = n2[0], s2 = n2[4], a2 = n2[8], o2 = n2[1], l2 = n2[5], h2 = n2[9], c2 = n2[2], u2 = n2[6], d2 = n2[10];
          switch (t2) {
            case "XYZ":
              this._y = Math.asin(Z(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-h2, d2), this._z = Math.atan2(-s2, r2)) : (this._x = Math.atan2(u2, l2), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-Z(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._y = Math.atan2(a2, d2), this._z = Math.atan2(o2, l2)) : (this._y = Math.atan2(-c2, r2), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(Z(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-c2, d2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(o2, r2));
              break;
            case "ZYX":
              this._y = Math.asin(-Z(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._x = Math.atan2(u2, d2), this._z = Math.atan2(o2, r2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
              break;
            case "YZX":
              this._z = Math.asin(Z(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-h2, l2), this._y = Math.atan2(-c2, r2)) : (this._x = 0, this._y = Math.atan2(a2, d2));
              break;
            case "XZY":
              this._z = Math.asin(-Z(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(u2, l2), this._y = Math.atan2(a2, r2)) : (this._x = Math.atan2(-h2, d2), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
          }
          return this._order = t2, true === i2 && this._onChangeCallback(), this;
        }
        setFromQuaternion(e2, t2, i2) {
          return pt.makeRotationFromQuaternion(e2), this.setFromRotationMatrix(pt, t2, i2);
        }
        setFromVector3(e2, t2 = this._order) {
          return this.set(e2.x, e2.y, e2.z, t2);
        }
        reorder(e2) {
          return mt.setFromEuler(this), this.setFromQuaternion(mt, e2);
        }
        equals(e2) {
          return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._order === this._order;
        }
        fromArray(e2) {
          return this._x = e2[0], this._y = e2[1], this._z = e2[2], void 0 !== e2[3] && (this._order = e2[3]), this._onChangeCallback(), this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._order, e2;
        }
        _onChange(e2) {
          return this._onChangeCallback = e2, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
        toVector3() {
          console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
        }
      }
      ft.DefaultOrder = "XYZ", ft.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class gt {
        constructor() {
          this.mask = 1;
        }
        set(e2) {
          this.mask = (1 << e2 | 0) >>> 0;
        }
        enable(e2) {
          this.mask |= 1 << e2 | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e2) {
          this.mask ^= 1 << e2 | 0;
        }
        disable(e2) {
          this.mask &= ~(1 << e2 | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e2) {
          return 0 != (this.mask & e2.mask);
        }
        isEnabled(e2) {
          return 0 != (this.mask & (1 << e2 | 0));
        }
      }
      let _t = 0;
      const vt = new Ae(), xt = new Ce(), yt = new st(), bt = new Ae(), Mt = new Ae(), St = new Ae(), wt = new Ce(), Tt = new Ae(1, 0, 0), Et = new Ae(0, 1, 0), Ct = new Ae(0, 0, 1), At = { type: "added" }, Pt = { type: "removed" };
      class Rt extends H {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: _t++ }), this.uuid = Y(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Rt.DefaultUp.clone();
          const e2 = new Ae(), t2 = new ft(), i2 = new Ce(), n2 = new Ae(1, 1, 1);
          t2._onChange(function() {
            i2.setFromEuler(t2, false);
          }), i2._onChange(function() {
            t2.setFromQuaternion(i2, void 0, false);
          }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e2 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: i2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new st() }, normalMatrix: { value: new ne() } }), this.matrix = new st(), this.matrixWorld = new st(), this.matrixAutoUpdate = Rt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new gt(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(e2) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e2), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e2) {
          return this.quaternion.premultiply(e2), this;
        }
        setRotationFromAxisAngle(e2, t2) {
          this.quaternion.setFromAxisAngle(e2, t2);
        }
        setRotationFromEuler(e2) {
          this.quaternion.setFromEuler(e2, true);
        }
        setRotationFromMatrix(e2) {
          this.quaternion.setFromRotationMatrix(e2);
        }
        setRotationFromQuaternion(e2) {
          this.quaternion.copy(e2);
        }
        rotateOnAxis(e2, t2) {
          return xt.setFromAxisAngle(e2, t2), this.quaternion.multiply(xt), this;
        }
        rotateOnWorldAxis(e2, t2) {
          return xt.setFromAxisAngle(e2, t2), this.quaternion.premultiply(xt), this;
        }
        rotateX(e2) {
          return this.rotateOnAxis(Tt, e2);
        }
        rotateY(e2) {
          return this.rotateOnAxis(Et, e2);
        }
        rotateZ(e2) {
          return this.rotateOnAxis(Ct, e2);
        }
        translateOnAxis(e2, t2) {
          return vt.copy(e2).applyQuaternion(this.quaternion), this.position.add(vt.multiplyScalar(t2)), this;
        }
        translateX(e2) {
          return this.translateOnAxis(Tt, e2);
        }
        translateY(e2) {
          return this.translateOnAxis(Et, e2);
        }
        translateZ(e2) {
          return this.translateOnAxis(Ct, e2);
        }
        localToWorld(e2) {
          return e2.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e2) {
          return e2.applyMatrix4(yt.copy(this.matrixWorld).invert());
        }
        lookAt(e2, t2, i2) {
          e2.isVector3 ? bt.copy(e2) : bt.set(e2, t2, i2);
          const n2 = this.parent;
          this.updateWorldMatrix(true, false), Mt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? yt.lookAt(Mt, bt, this.up) : yt.lookAt(bt, Mt, this.up), this.quaternion.setFromRotationMatrix(yt), n2 && (yt.extractRotation(n2.matrixWorld), xt.setFromRotationMatrix(yt), this.quaternion.premultiply(xt.invert()));
        }
        add(e2) {
          if (arguments.length > 1) {
            for (let e3 = 0; e3 < arguments.length; e3++)
              this.add(arguments[e3]);
            return this;
          }
          return e2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e2), this) : (e2 && e2.isObject3D ? (null !== e2.parent && e2.parent.remove(e2), e2.parent = this, this.children.push(e2), e2.dispatchEvent(At)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e2), this);
        }
        remove(e2) {
          if (arguments.length > 1) {
            for (let e3 = 0; e3 < arguments.length; e3++)
              this.remove(arguments[e3]);
            return this;
          }
          const t2 = this.children.indexOf(e2);
          return -1 !== t2 && (e2.parent = null, this.children.splice(t2, 1), e2.dispatchEvent(Pt)), this;
        }
        removeFromParent() {
          const e2 = this.parent;
          return null !== e2 && e2.remove(this), this;
        }
        clear() {
          for (let e2 = 0; e2 < this.children.length; e2++) {
            const t2 = this.children[e2];
            t2.parent = null, t2.dispatchEvent(Pt);
          }
          return this.children.length = 0, this;
        }
        attach(e2) {
          return this.updateWorldMatrix(true, false), yt.copy(this.matrixWorld).invert(), null !== e2.parent && (e2.parent.updateWorldMatrix(true, false), yt.multiply(e2.parent.matrixWorld)), e2.applyMatrix4(yt), this.add(e2), e2.updateWorldMatrix(false, true), this;
        }
        getObjectById(e2) {
          return this.getObjectByProperty("id", e2);
        }
        getObjectByName(e2) {
          return this.getObjectByProperty("name", e2);
        }
        getObjectByProperty(e2, t2) {
          if (this[e2] === t2)
            return this;
          for (let i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
            const n3 = this.children[i2].getObjectByProperty(e2, t2);
            if (void 0 !== n3)
              return n3;
          }
        }
        getWorldPosition(e2) {
          return this.updateWorldMatrix(true, false), e2.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Mt, e2, St), e2;
        }
        getWorldScale(e2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Mt, wt, e2), e2;
        }
        getWorldDirection(e2) {
          this.updateWorldMatrix(true, false);
          const t2 = this.matrixWorld.elements;
          return e2.set(t2[8], t2[9], t2[10]).normalize();
        }
        raycast() {
        }
        traverse(e2) {
          e2(this);
          const t2 = this.children;
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
            t2[i2].traverse(e2);
        }
        traverseVisible(e2) {
          if (false === this.visible)
            return;
          e2(this);
          const t2 = this.children;
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
            t2[i2].traverseVisible(e2);
        }
        traverseAncestors(e2) {
          const t2 = this.parent;
          null !== t2 && (e2(t2), t2.traverseAncestors(e2));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e2) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e2 = true);
          const t2 = this.children;
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
            t2[i2].updateMatrixWorld(e2);
        }
        updateWorldMatrix(e2, t2) {
          const i2 = this.parent;
          if (true === e2 && null !== i2 && i2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t2) {
            const e3 = this.children;
            for (let t3 = 0, i3 = e3.length; t3 < i3; t3++)
              e3[t3].updateWorldMatrix(false, true);
          }
        }
        toJSON(e2) {
          const t2 = void 0 === e2 || "string" == typeof e2, i2 = {};
          t2 && (e2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
          const n2 = {};
          function r2(t3, i3) {
            return void 0 === t3[i3.uuid] && (t3[i3.uuid] = i3.toJSON(e2)), i3.uuid;
          }
          if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), true === this.castShadow && (n2.castShadow = true), true === this.receiveShadow && (n2.receiveShadow = true), false === this.visible && (n2.visible = false), false === this.frustumCulled && (n2.frustumCulled = false), 0 !== this.renderOrder && (n2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene)
            this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(e2).uuid)), this.environment && this.environment.isTexture && (n2.environment = this.environment.toJSON(e2).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n2.geometry = r2(e2.geometries, this.geometry);
            const t3 = this.geometry.parameters;
            if (void 0 !== t3 && void 0 !== t3.shapes) {
              const i3 = t3.shapes;
              if (Array.isArray(i3))
                for (let t4 = 0, n3 = i3.length; t4 < n3; t4++) {
                  const n4 = i3[t4];
                  r2(e2.shapes, n4);
                }
              else
                r2(e2.shapes, i3);
            }
          }
          if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r2(e2.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), void 0 !== this.material)
            if (Array.isArray(this.material)) {
              const t3 = [];
              for (let i3 = 0, n3 = this.material.length; i3 < n3; i3++)
                t3.push(r2(e2.materials, this.material[i3]));
              n2.material = t3;
            } else
              n2.material = r2(e2.materials, this.material);
          if (this.children.length > 0) {
            n2.children = [];
            for (let t3 = 0; t3 < this.children.length; t3++)
              n2.children.push(this.children[t3].toJSON(e2).object);
          }
          if (this.animations.length > 0) {
            n2.animations = [];
            for (let t3 = 0; t3 < this.animations.length; t3++) {
              const i3 = this.animations[t3];
              n2.animations.push(r2(e2.animations, i3));
            }
          }
          if (t2) {
            const t3 = s2(e2.geometries), n3 = s2(e2.materials), r3 = s2(e2.textures), a2 = s2(e2.images), o2 = s2(e2.shapes), l2 = s2(e2.skeletons), h2 = s2(e2.animations), c2 = s2(e2.nodes);
            t3.length > 0 && (i2.geometries = t3), n3.length > 0 && (i2.materials = n3), r3.length > 0 && (i2.textures = r3), a2.length > 0 && (i2.images = a2), o2.length > 0 && (i2.shapes = o2), l2.length > 0 && (i2.skeletons = l2), h2.length > 0 && (i2.animations = h2), c2.length > 0 && (i2.nodes = c2);
          }
          return i2.object = n2, i2;
          function s2(e3) {
            const t3 = [];
            for (const i3 in e3) {
              const n3 = e3[i3];
              delete n3.metadata, t3.push(n3);
            }
            return t3;
          }
        }
        clone(e2) {
          return new this.constructor().copy(this, e2);
        }
        copy(e2, t2 = true) {
          if (this.name = e2.name, this.up.copy(e2.up), this.position.copy(e2.position), this.rotation.order = e2.rotation.order, this.quaternion.copy(e2.quaternion), this.scale.copy(e2.scale), this.matrix.copy(e2.matrix), this.matrixWorld.copy(e2.matrixWorld), this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e2.matrixWorldNeedsUpdate, this.layers.mask = e2.layers.mask, this.visible = e2.visible, this.castShadow = e2.castShadow, this.receiveShadow = e2.receiveShadow, this.frustumCulled = e2.frustumCulled, this.renderOrder = e2.renderOrder, this.userData = JSON.parse(JSON.stringify(e2.userData)), true === t2)
            for (let i2 = 0; i2 < e2.children.length; i2++) {
              const t3 = e2.children[i2];
              this.add(t3.clone());
            }
          return this;
        }
      }
      Rt.DefaultUp = new Ae(0, 1, 0), Rt.DefaultMatrixAutoUpdate = true;
      const Lt = new Ae(), It = new Ae(), Dt = new Ae(), Ft = new Ae(), Ot = new Ae(), Ut = new Ae(), zt = new Ae(), Nt = new Ae(), kt = new Ae(), Bt = new Ae();
      class Vt {
        constructor(e2 = new Ae(), t2 = new Ae(), i2 = new Ae()) {
          this.a = e2, this.b = t2, this.c = i2;
        }
        static getNormal(e2, t2, i2, n2) {
          n2.subVectors(i2, t2), Lt.subVectors(e2, t2), n2.cross(Lt);
          const r2 = n2.lengthSq();
          return r2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(r2)) : n2.set(0, 0, 0);
        }
        static getBarycoord(e2, t2, i2, n2, r2) {
          Lt.subVectors(n2, t2), It.subVectors(i2, t2), Dt.subVectors(e2, t2);
          const s2 = Lt.dot(Lt), a2 = Lt.dot(It), o2 = Lt.dot(Dt), l2 = It.dot(It), h2 = It.dot(Dt), c2 = s2 * l2 - a2 * a2;
          if (0 === c2)
            return r2.set(-2, -1, -1);
          const u2 = 1 / c2, d2 = (l2 * o2 - a2 * h2) * u2, p2 = (s2 * h2 - a2 * o2) * u2;
          return r2.set(1 - d2 - p2, p2, d2);
        }
        static containsPoint(e2, t2, i2, n2) {
          return this.getBarycoord(e2, t2, i2, n2, Ft), Ft.x >= 0 && Ft.y >= 0 && Ft.x + Ft.y <= 1;
        }
        static getUV(e2, t2, i2, n2, r2, s2, a2, o2) {
          return this.getBarycoord(e2, t2, i2, n2, Ft), o2.set(0, 0), o2.addScaledVector(r2, Ft.x), o2.addScaledVector(s2, Ft.y), o2.addScaledVector(a2, Ft.z), o2;
        }
        static isFrontFacing(e2, t2, i2, n2) {
          return Lt.subVectors(i2, t2), It.subVectors(e2, t2), Lt.cross(It).dot(n2) < 0;
        }
        set(e2, t2, i2) {
          return this.a.copy(e2), this.b.copy(t2), this.c.copy(i2), this;
        }
        setFromPointsAndIndices(e2, t2, i2, n2) {
          return this.a.copy(e2[t2]), this.b.copy(e2[i2]), this.c.copy(e2[n2]), this;
        }
        setFromAttributeAndIndices(e2, t2, i2, n2) {
          return this.a.fromBufferAttribute(e2, t2), this.b.fromBufferAttribute(e2, i2), this.c.fromBufferAttribute(e2, n2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          return this.a.copy(e2.a), this.b.copy(e2.b), this.c.copy(e2.c), this;
        }
        getArea() {
          return Lt.subVectors(this.c, this.b), It.subVectors(this.a, this.b), 0.5 * Lt.cross(It).length();
        }
        getMidpoint(e2) {
          return e2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e2) {
          return Vt.getNormal(this.a, this.b, this.c, e2);
        }
        getPlane(e2) {
          return e2.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e2, t2) {
          return Vt.getBarycoord(e2, this.a, this.b, this.c, t2);
        }
        getUV(e2, t2, i2, n2, r2) {
          return Vt.getUV(e2, this.a, this.b, this.c, t2, i2, n2, r2);
        }
        containsPoint(e2) {
          return Vt.containsPoint(e2, this.a, this.b, this.c);
        }
        isFrontFacing(e2) {
          return Vt.isFrontFacing(this.a, this.b, this.c, e2);
        }
        intersectsBox(e2) {
          return e2.intersectsTriangle(this);
        }
        closestPointToPoint(e2, t2) {
          const i2 = this.a, n2 = this.b, r2 = this.c;
          let s2, a2;
          Ot.subVectors(n2, i2), Ut.subVectors(r2, i2), Nt.subVectors(e2, i2);
          const o2 = Ot.dot(Nt), l2 = Ut.dot(Nt);
          if (o2 <= 0 && l2 <= 0)
            return t2.copy(i2);
          kt.subVectors(e2, n2);
          const h2 = Ot.dot(kt), c2 = Ut.dot(kt);
          if (h2 >= 0 && c2 <= h2)
            return t2.copy(n2);
          const u2 = o2 * c2 - h2 * l2;
          if (u2 <= 0 && o2 >= 0 && h2 <= 0)
            return s2 = o2 / (o2 - h2), t2.copy(i2).addScaledVector(Ot, s2);
          Bt.subVectors(e2, r2);
          const d2 = Ot.dot(Bt), p2 = Ut.dot(Bt);
          if (p2 >= 0 && d2 <= p2)
            return t2.copy(r2);
          const m2 = d2 * l2 - o2 * p2;
          if (m2 <= 0 && l2 >= 0 && p2 <= 0)
            return a2 = l2 / (l2 - p2), t2.copy(i2).addScaledVector(Ut, a2);
          const f2 = h2 * p2 - d2 * c2;
          if (f2 <= 0 && c2 - h2 >= 0 && d2 - p2 >= 0)
            return zt.subVectors(r2, n2), a2 = (c2 - h2) / (c2 - h2 + (d2 - p2)), t2.copy(n2).addScaledVector(zt, a2);
          const g2 = 1 / (f2 + m2 + u2);
          return s2 = m2 * g2, a2 = u2 * g2, t2.copy(i2).addScaledVector(Ot, s2).addScaledVector(Ut, a2);
        }
        equals(e2) {
          return e2.a.equals(this.a) && e2.b.equals(this.b) && e2.c.equals(this.c);
        }
      }
      let Gt = 0;
      class Ht extends H {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: Gt++ }), this.uuid = Y(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = i, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = k, this.stencilZFail = k, this.stencilZPass = k, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e2) {
          this._alphaTest > 0 != e2 > 0 && this.version++, this._alphaTest = e2;
        }
        onBuild() {
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e2) {
          if (void 0 !== e2)
            for (const t2 in e2) {
              const i2 = e2[t2];
              if (void 0 === i2) {
                console.warn("THREE.Material: '" + t2 + "' parameter is undefined.");
                continue;
              }
              if ("shading" === t2) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i2;
                continue;
              }
              const n2 = this[t2];
              void 0 !== n2 ? n2 && n2.isColor ? n2.set(i2) : n2 && n2.isVector3 && i2 && i2.isVector3 ? n2.copy(i2) : this[t2] = i2 : console.warn("THREE." + this.type + ": '" + t2 + "' is not a property of this material.");
            }
        }
        toJSON(e2) {
          const t2 = void 0 === e2 || "string" == typeof e2;
          t2 && (e2 = { textures: {}, images: {} });
          const i2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
          function n2(e3) {
            const t3 = [];
            for (const i3 in e3) {
              const n3 = e3[i3];
              delete n3.metadata, t3.push(n3);
            }
            return t3;
          }
          if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), this.color && this.color.isColor && (i2.color = this.color.getHex()), void 0 !== this.roughness && (i2.roughness = this.roughness), void 0 !== this.metalness && (i2.metalness = this.metalness), void 0 !== this.sheen && (i2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i2.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i2.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i2.shininess = this.shininess), void 0 !== this.clearcoat && (i2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i2.clearcoatMap = this.clearcoatMap.toJSON(e2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e2).uuid, i2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (i2.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i2.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i2.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i2.iridescenceMap = this.iridescenceMap.toJSON(e2).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e2).uuid), this.map && this.map.isTexture && (i2.map = this.map.toJSON(e2).uuid), this.matcap && this.matcap.isTexture && (i2.matcap = this.matcap.toJSON(e2).uuid), this.alphaMap && this.alphaMap.isTexture && (i2.alphaMap = this.alphaMap.toJSON(e2).uuid), this.lightMap && this.lightMap.isTexture && (i2.lightMap = this.lightMap.toJSON(e2).uuid, i2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i2.aoMap = this.aoMap.toJSON(e2).uuid, i2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i2.bumpMap = this.bumpMap.toJSON(e2).uuid, i2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i2.normalMap = this.normalMap.toJSON(e2).uuid, i2.normalMapType = this.normalMapType, i2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i2.displacementMap = this.displacementMap.toJSON(e2).uuid, i2.displacementScale = this.displacementScale, i2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i2.roughnessMap = this.roughnessMap.toJSON(e2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i2.metalnessMap = this.metalnessMap.toJSON(e2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i2.emissiveMap = this.emissiveMap.toJSON(e2).uuid), this.specularMap && this.specularMap.isTexture && (i2.specularMap = this.specularMap.toJSON(e2).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i2.specularIntensityMap = this.specularIntensityMap.toJSON(e2).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i2.specularColorMap = this.specularColorMap.toJSON(e2).uuid), this.envMap && this.envMap.isTexture && (i2.envMap = this.envMap.toJSON(e2).uuid, void 0 !== this.combine && (i2.combine = this.combine)), void 0 !== this.envMapIntensity && (i2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i2.gradientMap = this.gradientMap.toJSON(e2).uuid), void 0 !== this.transmission && (i2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i2.transmissionMap = this.transmissionMap.toJSON(e2).uuid), void 0 !== this.thickness && (i2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i2.thicknessMap = this.thicknessMap.toJSON(e2).uuid), void 0 !== this.attenuationDistance && (i2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i2.size = this.size), null !== this.shadowSide && (i2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i2.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i2.blending = this.blending), 0 !== this.side && (i2.side = this.side), this.vertexColors && (i2.vertexColors = true), this.opacity < 1 && (i2.opacity = this.opacity), true === this.transparent && (i2.transparent = this.transparent), i2.depthFunc = this.depthFunc, i2.depthTest = this.depthTest, i2.depthWrite = this.depthWrite, i2.colorWrite = this.colorWrite, i2.stencilWrite = this.stencilWrite, i2.stencilWriteMask = this.stencilWriteMask, i2.stencilFunc = this.stencilFunc, i2.stencilRef = this.stencilRef, i2.stencilFuncMask = this.stencilFuncMask, i2.stencilFail = this.stencilFail, i2.stencilZFail = this.stencilZFail, i2.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i2.rotation = this.rotation), true === this.polygonOffset && (i2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i2.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i2.linewidth = this.linewidth), void 0 !== this.dashSize && (i2.dashSize = this.dashSize), void 0 !== this.gapSize && (i2.gapSize = this.gapSize), void 0 !== this.scale && (i2.scale = this.scale), true === this.dithering && (i2.dithering = true), this.alphaTest > 0 && (i2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (i2.flatShading = this.flatShading), false === this.visible && (i2.visible = false), false === this.toneMapped && (i2.toneMapped = false), false === this.fog && (i2.fog = false), "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), t2) {
            const t3 = n2(e2.textures), r2 = n2(e2.images);
            t3.length > 0 && (i2.textures = t3), r2.length > 0 && (i2.images = r2);
          }
          return i2;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          this.name = e2.name, this.blending = e2.blending, this.side = e2.side, this.vertexColors = e2.vertexColors, this.opacity = e2.opacity, this.transparent = e2.transparent, this.blendSrc = e2.blendSrc, this.blendDst = e2.blendDst, this.blendEquation = e2.blendEquation, this.blendSrcAlpha = e2.blendSrcAlpha, this.blendDstAlpha = e2.blendDstAlpha, this.blendEquationAlpha = e2.blendEquationAlpha, this.depthFunc = e2.depthFunc, this.depthTest = e2.depthTest, this.depthWrite = e2.depthWrite, this.stencilWriteMask = e2.stencilWriteMask, this.stencilFunc = e2.stencilFunc, this.stencilRef = e2.stencilRef, this.stencilFuncMask = e2.stencilFuncMask, this.stencilFail = e2.stencilFail, this.stencilZFail = e2.stencilZFail, this.stencilZPass = e2.stencilZPass, this.stencilWrite = e2.stencilWrite;
          const t2 = e2.clippingPlanes;
          let i2 = null;
          if (null !== t2) {
            const e3 = t2.length;
            i2 = new Array(e3);
            for (let n2 = 0; n2 !== e3; ++n2)
              i2[n2] = t2[n2].clone();
          }
          return this.clippingPlanes = i2, this.clipIntersection = e2.clipIntersection, this.clipShadows = e2.clipShadows, this.shadowSide = e2.shadowSide, this.colorWrite = e2.colorWrite, this.precision = e2.precision, this.polygonOffset = e2.polygonOffset, this.polygonOffsetFactor = e2.polygonOffsetFactor, this.polygonOffsetUnits = e2.polygonOffsetUnits, this.dithering = e2.dithering, this.alphaTest = e2.alphaTest, this.alphaToCoverage = e2.alphaToCoverage, this.premultipliedAlpha = e2.premultipliedAlpha, this.visible = e2.visible, this.toneMapped = e2.toneMapped, this.userData = JSON.parse(JSON.stringify(e2.userData)), this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e2) {
          true === e2 && this.version++;
        }
        get vertexTangents() {
          return console.warn("THREE." + this.type + ": .vertexTangents has been removed."), false;
        }
        set vertexTangents(e2) {
          console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        }
      }
      Ht.fromType = function() {
        return null;
      };
      class jt extends Ht {
        constructor(e2) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new ge(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
        }
      }
      const Wt = new Ae(), Xt = new ie();
      class qt {
        constructor(e2, t2, i2) {
          if (Array.isArray(e2))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, this.name = "", this.array = e2, this.itemSize = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.normalized = true === i2, this.usage = B, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(e2) {
          true === e2 && this.version++;
        }
        setUsage(e2) {
          return this.usage = e2, this;
        }
        copy(e2) {
          return this.name = e2.name, this.array = new e2.array.constructor(e2.array), this.itemSize = e2.itemSize, this.count = e2.count, this.normalized = e2.normalized, this.usage = e2.usage, this;
        }
        copyAt(e2, t2, i2) {
          e2 *= this.itemSize, i2 *= t2.itemSize;
          for (let n2 = 0, r2 = this.itemSize; n2 < r2; n2++)
            this.array[e2 + n2] = t2.array[i2 + n2];
          return this;
        }
        copyArray(e2) {
          return this.array.set(e2), this;
        }
        copyColorsArray(e2) {
          const t2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            let r3 = e2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n2), r3 = new ge()), t2[i2++] = r3.r, t2[i2++] = r3.g, t2[i2++] = r3.b;
          }
          return this;
        }
        copyVector2sArray(e2) {
          const t2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            let r3 = e2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n2), r3 = new ie()), t2[i2++] = r3.x, t2[i2++] = r3.y;
          }
          return this;
        }
        copyVector3sArray(e2) {
          const t2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            let r3 = e2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n2), r3 = new Ae()), t2[i2++] = r3.x, t2[i2++] = r3.y, t2[i2++] = r3.z;
          }
          return this;
        }
        copyVector4sArray(e2) {
          const t2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            let r3 = e2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n2), r3 = new Se()), t2[i2++] = r3.x, t2[i2++] = r3.y, t2[i2++] = r3.z, t2[i2++] = r3.w;
          }
          return this;
        }
        applyMatrix3(e2) {
          if (2 === this.itemSize)
            for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
              Xt.fromBufferAttribute(this, t2), Xt.applyMatrix3(e2), this.setXY(t2, Xt.x, Xt.y);
          else if (3 === this.itemSize)
            for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
              Wt.fromBufferAttribute(this, t2), Wt.applyMatrix3(e2), this.setXYZ(t2, Wt.x, Wt.y, Wt.z);
          return this;
        }
        applyMatrix4(e2) {
          for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
            Wt.fromBufferAttribute(this, t2), Wt.applyMatrix4(e2), this.setXYZ(t2, Wt.x, Wt.y, Wt.z);
          return this;
        }
        applyNormalMatrix(e2) {
          for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
            Wt.fromBufferAttribute(this, t2), Wt.applyNormalMatrix(e2), this.setXYZ(t2, Wt.x, Wt.y, Wt.z);
          return this;
        }
        transformDirection(e2) {
          for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
            Wt.fromBufferAttribute(this, t2), Wt.transformDirection(e2), this.setXYZ(t2, Wt.x, Wt.y, Wt.z);
          return this;
        }
        set(e2, t2 = 0) {
          return this.array.set(e2, t2), this;
        }
        getX(e2) {
          return this.array[e2 * this.itemSize];
        }
        setX(e2, t2) {
          return this.array[e2 * this.itemSize] = t2, this;
        }
        getY(e2) {
          return this.array[e2 * this.itemSize + 1];
        }
        setY(e2, t2) {
          return this.array[e2 * this.itemSize + 1] = t2, this;
        }
        getZ(e2) {
          return this.array[e2 * this.itemSize + 2];
        }
        setZ(e2, t2) {
          return this.array[e2 * this.itemSize + 2] = t2, this;
        }
        getW(e2) {
          return this.array[e2 * this.itemSize + 3];
        }
        setW(e2, t2) {
          return this.array[e2 * this.itemSize + 3] = t2, this;
        }
        setXY(e2, t2, i2) {
          return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = i2, this;
        }
        setXYZ(e2, t2, i2, n2) {
          return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = i2, this.array[e2 + 2] = n2, this;
        }
        setXYZW(e2, t2, i2, n2, r2) {
          return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = i2, this.array[e2 + 2] = n2, this.array[e2 + 3] = r2, this;
        }
        onUpload(e2) {
          return this.onUploadCallback = e2, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
          return "" !== this.name && (e2.name = this.name), this.usage !== B && (e2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e2.updateRange = this.updateRange), e2;
        }
      }
      class Yt extends qt {
        constructor(e2, t2, i2) {
          super(new Uint16Array(e2), t2, i2);
        }
      }
      class Zt extends qt {
        constructor(e2, t2, i2) {
          super(new Uint32Array(e2), t2, i2);
        }
      }
      class Jt extends qt {
        constructor(e2, t2, i2) {
          super(new Float32Array(e2), t2, i2);
        }
      }
      let Kt = 0;
      const Qt = new st(), $t = new Rt(), ei = new Ae(), ti = new Le(), ii = new Le(), ni = new Ae();
      class ri extends H {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: Kt++ }), this.uuid = Y(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e2) {
          return Array.isArray(e2) ? this.index = new (re(e2) ? Zt : Yt)(e2, 1) : this.index = e2, this;
        }
        getAttribute(e2) {
          return this.attributes[e2];
        }
        setAttribute(e2, t2) {
          return this.attributes[e2] = t2, this;
        }
        deleteAttribute(e2) {
          return delete this.attributes[e2], this;
        }
        hasAttribute(e2) {
          return void 0 !== this.attributes[e2];
        }
        addGroup(e2, t2, i2 = 0) {
          this.groups.push({ start: e2, count: t2, materialIndex: i2 });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e2, t2) {
          this.drawRange.start = e2, this.drawRange.count = t2;
        }
        applyMatrix4(e2) {
          const t2 = this.attributes.position;
          void 0 !== t2 && (t2.applyMatrix4(e2), t2.needsUpdate = true);
          const i2 = this.attributes.normal;
          if (void 0 !== i2) {
            const t3 = new ne().getNormalMatrix(e2);
            i2.applyNormalMatrix(t3), i2.needsUpdate = true;
          }
          const n2 = this.attributes.tangent;
          return void 0 !== n2 && (n2.transformDirection(e2), n2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e2) {
          return Qt.makeRotationFromQuaternion(e2), this.applyMatrix4(Qt), this;
        }
        rotateX(e2) {
          return Qt.makeRotationX(e2), this.applyMatrix4(Qt), this;
        }
        rotateY(e2) {
          return Qt.makeRotationY(e2), this.applyMatrix4(Qt), this;
        }
        rotateZ(e2) {
          return Qt.makeRotationZ(e2), this.applyMatrix4(Qt), this;
        }
        translate(e2, t2, i2) {
          return Qt.makeTranslation(e2, t2, i2), this.applyMatrix4(Qt), this;
        }
        scale(e2, t2, i2) {
          return Qt.makeScale(e2, t2, i2), this.applyMatrix4(Qt), this;
        }
        lookAt(e2) {
          return $t.lookAt(e2), $t.updateMatrix(), this.applyMatrix4($t.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(ei).negate(), this.translate(ei.x, ei.y, ei.z), this;
        }
        setFromPoints(e2) {
          const t2 = [];
          for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
            const n3 = e2[i2];
            t2.push(n3.x, n3.y, n3.z || 0);
          }
          return this.setAttribute("position", new Jt(t2, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Le());
          const e2 = this.attributes.position, t2 = this.morphAttributes.position;
          if (e2 && e2.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Ae(-1 / 0, -1 / 0, -1 / 0), new Ae(1 / 0, 1 / 0, 1 / 0));
          if (void 0 !== e2) {
            if (this.boundingBox.setFromBufferAttribute(e2), t2)
              for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
                const e3 = t2[i2];
                ti.setFromBufferAttribute(e3), this.morphTargetsRelative ? (ni.addVectors(this.boundingBox.min, ti.min), this.boundingBox.expandByPoint(ni), ni.addVectors(this.boundingBox.max, ti.max), this.boundingBox.expandByPoint(ni)) : (this.boundingBox.expandByPoint(ti.min), this.boundingBox.expandByPoint(ti.max));
              }
          } else
            this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Je());
          const e2 = this.attributes.position, t2 = this.morphAttributes.position;
          if (e2 && e2.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Ae(), 1 / 0);
          if (e2) {
            const i2 = this.boundingSphere.center;
            if (ti.setFromBufferAttribute(e2), t2)
              for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) {
                const i3 = t2[e3];
                ii.setFromBufferAttribute(i3), this.morphTargetsRelative ? (ni.addVectors(ti.min, ii.min), ti.expandByPoint(ni), ni.addVectors(ti.max, ii.max), ti.expandByPoint(ni)) : (ti.expandByPoint(ii.min), ti.expandByPoint(ii.max));
              }
            ti.getCenter(i2);
            let n2 = 0;
            for (let t3 = 0, r2 = e2.count; t3 < r2; t3++)
              ni.fromBufferAttribute(e2, t3), n2 = Math.max(n2, i2.distanceToSquared(ni));
            if (t2)
              for (let r2 = 0, s2 = t2.length; r2 < s2; r2++) {
                const s3 = t2[r2], a2 = this.morphTargetsRelative;
                for (let t3 = 0, r3 = s3.count; t3 < r3; t3++)
                  ni.fromBufferAttribute(s3, t3), a2 && (ei.fromBufferAttribute(e2, t3), ni.add(ei)), n2 = Math.max(n2, i2.distanceToSquared(ni));
              }
            this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const e2 = this.index, t2 = this.attributes;
          if (null === e2 || void 0 === t2.position || void 0 === t2.normal || void 0 === t2.uv)
            return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          const i2 = e2.array, n2 = t2.position.array, r2 = t2.normal.array, s2 = t2.uv.array, a2 = n2.length / 3;
          false === this.hasAttribute("tangent") && this.setAttribute("tangent", new qt(new Float32Array(4 * a2), 4));
          const o2 = this.getAttribute("tangent").array, l2 = [], h2 = [];
          for (let T2 = 0; T2 < a2; T2++)
            l2[T2] = new Ae(), h2[T2] = new Ae();
          const c2 = new Ae(), u2 = new Ae(), d2 = new Ae(), p2 = new ie(), m2 = new ie(), f2 = new ie(), g2 = new Ae(), _2 = new Ae();
          function v2(e3, t3, i3) {
            c2.fromArray(n2, 3 * e3), u2.fromArray(n2, 3 * t3), d2.fromArray(n2, 3 * i3), p2.fromArray(s2, 2 * e3), m2.fromArray(s2, 2 * t3), f2.fromArray(s2, 2 * i3), u2.sub(c2), d2.sub(c2), m2.sub(p2), f2.sub(p2);
            const r3 = 1 / (m2.x * f2.y - f2.x * m2.y);
            isFinite(r3) && (g2.copy(u2).multiplyScalar(f2.y).addScaledVector(d2, -m2.y).multiplyScalar(r3), _2.copy(d2).multiplyScalar(m2.x).addScaledVector(u2, -f2.x).multiplyScalar(r3), l2[e3].add(g2), l2[t3].add(g2), l2[i3].add(g2), h2[e3].add(_2), h2[t3].add(_2), h2[i3].add(_2));
          }
          let x2 = this.groups;
          0 === x2.length && (x2 = [{ start: 0, count: i2.length }]);
          for (let T2 = 0, E2 = x2.length; T2 < E2; ++T2) {
            const e3 = x2[T2], t3 = e3.start;
            for (let n3 = t3, r3 = t3 + e3.count; n3 < r3; n3 += 3)
              v2(i2[n3 + 0], i2[n3 + 1], i2[n3 + 2]);
          }
          const y2 = new Ae(), b2 = new Ae(), M2 = new Ae(), S2 = new Ae();
          function w2(e3) {
            M2.fromArray(r2, 3 * e3), S2.copy(M2);
            const t3 = l2[e3];
            y2.copy(t3), y2.sub(M2.multiplyScalar(M2.dot(t3))).normalize(), b2.crossVectors(S2, t3);
            const i3 = b2.dot(h2[e3]) < 0 ? -1 : 1;
            o2[4 * e3] = y2.x, o2[4 * e3 + 1] = y2.y, o2[4 * e3 + 2] = y2.z, o2[4 * e3 + 3] = i3;
          }
          for (let T2 = 0, E2 = x2.length; T2 < E2; ++T2) {
            const e3 = x2[T2], t3 = e3.start;
            for (let n3 = t3, r3 = t3 + e3.count; n3 < r3; n3 += 3)
              w2(i2[n3 + 0]), w2(i2[n3 + 1]), w2(i2[n3 + 2]);
          }
        }
        computeVertexNormals() {
          const e2 = this.index, t2 = this.getAttribute("position");
          if (void 0 !== t2) {
            let i2 = this.getAttribute("normal");
            if (void 0 === i2)
              i2 = new qt(new Float32Array(3 * t2.count), 3), this.setAttribute("normal", i2);
            else
              for (let e3 = 0, t3 = i2.count; e3 < t3; e3++)
                i2.setXYZ(e3, 0, 0, 0);
            const n2 = new Ae(), r2 = new Ae(), s2 = new Ae(), a2 = new Ae(), o2 = new Ae(), l2 = new Ae(), h2 = new Ae(), c2 = new Ae();
            if (e2)
              for (let u2 = 0, d2 = e2.count; u2 < d2; u2 += 3) {
                const d3 = e2.getX(u2 + 0), p2 = e2.getX(u2 + 1), m2 = e2.getX(u2 + 2);
                n2.fromBufferAttribute(t2, d3), r2.fromBufferAttribute(t2, p2), s2.fromBufferAttribute(t2, m2), h2.subVectors(s2, r2), c2.subVectors(n2, r2), h2.cross(c2), a2.fromBufferAttribute(i2, d3), o2.fromBufferAttribute(i2, p2), l2.fromBufferAttribute(i2, m2), a2.add(h2), o2.add(h2), l2.add(h2), i2.setXYZ(d3, a2.x, a2.y, a2.z), i2.setXYZ(p2, o2.x, o2.y, o2.z), i2.setXYZ(m2, l2.x, l2.y, l2.z);
              }
            else
              for (let e3 = 0, u2 = t2.count; e3 < u2; e3 += 3)
                n2.fromBufferAttribute(t2, e3 + 0), r2.fromBufferAttribute(t2, e3 + 1), s2.fromBufferAttribute(t2, e3 + 2), h2.subVectors(s2, r2), c2.subVectors(n2, r2), h2.cross(c2), i2.setXYZ(e3 + 0, h2.x, h2.y, h2.z), i2.setXYZ(e3 + 1, h2.x, h2.y, h2.z), i2.setXYZ(e3 + 2, h2.x, h2.y, h2.z);
            this.normalizeNormals(), i2.needsUpdate = true;
          }
        }
        merge(e2, t2) {
          if (!e2 || !e2.isBufferGeometry)
            return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e2);
          void 0 === t2 && (t2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
          const i2 = this.attributes;
          for (const n2 in i2) {
            if (void 0 === e2.attributes[n2])
              continue;
            const r2 = i2[n2].array, s2 = e2.attributes[n2], a2 = s2.array, o2 = s2.itemSize * t2, l2 = Math.min(a2.length, r2.length - o2);
            for (let e3 = 0, t3 = o2; e3 < l2; e3++, t3++)
              r2[t3] = a2[e3];
          }
          return this;
        }
        normalizeNormals() {
          const e2 = this.attributes.normal;
          for (let t2 = 0, i2 = e2.count; t2 < i2; t2++)
            ni.fromBufferAttribute(e2, t2), ni.normalize(), e2.setXYZ(t2, ni.x, ni.y, ni.z);
        }
        toNonIndexed() {
          function e2(e3, t3) {
            const i3 = e3.array, n3 = e3.itemSize, r3 = e3.normalized, s3 = new i3.constructor(t3.length * n3);
            let a2 = 0, o2 = 0;
            for (let l2 = 0, h2 = t3.length; l2 < h2; l2++) {
              a2 = e3.isInterleavedBufferAttribute ? t3[l2] * e3.data.stride + e3.offset : t3[l2] * n3;
              for (let e4 = 0; e4 < n3; e4++)
                s3[o2++] = i3[a2++];
            }
            return new qt(s3, n3, r3);
          }
          if (null === this.index)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t2 = new ri(), i2 = this.index.array, n2 = this.attributes;
          for (const a2 in n2) {
            const r3 = e2(n2[a2], i2);
            t2.setAttribute(a2, r3);
          }
          const r2 = this.morphAttributes;
          for (const a2 in r2) {
            const n3 = [], s3 = r2[a2];
            for (let t3 = 0, r3 = s3.length; t3 < r3; t3++) {
              const r4 = e2(s3[t3], i2);
              n3.push(r4);
            }
            t2.morphAttributes[a2] = n3;
          }
          t2.morphTargetsRelative = this.morphTargetsRelative;
          const s2 = this.groups;
          for (let a2 = 0, o2 = s2.length; a2 < o2; a2++) {
            const e3 = s2[a2];
            t2.addGroup(e3.start, e3.count, e3.materialIndex);
          }
          return t2;
        }
        toJSON() {
          const e2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
          if (e2.uuid = this.uuid, e2.type = this.type, "" !== this.name && (e2.name = this.name), Object.keys(this.userData).length > 0 && (e2.userData = this.userData), void 0 !== this.parameters) {
            const t3 = this.parameters;
            for (const i3 in t3)
              void 0 !== t3[i3] && (e2[i3] = t3[i3]);
            return e2;
          }
          e2.data = { attributes: {} };
          const t2 = this.index;
          null !== t2 && (e2.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
          const i2 = this.attributes;
          for (const o2 in i2) {
            const t3 = i2[o2];
            e2.data.attributes[o2] = t3.toJSON(e2.data);
          }
          const n2 = {};
          let r2 = false;
          for (const o2 in this.morphAttributes) {
            const t3 = this.morphAttributes[o2], i3 = [];
            for (let n3 = 0, r3 = t3.length; n3 < r3; n3++) {
              const r4 = t3[n3];
              i3.push(r4.toJSON(e2.data));
            }
            i3.length > 0 && (n2[o2] = i3, r2 = true);
          }
          r2 && (e2.data.morphAttributes = n2, e2.data.morphTargetsRelative = this.morphTargetsRelative);
          const s2 = this.groups;
          s2.length > 0 && (e2.data.groups = JSON.parse(JSON.stringify(s2)));
          const a2 = this.boundingSphere;
          return null !== a2 && (e2.data.boundingSphere = { center: a2.center.toArray(), radius: a2.radius }), e2;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const t2 = {};
          this.name = e2.name;
          const i2 = e2.index;
          null !== i2 && this.setIndex(i2.clone(t2));
          const n2 = e2.attributes;
          for (const l2 in n2) {
            const e3 = n2[l2];
            this.setAttribute(l2, e3.clone(t2));
          }
          const r2 = e2.morphAttributes;
          for (const l2 in r2) {
            const e3 = [], i3 = r2[l2];
            for (let n3 = 0, r3 = i3.length; n3 < r3; n3++)
              e3.push(i3[n3].clone(t2));
            this.morphAttributes[l2] = e3;
          }
          this.morphTargetsRelative = e2.morphTargetsRelative;
          const s2 = e2.groups;
          for (let l2 = 0, h2 = s2.length; l2 < h2; l2++) {
            const e3 = s2[l2];
            this.addGroup(e3.start, e3.count, e3.materialIndex);
          }
          const a2 = e2.boundingBox;
          null !== a2 && (this.boundingBox = a2.clone());
          const o2 = e2.boundingSphere;
          return null !== o2 && (this.boundingSphere = o2.clone()), this.drawRange.start = e2.drawRange.start, this.drawRange.count = e2.drawRange.count, this.userData = e2.userData, void 0 !== e2.parameters && (this.parameters = Object.assign({}, e2.parameters)), this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const si = new st(), ai = new rt(), oi = new Je(), li = new Ae(), hi = new Ae(), ci = new Ae(), ui = new Ae(), di = new Ae(), pi = new Ae(), mi = new Ae(), fi = new Ae(), gi = new Ae(), _i = new ie(), vi = new ie(), xi = new ie(), yi = new Ae(), bi = new Ae();
      class Mi extends Rt {
        constructor(e2 = new ri(), t2 = new jt()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = e2, this.material = t2, this.updateMorphTargets();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), void 0 !== e2.morphTargetInfluences && (this.morphTargetInfluences = e2.morphTargetInfluences.slice()), void 0 !== e2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e2.morphTargetDictionary)), this.material = e2.material, this.geometry = e2.geometry, this;
        }
        updateMorphTargets() {
          const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
          if (t2.length > 0) {
            const i2 = e2[t2[0]];
            if (void 0 !== i2) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
                const t4 = i2[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
              }
            }
          }
        }
        raycast(e2, t2) {
          const i2 = this.geometry, n2 = this.material, r2 = this.matrixWorld;
          if (void 0 === n2)
            return;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), oi.copy(i2.boundingSphere), oi.applyMatrix4(r2), false === e2.ray.intersectsSphere(oi))
            return;
          if (si.copy(r2).invert(), ai.copy(e2.ray).applyMatrix4(si), null !== i2.boundingBox && false === ai.intersectsBox(i2.boundingBox))
            return;
          let s2;
          const a2 = i2.index, o2 = i2.attributes.position, l2 = i2.morphAttributes.position, h2 = i2.morphTargetsRelative, c2 = i2.attributes.uv, u2 = i2.attributes.uv2, d2 = i2.groups, p2 = i2.drawRange;
          if (null !== a2)
            if (Array.isArray(n2))
              for (let m2 = 0, f2 = d2.length; m2 < f2; m2++) {
                const i3 = d2[m2], r3 = n2[i3.materialIndex];
                for (let n3 = Math.max(i3.start, p2.start), d3 = Math.min(a2.count, Math.min(i3.start + i3.count, p2.start + p2.count)); n3 < d3; n3 += 3) {
                  const d4 = a2.getX(n3), p3 = a2.getX(n3 + 1), m3 = a2.getX(n3 + 2);
                  s2 = Si(this, r3, e2, ai, o2, l2, h2, c2, u2, d4, p3, m3), s2 && (s2.faceIndex = Math.floor(n3 / 3), s2.face.materialIndex = i3.materialIndex, t2.push(s2));
                }
              }
            else {
              for (let i3 = Math.max(0, p2.start), r3 = Math.min(a2.count, p2.start + p2.count); i3 < r3; i3 += 3) {
                const r4 = a2.getX(i3), d3 = a2.getX(i3 + 1), p3 = a2.getX(i3 + 2);
                s2 = Si(this, n2, e2, ai, o2, l2, h2, c2, u2, r4, d3, p3), s2 && (s2.faceIndex = Math.floor(i3 / 3), t2.push(s2));
              }
            }
          else if (void 0 !== o2)
            if (Array.isArray(n2))
              for (let m2 = 0, f2 = d2.length; m2 < f2; m2++) {
                const i3 = d2[m2], r3 = n2[i3.materialIndex];
                for (let n3 = Math.max(i3.start, p2.start), a3 = Math.min(o2.count, Math.min(i3.start + i3.count, p2.start + p2.count)); n3 < a3; n3 += 3) {
                  s2 = Si(this, r3, e2, ai, o2, l2, h2, c2, u2, n3, n3 + 1, n3 + 2), s2 && (s2.faceIndex = Math.floor(n3 / 3), s2.face.materialIndex = i3.materialIndex, t2.push(s2));
                }
              }
            else {
              for (let i3 = Math.max(0, p2.start), r3 = Math.min(o2.count, p2.start + p2.count); i3 < r3; i3 += 3) {
                s2 = Si(this, n2, e2, ai, o2, l2, h2, c2, u2, i3, i3 + 1, i3 + 2), s2 && (s2.faceIndex = Math.floor(i3 / 3), t2.push(s2));
              }
            }
        }
      }
      function Si(e2, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2, u2) {
        li.fromBufferAttribute(r2, h2), hi.fromBufferAttribute(r2, c2), ci.fromBufferAttribute(r2, u2);
        const d2 = e2.morphTargetInfluences;
        if (s2 && d2) {
          mi.set(0, 0, 0), fi.set(0, 0, 0), gi.set(0, 0, 0);
          for (let e3 = 0, t3 = s2.length; e3 < t3; e3++) {
            const t4 = d2[e3], i3 = s2[e3];
            0 !== t4 && (ui.fromBufferAttribute(i3, h2), di.fromBufferAttribute(i3, c2), pi.fromBufferAttribute(i3, u2), a2 ? (mi.addScaledVector(ui, t4), fi.addScaledVector(di, t4), gi.addScaledVector(pi, t4)) : (mi.addScaledVector(ui.sub(li), t4), fi.addScaledVector(di.sub(hi), t4), gi.addScaledVector(pi.sub(ci), t4)));
          }
          li.add(mi), hi.add(fi), ci.add(gi);
        }
        e2.isSkinnedMesh && (e2.boneTransform(h2, li), e2.boneTransform(c2, hi), e2.boneTransform(u2, ci));
        const p2 = function(e3, t3, i3, n3, r3, s3, a3, o3) {
          let l3;
          if (l3 = 1 === t3.side ? n3.intersectTriangle(a3, s3, r3, true, o3) : n3.intersectTriangle(r3, s3, a3, 2 !== t3.side, o3), null === l3)
            return null;
          bi.copy(o3), bi.applyMatrix4(e3.matrixWorld);
          const h3 = i3.ray.origin.distanceTo(bi);
          return h3 < i3.near || h3 > i3.far ? null : { distance: h3, point: bi.clone(), object: e3 };
        }(e2, t2, i2, n2, li, hi, ci, yi);
        if (p2) {
          o2 && (_i.fromBufferAttribute(o2, h2), vi.fromBufferAttribute(o2, c2), xi.fromBufferAttribute(o2, u2), p2.uv = Vt.getUV(yi, li, hi, ci, _i, vi, xi, new ie())), l2 && (_i.fromBufferAttribute(l2, h2), vi.fromBufferAttribute(l2, c2), xi.fromBufferAttribute(l2, u2), p2.uv2 = Vt.getUV(yi, li, hi, ci, _i, vi, xi, new ie()));
          const e3 = { a: h2, b: c2, c: u2, normal: new Ae(), materialIndex: 0 };
          Vt.getNormal(li, hi, ci, e3.normal), p2.face = e3;
        }
        return p2;
      }
      class wi extends ri {
        constructor(e2 = 1, t2 = 1, i2 = 1, n2 = 1, r2 = 1, s2 = 1) {
          super(), this.type = "BoxGeometry", this.parameters = { width: e2, height: t2, depth: i2, widthSegments: n2, heightSegments: r2, depthSegments: s2 };
          const a2 = this;
          n2 = Math.floor(n2), r2 = Math.floor(r2), s2 = Math.floor(s2);
          const o2 = [], l2 = [], h2 = [], c2 = [];
          let u2 = 0, d2 = 0;
          function p2(e3, t3, i3, n3, r3, s3, p3, m2, f2, g2, _2) {
            const v2 = s3 / f2, x2 = p3 / g2, y2 = s3 / 2, b2 = p3 / 2, M2 = m2 / 2, S2 = f2 + 1, w2 = g2 + 1;
            let T2 = 0, E2 = 0;
            const C2 = new Ae();
            for (let a3 = 0; a3 < w2; a3++) {
              const s4 = a3 * x2 - b2;
              for (let o3 = 0; o3 < S2; o3++) {
                const u3 = o3 * v2 - y2;
                C2[e3] = u3 * n3, C2[t3] = s4 * r3, C2[i3] = M2, l2.push(C2.x, C2.y, C2.z), C2[e3] = 0, C2[t3] = 0, C2[i3] = m2 > 0 ? 1 : -1, h2.push(C2.x, C2.y, C2.z), c2.push(o3 / f2), c2.push(1 - a3 / g2), T2 += 1;
              }
            }
            for (let a3 = 0; a3 < g2; a3++)
              for (let e4 = 0; e4 < f2; e4++) {
                const t4 = u2 + e4 + S2 * a3, i4 = u2 + e4 + S2 * (a3 + 1), n4 = u2 + (e4 + 1) + S2 * (a3 + 1), r4 = u2 + (e4 + 1) + S2 * a3;
                o2.push(t4, i4, r4), o2.push(i4, n4, r4), E2 += 6;
              }
            a2.addGroup(d2, E2, _2), d2 += E2, u2 += T2;
          }
          p2("z", "y", "x", -1, -1, i2, t2, e2, s2, r2, 0), p2("z", "y", "x", 1, -1, i2, t2, -e2, s2, r2, 1), p2("x", "z", "y", 1, 1, e2, i2, t2, n2, s2, 2), p2("x", "z", "y", 1, -1, e2, i2, -t2, n2, s2, 3), p2("x", "y", "z", 1, -1, e2, t2, i2, n2, r2, 4), p2("x", "y", "z", -1, -1, e2, t2, -i2, n2, r2, 5), this.setIndex(o2), this.setAttribute("position", new Jt(l2, 3)), this.setAttribute("normal", new Jt(h2, 3)), this.setAttribute("uv", new Jt(c2, 2));
        }
        static fromJSON(e2) {
          return new wi(e2.width, e2.height, e2.depth, e2.widthSegments, e2.heightSegments, e2.depthSegments);
        }
      }
      function Ti(e2) {
        const t2 = {};
        for (const i2 in e2) {
          t2[i2] = {};
          for (const n2 in e2[i2]) {
            const r2 = e2[i2][n2];
            r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? t2[i2][n2] = r2.clone() : Array.isArray(r2) ? t2[i2][n2] = r2.slice() : t2[i2][n2] = r2;
          }
        }
        return t2;
      }
      function Ei(e2) {
        const t2 = {};
        for (let i2 = 0; i2 < e2.length; i2++) {
          const n2 = Ti(e2[i2]);
          for (const e3 in n2)
            t2[e3] = n2[e3];
        }
        return t2;
      }
      const Ci = { clone: Ti, merge: Ei };
      class Ai extends Ht {
        constructor(e2) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e2 && (void 0 !== e2.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e2));
        }
        copy(e2) {
          return super.copy(e2), this.fragmentShader = e2.fragmentShader, this.vertexShader = e2.vertexShader, this.uniforms = Ti(e2.uniforms), this.defines = Object.assign({}, e2.defines), this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.fog = e2.fog, this.lights = e2.lights, this.clipping = e2.clipping, this.extensions = Object.assign({}, e2.extensions), this.glslVersion = e2.glslVersion, this;
        }
        toJSON(e2) {
          const t2 = super.toJSON(e2);
          t2.glslVersion = this.glslVersion, t2.uniforms = {};
          for (const n2 in this.uniforms) {
            const i3 = this.uniforms[n2].value;
            i3 && i3.isTexture ? t2.uniforms[n2] = { type: "t", value: i3.toJSON(e2).uuid } : i3 && i3.isColor ? t2.uniforms[n2] = { type: "c", value: i3.getHex() } : i3 && i3.isVector2 ? t2.uniforms[n2] = { type: "v2", value: i3.toArray() } : i3 && i3.isVector3 ? t2.uniforms[n2] = { type: "v3", value: i3.toArray() } : i3 && i3.isVector4 ? t2.uniforms[n2] = { type: "v4", value: i3.toArray() } : i3 && i3.isMatrix3 ? t2.uniforms[n2] = { type: "m3", value: i3.toArray() } : i3 && i3.isMatrix4 ? t2.uniforms[n2] = { type: "m4", value: i3.toArray() } : t2.uniforms[n2] = { value: i3 };
          }
          Object.keys(this.defines).length > 0 && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader;
          const i2 = {};
          for (const n2 in this.extensions)
            true === this.extensions[n2] && (i2[n2] = true);
          return Object.keys(i2).length > 0 && (t2.extensions = i2), t2;
        }
      }
      class Pi extends Rt {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new st(), this.projectionMatrix = new st(), this.projectionMatrixInverse = new st();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.matrixWorldInverse.copy(e2.matrixWorldInverse), this.projectionMatrix.copy(e2.projectionMatrix), this.projectionMatrixInverse.copy(e2.projectionMatrixInverse), this;
        }
        getWorldDirection(e2) {
          this.updateWorldMatrix(true, false);
          const t2 = this.matrixWorld.elements;
          return e2.set(-t2[8], -t2[9], -t2[10]).normalize();
        }
        updateMatrixWorld(e2) {
          super.updateMatrixWorld(e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e2, t2) {
          super.updateWorldMatrix(e2, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ri extends Pi {
        constructor(e2 = 50, t2 = 1, i2 = 0.1, n2 = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e2, this.zoom = 1, this.near = i2, this.far = n2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.fov = e2.fov, this.zoom = e2.zoom, this.near = e2.near, this.far = e2.far, this.focus = e2.focus, this.aspect = e2.aspect, this.view = null === e2.view ? null : Object.assign({}, e2.view), this.filmGauge = e2.filmGauge, this.filmOffset = e2.filmOffset, this;
        }
        setFocalLength(e2) {
          const t2 = 0.5 * this.getFilmHeight() / e2;
          this.fov = 2 * q * Math.atan(t2), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e2 = Math.tan(0.5 * X * this.fov);
          return 0.5 * this.getFilmHeight() / e2;
        }
        getEffectiveFOV() {
          return 2 * q * Math.atan(Math.tan(0.5 * X * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e2, t2, i2, n2, r2, s2) {
          this.aspect = e2 / t2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e2 = this.near;
          let t2 = e2 * Math.tan(0.5 * X * this.fov) / this.zoom, i2 = 2 * t2, n2 = this.aspect * i2, r2 = -0.5 * n2;
          const s2 = this.view;
          if (null !== this.view && this.view.enabled) {
            const e3 = s2.fullWidth, a3 = s2.fullHeight;
            r2 += s2.offsetX * n2 / e3, t2 -= s2.offsetY * i2 / a3, n2 *= s2.width / e3, i2 *= s2.height / a3;
          }
          const a2 = this.filmOffset;
          0 !== a2 && (r2 += e2 * a2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + n2, t2, t2 - i2, e2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e2) {
          const t2 = super.toJSON(e2);
          return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
        }
      }
      const Li = 90;
      class Ii extends Rt {
        constructor(e2, t2, i2) {
          if (super(), this.type = "CubeCamera", true !== i2.isWebGLCubeRenderTarget)
            return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          this.renderTarget = i2;
          const n2 = new Ri(Li, 1, e2, t2);
          n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new Ae(1, 0, 0)), this.add(n2);
          const r2 = new Ri(Li, 1, e2, t2);
          r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new Ae(-1, 0, 0)), this.add(r2);
          const s2 = new Ri(Li, 1, e2, t2);
          s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(new Ae(0, 1, 0)), this.add(s2);
          const a2 = new Ri(Li, 1, e2, t2);
          a2.layers = this.layers, a2.up.set(0, 0, -1), a2.lookAt(new Ae(0, -1, 0)), this.add(a2);
          const o2 = new Ri(Li, 1, e2, t2);
          o2.layers = this.layers, o2.up.set(0, -1, 0), o2.lookAt(new Ae(0, 0, 1)), this.add(o2);
          const l2 = new Ri(Li, 1, e2, t2);
          l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new Ae(0, 0, -1)), this.add(l2);
        }
        update(e2, t2) {
          null === this.parent && this.updateMatrixWorld();
          const i2 = this.renderTarget, [n2, r2, s2, a2, o2, l2] = this.children, h2 = e2.getRenderTarget(), c2 = e2.toneMapping, u2 = e2.xr.enabled;
          e2.toneMapping = 0, e2.xr.enabled = false;
          const d2 = i2.texture.generateMipmaps;
          i2.texture.generateMipmaps = false, e2.setRenderTarget(i2, 0), e2.render(t2, n2), e2.setRenderTarget(i2, 1), e2.render(t2, r2), e2.setRenderTarget(i2, 2), e2.render(t2, s2), e2.setRenderTarget(i2, 3), e2.render(t2, a2), e2.setRenderTarget(i2, 4), e2.render(t2, o2), i2.texture.generateMipmaps = d2, e2.setRenderTarget(i2, 5), e2.render(t2, l2), e2.setRenderTarget(h2), e2.toneMapping = c2, e2.xr.enabled = u2, i2.texture.needsPMREMUpdate = true;
        }
      }
      class Di extends Me {
        constructor(e2, t2, i2, n2, s2, a2, o2, l2, h2, c2) {
          super(e2 = void 0 !== e2 ? e2 : [], t2 = void 0 !== t2 ? t2 : r, i2, n2, s2, a2, o2, l2, h2, c2), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(e2) {
          this.image = e2;
        }
      }
      class Fi extends we {
        constructor(e2, t2 = {}) {
          super(e2, e2, t2), this.isWebGLCubeRenderTarget = true;
          const i2 = { width: e2, height: e2, depth: 1 }, n2 = [i2, i2, i2, i2, i2, i2];
          this.texture = new Di(n2, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t2.generateMipmaps && t2.generateMipmaps, this.texture.minFilter = void 0 !== t2.minFilter ? t2.minFilter : m;
        }
        fromEquirectangularTexture(e2, t2) {
          this.texture.type = t2.type, this.texture.encoding = t2.encoding, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
          const i2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, n2 = new wi(5, 5, 5), r2 = new Ai({ name: "CubemapFromEquirect", uniforms: Ti(i2.uniforms), vertexShader: i2.vertexShader, fragmentShader: i2.fragmentShader, side: 1, blending: 0 });
          r2.uniforms.tEquirect.value = t2;
          const s2 = new Mi(n2, r2), a2 = t2.minFilter;
          t2.minFilter === f && (t2.minFilter = m);
          return new Ii(1, 10, this).update(e2, s2), t2.minFilter = a2, s2.geometry.dispose(), s2.material.dispose(), this;
        }
        clear(e2, t2, i2, n2) {
          const r2 = e2.getRenderTarget();
          for (let s2 = 0; s2 < 6; s2++)
            e2.setRenderTarget(this, s2), e2.clear(t2, i2, n2);
          e2.setRenderTarget(r2);
        }
      }
      const Oi = new Ae(), Ui = new Ae(), zi = new ne();
      class Ni {
        constructor(e2 = new Ae(1, 0, 0), t2 = 0) {
          this.isPlane = true, this.normal = e2, this.constant = t2;
        }
        set(e2, t2) {
          return this.normal.copy(e2), this.constant = t2, this;
        }
        setComponents(e2, t2, i2, n2) {
          return this.normal.set(e2, t2, i2), this.constant = n2, this;
        }
        setFromNormalAndCoplanarPoint(e2, t2) {
          return this.normal.copy(e2), this.constant = -t2.dot(this.normal), this;
        }
        setFromCoplanarPoints(e2, t2, i2) {
          const n2 = Oi.subVectors(i2, t2).cross(Ui.subVectors(e2, t2)).normalize();
          return this.setFromNormalAndCoplanarPoint(n2, e2), this;
        }
        copy(e2) {
          return this.normal.copy(e2.normal), this.constant = e2.constant, this;
        }
        normalize() {
          const e2 = 1 / this.normal.length();
          return this.normal.multiplyScalar(e2), this.constant *= e2, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e2) {
          return this.normal.dot(e2) + this.constant;
        }
        distanceToSphere(e2) {
          return this.distanceToPoint(e2.center) - e2.radius;
        }
        projectPoint(e2, t2) {
          return t2.copy(this.normal).multiplyScalar(-this.distanceToPoint(e2)).add(e2);
        }
        intersectLine(e2, t2) {
          const i2 = e2.delta(Oi), n2 = this.normal.dot(i2);
          if (0 === n2)
            return 0 === this.distanceToPoint(e2.start) ? t2.copy(e2.start) : null;
          const r2 = -(e2.start.dot(this.normal) + this.constant) / n2;
          return r2 < 0 || r2 > 1 ? null : t2.copy(i2).multiplyScalar(r2).add(e2.start);
        }
        intersectsLine(e2) {
          const t2 = this.distanceToPoint(e2.start), i2 = this.distanceToPoint(e2.end);
          return t2 < 0 && i2 > 0 || i2 < 0 && t2 > 0;
        }
        intersectsBox(e2) {
          return e2.intersectsPlane(this);
        }
        intersectsSphere(e2) {
          return e2.intersectsPlane(this);
        }
        coplanarPoint(e2) {
          return e2.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e2, t2) {
          const i2 = t2 || zi.getNormalMatrix(e2), n2 = this.coplanarPoint(Oi).applyMatrix4(e2), r2 = this.normal.applyMatrix3(i2).normalize();
          return this.constant = -n2.dot(r2), this;
        }
        translate(e2) {
          return this.constant -= e2.dot(this.normal), this;
        }
        equals(e2) {
          return e2.normal.equals(this.normal) && e2.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const ki = new Je(), Bi = new Ae();
      class Vi {
        constructor(e2 = new Ni(), t2 = new Ni(), i2 = new Ni(), n2 = new Ni(), r2 = new Ni(), s2 = new Ni()) {
          this.planes = [e2, t2, i2, n2, r2, s2];
        }
        set(e2, t2, i2, n2, r2, s2) {
          const a2 = this.planes;
          return a2[0].copy(e2), a2[1].copy(t2), a2[2].copy(i2), a2[3].copy(n2), a2[4].copy(r2), a2[5].copy(s2), this;
        }
        copy(e2) {
          const t2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++)
            t2[i2].copy(e2.planes[i2]);
          return this;
        }
        setFromProjectionMatrix(e2) {
          const t2 = this.planes, i2 = e2.elements, n2 = i2[0], r2 = i2[1], s2 = i2[2], a2 = i2[3], o2 = i2[4], l2 = i2[5], h2 = i2[6], c2 = i2[7], u2 = i2[8], d2 = i2[9], p2 = i2[10], m2 = i2[11], f2 = i2[12], g2 = i2[13], _2 = i2[14], v2 = i2[15];
          return t2[0].setComponents(a2 - n2, c2 - o2, m2 - u2, v2 - f2).normalize(), t2[1].setComponents(a2 + n2, c2 + o2, m2 + u2, v2 + f2).normalize(), t2[2].setComponents(a2 + r2, c2 + l2, m2 + d2, v2 + g2).normalize(), t2[3].setComponents(a2 - r2, c2 - l2, m2 - d2, v2 - g2).normalize(), t2[4].setComponents(a2 - s2, c2 - h2, m2 - p2, v2 - _2).normalize(), t2[5].setComponents(a2 + s2, c2 + h2, m2 + p2, v2 + _2).normalize(), this;
        }
        intersectsObject(e2) {
          const t2 = e2.geometry;
          return null === t2.boundingSphere && t2.computeBoundingSphere(), ki.copy(t2.boundingSphere).applyMatrix4(e2.matrixWorld), this.intersectsSphere(ki);
        }
        intersectsSprite(e2) {
          return ki.center.set(0, 0, 0), ki.radius = 0.7071067811865476, ki.applyMatrix4(e2.matrixWorld), this.intersectsSphere(ki);
        }
        intersectsSphere(e2) {
          const t2 = this.planes, i2 = e2.center, n2 = -e2.radius;
          for (let r2 = 0; r2 < 6; r2++) {
            if (t2[r2].distanceToPoint(i2) < n2)
              return false;
          }
          return true;
        }
        intersectsBox(e2) {
          const t2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const n2 = t2[i2];
            if (Bi.x = n2.normal.x > 0 ? e2.max.x : e2.min.x, Bi.y = n2.normal.y > 0 ? e2.max.y : e2.min.y, Bi.z = n2.normal.z > 0 ? e2.max.z : e2.min.z, n2.distanceToPoint(Bi) < 0)
              return false;
          }
          return true;
        }
        containsPoint(e2) {
          const t2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++)
            if (t2[i2].distanceToPoint(e2) < 0)
              return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Gi() {
        let e2 = null, t2 = false, i2 = null, n2 = null;
        function r2(t3, s2) {
          i2(t3, s2), n2 = e2.requestAnimationFrame(r2);
        }
        return { start: function() {
          true !== t2 && null !== i2 && (n2 = e2.requestAnimationFrame(r2), t2 = true);
        }, stop: function() {
          e2.cancelAnimationFrame(n2), t2 = false;
        }, setAnimationLoop: function(e3) {
          i2 = e3;
        }, setContext: function(t3) {
          e2 = t3;
        } };
      }
      function Hi(e2, t2) {
        const i2 = t2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
        return { get: function(e3) {
          return e3.isInterleavedBufferAttribute && (e3 = e3.data), n2.get(e3);
        }, remove: function(t3) {
          t3.isInterleavedBufferAttribute && (t3 = t3.data);
          const i3 = n2.get(t3);
          i3 && (e2.deleteBuffer(i3.buffer), n2.delete(t3));
        }, update: function(t3, r2) {
          if (t3.isGLBufferAttribute) {
            const e3 = n2.get(t3);
            return void ((!e3 || e3.version < t3.version) && n2.set(t3, { buffer: t3.buffer, type: t3.type, bytesPerElement: t3.elementSize, version: t3.version }));
          }
          t3.isInterleavedBufferAttribute && (t3 = t3.data);
          const s2 = n2.get(t3);
          void 0 === s2 ? n2.set(t3, function(t4, n3) {
            const r3 = t4.array, s3 = t4.usage, a2 = e2.createBuffer();
            let o2;
            if (e2.bindBuffer(n3, a2), e2.bufferData(n3, r3, s3), t4.onUploadCallback(), r3 instanceof Float32Array)
              o2 = 5126;
            else if (r3 instanceof Uint16Array)
              if (t4.isFloat16BufferAttribute) {
                if (!i2)
                  throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                o2 = 5131;
              } else
                o2 = 5123;
            else if (r3 instanceof Int16Array)
              o2 = 5122;
            else if (r3 instanceof Uint32Array)
              o2 = 5125;
            else if (r3 instanceof Int32Array)
              o2 = 5124;
            else if (r3 instanceof Int8Array)
              o2 = 5120;
            else if (r3 instanceof Uint8Array)
              o2 = 5121;
            else {
              if (!(r3 instanceof Uint8ClampedArray))
                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r3);
              o2 = 5121;
            }
            return { buffer: a2, type: o2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: t4.version };
          }(t3, r2)) : s2.version < t3.version && (!function(t4, n3, r3) {
            const s3 = n3.array, a2 = n3.updateRange;
            e2.bindBuffer(r3, t4), -1 === a2.count ? e2.bufferSubData(r3, 0, s3) : (i2 ? e2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3, a2.offset, a2.count) : e2.bufferSubData(r3, a2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(a2.offset, a2.offset + a2.count)), a2.count = -1);
          }(s2.buffer, t3, r2), s2.version = t3.version);
        } };
      }
      class ji extends ri {
        constructor(e2 = 1, t2 = 1, i2 = 1, n2 = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = { width: e2, height: t2, widthSegments: i2, heightSegments: n2 };
          const r2 = e2 / 2, s2 = t2 / 2, a2 = Math.floor(i2), o2 = Math.floor(n2), l2 = a2 + 1, h2 = o2 + 1, c2 = e2 / a2, u2 = t2 / o2, d2 = [], p2 = [], m2 = [], f2 = [];
          for (let g2 = 0; g2 < h2; g2++) {
            const e3 = g2 * u2 - s2;
            for (let t3 = 0; t3 < l2; t3++) {
              const i3 = t3 * c2 - r2;
              p2.push(i3, -e3, 0), m2.push(0, 0, 1), f2.push(t3 / a2), f2.push(1 - g2 / o2);
            }
          }
          for (let g2 = 0; g2 < o2; g2++)
            for (let e3 = 0; e3 < a2; e3++) {
              const t3 = e3 + l2 * g2, i3 = e3 + l2 * (g2 + 1), n3 = e3 + 1 + l2 * (g2 + 1), r3 = e3 + 1 + l2 * g2;
              d2.push(t3, i3, r3), d2.push(i3, n3, r3);
            }
          this.setIndex(d2), this.setAttribute("position", new Jt(p2, 3)), this.setAttribute("normal", new Jt(m2, 3)), this.setAttribute("uv", new Jt(f2, 2));
        }
        static fromJSON(e2) {
          return new ji(e2.width, e2.height, e2.widthSegments, e2.heightSegments);
        }
      }
      const Wi = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", iridescence_fragment: "#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			#if defined( ENVMAP_TYPE_CUBE_UV )\n				vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n				vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n			#else\n				vec4 envMapColor = textureCube( envMap, worldNormal );\n			#endif\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			#if defined( ENVMAP_TYPE_CUBE_UV )\n				vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			#else\n				vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n				vec4 envMapColor = textureCube( envMap, queryReflectVec );\n			#endif\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n	material.iridescence = 0.0;\n} else {\n	material.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && ( defined( ENVMAP_TYPE_CUBE_UV ) || defined( ENVMAP_TYPE_CUBE ) )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" }, Xi = { common: { diffuse: { value: new ge(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ne() }, uv2Transform: { value: new ne() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new ie(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new ge(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new ge(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ne() } }, sprite: { diffuse: { value: new ge(16777215) }, opacity: { value: 1 }, center: { value: new ie(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new ne() } } }, qi = { basic: { uniforms: Ei([Xi.common, Xi.specularmap, Xi.envmap, Xi.aomap, Xi.lightmap, Xi.fog]), vertexShader: Wi.meshbasic_vert, fragmentShader: Wi.meshbasic_frag }, lambert: { uniforms: Ei([Xi.common, Xi.specularmap, Xi.envmap, Xi.aomap, Xi.lightmap, Xi.emissivemap, Xi.fog, Xi.lights, { emissive: { value: new ge(0) } }]), vertexShader: Wi.meshlambert_vert, fragmentShader: Wi.meshlambert_frag }, phong: { uniforms: Ei([Xi.common, Xi.specularmap, Xi.envmap, Xi.aomap, Xi.lightmap, Xi.emissivemap, Xi.bumpmap, Xi.normalmap, Xi.displacementmap, Xi.fog, Xi.lights, { emissive: { value: new ge(0) }, specular: { value: new ge(1118481) }, shininess: { value: 30 } }]), vertexShader: Wi.meshphong_vert, fragmentShader: Wi.meshphong_frag }, standard: { uniforms: Ei([Xi.common, Xi.envmap, Xi.aomap, Xi.lightmap, Xi.emissivemap, Xi.bumpmap, Xi.normalmap, Xi.displacementmap, Xi.roughnessmap, Xi.metalnessmap, Xi.fog, Xi.lights, { emissive: { value: new ge(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Wi.meshphysical_vert, fragmentShader: Wi.meshphysical_frag }, toon: { uniforms: Ei([Xi.common, Xi.aomap, Xi.lightmap, Xi.emissivemap, Xi.bumpmap, Xi.normalmap, Xi.displacementmap, Xi.gradientmap, Xi.fog, Xi.lights, { emissive: { value: new ge(0) } }]), vertexShader: Wi.meshtoon_vert, fragmentShader: Wi.meshtoon_frag }, matcap: { uniforms: Ei([Xi.common, Xi.bumpmap, Xi.normalmap, Xi.displacementmap, Xi.fog, { matcap: { value: null } }]), vertexShader: Wi.meshmatcap_vert, fragmentShader: Wi.meshmatcap_frag }, points: { uniforms: Ei([Xi.points, Xi.fog]), vertexShader: Wi.points_vert, fragmentShader: Wi.points_frag }, dashed: { uniforms: Ei([Xi.common, Xi.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Wi.linedashed_vert, fragmentShader: Wi.linedashed_frag }, depth: { uniforms: Ei([Xi.common, Xi.displacementmap]), vertexShader: Wi.depth_vert, fragmentShader: Wi.depth_frag }, normal: { uniforms: Ei([Xi.common, Xi.bumpmap, Xi.normalmap, Xi.displacementmap, { opacity: { value: 1 } }]), vertexShader: Wi.meshnormal_vert, fragmentShader: Wi.meshnormal_frag }, sprite: { uniforms: Ei([Xi.sprite, Xi.fog]), vertexShader: Wi.sprite_vert, fragmentShader: Wi.sprite_frag }, background: { uniforms: { uvTransform: { value: new ne() }, t2D: { value: null } }, vertexShader: Wi.background_vert, fragmentShader: Wi.background_frag }, cube: { uniforms: Ei([Xi.envmap, { opacity: { value: 1 } }]), vertexShader: Wi.cube_vert, fragmentShader: Wi.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Wi.equirect_vert, fragmentShader: Wi.equirect_frag }, distanceRGBA: { uniforms: Ei([Xi.common, Xi.displacementmap, { referencePosition: { value: new Ae() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Wi.distanceRGBA_vert, fragmentShader: Wi.distanceRGBA_frag }, shadow: { uniforms: Ei([Xi.lights, Xi.fog, { color: { value: new ge(0) }, opacity: { value: 1 } }]), vertexShader: Wi.shadow_vert, fragmentShader: Wi.shadow_frag } };
      function Yi(e2, t2, i2, n2, r2, s2) {
        const a2 = new ge(0);
        let l2, h2, c2 = true === r2 ? 0 : 1, u2 = null, d2 = 0, p2 = null;
        function m2(e3, t3) {
          i2.buffers.color.setClear(e3.r, e3.g, e3.b, t3, s2);
        }
        return { getClearColor: function() {
          return a2;
        }, setClearColor: function(e3, t3 = 1) {
          a2.set(e3), c2 = t3, m2(a2, c2);
        }, getClearAlpha: function() {
          return c2;
        }, setClearAlpha: function(e3) {
          c2 = e3, m2(a2, c2);
        }, render: function(i3, r3) {
          let s3 = false, f2 = true === r3.isScene ? r3.background : null;
          f2 && f2.isTexture && (f2 = t2.get(f2));
          const g2 = e2.xr, _2 = g2.getSession && g2.getSession();
          _2 && "additive" === _2.environmentBlendMode && (f2 = null), null === f2 ? m2(a2, c2) : f2 && f2.isColor && (m2(f2, 1), s3 = true), (e2.autoClear || s3) && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), f2 && (f2.isCubeTexture || f2.mapping === o) ? (void 0 === h2 && (h2 = new Mi(new wi(1, 1, 1), new Ai({ name: "BackgroundCubeMaterial", uniforms: Ti(qi.cube.uniforms), vertexShader: qi.cube.vertexShader, fragmentShader: qi.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), h2.geometry.deleteAttribute("normal"), h2.geometry.deleteAttribute("uv"), h2.onBeforeRender = function(e3, t3, i4) {
            this.matrixWorld.copyPosition(i4.matrixWorld);
          }, Object.defineProperty(h2.material, "envMap", { get: function() {
            return this.uniforms.envMap.value;
          } }), n2.update(h2)), h2.material.uniforms.envMap.value = f2, h2.material.uniforms.flipEnvMap.value = f2.isCubeTexture && false === f2.isRenderTargetTexture ? -1 : 1, u2 === f2 && d2 === f2.version && p2 === e2.toneMapping || (h2.material.needsUpdate = true, u2 = f2, d2 = f2.version, p2 = e2.toneMapping), h2.layers.enableAll(), i3.unshift(h2, h2.geometry, h2.material, 0, 0, null)) : f2 && f2.isTexture && (void 0 === l2 && (l2 = new Mi(new ji(2, 2), new Ai({ name: "BackgroundMaterial", uniforms: Ti(qi.background.uniforms), vertexShader: qi.background.vertexShader, fragmentShader: qi.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), Object.defineProperty(l2.material, "map", { get: function() {
            return this.uniforms.t2D.value;
          } }), n2.update(l2)), l2.material.uniforms.t2D.value = f2, true === f2.matrixAutoUpdate && f2.updateMatrix(), l2.material.uniforms.uvTransform.value.copy(f2.matrix), u2 === f2 && d2 === f2.version && p2 === e2.toneMapping || (l2.material.needsUpdate = true, u2 = f2, d2 = f2.version, p2 = e2.toneMapping), l2.layers.enableAll(), i3.unshift(l2, l2.geometry, l2.material, 0, 0, null));
        } };
      }
      function Zi(e2, t2, i2, n2) {
        const r2 = e2.getParameter(34921), s2 = n2.isWebGL2 ? null : t2.get("OES_vertex_array_object"), a2 = n2.isWebGL2 || null !== s2, o2 = {}, l2 = p2(null);
        let h2 = l2, c2 = false;
        function u2(t3) {
          return n2.isWebGL2 ? e2.bindVertexArray(t3) : s2.bindVertexArrayOES(t3);
        }
        function d2(t3) {
          return n2.isWebGL2 ? e2.deleteVertexArray(t3) : s2.deleteVertexArrayOES(t3);
        }
        function p2(e3) {
          const t3 = [], i3 = [], n3 = [];
          for (let s3 = 0; s3 < r2; s3++)
            t3[s3] = 0, i3[s3] = 0, n3[s3] = 0;
          return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: i3, attributeDivisors: n3, object: e3, attributes: {}, index: null };
        }
        function m2() {
          const e3 = h2.newAttributes;
          for (let t3 = 0, i3 = e3.length; t3 < i3; t3++)
            e3[t3] = 0;
        }
        function f2(e3) {
          g2(e3, 0);
        }
        function g2(i3, r3) {
          const s3 = h2.newAttributes, a3 = h2.enabledAttributes, o3 = h2.attributeDivisors;
          if (s3[i3] = 1, 0 === a3[i3] && (e2.enableVertexAttribArray(i3), a3[i3] = 1), o3[i3] !== r3) {
            (n2.isWebGL2 ? e2 : t2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i3, r3), o3[i3] = r3;
          }
        }
        function _2() {
          const t3 = h2.newAttributes, i3 = h2.enabledAttributes;
          for (let n3 = 0, r3 = i3.length; n3 < r3; n3++)
            i3[n3] !== t3[n3] && (e2.disableVertexAttribArray(n3), i3[n3] = 0);
        }
        function v2(t3, i3, r3, s3, a3, o3) {
          true !== n2.isWebGL2 || 5124 !== r3 && 5125 !== r3 ? e2.vertexAttribPointer(t3, i3, r3, s3, a3, o3) : e2.vertexAttribIPointer(t3, i3, r3, a3, o3);
        }
        function x2() {
          y2(), c2 = true, h2 !== l2 && (h2 = l2, u2(h2.object));
        }
        function y2() {
          l2.geometry = null, l2.program = null, l2.wireframe = false;
        }
        return { setup: function(r3, l3, d3, x3, y3) {
          let b2 = false;
          if (a2) {
            const t3 = function(t4, i3, r4) {
              const a3 = true === r4.wireframe;
              let l4 = o2[t4.id];
              void 0 === l4 && (l4 = {}, o2[t4.id] = l4);
              let h3 = l4[i3.id];
              void 0 === h3 && (h3 = {}, l4[i3.id] = h3);
              let c3 = h3[a3];
              void 0 === c3 && (c3 = p2(n2.isWebGL2 ? e2.createVertexArray() : s2.createVertexArrayOES()), h3[a3] = c3);
              return c3;
            }(x3, d3, l3);
            h2 !== t3 && (h2 = t3, u2(h2.object)), b2 = function(e3, t4, i3, n3) {
              const r4 = h2.attributes, s3 = t4.attributes;
              let a3 = 0;
              const o3 = i3.getAttributes();
              for (const l4 in o3) {
                if (o3[l4].location >= 0) {
                  const t5 = r4[l4];
                  let i4 = s3[l4];
                  if (void 0 === i4 && ("instanceMatrix" === l4 && e3.instanceMatrix && (i4 = e3.instanceMatrix), "instanceColor" === l4 && e3.instanceColor && (i4 = e3.instanceColor)), void 0 === t5)
                    return true;
                  if (t5.attribute !== i4)
                    return true;
                  if (i4 && t5.data !== i4.data)
                    return true;
                  a3++;
                }
              }
              return h2.attributesNum !== a3 || h2.index !== n3;
            }(r3, x3, d3, y3), b2 && function(e3, t4, i3, n3) {
              const r4 = {}, s3 = t4.attributes;
              let a3 = 0;
              const o3 = i3.getAttributes();
              for (const l4 in o3) {
                if (o3[l4].location >= 0) {
                  let t5 = s3[l4];
                  void 0 === t5 && ("instanceMatrix" === l4 && e3.instanceMatrix && (t5 = e3.instanceMatrix), "instanceColor" === l4 && e3.instanceColor && (t5 = e3.instanceColor));
                  const i4 = {};
                  i4.attribute = t5, t5 && t5.data && (i4.data = t5.data), r4[l4] = i4, a3++;
                }
              }
              h2.attributes = r4, h2.attributesNum = a3, h2.index = n3;
            }(r3, x3, d3, y3);
          } else {
            const e3 = true === l3.wireframe;
            h2.geometry === x3.id && h2.program === d3.id && h2.wireframe === e3 || (h2.geometry = x3.id, h2.program = d3.id, h2.wireframe = e3, b2 = true);
          }
          null !== y3 && i2.update(y3, 34963), (b2 || c2) && (c2 = false, function(r4, s3, a3, o3) {
            if (false === n2.isWebGL2 && (r4.isInstancedMesh || o3.isInstancedBufferGeometry) && null === t2.get("ANGLE_instanced_arrays"))
              return;
            m2();
            const l4 = o3.attributes, h3 = a3.getAttributes(), c3 = s3.defaultAttributeValues;
            for (const t3 in h3) {
              const n3 = h3[t3];
              if (n3.location >= 0) {
                let s4 = l4[t3];
                if (void 0 === s4 && ("instanceMatrix" === t3 && r4.instanceMatrix && (s4 = r4.instanceMatrix), "instanceColor" === t3 && r4.instanceColor && (s4 = r4.instanceColor)), void 0 !== s4) {
                  const t4 = s4.normalized, a4 = s4.itemSize, l5 = i2.get(s4);
                  if (void 0 === l5)
                    continue;
                  const h4 = l5.buffer, c4 = l5.type, u3 = l5.bytesPerElement;
                  if (s4.isInterleavedBufferAttribute) {
                    const i3 = s4.data, l6 = i3.stride, d4 = s4.offset;
                    if (i3.isInstancedInterleavedBuffer) {
                      for (let e3 = 0; e3 < n3.locationSize; e3++)
                        g2(n3.location + e3, i3.meshPerAttribute);
                      true !== r4.isInstancedMesh && void 0 === o3._maxInstanceCount && (o3._maxInstanceCount = i3.meshPerAttribute * i3.count);
                    } else
                      for (let e3 = 0; e3 < n3.locationSize; e3++)
                        f2(n3.location + e3);
                    e2.bindBuffer(34962, h4);
                    for (let e3 = 0; e3 < n3.locationSize; e3++)
                      v2(n3.location + e3, a4 / n3.locationSize, c4, t4, l6 * u3, (d4 + a4 / n3.locationSize * e3) * u3);
                  } else {
                    if (s4.isInstancedBufferAttribute) {
                      for (let e3 = 0; e3 < n3.locationSize; e3++)
                        g2(n3.location + e3, s4.meshPerAttribute);
                      true !== r4.isInstancedMesh && void 0 === o3._maxInstanceCount && (o3._maxInstanceCount = s4.meshPerAttribute * s4.count);
                    } else
                      for (let e3 = 0; e3 < n3.locationSize; e3++)
                        f2(n3.location + e3);
                    e2.bindBuffer(34962, h4);
                    for (let e3 = 0; e3 < n3.locationSize; e3++)
                      v2(n3.location + e3, a4 / n3.locationSize, c4, t4, a4 * u3, a4 / n3.locationSize * e3 * u3);
                  }
                } else if (void 0 !== c3) {
                  const i3 = c3[t3];
                  if (void 0 !== i3)
                    switch (i3.length) {
                      case 2:
                        e2.vertexAttrib2fv(n3.location, i3);
                        break;
                      case 3:
                        e2.vertexAttrib3fv(n3.location, i3);
                        break;
                      case 4:
                        e2.vertexAttrib4fv(n3.location, i3);
                        break;
                      default:
                        e2.vertexAttrib1fv(n3.location, i3);
                    }
                }
              }
            }
            _2();
          }(r3, l3, d3, x3), null !== y3 && e2.bindBuffer(34963, i2.get(y3).buffer));
        }, reset: x2, resetDefaultState: y2, dispose: function() {
          x2();
          for (const e3 in o2) {
            const t3 = o2[e3];
            for (const e4 in t3) {
              const i3 = t3[e4];
              for (const e5 in i3)
                d2(i3[e5].object), delete i3[e5];
              delete t3[e4];
            }
            delete o2[e3];
          }
        }, releaseStatesOfGeometry: function(e3) {
          if (void 0 === o2[e3.id])
            return;
          const t3 = o2[e3.id];
          for (const i3 in t3) {
            const e4 = t3[i3];
            for (const t4 in e4)
              d2(e4[t4].object), delete e4[t4];
            delete t3[i3];
          }
          delete o2[e3.id];
        }, releaseStatesOfProgram: function(e3) {
          for (const t3 in o2) {
            const i3 = o2[t3];
            if (void 0 === i3[e3.id])
              continue;
            const n3 = i3[e3.id];
            for (const e4 in n3)
              d2(n3[e4].object), delete n3[e4];
            delete i3[e3.id];
          }
        }, initAttributes: m2, enableAttribute: f2, disableUnusedAttributes: _2 };
      }
      function Ji(e2, t2, i2, n2) {
        const r2 = n2.isWebGL2;
        let s2;
        this.setMode = function(e3) {
          s2 = e3;
        }, this.render = function(t3, n3) {
          e2.drawArrays(s2, t3, n3), i2.update(n3, s2, 1);
        }, this.renderInstances = function(n3, a2, o2) {
          if (0 === o2)
            return;
          let l2, h2;
          if (r2)
            l2 = e2, h2 = "drawArraysInstanced";
          else if (l2 = t2.get("ANGLE_instanced_arrays"), h2 = "drawArraysInstancedANGLE", null === l2)
            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          l2[h2](s2, n3, a2, o2), i2.update(a2, s2, o2);
        };
      }
      function Ki(e2, t2, i2) {
        let n2;
        function r2(t3) {
          if ("highp" === t3) {
            if (e2.getShaderPrecisionFormat(35633, 36338).precision > 0 && e2.getShaderPrecisionFormat(35632, 36338).precision > 0)
              return "highp";
            t3 = "mediump";
          }
          return "mediump" === t3 && e2.getShaderPrecisionFormat(35633, 36337).precision > 0 && e2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
        }
        const s2 = "undefined" != typeof WebGL2RenderingContext && e2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e2 instanceof WebGL2ComputeRenderingContext;
        let a2 = void 0 !== i2.precision ? i2.precision : "highp";
        const o2 = r2(a2);
        o2 !== a2 && (console.warn("THREE.WebGLRenderer:", a2, "not supported, using", o2, "instead."), a2 = o2);
        const l2 = s2 || t2.has("WEBGL_draw_buffers"), h2 = true === i2.logarithmicDepthBuffer, c2 = e2.getParameter(34930), u2 = e2.getParameter(35660), d2 = e2.getParameter(3379), p2 = e2.getParameter(34076), m2 = e2.getParameter(34921), f2 = e2.getParameter(36347), g2 = e2.getParameter(36348), _2 = e2.getParameter(36349), v2 = u2 > 0, x2 = s2 || t2.has("OES_texture_float");
        return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
          if (void 0 !== n2)
            return n2;
          if (true === t2.has("EXT_texture_filter_anisotropic")) {
            const i3 = t2.get("EXT_texture_filter_anisotropic");
            n2 = e2.getParameter(i3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else
            n2 = 0;
          return n2;
        }, getMaxPrecision: r2, precision: a2, logarithmicDepthBuffer: h2, maxTextures: c2, maxVertexTextures: u2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: m2, maxVertexUniforms: f2, maxVaryings: g2, maxFragmentUniforms: _2, vertexTextures: v2, floatFragmentTextures: x2, floatVertexTextures: v2 && x2, maxSamples: s2 ? e2.getParameter(36183) : 0 };
      }
      function Qi(e2) {
        const t2 = this;
        let i2 = null, n2 = 0, r2 = false, s2 = false;
        const a2 = new Ni(), o2 = new ne(), l2 = { value: null, needsUpdate: false };
        function h2() {
          l2.value !== i2 && (l2.value = i2, l2.needsUpdate = n2 > 0), t2.numPlanes = n2, t2.numIntersection = 0;
        }
        function c2(e3, i3, n3, r3) {
          const s3 = null !== e3 ? e3.length : 0;
          let h3 = null;
          if (0 !== s3) {
            if (h3 = l2.value, true !== r3 || null === h3) {
              const t3 = n3 + 4 * s3, r4 = i3.matrixWorldInverse;
              o2.getNormalMatrix(r4), (null === h3 || h3.length < t3) && (h3 = new Float32Array(t3));
              for (let i4 = 0, l3 = n3; i4 !== s3; ++i4, l3 += 4)
                a2.copy(e3[i4]).applyMatrix4(r4, o2), a2.normal.toArray(h3, l3), h3[l3 + 3] = a2.constant;
            }
            l2.value = h3, l2.needsUpdate = true;
          }
          return t2.numPlanes = s3, t2.numIntersection = 0, h3;
        }
        this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e3, t3, s3) {
          const a3 = 0 !== e3.length || t3 || 0 !== n2 || r2;
          return r2 = t3, i2 = c2(e3, s3, 0), n2 = e3.length, a3;
        }, this.beginShadows = function() {
          s2 = true, c2(null);
        }, this.endShadows = function() {
          s2 = false, h2();
        }, this.setState = function(t3, a3, o3) {
          const u2 = t3.clippingPlanes, d2 = t3.clipIntersection, p2 = t3.clipShadows, m2 = e2.get(t3);
          if (!r2 || null === u2 || 0 === u2.length || s2 && !p2)
            s2 ? c2(null) : h2();
          else {
            const e3 = s2 ? 0 : n2, t4 = 4 * e3;
            let r3 = m2.clippingState || null;
            l2.value = r3, r3 = c2(u2, a3, t4, o3);
            for (let n3 = 0; n3 !== t4; ++n3)
              r3[n3] = i2[n3];
            m2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += e3;
          }
        };
      }
      function $i(e2) {
        let t2 = /* @__PURE__ */ new WeakMap();
        function i2(e3, t3) {
          return t3 === a ? e3.mapping = r : 304 === t3 && (e3.mapping = s), e3;
        }
        function n2(e3) {
          const i3 = e3.target;
          i3.removeEventListener("dispose", n2);
          const r2 = t2.get(i3);
          void 0 !== r2 && (t2.delete(i3), r2.dispose());
        }
        return { get: function(r2) {
          if (r2 && r2.isTexture && false === r2.isRenderTargetTexture) {
            const s2 = r2.mapping;
            if (s2 === a || 304 === s2) {
              if (t2.has(r2)) {
                return i2(t2.get(r2).texture, r2.mapping);
              }
              {
                const s3 = r2.image;
                if (s3 && s3.height > 0) {
                  const a2 = new Fi(s3.height / 2);
                  return a2.fromEquirectangularTexture(e2, r2), t2.set(r2, a2), r2.addEventListener("dispose", n2), i2(a2.texture, r2.mapping);
                }
                return null;
              }
            }
          }
          return r2;
        }, dispose: function() {
          t2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      qi.physical = { uniforms: Ei([qi.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new ie(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new ge(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new ie() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new ge(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new ge(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Wi.meshphysical_vert, fragmentShader: Wi.meshphysical_frag };
      class en extends Pi {
        constructor(e2 = -1, t2 = 1, i2 = 1, n2 = -1, r2 = 0.1, s2 = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e2, this.right = t2, this.top = i2, this.bottom = n2, this.near = r2, this.far = s2, this.updateProjectionMatrix();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.left = e2.left, this.right = e2.right, this.top = e2.top, this.bottom = e2.bottom, this.near = e2.near, this.far = e2.far, this.zoom = e2.zoom, this.view = null === e2.view ? null : Object.assign({}, e2.view), this;
        }
        setViewOffset(e2, t2, i2, n2, r2, s2) {
          null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e2 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), i2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
          let r2 = i2 - e2, s2 = i2 + e2, a2 = n2 + t2, o2 = n2 - t2;
          if (null !== this.view && this.view.enabled) {
            const e3 = (this.right - this.left) / this.view.fullWidth / this.zoom, t3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r2 += e3 * this.view.offsetX, s2 = r2 + e3 * this.view.width, a2 -= t3 * this.view.offsetY, o2 = a2 - t3 * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r2, s2, a2, o2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e2) {
          const t2 = super.toJSON(e2);
          return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2;
        }
      }
      const tn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], nn = 20, rn = new en(), sn = new ge();
      let an = null;
      const on = (1 + Math.sqrt(5)) / 2, ln = 1 / on, hn = [new Ae(1, 1, 1), new Ae(-1, 1, 1), new Ae(1, 1, -1), new Ae(-1, 1, -1), new Ae(0, on, ln), new Ae(0, on, -ln), new Ae(ln, 0, on), new Ae(-ln, 0, on), new Ae(on, ln, 0), new Ae(-on, ln, 0)];
      class cn {
        constructor(e2) {
          this._renderer = e2, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e2, t2 = 0, i2 = 0.1, n2 = 100, r2 = null, s2 = null) {
          return an = this._renderer.getRenderTarget(), r2 || (r2 = this._allocateTargets()), s2 && (this._pingPongRenderTarget = s2), this._setSize(256), r2.depthBuffer = true, this._sceneToCubeUV(e2, i2, n2, r2), t2 > 0 && this._blur(r2, 0, 0, t2), this._applyPMREM(r2), this._cleanup(r2), r2;
        }
        prepareForRenderTarget(e2, t2 = null, i2 = 256) {
          this._setSize(i2);
          const { _lodMax: n2 } = this;
          ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = un(n2));
          const r2 = 3 * Math.max(this._cubeSize, 112), s2 = 4 * this._cubeSize;
          this._blurMaterial = mn(n2, r2, s2), e2.setSize(r2, s2), t2 && t2.setSize(r2, s2);
        }
        fromSceneToRenderTarget(e2, t2, i2, n2 = 0, r2 = 0.1, s2 = 100) {
          return an = this._renderer.getRenderTarget(), this._pingPongRenderTarget = i2, this._sceneToCubeUV(e2, r2, s2, t2), n2 > 0 && this._blur(t2, 0, 0, n2), this._applyPMREM(t2), this._renderer.setRenderTarget(an), t2.scissorTest = false, pn(t2, 0, 0, t2.width, t2.height), t2;
        }
        fromEquirectangular(e2, t2 = null) {
          return this._fromTexture(e2, t2);
        }
        fromCubemap(e2, t2 = null) {
          return this._fromTexture(e2, t2);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial && (this._cubemapMaterial = gn(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial && (this._equirectMaterial = fn(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e2) {
          this._lodMax = Math.floor(Math.log2(e2)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
          for (let e2 = 0; e2 < this._lodPlanes.length; e2++)
            this._lodPlanes[e2].dispose();
        }
        _cleanup(e2) {
          this._renderer.setRenderTarget(an), e2.scissorTest = false, pn(e2, 0, 0, e2.width, e2.height);
        }
        _fromTexture(e2, t2) {
          e2.mapping === r || e2.mapping === s ? this._setSize(0 === e2.image.length ? 16 : e2.image[0].width || e2.image[0].image.width) : this._setSize(e2.image.width / 4), an = this._renderer.getRenderTarget();
          const i2 = t2 || this._allocateTargets();
          return this._textureToCubeUV(e2, i2), this._applyPMREM(i2), this._cleanup(i2), i2;
        }
        _allocateTargets() {
          const e2 = 3 * Math.max(this._cubeSize, 112), t2 = 4 * this._cubeSize, i2 = { magFilter: m, minFilter: m, generateMipmaps: false, type: x, format: b, encoding: O, depthBuffer: false }, n2 = dn(e2, t2, i2);
          if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e2) {
            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = dn(e2, t2, i2);
            const { _lodMax: n3 } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = un(n3)), this._blurMaterial = mn(n3, e2, t2);
          }
          return n2;
        }
        _compileMaterial(e2) {
          const t2 = new Mi(this._lodPlanes[0], e2);
          this._renderer.compile(t2, rn);
        }
        _sceneToCubeUV(e2, t2, i2, n2) {
          const r2 = new Ri(90, 1, t2, i2), s2 = [1, -1, 1, 1, 1, 1], a2 = [1, 1, 1, -1, -1, -1], o2 = this._renderer, l2 = o2.autoClear, h2 = o2.toneMapping;
          o2.getClearColor(sn), o2.toneMapping = 0, o2.autoClear = false;
          const c2 = new jt({ name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false }), u2 = new Mi(new wi(), c2);
          let d2 = false;
          const p2 = e2.background;
          p2 ? p2.isColor && (c2.color.copy(p2), e2.background = null, d2 = true) : (c2.color.copy(sn), d2 = true);
          for (let m2 = 0; m2 < 6; m2++) {
            const t3 = m2 % 3;
            0 === t3 ? (r2.up.set(0, s2[m2], 0), r2.lookAt(a2[m2], 0, 0)) : 1 === t3 ? (r2.up.set(0, 0, s2[m2]), r2.lookAt(0, a2[m2], 0)) : (r2.up.set(0, s2[m2], 0), r2.lookAt(0, 0, a2[m2]));
            const i3 = this._cubeSize;
            pn(n2, t3 * i3, m2 > 2 ? i3 : 0, i3, i3), o2.setRenderTarget(n2), d2 && o2.render(u2, r2), o2.render(e2, r2);
          }
          u2.geometry.dispose(), u2.material.dispose(), o2.toneMapping = h2, o2.autoClear = l2, e2.background = p2;
        }
        _textureToCubeUV(e2, t2) {
          const i2 = this._renderer, n2 = e2.mapping === r || e2.mapping === s;
          n2 ? (null === this._cubemapMaterial && (this._cubemapMaterial = gn()), this._cubemapMaterial.uniforms.flipEnvMap.value = false === e2.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = fn());
          const a2 = n2 ? this._cubemapMaterial : this._equirectMaterial, o2 = new Mi(this._lodPlanes[0], a2);
          a2.uniforms.envMap.value = e2;
          const l2 = this._cubeSize;
          pn(t2, 0, 0, 3 * l2, 2 * l2), i2.setRenderTarget(t2), i2.render(o2, rn);
        }
        _applyPMREM(e2) {
          const t2 = this._renderer, i2 = t2.autoClear;
          t2.autoClear = false;
          for (let n2 = 1; n2 < this._lodPlanes.length; n2++) {
            const t3 = Math.sqrt(this._sigmas[n2] * this._sigmas[n2] - this._sigmas[n2 - 1] * this._sigmas[n2 - 1]), i3 = hn[(n2 - 1) % hn.length];
            this._blur(e2, n2 - 1, n2, t3, i3);
          }
          t2.autoClear = i2;
        }
        _blur(e2, t2, i2, n2, r2) {
          const s2 = this._pingPongRenderTarget;
          this._halfBlur(e2, s2, t2, i2, n2, "latitudinal", r2), this._halfBlur(s2, e2, i2, i2, n2, "longitudinal", r2);
        }
        _halfBlur(e2, t2, i2, n2, r2, s2, a2) {
          const o2 = this._renderer, l2 = this._blurMaterial;
          "latitudinal" !== s2 && "longitudinal" !== s2 && console.error("blur direction must be either latitudinal or longitudinal!");
          const h2 = new Mi(this._lodPlanes[n2], l2), c2 = l2.uniforms, u2 = this._sizeLods[i2] - 1, d2 = isFinite(r2) ? Math.PI / (2 * u2) : 2 * Math.PI / 39, p2 = r2 / d2, m2 = isFinite(r2) ? 1 + Math.floor(3 * p2) : nn;
          m2 > nn && console.warn(`sigmaRadians, ${r2}, is too large and will clip, as it requested ${m2} samples when the maximum is set to 20`);
          const f2 = [];
          let g2 = 0;
          for (let x2 = 0; x2 < nn; ++x2) {
            const e3 = x2 / p2, t3 = Math.exp(-e3 * e3 / 2);
            f2.push(t3), 0 === x2 ? g2 += t3 : x2 < m2 && (g2 += 2 * t3);
          }
          for (let x2 = 0; x2 < f2.length; x2++)
            f2[x2] = f2[x2] / g2;
          c2.envMap.value = e2.texture, c2.samples.value = m2, c2.weights.value = f2, c2.latitudinal.value = "latitudinal" === s2, a2 && (c2.poleAxis.value = a2);
          const { _lodMax: _2 } = this;
          c2.dTheta.value = d2, c2.mipInt.value = _2 - i2;
          const v2 = this._sizeLods[n2];
          pn(t2, 3 * v2 * (n2 > _2 - 4 ? n2 - _2 + 4 : 0), 4 * (this._cubeSize - v2), 3 * v2, 2 * v2), o2.setRenderTarget(t2), o2.render(h2, rn);
        }
      }
      function un(e2) {
        const t2 = [], i2 = [], n2 = [];
        let r2 = e2;
        const s2 = e2 - 4 + 1 + tn.length;
        for (let a2 = 0; a2 < s2; a2++) {
          const s3 = Math.pow(2, r2);
          i2.push(s3);
          let o2 = 1 / s3;
          a2 > e2 - 4 ? o2 = tn[a2 - e2 + 4 - 1] : 0 === a2 && (o2 = 0), n2.push(o2);
          const l2 = 1 / (s3 - 2), h2 = -l2, c2 = 1 + l2, u2 = [h2, h2, c2, h2, c2, c2, h2, h2, c2, c2, h2, c2], d2 = 6, p2 = 6, m2 = 3, f2 = 2, g2 = 1, _2 = new Float32Array(m2 * p2 * d2), v2 = new Float32Array(f2 * p2 * d2), x2 = new Float32Array(g2 * p2 * d2);
          for (let e3 = 0; e3 < d2; e3++) {
            const t3 = e3 % 3 * 2 / 3 - 1, i3 = e3 > 2 ? 0 : -1, n3 = [t3, i3, 0, t3 + 2 / 3, i3, 0, t3 + 2 / 3, i3 + 1, 0, t3, i3, 0, t3 + 2 / 3, i3 + 1, 0, t3, i3 + 1, 0];
            _2.set(n3, m2 * p2 * e3), v2.set(u2, f2 * p2 * e3);
            const r3 = [e3, e3, e3, e3, e3, e3];
            x2.set(r3, g2 * p2 * e3);
          }
          const y2 = new ri();
          y2.setAttribute("position", new qt(_2, m2)), y2.setAttribute("uv", new qt(v2, f2)), y2.setAttribute("faceIndex", new qt(x2, g2)), t2.push(y2), r2 > 4 && r2--;
        }
        return { lodPlanes: t2, sizeLods: i2, sigmas: n2 };
      }
      function dn(e2, t2, i2) {
        const n2 = new we(e2, t2, i2);
        return n2.texture.mapping = o, n2.texture.name = "PMREM.cubeUv", n2.scissorTest = true, n2;
      }
      function pn(e2, t2, i2, n2, r2) {
        e2.viewport.set(t2, i2, n2, r2), e2.scissor.set(t2, i2, n2, r2);
      }
      function mn(e2, t2, i2) {
        const n2 = new Float32Array(nn), r2 = new Ae(0, 1, 0);
        return new Ai({ name: "SphericalGaussianBlur", defines: { n: nn, CUBEUV_TEXEL_WIDTH: 1 / t2, CUBEUV_TEXEL_HEIGHT: 1 / i2, CUBEUV_MAX_MIP: `${e2}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n2 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r2 } }, vertexShader: _n(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
      }
      function fn() {
        return new Ai({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: _n(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
      }
      function gn() {
        return new Ai({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: _n(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: 0, depthTest: false, depthWrite: false });
      }
      function _n() {
        return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		mat3 getRotationMatrix(vec3 axis, float angle) {\n			axis = normalize(axis);\n			float s = sin(angle);\n			float c = cos(angle);\n			float oc = 1.0 - c;\n		\n			return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n		}\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n			mat3 rotationMatrix = getRotationMatrix(vec3(1.0, 0.0, 0.0), 1.57);\n			direction = rotationMatrix * direction;\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
      }
      function vn(e2) {
        let t2 = /* @__PURE__ */ new WeakMap(), i2 = null;
        function n2(e3) {
          const i3 = e3.target;
          i3.removeEventListener("dispose", n2);
          const r2 = t2.get(i3);
          void 0 !== r2 && (t2.delete(i3), r2.dispose());
        }
        return { get: function(o2) {
          if (o2 && o2.isTexture) {
            const l2 = o2.mapping, h2 = l2 === a || 304 === l2, c2 = l2 === r || l2 === s;
            if (h2 || c2) {
              if (o2.isRenderTargetTexture && true === o2.needsPMREMUpdate) {
                o2.needsPMREMUpdate = false;
                let n3 = t2.get(o2);
                return null === i2 && (i2 = new cn(e2)), n3 = h2 ? i2.fromEquirectangular(o2, n3) : i2.fromCubemap(o2, n3), t2.set(o2, n3), n3.texture;
              }
              if (t2.has(o2))
                return t2.get(o2).texture;
              {
                const r2 = o2.image;
                if (h2 && r2 && r2.height > 0 || c2 && r2 && function(e3) {
                  let t3 = 0;
                  const i3 = 6;
                  for (let n3 = 0; n3 < i3; n3++)
                    void 0 !== e3[n3] && t3++;
                  return t3 === i3;
                }(r2)) {
                  null === i2 && (i2 = new cn(e2));
                  const r3 = h2 ? i2.fromEquirectangular(o2) : i2.fromCubemap(o2);
                  return t2.set(o2, r3), o2.addEventListener("dispose", n2), r3.texture;
                }
                return null;
              }
            }
          }
          return o2;
        }, dispose: function() {
          t2 = /* @__PURE__ */ new WeakMap(), null !== i2 && (i2.dispose(), i2 = null);
        } };
      }
      function xn(e2) {
        const t2 = {};
        function i2(i3) {
          if (void 0 !== t2[i3])
            return t2[i3];
          let n2;
          switch (i3) {
            case "WEBGL_depth_texture":
              n2 = e2.getExtension("WEBGL_depth_texture") || e2.getExtension("MOZ_WEBGL_depth_texture") || e2.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n2 = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n2 = e2.getExtension("WEBGL_compressed_texture_s3tc") || e2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n2 = e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n2 = e2.getExtension(i3);
          }
          return t2[i3] = n2, n2;
        }
        return { has: function(e3) {
          return null !== i2(e3);
        }, init: function(e3) {
          e3.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float"), i2("WEBGL_multisampled_render_to_texture");
        }, get: function(e3) {
          const t3 = i2(e3);
          return null === t3 && console.warn("THREE.WebGLRenderer: " + e3 + " extension not supported."), t3;
        } };
      }
      function yn(e2, t2, i2, n2) {
        const r2 = {}, s2 = /* @__PURE__ */ new WeakMap();
        function a2(e3) {
          const o3 = e3.target;
          null !== o3.index && t2.remove(o3.index);
          for (const i3 in o3.attributes)
            t2.remove(o3.attributes[i3]);
          o3.removeEventListener("dispose", a2), delete r2[o3.id];
          const l2 = s2.get(o3);
          l2 && (t2.remove(l2), s2.delete(o3)), n2.releaseStatesOfGeometry(o3), true === o3.isInstancedBufferGeometry && delete o3._maxInstanceCount, i2.memory.geometries--;
        }
        function o2(e3) {
          const i3 = [], n3 = e3.index, r3 = e3.attributes.position;
          let a3 = 0;
          if (null !== n3) {
            const e4 = n3.array;
            a3 = n3.version;
            for (let t3 = 0, n4 = e4.length; t3 < n4; t3 += 3) {
              const n5 = e4[t3 + 0], r4 = e4[t3 + 1], s3 = e4[t3 + 2];
              i3.push(n5, r4, r4, s3, s3, n5);
            }
          } else {
            const e4 = r3.array;
            a3 = r3.version;
            for (let t3 = 0, n4 = e4.length / 3 - 1; t3 < n4; t3 += 3) {
              const e5 = t3 + 0, n5 = t3 + 1, r4 = t3 + 2;
              i3.push(e5, n5, n5, r4, r4, e5);
            }
          }
          const o3 = new (re(i3) ? Zt : Yt)(i3, 1);
          o3.version = a3;
          const l2 = s2.get(e3);
          l2 && t2.remove(l2), s2.set(e3, o3);
        }
        return { get: function(e3, t3) {
          return true === r2[t3.id] || (t3.addEventListener("dispose", a2), r2[t3.id] = true, i2.memory.geometries++), t3;
        }, update: function(e3) {
          const i3 = e3.attributes;
          for (const r3 in i3)
            t2.update(i3[r3], 34962);
          const n3 = e3.morphAttributes;
          for (const r3 in n3) {
            const e4 = n3[r3];
            for (let i4 = 0, n4 = e4.length; i4 < n4; i4++)
              t2.update(e4[i4], 34962);
          }
        }, getWireframeAttribute: function(e3) {
          const t3 = s2.get(e3);
          if (t3) {
            const i3 = e3.index;
            null !== i3 && t3.version < i3.version && o2(e3);
          } else
            o2(e3);
          return s2.get(e3);
        } };
      }
      function bn(e2, t2, i2, n2) {
        const r2 = n2.isWebGL2;
        let s2, a2, o2;
        this.setMode = function(e3) {
          s2 = e3;
        }, this.setIndex = function(e3) {
          a2 = e3.type, o2 = e3.bytesPerElement;
        }, this.render = function(t3, n3) {
          e2.drawElements(s2, n3, a2, t3 * o2), i2.update(n3, s2, 1);
        }, this.renderInstances = function(n3, l2, h2) {
          if (0 === h2)
            return;
          let c2, u2;
          if (r2)
            c2 = e2, u2 = "drawElementsInstanced";
          else if (c2 = t2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", null === c2)
            return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          c2[u2](s2, l2, a2, n3 * o2, h2), i2.update(l2, s2, h2);
        };
      }
      function Mn(e2) {
        const t2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return { memory: { geometries: 0, textures: 0 }, render: t2, programs: null, autoReset: true, reset: function() {
          t2.frame++, t2.calls = 0, t2.triangles = 0, t2.points = 0, t2.lines = 0;
        }, update: function(e3, i2, n2) {
          switch (t2.calls++, i2) {
            case 4:
              t2.triangles += n2 * (e3 / 3);
              break;
            case 1:
              t2.lines += n2 * (e3 / 2);
              break;
            case 3:
              t2.lines += n2 * (e3 - 1);
              break;
            case 2:
              t2.lines += n2 * e3;
              break;
            case 0:
              t2.points += n2 * e3;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", i2);
          }
        } };
      }
      function Sn(e2, t2) {
        return e2[0] - t2[0];
      }
      function wn(e2, t2) {
        return Math.abs(t2[1]) - Math.abs(e2[1]);
      }
      function Tn(e2, t2) {
        let i2 = 1;
        const n2 = t2.isInterleavedBufferAttribute ? t2.data.array : t2.array;
        n2 instanceof Int8Array ? i2 = 127 : n2 instanceof Int16Array ? i2 = 32767 : n2 instanceof Int32Array ? i2 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n2), e2.divideScalar(i2);
      }
      function En(e2, t2, i2) {
        const n2 = {}, r2 = new Float32Array(8), s2 = /* @__PURE__ */ new WeakMap(), a2 = new Se(), o2 = [];
        for (let l2 = 0; l2 < 8; l2++)
          o2[l2] = [l2, 0];
        return { update: function(l2, h2, c2, u2) {
          const d2 = l2.morphTargetInfluences;
          if (true === t2.isWebGL2) {
            const n3 = h2.morphAttributes.position || h2.morphAttributes.normal || h2.morphAttributes.color, r3 = void 0 !== n3 ? n3.length : 0;
            let o3 = s2.get(h2);
            if (void 0 === o3 || o3.count !== r3) {
              let e3 = function() {
                _2.dispose(), s2.delete(h2), h2.removeEventListener("dispose", e3);
              };
              void 0 !== o3 && o3.texture.dispose();
              const i3 = void 0 !== h2.morphAttributes.position, n4 = void 0 !== h2.morphAttributes.normal, l4 = void 0 !== h2.morphAttributes.color, c4 = h2.morphAttributes.position || [], u3 = h2.morphAttributes.normal || [], d3 = h2.morphAttributes.color || [];
              let p2 = 0;
              true === i3 && (p2 = 1), true === n4 && (p2 = 2), true === l4 && (p2 = 3);
              let m2 = h2.attributes.position.count * p2, f2 = 1;
              m2 > t2.maxTextureSize && (f2 = Math.ceil(m2 / t2.maxTextureSize), m2 = t2.maxTextureSize);
              const g2 = new Float32Array(m2 * f2 * 4 * r3), _2 = new Te(g2, m2, f2, r3);
              _2.type = v, _2.needsUpdate = true;
              const x2 = 4 * p2;
              for (let t3 = 0; t3 < r3; t3++) {
                const e4 = c4[t3], r4 = u3[t3], s3 = d3[t3], o4 = m2 * f2 * 4 * t3;
                for (let t4 = 0; t4 < e4.count; t4++) {
                  const h3 = t4 * x2;
                  true === i3 && (a2.fromBufferAttribute(e4, t4), true === e4.normalized && Tn(a2, e4), g2[o4 + h3 + 0] = a2.x, g2[o4 + h3 + 1] = a2.y, g2[o4 + h3 + 2] = a2.z, g2[o4 + h3 + 3] = 0), true === n4 && (a2.fromBufferAttribute(r4, t4), true === r4.normalized && Tn(a2, r4), g2[o4 + h3 + 4] = a2.x, g2[o4 + h3 + 5] = a2.y, g2[o4 + h3 + 6] = a2.z, g2[o4 + h3 + 7] = 0), true === l4 && (a2.fromBufferAttribute(s3, t4), true === s3.normalized && Tn(a2, s3), g2[o4 + h3 + 8] = a2.x, g2[o4 + h3 + 9] = a2.y, g2[o4 + h3 + 10] = a2.z, g2[o4 + h3 + 11] = 4 === s3.itemSize ? a2.w : 1);
                }
              }
              o3 = { count: r3, texture: _2, size: new ie(m2, f2) }, s2.set(h2, o3), h2.addEventListener("dispose", e3);
            }
            let l3 = 0;
            for (let e3 = 0; e3 < d2.length; e3++)
              l3 += d2[e3];
            const c3 = h2.morphTargetsRelative ? 1 : 1 - l3;
            u2.getUniforms().setValue(e2, "morphTargetBaseInfluence", c3), u2.getUniforms().setValue(e2, "morphTargetInfluences", d2), u2.getUniforms().setValue(e2, "morphTargetsTexture", o3.texture, i2), u2.getUniforms().setValue(e2, "morphTargetsTextureSize", o3.size);
          } else {
            const t3 = void 0 === d2 ? 0 : d2.length;
            let i3 = n2[h2.id];
            if (void 0 === i3 || i3.length !== t3) {
              i3 = [];
              for (let e3 = 0; e3 < t3; e3++)
                i3[e3] = [e3, 0];
              n2[h2.id] = i3;
            }
            for (let e3 = 0; e3 < t3; e3++) {
              const t4 = i3[e3];
              t4[0] = e3, t4[1] = d2[e3];
            }
            i3.sort(wn);
            for (let e3 = 0; e3 < 8; e3++)
              e3 < t3 && i3[e3][1] ? (o2[e3][0] = i3[e3][0], o2[e3][1] = i3[e3][1]) : (o2[e3][0] = Number.MAX_SAFE_INTEGER, o2[e3][1] = 0);
            o2.sort(Sn);
            const s3 = h2.morphAttributes.position, a3 = h2.morphAttributes.normal;
            let l3 = 0;
            for (let e3 = 0; e3 < 8; e3++) {
              const t4 = o2[e3], i4 = t4[0], n3 = t4[1];
              i4 !== Number.MAX_SAFE_INTEGER && n3 ? (s3 && h2.getAttribute("morphTarget" + e3) !== s3[i4] && h2.setAttribute("morphTarget" + e3, s3[i4]), a3 && h2.getAttribute("morphNormal" + e3) !== a3[i4] && h2.setAttribute("morphNormal" + e3, a3[i4]), r2[e3] = n3, l3 += n3) : (s3 && true === h2.hasAttribute("morphTarget" + e3) && h2.deleteAttribute("morphTarget" + e3), a3 && true === h2.hasAttribute("morphNormal" + e3) && h2.deleteAttribute("morphNormal" + e3), r2[e3] = 0);
            }
            const c3 = h2.morphTargetsRelative ? 1 : 1 - l3;
            u2.getUniforms().setValue(e2, "morphTargetBaseInfluence", c3), u2.getUniforms().setValue(e2, "morphTargetInfluences", r2);
          }
        } };
      }
      function Cn(e2, t2, i2, n2) {
        let r2 = /* @__PURE__ */ new WeakMap();
        function s2(e3) {
          const t3 = e3.target;
          t3.removeEventListener("dispose", s2), i2.remove(t3.instanceMatrix), null !== t3.instanceColor && i2.remove(t3.instanceColor);
        }
        return { update: function(e3) {
          const a2 = n2.render.frame, o2 = e3.geometry, l2 = t2.get(e3, o2);
          return r2.get(l2) !== a2 && (t2.update(l2), r2.set(l2, a2)), e3.isInstancedMesh && (false === e3.hasEventListener("dispose", s2) && e3.addEventListener("dispose", s2), i2.update(e3.instanceMatrix, 34962), null !== e3.instanceColor && i2.update(e3.instanceColor, 34962)), l2;
        }, dispose: function() {
          r2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      const An = new Me(), Pn = new Te(), Rn = new class extends Me {
        constructor(e2 = null, t2 = 1, i2 = 1, n2 = 1) {
          super(null), this.isData3DTexture = true, this.image = { data: e2, width: t2, height: i2, depth: n2 }, this.magFilter = u, this.minFilter = u, this.wrapR = h, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }(), Ln = new Di(), In = [], Dn = [], Fn = new Float32Array(16), On = new Float32Array(9), Un = new Float32Array(4);
      function zn(e2, t2, i2) {
        const n2 = e2[0];
        if (n2 <= 0 || n2 > 0)
          return e2;
        const r2 = t2 * i2;
        let s2 = In[r2];
        if (void 0 === s2 && (s2 = new Float32Array(r2), In[r2] = s2), 0 !== t2) {
          n2.toArray(s2, 0);
          for (let n3 = 1, r3 = 0; n3 !== t2; ++n3)
            r3 += i2, e2[n3].toArray(s2, r3);
        }
        return s2;
      }
      function Nn(e2, t2) {
        if (e2.length !== t2.length)
          return false;
        for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
          if (e2[i2] !== t2[i2])
            return false;
        return true;
      }
      function kn(e2, t2) {
        for (let i2 = 0, n2 = t2.length; i2 < n2; i2++)
          e2[i2] = t2[i2];
      }
      function Bn(e2, t2) {
        let i2 = Dn[t2];
        void 0 === i2 && (i2 = new Int32Array(t2), Dn[t2] = i2);
        for (let n2 = 0; n2 !== t2; ++n2)
          i2[n2] = e2.allocateTextureUnit();
        return i2;
      }
      function Vn(e2, t2) {
        const i2 = this.cache;
        i2[0] !== t2 && (e2.uniform1f(this.addr, t2), i2[0] = t2);
      }
      function Gn(e2, t2) {
        const i2 = this.cache;
        if (void 0 !== t2.x)
          i2[0] === t2.x && i2[1] === t2.y || (e2.uniform2f(this.addr, t2.x, t2.y), i2[0] = t2.x, i2[1] = t2.y);
        else {
          if (Nn(i2, t2))
            return;
          e2.uniform2fv(this.addr, t2), kn(i2, t2);
        }
      }
      function Hn(e2, t2) {
        const i2 = this.cache;
        if (void 0 !== t2.x)
          i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z || (e2.uniform3f(this.addr, t2.x, t2.y, t2.z), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z);
        else if (void 0 !== t2.r)
          i2[0] === t2.r && i2[1] === t2.g && i2[2] === t2.b || (e2.uniform3f(this.addr, t2.r, t2.g, t2.b), i2[0] = t2.r, i2[1] = t2.g, i2[2] = t2.b);
        else {
          if (Nn(i2, t2))
            return;
          e2.uniform3fv(this.addr, t2), kn(i2, t2);
        }
      }
      function jn(e2, t2) {
        const i2 = this.cache;
        if (void 0 !== t2.x)
          i2[0] === t2.x && i2[1] === t2.y && i2[2] === t2.z && i2[3] === t2.w || (e2.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), i2[0] = t2.x, i2[1] = t2.y, i2[2] = t2.z, i2[3] = t2.w);
        else {
          if (Nn(i2, t2))
            return;
          e2.uniform4fv(this.addr, t2), kn(i2, t2);
        }
      }
      function Wn(e2, t2) {
        const i2 = this.cache, n2 = t2.elements;
        if (void 0 === n2) {
          if (Nn(i2, t2))
            return;
          e2.uniformMatrix2fv(this.addr, false, t2), kn(i2, t2);
        } else {
          if (Nn(i2, n2))
            return;
          Un.set(n2), e2.uniformMatrix2fv(this.addr, false, Un), kn(i2, n2);
        }
      }
      function Xn(e2, t2) {
        const i2 = this.cache, n2 = t2.elements;
        if (void 0 === n2) {
          if (Nn(i2, t2))
            return;
          e2.uniformMatrix3fv(this.addr, false, t2), kn(i2, t2);
        } else {
          if (Nn(i2, n2))
            return;
          On.set(n2), e2.uniformMatrix3fv(this.addr, false, On), kn(i2, n2);
        }
      }
      function qn(e2, t2) {
        const i2 = this.cache, n2 = t2.elements;
        if (void 0 === n2) {
          if (Nn(i2, t2))
            return;
          e2.uniformMatrix4fv(this.addr, false, t2), kn(i2, t2);
        } else {
          if (Nn(i2, n2))
            return;
          Fn.set(n2), e2.uniformMatrix4fv(this.addr, false, Fn), kn(i2, n2);
        }
      }
      function Yn(e2, t2) {
        const i2 = this.cache;
        i2[0] !== t2 && (e2.uniform1i(this.addr, t2), i2[0] = t2);
      }
      function Zn(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform2iv(this.addr, t2), kn(i2, t2));
      }
      function Jn(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform3iv(this.addr, t2), kn(i2, t2));
      }
      function Kn(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform4iv(this.addr, t2), kn(i2, t2));
      }
      function Qn(e2, t2) {
        const i2 = this.cache;
        i2[0] !== t2 && (e2.uniform1ui(this.addr, t2), i2[0] = t2);
      }
      function $n(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform2uiv(this.addr, t2), kn(i2, t2));
      }
      function er(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform3uiv(this.addr, t2), kn(i2, t2));
      }
      function tr(e2, t2) {
        const i2 = this.cache;
        Nn(i2, t2) || (e2.uniform4uiv(this.addr, t2), kn(i2, t2));
      }
      function ir(e2, t2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (e2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2D(t2 || An, r2);
      }
      function nr(e2, t2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (e2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture3D(t2 || Rn, r2);
      }
      function rr(e2, t2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (e2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTextureCube(t2 || Ln, r2);
      }
      function sr(e2, t2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (e2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2DArray(t2 || Pn, r2);
      }
      function ar(e2, t2) {
        e2.uniform1fv(this.addr, t2);
      }
      function or(e2, t2) {
        const i2 = zn(t2, this.size, 2);
        e2.uniform2fv(this.addr, i2);
      }
      function lr(e2, t2) {
        const i2 = zn(t2, this.size, 3);
        e2.uniform3fv(this.addr, i2);
      }
      function hr(e2, t2) {
        const i2 = zn(t2, this.size, 4);
        e2.uniform4fv(this.addr, i2);
      }
      function cr(e2, t2) {
        const i2 = zn(t2, this.size, 4);
        e2.uniformMatrix2fv(this.addr, false, i2);
      }
      function ur(e2, t2) {
        const i2 = zn(t2, this.size, 9);
        e2.uniformMatrix3fv(this.addr, false, i2);
      }
      function dr(e2, t2) {
        const i2 = zn(t2, this.size, 16);
        e2.uniformMatrix4fv(this.addr, false, i2);
      }
      function pr(e2, t2) {
        e2.uniform1iv(this.addr, t2);
      }
      function mr(e2, t2) {
        e2.uniform2iv(this.addr, t2);
      }
      function fr(e2, t2) {
        e2.uniform3iv(this.addr, t2);
      }
      function gr(e2, t2) {
        e2.uniform4iv(this.addr, t2);
      }
      function _r(e2, t2) {
        e2.uniform1uiv(this.addr, t2);
      }
      function vr(e2, t2) {
        e2.uniform2uiv(this.addr, t2);
      }
      function xr(e2, t2) {
        e2.uniform3uiv(this.addr, t2);
      }
      function yr(e2, t2) {
        e2.uniform4uiv(this.addr, t2);
      }
      function br(e2, t2, i2) {
        const n2 = t2.length, r2 = Bn(i2, n2);
        e2.uniform1iv(this.addr, r2);
        for (let s2 = 0; s2 !== n2; ++s2)
          i2.setTexture2D(t2[s2] || An, r2[s2]);
      }
      function Mr(e2, t2, i2) {
        const n2 = t2.length, r2 = Bn(i2, n2);
        e2.uniform1iv(this.addr, r2);
        for (let s2 = 0; s2 !== n2; ++s2)
          i2.setTexture3D(t2[s2] || Rn, r2[s2]);
      }
      function Sr(e2, t2, i2) {
        const n2 = t2.length, r2 = Bn(i2, n2);
        e2.uniform1iv(this.addr, r2);
        for (let s2 = 0; s2 !== n2; ++s2)
          i2.setTextureCube(t2[s2] || Ln, r2[s2]);
      }
      function wr(e2, t2, i2) {
        const n2 = t2.length, r2 = Bn(i2, n2);
        e2.uniform1iv(this.addr, r2);
        for (let s2 = 0; s2 !== n2; ++s2)
          i2.setTexture2DArray(t2[s2] || Pn, r2[s2]);
      }
      class Tr {
        constructor(e2, t2, i2) {
          this.id = e2, this.addr = i2, this.cache = [], this.setValue = function(e3) {
            switch (e3) {
              case 5126:
                return Vn;
              case 35664:
                return Gn;
              case 35665:
                return Hn;
              case 35666:
                return jn;
              case 35674:
                return Wn;
              case 35675:
                return Xn;
              case 35676:
                return qn;
              case 5124:
              case 35670:
                return Yn;
              case 35667:
              case 35671:
                return Zn;
              case 35668:
              case 35672:
                return Jn;
              case 35669:
              case 35673:
                return Kn;
              case 5125:
                return Qn;
              case 36294:
                return $n;
              case 36295:
                return er;
              case 36296:
                return tr;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return ir;
              case 35679:
              case 36299:
              case 36307:
                return nr;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return rr;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return sr;
            }
          }(t2.type);
        }
      }
      class Er {
        constructor(e2, t2, i2) {
          this.id = e2, this.addr = i2, this.cache = [], this.size = t2.size, this.setValue = function(e3) {
            switch (e3) {
              case 5126:
                return ar;
              case 35664:
                return or;
              case 35665:
                return lr;
              case 35666:
                return hr;
              case 35674:
                return cr;
              case 35675:
                return ur;
              case 35676:
                return dr;
              case 5124:
              case 35670:
                return pr;
              case 35667:
              case 35671:
                return mr;
              case 35668:
              case 35672:
                return fr;
              case 35669:
              case 35673:
                return gr;
              case 5125:
                return _r;
              case 36294:
                return vr;
              case 36295:
                return xr;
              case 36296:
                return yr;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return br;
              case 35679:
              case 36299:
              case 36307:
                return Mr;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Sr;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return wr;
            }
          }(t2.type);
        }
      }
      class Cr {
        constructor(e2) {
          this.id = e2, this.seq = [], this.map = {};
        }
        setValue(e2, t2, i2) {
          const n2 = this.seq;
          for (let r2 = 0, s2 = n2.length; r2 !== s2; ++r2) {
            const s3 = n2[r2];
            s3.setValue(e2, t2[s3.id], i2);
          }
        }
      }
      const Ar = /(\w+)(\])?(\[|\.)?/g;
      function Pr(e2, t2) {
        e2.seq.push(t2), e2.map[t2.id] = t2;
      }
      function Rr(e2, t2, i2) {
        const n2 = e2.name, r2 = n2.length;
        for (Ar.lastIndex = 0; ; ) {
          const s2 = Ar.exec(n2), a2 = Ar.lastIndex;
          let o2 = s2[1];
          const l2 = "]" === s2[2], h2 = s2[3];
          if (l2 && (o2 |= 0), void 0 === h2 || "[" === h2 && a2 + 2 === r2) {
            Pr(i2, void 0 === h2 ? new Tr(o2, e2, t2) : new Er(o2, e2, t2));
            break;
          }
          {
            let e3 = i2.map[o2];
            void 0 === e3 && (e3 = new Cr(o2), Pr(i2, e3)), i2 = e3;
          }
        }
      }
      class Lr {
        constructor(e2, t2) {
          this.seq = [], this.map = {};
          const i2 = e2.getProgramParameter(t2, 35718);
          for (let n2 = 0; n2 < i2; ++n2) {
            const i3 = e2.getActiveUniform(t2, n2);
            Rr(i3, e2.getUniformLocation(t2, i3.name), this);
          }
        }
        setValue(e2, t2, i2, n2) {
          const r2 = this.map[t2];
          void 0 !== r2 && r2.setValue(e2, i2, n2);
        }
        setOptional(e2, t2, i2) {
          const n2 = t2[i2];
          void 0 !== n2 && this.setValue(e2, i2, n2);
        }
        static upload(e2, t2, i2, n2) {
          for (let r2 = 0, s2 = t2.length; r2 !== s2; ++r2) {
            const s3 = t2[r2], a2 = i2[s3.id];
            false !== a2.needsUpdate && s3.setValue(e2, a2.value, n2);
          }
        }
        static seqWithValue(e2, t2) {
          const i2 = [];
          for (let n2 = 0, r2 = e2.length; n2 !== r2; ++n2) {
            const r3 = e2[n2];
            r3.id in t2 && i2.push(r3);
          }
          return i2;
        }
      }
      function Ir(e2, t2, i2) {
        const n2 = e2.createShader(t2);
        return e2.shaderSource(n2, i2), e2.compileShader(n2), n2;
      }
      let Dr = 0;
      function Fr(e2, t2, i2) {
        const n2 = e2.getShaderParameter(t2, 35713), r2 = e2.getShaderInfoLog(t2).trim();
        if (n2 && "" === r2)
          return "";
        const s2 = /ERROR: 0:(\d+)/.exec(r2);
        if (s2) {
          const n3 = parseInt(s2[1]);
          return i2.toUpperCase() + "\n\n" + r2 + "\n\n" + function(e3, t3) {
            const i3 = e3.split("\n"), n4 = [], r3 = Math.max(t3 - 6, 0), s3 = Math.min(t3 + 6, i3.length);
            for (let a2 = r3; a2 < s3; a2++) {
              const e4 = a2 + 1;
              n4.push(`${e4 === t3 ? ">" : " "} ${e4}: ${i3[a2]}`);
            }
            return n4.join("\n");
          }(e2.getShaderSource(t2), n3);
        }
        return r2;
      }
      function Or(e2, t2) {
        const i2 = function(e3) {
          switch (e3) {
            case O:
              return ["Linear", "( value )"];
            case U:
              return ["sRGB", "( value )"];
            default:
              return console.warn("THREE.WebGLProgram: Unsupported encoding:", e3), ["Linear", "( value )"];
          }
        }(t2);
        return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + i2[0] + i2[1] + "; }";
      }
      function Ur(e2, t2) {
        let i2;
        switch (t2) {
          case 1:
            i2 = "Linear";
            break;
          case 2:
            i2 = "Reinhard";
            break;
          case 3:
            i2 = "OptimizedCineon";
            break;
          case 4:
            i2 = "ACESFilmic";
            break;
          case 5:
            i2 = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), i2 = "Linear";
        }
        return "vec3 " + e2 + "( vec3 color ) { return " + i2 + "ToneMapping( color ); }";
      }
      function zr(e2) {
        return "" !== e2;
      }
      function Nr(e2, t2) {
        return e2.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
      }
      function kr(e2, t2) {
        return e2.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
      }
      const Br = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Vr(e2) {
        return e2.replace(Br, Gr);
      }
      function Gr(e2, t2) {
        const i2 = Wi[t2];
        if (void 0 === i2)
          throw new Error("Can not resolve #include <" + t2 + ">");
        return Vr(i2);
      }
      const Hr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, jr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Wr(e2) {
        return e2.replace(jr, qr).replace(Hr, Xr);
      }
      function Xr(e2, t2, i2, n2) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), qr(e2, t2, i2, n2);
      }
      function qr(e2, t2, i2, n2) {
        let r2 = "";
        for (let s2 = parseInt(t2); s2 < parseInt(i2); s2++)
          r2 += n2.replace(/\[\s*i\s*\]/g, "[ " + s2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, s2);
        return r2;
      }
      function Yr(e2) {
        let t2 = "precision " + e2.precision + " float;\nprecision " + e2.precision + " int;";
        return "highp" === e2.precision ? t2 += "\n#define HIGH_PRECISION" : "mediump" === e2.precision ? t2 += "\n#define MEDIUM_PRECISION" : "lowp" === e2.precision && (t2 += "\n#define LOW_PRECISION"), t2;
      }
      function Zr(e2, t2, i2, n2) {
        const a2 = e2.getContext(), l2 = i2.defines;
        let h2 = i2.vertexShader, c2 = i2.fragmentShader;
        const u2 = function(e3) {
          let t3 = "SHADOWMAP_TYPE_BASIC";
          return 1 === e3.shadowMapType ? t3 = "SHADOWMAP_TYPE_PCF" : 2 === e3.shadowMapType ? t3 = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e3.shadowMapType && (t3 = "SHADOWMAP_TYPE_VSM"), t3;
        }(i2), d2 = function(e3) {
          let t3 = "ENVMAP_TYPE_CUBE";
          if (e3.envMap)
            switch (e3.envMapMode) {
              case r:
              case s:
                t3 = "ENVMAP_TYPE_CUBE";
                break;
              case o:
                t3 = "ENVMAP_TYPE_CUBE_UV";
            }
          return t3;
        }(i2), p2 = function(e3) {
          let t3 = "ENVMAP_MODE_REFLECTION";
          e3.envMap && e3.envMapMode === s && (t3 = "ENVMAP_MODE_REFRACTION");
          return t3;
        }(i2), m2 = function(e3) {
          let t3 = "ENVMAP_BLENDING_NONE";
          if (e3.envMap)
            switch (e3.combine) {
              case 0:
                t3 = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                t3 = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                t3 = "ENVMAP_BLENDING_ADD";
            }
          return t3;
        }(i2), f2 = function(e3) {
          const t3 = e3.envMapCubeUVHeight;
          if (null === t3)
            return null;
          const i3 = Math.log2(t3) - 2, n3 = 1 / t3;
          return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i3), 112)), texelHeight: n3, maxMip: i3 };
        }(i2), g2 = i2.isWebGL2 ? "" : function(e3) {
          return [e3.extensionDerivatives || e3.envMapCubeUVHeight || e3.bumpMap || e3.tangentSpaceNormalMap || e3.clearcoatNormalMap || e3.flatShading || "physical" === e3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e3.extensionFragDepth || e3.logarithmicDepthBuffer) && e3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e3.extensionDrawBuffers && e3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e3.extensionShaderTextureLOD || e3.envMap || e3.transmission) && e3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(zr).join("\n");
        }(i2), _2 = function(e3) {
          const t3 = [];
          for (const i3 in e3) {
            const n3 = e3[i3];
            false !== n3 && t3.push("#define " + i3 + " " + n3);
          }
          return t3.join("\n");
        }(l2), v2 = a2.createProgram();
        let x2, y2, b2 = i2.glslVersion ? "#version " + i2.glslVersion + "\n" : "";
        if (i2.isRawShaderMaterial ? (x2 = [_2].filter(zr).join("\n"), x2.length > 0 && (x2 += "\n"), y2 = [g2, _2].filter(zr).join("\n"), y2.length > 0 && (y2 += "\n")) : (x2 = [Yr(i2), "#define SHADER_NAME " + i2.shaderName, _2, i2.instancing ? "#define USE_INSTANCING" : "", i2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + p2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.displacementMap && i2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.skinning ? "#define USE_SKINNING" : "", i2.morphTargets ? "#define USE_MORPHTARGETS" : "", i2.morphNormals && false === i2.flatShading ? "#define USE_MORPHNORMALS" : "", i2.morphColors && i2.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i2.morphTextureStride : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i2.morphTargetsCount : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + u2 : "", i2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(zr).join("\n"), y2 = [g2, Yr(i2), "#define SHADER_NAME " + i2.shaderName, _2, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.matcap ? "#define USE_MATCAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + d2 : "", i2.envMap ? "#define " + p2 : "", i2.envMap ? "#define " + m2 : "", f2 ? "#define CUBEUV_TEXEL_WIDTH " + f2.texelWidth : "", f2 ? "#define CUBEUV_TEXEL_HEIGHT " + f2.texelHeight : "", f2 ? "#define CUBEUV_MAX_MIP " + f2.maxMip + ".0" : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoat ? "#define USE_CLEARCOAT" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescence ? "#define USE_IRIDESCENCE" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.alphaTest ? "#define USE_ALPHATEST" : "", i2.sheen ? "#define USE_SHEEN" : "", i2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors || i2.instancingColor ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.gradientMap ? "#define USE_GRADIENTMAP" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + u2 : "", i2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i2.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i2.toneMapping ? Wi.tonemapping_pars_fragment : "", 0 !== i2.toneMapping ? Ur("toneMapping", i2.toneMapping) : "", i2.dithering ? "#define DITHERING" : "", i2.opaque ? "#define OPAQUE" : "", Wi.encodings_pars_fragment, Or("linearToOutputTexel", i2.outputEncoding), i2.useDepthPacking ? "#define DEPTH_PACKING " + i2.depthPacking : "", "\n"].filter(zr).join("\n")), e2.onShaderBeforeResolve) {
          const t3 = e2.onShaderBeforeResolve(h2, c2, i2);
          h2 = t3.vertexShader, c2 = t3.fragmentShader;
        }
        h2 = Vr(h2), h2 = Nr(h2, i2), h2 = kr(h2, i2), c2 = Vr(c2), c2 = Nr(c2, i2), c2 = kr(c2, i2), h2 = Wr(h2), c2 = Wr(c2), i2.isWebGL2 && true !== i2.isRawShaderMaterial && (b2 = "#version 300 es\n", x2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x2, y2 = ["#define varying in", i2.glslVersion === V ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i2.glslVersion === V ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y2);
        let M2 = b2 + x2 + h2, S2 = b2 + y2 + c2;
        if (e2.onShaderBeforeCompile) {
          const t3 = e2.onShaderBeforeCompile(M2, S2, i2);
          M2 = t3.vertexShader, S2 = t3.fragmentShader;
        }
        const w2 = Ir(a2, 35633, M2), T2 = Ir(a2, 35632, S2);
        if (a2.attachShader(v2, w2), a2.attachShader(v2, T2), void 0 !== i2.index0AttributeName ? a2.bindAttribLocation(v2, 0, i2.index0AttributeName) : true === i2.morphTargets && a2.bindAttribLocation(v2, 0, "position"), a2.linkProgram(v2), e2.debug.checkShaderErrors) {
          const e3 = a2.getProgramInfoLog(v2).trim(), t3 = a2.getShaderInfoLog(w2).trim(), i3 = a2.getShaderInfoLog(T2).trim();
          let n3 = true, r2 = true;
          if (false === a2.getProgramParameter(v2, 35714)) {
            n3 = false;
            const t4 = Fr(a2, w2, "vertex"), i4 = Fr(a2, T2, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + a2.getError() + " - VALIDATE_STATUS " + a2.getProgramParameter(v2, 35715) + "\n\nProgram Info Log: " + e3 + "\n" + t4 + "\n" + i4);
          } else
            "" !== e3 ? console.warn("THREE.WebGLProgram: Program Info Log:", e3) : "" !== t3 && "" !== i3 || (r2 = false);
          r2 && (this.diagnostics = { runnable: n3, programLog: e3, vertexShader: { log: t3, prefix: x2 }, fragmentShader: { log: i3, prefix: y2 } });
        }
        let E2, C2;
        return a2.deleteShader(w2), a2.deleteShader(T2), this.getUniforms = function() {
          return void 0 === E2 && (E2 = new Lr(a2, v2)), E2;
        }, this.getAttributes = function() {
          return void 0 === C2 && (C2 = function(e3, t3) {
            const i3 = {}, n3 = e3.getProgramParameter(t3, 35721);
            for (let r2 = 0; r2 < n3; r2++) {
              const n4 = e3.getActiveAttrib(t3, r2), s2 = n4.name;
              let a3 = 1;
              35674 === n4.type && (a3 = 2), 35675 === n4.type && (a3 = 3), 35676 === n4.type && (a3 = 4), i3[s2] = { type: n4.type, location: e3.getAttribLocation(t3, s2), locationSize: a3 };
            }
            return i3;
          }(a2, v2)), C2;
        }, this.destroy = function() {
          n2.releaseStatesOfProgram(this), a2.deleteProgram(v2), this.program = void 0;
        }, this.name = i2.shaderName, this.id = Dr++, this.cacheKey = t2, this.usedTimes = 1, this.program = v2, this.vertexShader = w2, this.fragmentShader = T2, this;
      }
      let Jr = 0;
      class Kr {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(e2) {
          const t2 = e2.vertexShader, i2 = e2.fragmentShader, n2 = this._getShaderStage(t2), r2 = this._getShaderStage(i2), s2 = this._getShaderCacheForMaterial(e2);
          return false === s2.has(n2) && (s2.add(n2), n2.usedTimes++), false === s2.has(r2) && (s2.add(r2), r2.usedTimes++), this;
        }
        remove(e2) {
          const t2 = this.materialCache.get(e2);
          for (const i2 of t2)
            i2.usedTimes--, 0 === i2.usedTimes && this.shaderCache.delete(i2.code);
          return this.materialCache.delete(e2), this;
        }
        getVertexShaderID(e2) {
          return this._getShaderStage(e2.vertexShader).id;
        }
        getFragmentShaderID(e2) {
          return this._getShaderStage(e2.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e2) {
          const t2 = this.materialCache;
          return false === t2.has(e2) && t2.set(e2, /* @__PURE__ */ new Set()), t2.get(e2);
        }
        _getShaderStage(e2) {
          const t2 = this.shaderCache;
          if (false === t2.has(e2)) {
            const i2 = new Qr(e2);
            t2.set(e2, i2);
          }
          return t2.get(e2);
        }
      }
      class Qr {
        constructor(e2) {
          this.id = Jr++, this.code = e2, this.usedTimes = 0;
        }
      }
      function $r(e2, t2, i2, n2, r2, s2, a2) {
        const l2 = new gt(), h2 = new Kr(), c2 = [], u2 = r2.isWebGL2, d2 = r2.logarithmicDepthBuffer, p2 = r2.vertexTextures;
        let m2 = r2.precision;
        const f2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
        return { getParameters: function(s3, l3, c3, g2, _2) {
          const v2 = g2.fog, x2 = _2.geometry, y2 = s3.isMeshStandardMaterial ? g2.environment : null, b2 = (s3.isMeshStandardMaterial ? i2 : t2).get(s3.envMap || y2), M2 = b2 && b2.mapping === o ? b2.image.height : null, S2 = f2[s3.type];
          null !== s3.precision && (m2 = r2.getMaxPrecision(s3.precision), m2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", m2, "instead."));
          const w2 = x2.morphAttributes.position || x2.morphAttributes.normal || x2.morphAttributes.color, T2 = void 0 !== w2 ? w2.length : 0;
          let E2, C2, A2, P2, R2 = 0;
          if (void 0 !== x2.morphAttributes.position && (R2 = 1), void 0 !== x2.morphAttributes.normal && (R2 = 2), void 0 !== x2.morphAttributes.color && (R2 = 3), S2) {
            const e3 = qi[S2];
            E2 = e3.vertexShader, C2 = e3.fragmentShader;
          } else
            E2 = s3.vertexShader, C2 = s3.fragmentShader, h2.update(s3), A2 = h2.getVertexShaderID(s3), P2 = h2.getFragmentShaderID(s3);
          const L2 = e2.getRenderTarget(), I2 = s3.alphaTest > 0, D2 = s3.clearcoat > 0, F2 = s3.iridescence > 0;
          return { isWebGL2: u2, shaderID: S2, shaderName: s3.type, vertexShader: E2, fragmentShader: C2, defines: s3.defines, customVertexShaderID: A2, customFragmentShaderID: P2, isRawShaderMaterial: true === s3.isRawShaderMaterial, glslVersion: s3.glslVersion, precision: m2, instancing: true === _2.isInstancedMesh, instancingColor: true === _2.isInstancedMesh && null !== _2.instanceColor, supportsVertexTextures: p2, outputEncoding: null === L2 ? e2.outputEncoding : true === L2.isXRRenderTarget ? L2.texture.encoding : O, map: !!s3.map, matcap: !!s3.matcap, envMap: !!b2, envMapMode: b2 && b2.mapping, envMapCubeUVHeight: M2, lightMap: !!s3.lightMap, aoMap: !!s3.aoMap, emissiveMap: !!s3.emissiveMap, bumpMap: !!s3.bumpMap, normalMap: !!s3.normalMap, objectSpaceNormalMap: 1 === s3.normalMapType, tangentSpaceNormalMap: 0 === s3.normalMapType, decodeVideoTexture: !!s3.map && true === s3.map.isVideoTexture && s3.map.encoding === U, clearcoat: D2, clearcoatMap: D2 && !!s3.clearcoatMap, clearcoatRoughnessMap: D2 && !!s3.clearcoatRoughnessMap, clearcoatNormalMap: D2 && !!s3.clearcoatNormalMap, iridescence: F2, iridescenceMap: F2 && !!s3.iridescenceMap, iridescenceThicknessMap: F2 && !!s3.iridescenceThicknessMap, displacementMap: !!s3.displacementMap, roughnessMap: !!s3.roughnessMap, metalnessMap: !!s3.metalnessMap, specularMap: !!s3.specularMap, specularIntensityMap: !!s3.specularIntensityMap, specularColorMap: !!s3.specularColorMap, opaque: false === s3.transparent && 1 === s3.blending, alphaMap: !!s3.alphaMap, alphaTest: I2, gradientMap: !!s3.gradientMap, sheen: s3.sheen > 0, sheenColorMap: !!s3.sheenColorMap, sheenRoughnessMap: !!s3.sheenRoughnessMap, transmission: s3.transmission > 0, transmissionMap: !!s3.transmissionMap, thicknessMap: !!s3.thicknessMap, combine: s3.combine, vertexTangents: !!s3.normalMap && !!x2.attributes.tangent, vertexColors: s3.vertexColors, vertexAlphas: true === s3.vertexColors && !!x2.attributes.color && 4 === x2.attributes.color.itemSize, vertexUvs: !!(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatMap || s3.clearcoatRoughnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.displacementMap || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheenColorMap || s3.sheenRoughnessMap), uvsVertexOnly: !(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.transmission > 0 || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheen > 0 || s3.sheenColorMap || s3.sheenRoughnessMap || !s3.displacementMap), fog: !!v2, useFog: true === s3.fog, fogExp2: v2 && v2.isFogExp2, flatShading: !!s3.flatShading, sizeAttenuation: s3.sizeAttenuation, logarithmicDepthBuffer: d2, skinning: true === _2.isSkinnedMesh, morphTargets: void 0 !== x2.morphAttributes.position, morphNormals: void 0 !== x2.morphAttributes.normal, morphColors: void 0 !== x2.morphAttributes.color, morphTargetsCount: T2, morphTextureStride: R2, numDirLights: l3.directional.length, numPointLights: l3.point.length, numSpotLights: l3.spot.length, numRectAreaLights: l3.rectArea.length, numHemiLights: l3.hemi.length, numDirLightShadows: l3.directionalShadowMap.length, numPointLightShadows: l3.pointShadowMap.length, numSpotLightShadows: l3.spotShadowMap.length, numClippingPlanes: a2.numPlanes, numClipIntersection: a2.numIntersection, dithering: s3.dithering, shadowMapEnabled: e2.shadowMap.enabled && c3.length > 0, shadowMapType: e2.shadowMap.type, toneMapping: s3.toneMapped ? e2.toneMapping : 0, physicallyCorrectLights: e2.physicallyCorrectLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: 2 === s3.side, flipSided: 1 === s3.side, useDepthPacking: !!s3.depthPacking, depthPacking: s3.depthPacking || 0, index0AttributeName: s3.index0AttributeName, extensionDerivatives: s3.extensions && s3.extensions.derivatives, extensionFragDepth: s3.extensions && s3.extensions.fragDepth, extensionDrawBuffers: s3.extensions && s3.extensions.drawBuffers, extensionShaderTextureLOD: s3.extensions && s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: u2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: u2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: u2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey(), extraProgramCacheKey: e2.extraProgramCacheKey };
        }, getProgramCacheKey: function(t3) {
          const i3 = [];
          if (t3.shaderID ? i3.push(t3.shaderID) : (i3.push(t3.customVertexShaderID), i3.push(t3.customFragmentShaderID)), void 0 !== t3.defines)
            for (const e3 in t3.defines)
              i3.push(e3), i3.push(t3.defines[e3]);
          return false === t3.isRawShaderMaterial && (!function(e3, t4) {
            e3.push(t4.precision), e3.push(t4.outputEncoding), e3.push(t4.envMapMode), e3.push(t4.envMapCubeUVHeight), e3.push(t4.combine), e3.push(t4.vertexUvs), e3.push(t4.fogExp2), e3.push(t4.sizeAttenuation), e3.push(t4.morphTargetsCount), e3.push(t4.morphAttributeCount), e3.push(t4.numDirLights), e3.push(t4.numPointLights), e3.push(t4.numSpotLights), e3.push(t4.numHemiLights), e3.push(t4.numRectAreaLights), e3.push(t4.numDirLightShadows), e3.push(t4.numPointLightShadows), e3.push(t4.numSpotLightShadows), e3.push(t4.shadowMapType), e3.push(t4.toneMapping), e3.push(t4.numClippingPlanes), e3.push(t4.numClipIntersection), e3.push(t4.depthPacking);
          }(i3, t3), function(e3, t4) {
            l2.disableAll(), t4.isWebGL2 && l2.enable(0);
            t4.supportsVertexTextures && l2.enable(1);
            t4.instancing && l2.enable(2);
            t4.instancingColor && l2.enable(3);
            t4.map && l2.enable(4);
            t4.matcap && l2.enable(5);
            t4.envMap && l2.enable(6);
            t4.lightMap && l2.enable(7);
            t4.aoMap && l2.enable(8);
            t4.emissiveMap && l2.enable(9);
            t4.bumpMap && l2.enable(10);
            t4.normalMap && l2.enable(11);
            t4.objectSpaceNormalMap && l2.enable(12);
            t4.tangentSpaceNormalMap && l2.enable(13);
            t4.clearcoat && l2.enable(14);
            t4.clearcoatMap && l2.enable(15);
            t4.clearcoatRoughnessMap && l2.enable(16);
            t4.clearcoatNormalMap && l2.enable(17);
            t4.iridescence && l2.enable(18);
            t4.iridescenceMap && l2.enable(19);
            t4.iridescenceThicknessMap && l2.enable(20);
            t4.displacementMap && l2.enable(21);
            t4.specularMap && l2.enable(22);
            t4.roughnessMap && l2.enable(23);
            t4.metalnessMap && l2.enable(24);
            t4.gradientMap && l2.enable(25);
            t4.alphaMap && l2.enable(26);
            t4.alphaTest && l2.enable(27);
            t4.vertexColors && l2.enable(28);
            t4.vertexAlphas && l2.enable(29);
            t4.vertexUvs && l2.enable(30);
            t4.vertexTangents && l2.enable(31);
            t4.uvsVertexOnly && l2.enable(32);
            t4.fog && l2.enable(33);
            e3.push(l2.mask), l2.disableAll(), t4.useFog && l2.enable(0);
            t4.flatShading && l2.enable(1);
            t4.logarithmicDepthBuffer && l2.enable(2);
            t4.skinning && l2.enable(3);
            t4.morphTargets && l2.enable(4);
            t4.morphNormals && l2.enable(5);
            t4.morphColors && l2.enable(6);
            t4.premultipliedAlpha && l2.enable(7);
            t4.shadowMapEnabled && l2.enable(8);
            t4.physicallyCorrectLights && l2.enable(9);
            t4.doubleSided && l2.enable(10);
            t4.flipSided && l2.enable(11);
            t4.useDepthPacking && l2.enable(12);
            t4.dithering && l2.enable(13);
            t4.specularIntensityMap && l2.enable(14);
            t4.specularColorMap && l2.enable(15);
            t4.transmission && l2.enable(16);
            t4.transmissionMap && l2.enable(17);
            t4.thicknessMap && l2.enable(18);
            t4.sheen && l2.enable(19);
            t4.sheenColorMap && l2.enable(20);
            t4.sheenRoughnessMap && l2.enable(21);
            t4.decodeVideoTexture && l2.enable(22);
            t4.opaque && l2.enable(23);
            e3.push(l2.mask);
          }(i3, t3), i3.push(e2.outputEncoding)), i3.push(t3.customProgramCacheKey), e2.extraProgramCacheKey && i3.push(e2.extraProgramCacheKey), i3.join();
        }, getUniforms: function(e3) {
          const t3 = f2[e3.type];
          let i3;
          if (t3) {
            const e4 = qi[t3];
            i3 = Ci.clone(e4.uniforms);
          } else
            i3 = e3.uniforms;
          return i3;
        }, acquireProgram: function(t3, i3) {
          let n3;
          for (let e3 = 0, r3 = c2.length; e3 < r3; e3++) {
            const t4 = c2[e3];
            if (t4.cacheKey === i3) {
              n3 = t4, ++n3.usedTimes;
              break;
            }
          }
          return void 0 === n3 && (n3 = new Zr(e2, i3, t3, s2), c2.push(n3)), n3;
        }, releaseProgram: function(e3) {
          if (0 == --e3.usedTimes) {
            const t3 = c2.indexOf(e3);
            c2[t3] = c2[c2.length - 1], c2.pop(), e3.destroy();
          }
        }, releaseShaderCache: function(e3) {
          h2.remove(e3);
        }, programs: c2, dispose: function() {
          h2.dispose();
        } };
      }
      function es() {
        let e2 = /* @__PURE__ */ new WeakMap();
        return { get: function(t2) {
          let i2 = e2.get(t2);
          return void 0 === i2 && (i2 = {}, e2.set(t2, i2)), i2;
        }, remove: function(t2) {
          e2.delete(t2);
        }, update: function(t2, i2, n2) {
          e2.get(t2)[i2] = n2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function ts(e2, t2) {
        return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.material.id !== t2.material.id ? e2.material.id - t2.material.id : e2.z !== t2.z ? e2.z - t2.z : e2.id - t2.id;
      }
      function is(e2, t2) {
        return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.z !== t2.z ? t2.z - e2.z : e2.id - t2.id;
      }
      function ns() {
        const e2 = [];
        let t2 = 0;
        const i2 = [], n2 = [], r2 = [];
        function s2(i3, n3, r3, s3, a2, o2) {
          let l2 = e2[t2];
          return void 0 === l2 ? (l2 = { id: i3.id, object: i3, geometry: n3, material: r3, groupOrder: s3, renderOrder: i3.renderOrder, z: a2, group: o2 }, e2[t2] = l2) : (l2.id = i3.id, l2.object = i3, l2.geometry = n3, l2.material = r3, l2.groupOrder = s3, l2.renderOrder = i3.renderOrder, l2.z = a2, l2.group = o2), t2++, l2;
        }
        return { opaque: i2, transmissive: n2, transparent: r2, init: function() {
          t2 = 0, i2.length = 0, n2.length = 0, r2.length = 0;
        }, push: function(e3, t3, a2, o2, l2, h2) {
          const c2 = s2(e3, t3, a2, o2, l2, h2);
          a2.transmission > 0 ? n2.push(c2) : true === a2.transparent ? r2.push(c2) : i2.push(c2);
        }, unshift: function(e3, t3, a2, o2, l2, h2) {
          const c2 = s2(e3, t3, a2, o2, l2, h2);
          a2.transmission > 0 ? n2.unshift(c2) : true === a2.transparent ? r2.unshift(c2) : i2.unshift(c2);
        }, finish: function() {
          for (let i3 = t2, n3 = e2.length; i3 < n3; i3++) {
            const t3 = e2[i3];
            if (null === t3.id)
              break;
            t3.id = null, t3.object = null, t3.geometry = null, t3.material = null, t3.group = null;
          }
        }, sort: function(e3, t3) {
          i2.length > 1 && i2.sort(e3 || ts), n2.length > 1 && n2.sort(t3 || is), r2.length > 1 && r2.sort(t3 || is);
        } };
      }
      function rs() {
        let e2 = /* @__PURE__ */ new WeakMap();
        return { get: function(t2, i2) {
          let n2;
          return false === e2.has(t2) ? (n2 = new ns(), e2.set(t2, [n2])) : i2 >= e2.get(t2).length ? (n2 = new ns(), e2.get(t2).push(n2)) : n2 = e2.get(t2)[i2], n2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function ss() {
        const e2 = {};
        return { get: function(t2) {
          if (void 0 !== e2[t2.id])
            return e2[t2.id];
          let i2;
          switch (t2.type) {
            case "DirectionalLight":
              i2 = { direction: new Ae(), color: new ge() };
              break;
            case "SpotLight":
              i2 = { position: new Ae(), direction: new Ae(), color: new ge(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
              break;
            case "PointLight":
              i2 = { position: new Ae(), color: new ge(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              i2 = { direction: new Ae(), skyColor: new ge(), groundColor: new ge() };
              break;
            case "RectAreaLight":
              i2 = { color: new ge(), position: new Ae(), halfWidth: new Ae(), halfHeight: new Ae() };
          }
          return e2[t2.id] = i2, i2;
        } };
      }
      let as = 0;
      function os(e2, t2) {
        return (t2.castShadow ? 1 : 0) - (e2.castShadow ? 1 : 0);
      }
      function ls(e2, t2) {
        const i2 = new ss(), n2 = function() {
          const e3 = {};
          return { get: function(t3) {
            if (void 0 !== e3[t3.id])
              return e3[t3.id];
            let i3;
            switch (t3.type) {
              case "DirectionalLight":
              case "SpotLight":
                i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ie() };
                break;
              case "PointLight":
                i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ie(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
            }
            return e3[t3.id] = i3, i3;
          } };
        }(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
        for (let l2 = 0; l2 < 9; l2++)
          r2.probe.push(new Ae());
        const s2 = new Ae(), a2 = new st(), o2 = new st();
        return { setup: function(s3, a3) {
          let o3 = 0, l2 = 0, h2 = 0;
          for (let e3 = 0; e3 < 9; e3++)
            r2.probe[e3].set(0, 0, 0);
          let c2 = 0, u2 = 0, d2 = 0, p2 = 0, m2 = 0, f2 = 0, g2 = 0, _2 = 0;
          s3.sort(os);
          const v2 = true !== a3 ? Math.PI : 1;
          for (let e3 = 0, t3 = s3.length; e3 < t3; e3++) {
            const t4 = s3[e3], a4 = t4.color, x3 = t4.intensity, y2 = t4.distance, b2 = t4.shadow && t4.shadow.map ? t4.shadow.map.texture : null;
            if (t4.isAmbientLight)
              o3 += a4.r * x3 * v2, l2 += a4.g * x3 * v2, h2 += a4.b * x3 * v2;
            else if (t4.isLightProbe)
              for (let e4 = 0; e4 < 9; e4++)
                r2.probe[e4].addScaledVector(t4.sh.coefficients[e4], x3);
            else if (t4.isDirectionalLight) {
              const e4 = i2.get(t4);
              if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * v2), t4.castShadow) {
                const e5 = t4.shadow, i3 = n2.get(t4);
                i3.shadowBias = e5.bias, i3.shadowNormalBias = e5.normalBias, i3.shadowRadius = e5.radius, i3.shadowMapSize = e5.mapSize, r2.directionalShadow[c2] = i3, r2.directionalShadowMap[c2] = b2, r2.directionalShadowMatrix[c2] = t4.shadow.matrix, f2++;
              }
              r2.directional[c2] = e4, c2++;
            } else if (t4.isSpotLight) {
              const e4 = i2.get(t4);
              if (e4.position.setFromMatrixPosition(t4.matrixWorld), e4.color.copy(a4).multiplyScalar(x3 * v2), e4.distance = y2, e4.coneCos = Math.cos(t4.angle), e4.penumbraCos = Math.cos(t4.angle * (1 - t4.penumbra)), e4.decay = t4.decay, t4.castShadow) {
                const e5 = t4.shadow, i3 = n2.get(t4);
                i3.shadowBias = e5.bias, i3.shadowNormalBias = e5.normalBias, i3.shadowRadius = e5.radius, i3.shadowMapSize = e5.mapSize, r2.spotShadow[d2] = i3, r2.spotShadowMap[d2] = b2, r2.spotShadowMatrix[d2] = t4.shadow.matrix, _2++;
              }
              r2.spot[d2] = e4, d2++;
            } else if (t4.isRectAreaLight) {
              const e4 = i2.get(t4);
              e4.color.copy(a4).multiplyScalar(x3), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), r2.rectArea[p2] = e4, p2++;
            } else if (t4.isPointLight) {
              const e4 = i2.get(t4);
              if (e4.color.copy(t4.color).multiplyScalar(t4.intensity * v2), e4.distance = t4.distance, e4.decay = t4.decay, t4.castShadow) {
                const e5 = t4.shadow, i3 = n2.get(t4);
                i3.shadowBias = e5.bias, i3.shadowNormalBias = e5.normalBias, i3.shadowRadius = e5.radius, i3.shadowMapSize = e5.mapSize, i3.shadowCameraNear = e5.camera.near, i3.shadowCameraFar = e5.camera.far, r2.pointShadow[u2] = i3, r2.pointShadowMap[u2] = b2, r2.pointShadowMatrix[u2] = t4.shadow.matrix, g2++;
              }
              r2.point[u2] = e4, u2++;
            } else if (t4.isHemisphereLight) {
              const e4 = i2.get(t4);
              e4.skyColor.copy(t4.color).multiplyScalar(x3 * v2), e4.groundColor.copy(t4.groundColor).multiplyScalar(x3 * v2), r2.hemi[m2] = e4, m2++;
            }
          }
          p2 > 0 && (t2.isWebGL2 || true === e2.has("OES_texture_float_linear") ? (r2.rectAreaLTC1 = Xi.LTC_FLOAT_1, r2.rectAreaLTC2 = Xi.LTC_FLOAT_2) : true === e2.has("OES_texture_half_float_linear") ? (r2.rectAreaLTC1 = Xi.LTC_HALF_1, r2.rectAreaLTC2 = Xi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = o3, r2.ambient[1] = l2, r2.ambient[2] = h2;
          const x2 = r2.hash;
          x2.directionalLength === c2 && x2.pointLength === u2 && x2.spotLength === d2 && x2.rectAreaLength === p2 && x2.hemiLength === m2 && x2.numDirectionalShadows === f2 && x2.numPointShadows === g2 && x2.numSpotShadows === _2 || (r2.directional.length = c2, r2.spot.length = d2, r2.rectArea.length = p2, r2.point.length = u2, r2.hemi.length = m2, r2.directionalShadow.length = f2, r2.directionalShadowMap.length = f2, r2.pointShadow.length = g2, r2.pointShadowMap.length = g2, r2.spotShadow.length = _2, r2.spotShadowMap.length = _2, r2.directionalShadowMatrix.length = f2, r2.pointShadowMatrix.length = g2, r2.spotShadowMatrix.length = _2, x2.directionalLength = c2, x2.pointLength = u2, x2.spotLength = d2, x2.rectAreaLength = p2, x2.hemiLength = m2, x2.numDirectionalShadows = f2, x2.numPointShadows = g2, x2.numSpotShadows = _2, r2.version = as++);
        }, setupView: function(e3, t3) {
          let i3 = 0, n3 = 0, l2 = 0, h2 = 0, c2 = 0;
          const u2 = t3.matrixWorldInverse;
          for (let d2 = 0, p2 = e3.length; d2 < p2; d2++) {
            const t4 = e3[d2];
            if (t4.isDirectionalLight) {
              const e4 = r2.directional[i3];
              e4.direction.setFromMatrixPosition(t4.matrixWorld), s2.setFromMatrixPosition(t4.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(u2), i3++;
            } else if (t4.isSpotLight) {
              const e4 = r2.spot[l2];
              e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), e4.direction.setFromMatrixPosition(t4.matrixWorld), s2.setFromMatrixPosition(t4.target.matrixWorld), e4.direction.sub(s2), e4.direction.transformDirection(u2), l2++;
            } else if (t4.isRectAreaLight) {
              const e4 = r2.rectArea[h2];
              e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), o2.identity(), a2.copy(t4.matrixWorld), a2.premultiply(u2), o2.extractRotation(a2), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), e4.halfWidth.applyMatrix4(o2), e4.halfHeight.applyMatrix4(o2), h2++;
            } else if (t4.isPointLight) {
              const e4 = r2.point[n3];
              e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), n3++;
            } else if (t4.isHemisphereLight) {
              const e4 = r2.hemi[c2];
              e4.direction.setFromMatrixPosition(t4.matrixWorld), e4.direction.transformDirection(u2), c2++;
            }
          }
        }, state: r2 };
      }
      function hs(e2, t2) {
        const i2 = new ls(e2, t2), n2 = [], r2 = [];
        return { init: function() {
          n2.length = 0, r2.length = 0;
        }, state: { lightsArray: n2, shadowsArray: r2, lights: i2 }, setupLights: function(e3) {
          i2.setup(n2, e3);
        }, setupLightsView: function(e3) {
          i2.setupView(n2, e3);
        }, pushLight: function(e3) {
          n2.push(e3);
        }, pushShadow: function(e3) {
          r2.push(e3);
        } };
      }
      function cs(e2, t2) {
        let i2 = /* @__PURE__ */ new WeakMap();
        return { get: function(n2, r2 = 0) {
          let s2;
          return false === i2.has(n2) ? (s2 = new hs(e2, t2), i2.set(n2, [s2])) : r2 >= i2.get(n2).length ? (s2 = new hs(e2, t2), i2.get(n2).push(s2)) : s2 = i2.get(n2)[r2], s2;
        }, dispose: function() {
          i2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      class us extends Ht {
        constructor(e2) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.depthPacking = e2.depthPacking, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this;
        }
      }
      class ds extends Ht {
        constructor(e2) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new Ae(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.referencePosition.copy(e2.referencePosition), this.nearDistance = e2.nearDistance, this.farDistance = e2.farDistance, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this;
        }
      }
      function ps(e2, t2, i2) {
        let n2 = new Vi();
        const r2 = new ie(), s2 = new ie(), a2 = new Se(), o2 = new us({ depthPacking: 3201 }), l2 = new ds(), h2 = {}, c2 = i2.maxTextureSize, d2 = { 0: 1, 1: 0, 2: 2 }, p2 = new Ai({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new ie() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), m2 = p2.clone();
        m2.defines.HORIZONTAL_PASS = 1;
        const f2 = new ri();
        f2.setAttribute("position", new qt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const g2 = new Mi(f2, p2), _2 = this;
        function v2(i3, n3) {
          const r3 = t2.update(g2);
          p2.defines.VSM_SAMPLES !== i3.blurSamples && (p2.defines.VSM_SAMPLES = i3.blurSamples, m2.defines.VSM_SAMPLES = i3.blurSamples, p2.needsUpdate = true, m2.needsUpdate = true), p2.uniforms.shadow_pass.value = i3.map.texture, p2.uniforms.resolution.value = i3.mapSize, p2.uniforms.radius.value = i3.radius, e2.setRenderTarget(i3.mapPass), e2.clear(), e2.renderBufferDirect(n3, null, r3, p2, g2, null), m2.uniforms.shadow_pass.value = i3.mapPass.texture, m2.uniforms.resolution.value = i3.mapSize, m2.uniforms.radius.value = i3.radius, e2.setRenderTarget(i3.map), e2.clear(), e2.renderBufferDirect(n3, null, r3, m2, g2, null);
        }
        function x2(t3, i3, n3, r3, s3, a3) {
          let c3 = null;
          const u2 = true === n3.isPointLight ? t3.customDistanceMaterial : t3.customDepthMaterial;
          if (c3 = void 0 !== u2 ? u2 : true === n3.isPointLight ? l2 : o2, e2.localClippingEnabled && true === i3.clipShadows && 0 !== i3.clippingPlanes.length || i3.displacementMap && 0 !== i3.displacementScale || i3.alphaMap && i3.alphaTest > 0) {
            const e3 = c3.uuid, t4 = i3.uuid;
            let n4 = h2[e3];
            void 0 === n4 && (n4 = {}, h2[e3] = n4);
            let r4 = n4[t4];
            void 0 === r4 && (r4 = c3.clone(), n4[t4] = r4), c3 = r4;
          }
          return c3.visible = i3.visible, c3.wireframe = i3.wireframe, c3.side = 3 === a3 ? null !== i3.shadowSide ? i3.shadowSide : i3.side : null !== i3.shadowSide ? i3.shadowSide : d2[i3.side], c3.alphaMap = i3.alphaMap, c3.alphaTest = i3.alphaTest, c3.clipShadows = i3.clipShadows, c3.clippingPlanes = i3.clippingPlanes, c3.clipIntersection = i3.clipIntersection, c3.displacementMap = i3.displacementMap, c3.displacementScale = i3.displacementScale, c3.displacementBias = i3.displacementBias, c3.wireframeLinewidth = i3.wireframeLinewidth, c3.linewidth = i3.linewidth, true === n3.isPointLight && true === c3.isMeshDistanceMaterial && (c3.referencePosition.setFromMatrixPosition(n3.matrixWorld), c3.nearDistance = r3, c3.farDistance = s3), c3;
        }
        function y2(i3, r3, s3, a3, o3) {
          if (false === i3.visible)
            return;
          if (i3.layers.test(r3.layers) && (i3.isMesh || i3.isLine || i3.isPoints) && (i3.castShadow || i3.receiveShadow && 3 === o3) && (!i3.frustumCulled || n2.intersectsObject(i3))) {
            i3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, i3.matrixWorld);
            const n3 = t2.update(i3), r4 = i3.material;
            if (Array.isArray(r4)) {
              const t3 = n3.groups;
              for (let l4 = 0, h3 = t3.length; l4 < h3; l4++) {
                const h4 = t3[l4], c3 = r4[h4.materialIndex];
                if (c3 && c3.visible) {
                  const t4 = x2(i3, c3, a3, s3.near, s3.far, o3);
                  e2.renderBufferDirect(s3, null, n3, t4, i3, h4);
                }
              }
            } else if (r4.visible) {
              const t3 = x2(i3, r4, a3, s3.near, s3.far, o3);
              e2.renderBufferDirect(s3, null, n3, t3, i3, null);
            }
          }
          const l3 = i3.children;
          for (let e3 = 0, t3 = l3.length; e3 < t3; e3++)
            y2(l3[e3], r3, s3, a3, o3);
        }
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(t3, i3, o3) {
          if (false === _2.enabled)
            return;
          if (false === _2.autoUpdate && false === _2.needsUpdate)
            return;
          if (0 === t3.length)
            return;
          const l3 = e2.getRenderTarget(), h3 = e2.getActiveCubeFace(), d3 = e2.getActiveMipmapLevel(), p3 = e2.state;
          p3.setBlending(0), p3.buffers.color.setClear(1, 1, 1, 1), p3.buffers.depth.setTest(true), p3.setScissorTest(false);
          for (let m3 = 0, f3 = t3.length; m3 < f3; m3++) {
            const l4 = t3[m3], h4 = l4.shadow;
            if (void 0 === h4) {
              console.warn("THREE.WebGLShadowMap:", l4, "has no shadow.");
              continue;
            }
            if (false === h4.autoUpdate && false === h4.needsUpdate)
              continue;
            r2.copy(h4.mapSize);
            const d4 = h4.getFrameExtents();
            if (r2.multiply(d4), s2.copy(h4.mapSize), (r2.x > c2 || r2.y > c2) && (r2.x > c2 && (s2.x = Math.floor(c2 / d4.x), r2.x = s2.x * d4.x, h4.mapSize.x = s2.x), r2.y > c2 && (s2.y = Math.floor(c2 / d4.y), r2.y = s2.y * d4.y, h4.mapSize.y = s2.y)), null !== h4.map || h4.isPointLightShadow || 3 !== this.type || (h4.map = new we(r2.x, r2.y), h4.map.texture.name = l4.name + ".shadowMap", h4.mapPass = new we(r2.x, r2.y), h4.camera.updateProjectionMatrix()), null === h4.map) {
              const e3 = { minFilter: u, magFilter: u, format: b };
              h4.map = new we(r2.x, r2.y, e3), h4.map.texture.name = l4.name + ".shadowMap", h4.camera.updateProjectionMatrix();
            }
            e2.setRenderTarget(h4.map), e2.clear();
            const f4 = h4.getViewportCount();
            for (let e3 = 0; e3 < f4; e3++) {
              const t4 = h4.getViewport(e3);
              a2.set(s2.x * t4.x, s2.y * t4.y, s2.x * t4.z, s2.y * t4.w), p3.viewport(a2), h4.updateMatrices(l4, e3), n2 = h4.getFrustum(), y2(i3, o3, h4.camera, l4, this.type);
            }
            h4.isPointLightShadow || 3 !== this.type || v2(h4, o3), h4.needsUpdate = false;
          }
          _2.needsUpdate = false, e2.setRenderTarget(l3, h3, d3);
        };
      }
      function ms(e2, t2, r2) {
        const s2 = r2.isWebGL2;
        const a2 = new function() {
          let t3 = false;
          const i2 = new Se();
          let n2 = null;
          const r3 = new Se(0, 0, 0, 0);
          return { setMask: function(i3) {
            n2 === i3 || t3 || (e2.colorMask(i3, i3, i3, i3), n2 = i3);
          }, setLocked: function(e3) {
            t3 = e3;
          }, setClear: function(t4, n3, s3, a3, o3) {
            true === o3 && (t4 *= a3, n3 *= a3, s3 *= a3), i2.set(t4, n3, s3, a3), false === r3.equals(i2) && (e2.clearColor(t4, n3, s3, a3), r3.copy(i2));
          }, reset: function() {
            t3 = false, n2 = null, r3.set(-1, 0, 0, 0);
          } };
        }(), o2 = new function() {
          let t3 = false, i2 = null, n2 = null, r3 = null;
          return { setTest: function(e3) {
            e3 ? B2(2929) : V2(2929);
          }, setMask: function(n3) {
            i2 === n3 || t3 || (e2.depthMask(n3), i2 = n3);
          }, setFunc: function(t4) {
            if (n2 !== t4) {
              if (t4)
                switch (t4) {
                  case 0:
                    e2.depthFunc(512);
                    break;
                  case 1:
                    e2.depthFunc(519);
                    break;
                  case 2:
                    e2.depthFunc(513);
                    break;
                  case 3:
                  default:
                    e2.depthFunc(515);
                    break;
                  case 4:
                    e2.depthFunc(514);
                    break;
                  case 5:
                    e2.depthFunc(518);
                    break;
                  case 6:
                    e2.depthFunc(516);
                    break;
                  case 7:
                    e2.depthFunc(517);
                }
              else
                e2.depthFunc(515);
              n2 = t4;
            }
          }, setLocked: function(e3) {
            t3 = e3;
          }, setClear: function(t4) {
            r3 !== t4 && (e2.clearDepth(t4), r3 = t4);
          }, reset: function() {
            t3 = false, i2 = null, n2 = null, r3 = null;
          } };
        }(), l2 = new function() {
          let t3 = false, i2 = null, n2 = null, r3 = null, s3 = null, a3 = null, o3 = null, l3 = null, h3 = null;
          return { setTest: function(e3) {
            t3 || (e3 ? B2(2960) : V2(2960));
          }, setMask: function(n3) {
            i2 === n3 || t3 || (e2.stencilMask(n3), i2 = n3);
          }, setFunc: function(t4, i3, a4) {
            n2 === t4 && r3 === i3 && s3 === a4 || (e2.stencilFunc(t4, i3, a4), n2 = t4, r3 = i3, s3 = a4);
          }, setOp: function(t4, i3, n3) {
            a3 === t4 && o3 === i3 && l3 === n3 || (e2.stencilOp(t4, i3, n3), a3 = t4, o3 = i3, l3 = n3);
          }, setLocked: function(e3) {
            t3 = e3;
          }, setClear: function(t4) {
            h3 !== t4 && (e2.clearStencil(t4), h3 = t4);
          }, reset: function() {
            t3 = false, i2 = null, n2 = null, r3 = null, s3 = null, a3 = null, o3 = null, l3 = null, h3 = null;
          } };
        }();
        let h2 = {}, c2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, m2 = false, f2 = null, g2 = null, _2 = null, v2 = null, x2 = null, y2 = null, b2 = null, M2 = false, S2 = null, w2 = null, T2 = null, E2 = null, C2 = null;
        const A2 = e2.getParameter(35661);
        let P2 = false, R2 = 0;
        const L2 = e2.getParameter(7938);
        -1 !== L2.indexOf("WebGL") ? (R2 = parseFloat(/^WebGL (\d)/.exec(L2)[1]), P2 = R2 >= 1) : -1 !== L2.indexOf("OpenGL ES") && (R2 = parseFloat(/^OpenGL ES (\d)/.exec(L2)[1]), P2 = R2 >= 2);
        let I2 = null, D2 = {};
        const F2 = e2.getParameter(3088), O2 = e2.getParameter(2978), U2 = new Se().fromArray(F2), z2 = new Se().fromArray(O2);
        function N2(t3, i2, n2) {
          const r3 = new Uint8Array(4), s3 = e2.createTexture();
          e2.bindTexture(t3, s3), e2.texParameteri(t3, 10241, 9728), e2.texParameteri(t3, 10240, 9728);
          for (let a3 = 0; a3 < n2; a3++)
            e2.texImage2D(i2 + a3, 0, 6408, 1, 1, 0, 6408, 5121, r3);
          return s3;
        }
        const k2 = {};
        function B2(t3) {
          true !== h2[t3] && (e2.enable(t3), h2[t3] = true);
        }
        function V2(t3) {
          false !== h2[t3] && (e2.disable(t3), h2[t3] = false);
        }
        k2[3553] = N2(3553, 3553, 1), k2[34067] = N2(34067, 34069, 6), a2.setClear(0, 0, 0, 1), o2.setClear(1), l2.setClear(0), B2(2929), o2.setFunc(3), W2(false), X2(1), B2(2884), j2(0);
        const G2 = { [i]: 32774, 101: 32778, 102: 32779 };
        if (s2)
          G2[103] = 32775, G2[104] = 32776;
        else {
          const e3 = t2.get("EXT_blend_minmax");
          null !== e3 && (G2[103] = e3.MIN_EXT, G2[104] = e3.MAX_EXT);
        }
        const H2 = { 200: 0, [n]: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
        function j2(t3, n2, r3, s3, a3, o3, l3, h3) {
          if (0 !== t3) {
            if (false === m2 && (B2(3042), m2 = true), 5 === t3)
              a3 = a3 || n2, o3 = o3 || r3, l3 = l3 || s3, n2 === g2 && a3 === x2 || (e2.blendEquationSeparate(G2[n2], G2[a3]), g2 = n2, x2 = a3), r3 === _2 && s3 === v2 && o3 === y2 && l3 === b2 || (e2.blendFuncSeparate(H2[r3], H2[s3], H2[o3], H2[l3]), _2 = r3, v2 = s3, y2 = o3, b2 = l3), f2 = t3, M2 = null;
            else if (t3 !== f2 || h3 !== M2) {
              if (g2 === i && x2 === i || (e2.blendEquation(32774), g2 = i, x2 = i), h3)
                switch (t3) {
                  case 1:
                    e2.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case 2:
                    e2.blendFunc(1, 1);
                    break;
                  case 3:
                    e2.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    e2.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t3);
                }
              else
                switch (t3) {
                  case 1:
                    e2.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case 2:
                    e2.blendFunc(770, 1);
                    break;
                  case 3:
                    e2.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case 4:
                    e2.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t3);
                }
              _2 = null, v2 = null, y2 = null, b2 = null, f2 = t3, M2 = h3;
            }
          } else
            true === m2 && (V2(3042), m2 = false);
        }
        function W2(t3) {
          S2 !== t3 && (t3 ? e2.frontFace(2304) : e2.frontFace(2305), S2 = t3);
        }
        function X2(t3) {
          0 !== t3 ? (B2(2884), t3 !== w2 && (1 === t3 ? e2.cullFace(1029) : 2 === t3 ? e2.cullFace(1028) : e2.cullFace(1032))) : V2(2884), w2 = t3;
        }
        function q2(t3, i2, n2) {
          t3 ? (B2(32823), E2 === i2 && C2 === n2 || (e2.polygonOffset(i2, n2), E2 = i2, C2 = n2)) : V2(32823);
        }
        function Y2(t3) {
          void 0 === t3 && (t3 = 33984 + A2 - 1), I2 !== t3 && (e2.activeTexture(t3), I2 = t3);
        }
        return { buffers: { color: a2, depth: o2, stencil: l2 }, enable: B2, disable: V2, bindFramebuffer: function(t3, i2) {
          return c2[t3] !== i2 && (e2.bindFramebuffer(t3, i2), c2[t3] = i2, s2 && (36009 === t3 && (c2[36160] = i2), 36160 === t3 && (c2[36009] = i2)), true);
        }, drawBuffers: function(i2, n2) {
          let s3 = d2, a3 = false;
          if (i2)
            if (s3 = u2.get(n2), void 0 === s3 && (s3 = [], u2.set(n2, s3)), i2.isWebGLMultipleRenderTargets) {
              const e3 = i2.texture;
              if (s3.length !== e3.length || 36064 !== s3[0]) {
                for (let t3 = 0, i3 = e3.length; t3 < i3; t3++)
                  s3[t3] = 36064 + t3;
                s3.length = e3.length, a3 = true;
              }
            } else
              36064 !== s3[0] && (s3[0] = 36064, a3 = true);
          else
            1029 !== s3[0] && (s3[0] = 1029, a3 = true);
          a3 && (r2.isWebGL2 ? e2.drawBuffers(s3) : t2.get("WEBGL_draw_buffers").drawBuffersWEBGL(s3));
        }, useProgram: function(t3) {
          return p2 !== t3 && (e2.useProgram(t3), p2 = t3, true);
        }, setBlending: j2, setMaterial: function(e3, t3) {
          2 === e3.side ? V2(2884) : B2(2884);
          let i2 = 1 === e3.side;
          t3 && (i2 = !i2), W2(i2), 1 === e3.blending && false === e3.transparent ? j2(0) : j2(e3.blending, e3.blendEquation, e3.blendSrc, e3.blendDst, e3.blendEquationAlpha, e3.blendSrcAlpha, e3.blendDstAlpha, e3.premultipliedAlpha), o2.setFunc(e3.depthFunc), o2.setTest(e3.depthTest), o2.setMask(e3.depthWrite), a2.setMask(e3.colorWrite);
          const n2 = e3.stencilWrite;
          l2.setTest(n2), n2 && (l2.setMask(e3.stencilWriteMask), l2.setFunc(e3.stencilFunc, e3.stencilRef, e3.stencilFuncMask), l2.setOp(e3.stencilFail, e3.stencilZFail, e3.stencilZPass)), q2(e3.polygonOffset, e3.polygonOffsetFactor, e3.polygonOffsetUnits), true === e3.alphaToCoverage ? B2(32926) : V2(32926);
        }, setFlipSided: W2, setCullFace: X2, setLineWidth: function(t3) {
          t3 !== T2 && (P2 && e2.lineWidth(t3), T2 = t3);
        }, setPolygonOffset: q2, setScissorTest: function(e3) {
          e3 ? B2(3089) : V2(3089);
        }, activeTexture: Y2, bindTexture: function(t3, i2) {
          null === I2 && Y2();
          let n2 = D2[I2];
          void 0 === n2 && (n2 = { type: void 0, texture: void 0 }, D2[I2] = n2), n2.type === t3 && n2.texture === i2 || (e2.bindTexture(t3, i2 || k2[t3]), n2.type = t3, n2.texture = i2);
        }, unbindTexture: function() {
          const t3 = D2[I2];
          void 0 !== t3 && void 0 !== t3.type && (e2.bindTexture(t3.type, null), t3.type = void 0, t3.texture = void 0);
        }, compressedTexImage2D: function() {
          try {
            e2.compressedTexImage2D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage2D: function() {
          try {
            e2.texImage2D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage3D: function() {
          try {
            e2.texImage3D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texStorage2D: function() {
          try {
            e2.texStorage2D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texStorage3D: function() {
          try {
            e2.texStorage3D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texSubImage2D: function() {
          try {
            e2.texSubImage2D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texSubImage3D: function() {
          try {
            e2.texSubImage3D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, compressedTexSubImage2D: function() {
          try {
            e2.compressedTexSubImage2D.apply(e2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, scissor: function(t3) {
          false === U2.equals(t3) && (e2.scissor(t3.x, t3.y, t3.z, t3.w), U2.copy(t3));
        }, viewport: function(t3) {
          false === z2.equals(t3) && (e2.viewport(t3.x, t3.y, t3.z, t3.w), z2.copy(t3));
        }, reset: function() {
          e2.disable(3042), e2.disable(2884), e2.disable(2929), e2.disable(32823), e2.disable(3089), e2.disable(2960), e2.disable(32926), e2.blendEquation(32774), e2.blendFunc(1, 0), e2.blendFuncSeparate(1, 0, 1, 0), e2.colorMask(true, true, true, true), e2.clearColor(0, 0, 0, 0), e2.depthMask(true), e2.depthFunc(513), e2.clearDepth(1), e2.stencilMask(4294967295), e2.stencilFunc(519, 0, 4294967295), e2.stencilOp(7680, 7680, 7680), e2.clearStencil(0), e2.cullFace(1029), e2.frontFace(2305), e2.polygonOffset(0, 0), e2.activeTexture(33984), e2.bindFramebuffer(36160, null), true === s2 && (e2.bindFramebuffer(36009, null), e2.bindFramebuffer(36008, null)), e2.useProgram(null), e2.lineWidth(1), e2.scissor(0, 0, e2.canvas.width, e2.canvas.height), e2.viewport(0, 0, e2.canvas.width, e2.canvas.height), h2 = {}, I2 = null, D2 = {}, c2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, m2 = false, f2 = null, g2 = null, _2 = null, v2 = null, x2 = null, y2 = null, b2 = null, M2 = false, S2 = null, w2 = null, T2 = null, E2 = null, C2 = null, U2.set(0, 0, e2.canvas.width, e2.canvas.height), z2.set(0, 0, e2.canvas.width, e2.canvas.height), a2.reset(), o2.reset(), l2.reset();
        } };
      }
      function fs(e2, t2, i2, n2, r2, s2, a2) {
        const o2 = r2.isWebGL2, w2 = r2.maxTextures, T2 = r2.maxCubemapSize, E2 = r2.maxTextureSize, C2 = r2.maxSamples, A2 = t2.has("WEBGL_multisampled_render_to_texture") ? t2.get("WEBGL_multisampled_render_to_texture") : null, P2 = /OculusBrowser/g.test(navigator.userAgent), R2 = /* @__PURE__ */ new WeakMap();
        let L2;
        const I2 = /* @__PURE__ */ new WeakMap();
        let D2 = false;
        try {
          D2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (ce2) {
        }
        function F2(e3, t3) {
          return D2 ? new OffscreenCanvas(e3, t3) : se("canvas");
        }
        function z2(e3, t3, i3, n3) {
          let r3 = 1;
          if ((e3.width > n3 || e3.height > n3) && (r3 = n3 / Math.max(e3.width, e3.height)), r3 < 1 || true === t3) {
            if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
              const n4 = t3 ? ee : Math.floor, s3 = n4(r3 * e3.width), a3 = n4(r3 * e3.height);
              void 0 === L2 && (L2 = F2(s3, a3));
              const o3 = i3 ? F2(s3, a3) : L2;
              o3.width = s3, o3.height = a3;
              return o3.getContext("2d").drawImage(e3, 0, 0, s3, a3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e3.width + "x" + e3.height + ") to (" + s3 + "x" + a3 + ")."), o3;
            }
            return "data" in e3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e3.width + "x" + e3.height + ")."), e3;
          }
          return e3;
        }
        function N2(e3) {
          return Q(e3.width) && Q(e3.height);
        }
        function k2(e3, t3) {
          return e3.generateMipmaps && t3 && e3.minFilter !== u && e3.minFilter !== m;
        }
        function B2(t3) {
          e2.generateMipmap(t3);
        }
        function V2(i3, n3, r3, s3, a3 = false) {
          if (false === o2)
            return n3;
          if (null !== i3) {
            if (void 0 !== e2[i3])
              return e2[i3];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i3 + "'");
          }
          let l2 = n3;
          return 6403 === n3 && (5126 === r3 && (l2 = 33326), 5131 === r3 && (l2 = 33325), 5121 === r3 && (l2 = 33321)), 33319 === n3 && (5126 === r3 && (l2 = 33328), 5131 === r3 && (l2 = 33327), 5121 === r3 && (l2 = 33323)), 6408 === n3 && (5126 === r3 && (l2 = 34836), 5131 === r3 && (l2 = 34842), 5121 === r3 && (l2 = s3 === U && false === a3 ? 35907 : 32856), 32819 === r3 && (l2 = 32854), 32820 === r3 && (l2 = 32855)), 33325 !== l2 && 33326 !== l2 && 33327 !== l2 && 33328 !== l2 && 34842 !== l2 && 34836 !== l2 || t2.get("EXT_color_buffer_float"), l2;
        }
        function H2(e3, t3, i3) {
          return true === k2(e3, i3) || e3.isFramebufferTexture && e3.minFilter !== u && e3.minFilter !== m ? Math.log2(Math.max(t3.width, t3.height)) + 1 : void 0 !== e3.mipmaps && e3.mipmaps.length > 0 ? e3.mipmaps.length : e3.isCompressedTexture && Array.isArray(e3.image) ? t3.mipmaps.length : 1;
        }
        function j2(e3) {
          return e3 === u || e3 === d || e3 === p ? 9728 : 9729;
        }
        function W2(e3) {
          const t3 = e3.target;
          t3.removeEventListener("dispose", W2), function(e4) {
            const t4 = n2.get(e4);
            if (void 0 === t4.__webglInit)
              return;
            const i3 = e4.source, r3 = I2.get(i3);
            if (r3) {
              const n3 = r3[t4.__cacheKey];
              n3.usedTimes--, 0 === n3.usedTimes && q2(e4), 0 === Object.keys(r3).length && I2.delete(i3);
            }
            n2.remove(e4);
          }(t3), t3.isVideoTexture && R2.delete(t3);
        }
        function X2(t3) {
          const i3 = t3.target;
          i3.removeEventListener("dispose", X2), function(t4) {
            const i4 = t4.texture, r3 = n2.get(t4), s3 = n2.get(i4);
            void 0 !== s3.__webglTexture && (e2.deleteTexture(s3.__webglTexture), a2.memory.textures--);
            t4.depthTexture && t4.depthTexture.dispose();
            if (t4.isWebGLCubeRenderTarget)
              for (let n3 = 0; n3 < 6; n3++)
                e2.deleteFramebuffer(r3.__webglFramebuffer[n3]), r3.__webglDepthbuffer && e2.deleteRenderbuffer(r3.__webglDepthbuffer[n3]);
            else {
              if (e2.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && e2.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && e2.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer)
                for (let t5 = 0; t5 < r3.__webglColorRenderbuffer.length; t5++)
                  r3.__webglColorRenderbuffer[t5] && e2.deleteRenderbuffer(r3.__webglColorRenderbuffer[t5]);
              r3.__webglDepthRenderbuffer && e2.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
            }
            if (t4.isWebGLMultipleRenderTargets)
              for (let o3 = 0, l2 = i4.length; o3 < l2; o3++) {
                const t5 = n2.get(i4[o3]);
                t5.__webglTexture && (e2.deleteTexture(t5.__webglTexture), a2.memory.textures--), n2.remove(i4[o3]);
              }
            n2.remove(i4), n2.remove(t4);
          }(i3);
        }
        function q2(t3) {
          const i3 = n2.get(t3);
          e2.deleteTexture(i3.__webglTexture);
          const r3 = t3.source;
          delete I2.get(r3)[i3.__cacheKey], a2.memory.textures--;
        }
        let Y2 = 0;
        function Z2(e3, t3) {
          const r3 = n2.get(e3);
          if (e3.isVideoTexture && function(e4) {
            const t4 = a2.render.frame;
            R2.get(e4) !== t4 && (R2.set(e4, t4), e4.update());
          }(e3), false === e3.isRenderTargetTexture && e3.version > 0 && r3.__version !== e3.version) {
            const i3 = e3.image;
            if (null === i3)
              console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else {
              if (false !== i3.complete)
                return void ie2(r3, e3, t3);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          i2.activeTexture(33984 + t3), i2.bindTexture(3553, r3.__webglTexture);
        }
        const J2 = { [l]: 10497, [h]: 33071, [c]: 33648 }, K2 = { [u]: 9728, [d]: 9984, [p]: 9986, [m]: 9729, 1007: 9985, [f]: 9987 };
        function $2(i3, s3, a3) {
          if (a3 ? (e2.texParameteri(i3, 10242, J2[s3.wrapS]), e2.texParameteri(i3, 10243, J2[s3.wrapT]), 32879 !== i3 && 35866 !== i3 || e2.texParameteri(i3, 32882, J2[s3.wrapR]), e2.texParameteri(i3, 10240, K2[s3.magFilter]), e2.texParameteri(i3, 10241, K2[s3.minFilter])) : (e2.texParameteri(i3, 10242, 33071), e2.texParameteri(i3, 10243, 33071), 32879 !== i3 && 35866 !== i3 || e2.texParameteri(i3, 32882, 33071), s3.wrapS === h && s3.wrapT === h || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e2.texParameteri(i3, 10240, j2(s3.magFilter)), e2.texParameteri(i3, 10241, j2(s3.minFilter)), s3.minFilter !== u && s3.minFilter !== m && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === t2.has("EXT_texture_filter_anisotropic")) {
            const a4 = t2.get("EXT_texture_filter_anisotropic");
            if (s3.type === v && false === t2.has("OES_texture_float_linear"))
              return;
            if (false === o2 && s3.type === x && false === t2.has("OES_texture_half_float_linear"))
              return;
            (s3.anisotropy > 1 || n2.get(s3).__currentAnisotropy) && (e2.texParameterf(i3, a4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, r2.getMaxAnisotropy())), n2.get(s3).__currentAnisotropy = s3.anisotropy);
          }
        }
        function te2(t3, i3) {
          let n3 = false;
          void 0 === t3.__webglInit && (t3.__webglInit = true, i3.addEventListener("dispose", W2));
          const r3 = i3.source;
          let s3 = I2.get(r3);
          void 0 === s3 && (s3 = {}, I2.set(r3, s3));
          const o3 = function(e3) {
            const t4 = [];
            return t4.push(e3.wrapS), t4.push(e3.wrapT), t4.push(e3.magFilter), t4.push(e3.minFilter), t4.push(e3.anisotropy), t4.push(e3.internalFormat), t4.push(e3.format), t4.push(e3.type), t4.push(e3.generateMipmaps), t4.push(e3.premultiplyAlpha), t4.push(e3.flipY), t4.push(e3.unpackAlignment), t4.push(e3.encoding), t4.join();
          }(i3);
          if (o3 !== t3.__cacheKey) {
            void 0 === s3[o3] && (s3[o3] = { texture: e2.createTexture(), usedTimes: 0 }, a2.memory.textures++, n3 = true), s3[o3].usedTimes++;
            const r4 = s3[t3.__cacheKey];
            void 0 !== r4 && (s3[t3.__cacheKey].usedTimes--, 0 === r4.usedTimes && q2(i3)), t3.__cacheKey = o3, t3.__webglTexture = s3[o3].texture;
          }
          return n3;
        }
        function ie2(t3, n3, r3) {
          let a3 = 3553;
          n3.isDataArrayTexture && (a3 = 35866), n3.isData3DTexture && (a3 = 32879);
          const l2 = te2(t3, n3), c2 = n3.source;
          if (i2.activeTexture(33984 + r3), i2.bindTexture(a3, t3.__webglTexture), c2.version !== c2.__currentVersion || true === l2) {
            e2.pixelStorei(37440, n3.flipY), e2.pixelStorei(37441, n3.premultiplyAlpha), e2.pixelStorei(3317, n3.unpackAlignment), e2.pixelStorei(37443, 0);
            const t4 = function(e3) {
              return !o2 && (e3.wrapS !== h || e3.wrapT !== h || e3.minFilter !== u && e3.minFilter !== m);
            }(n3) && false === N2(n3.image);
            let r4 = z2(n3.image, t4, false, E2);
            r4 = he2(n3, r4);
            const d2 = N2(r4) || o2, p2 = s2.convert(n3.format, n3.encoding);
            let f2, g2 = s2.convert(n3.type), x2 = V2(n3.internalFormat, p2, g2, n3.encoding, n3.isVideoTexture);
            $2(a3, n3, d2);
            const w3 = n3.mipmaps, T3 = o2 && true !== n3.isVideoTexture, C3 = void 0 === c2.__currentVersion || true === l2, A3 = H2(n3, r4, d2);
            if (n3.isDepthTexture)
              x2 = 6402, o2 ? x2 = n3.type === v ? 36012 : n3.type === _ ? 33190 : n3.type === y ? 35056 : 33189 : n3.type === v && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n3.format === M && 6402 === x2 && 1012 !== n3.type && n3.type !== _ && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = _, g2 = s2.convert(n3.type)), n3.format === S && 6402 === x2 && (x2 = 34041, n3.type !== y && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = y, g2 = s2.convert(n3.type))), C3 && (T3 ? i2.texStorage2D(3553, 1, x2, r4.width, r4.height) : i2.texImage2D(3553, 0, x2, r4.width, r4.height, 0, p2, g2, null));
            else if (n3.isDataTexture)
              if (w3.length > 0 && d2) {
                T3 && C3 && i2.texStorage2D(3553, A3, x2, w3[0].width, w3[0].height);
                for (let e3 = 0, t5 = w3.length; e3 < t5; e3++)
                  f2 = w3[e3], T3 ? i2.texSubImage2D(3553, e3, 0, 0, f2.width, f2.height, p2, g2, f2.data) : i2.texImage2D(3553, e3, x2, f2.width, f2.height, 0, p2, g2, f2.data);
                n3.generateMipmaps = false;
              } else
                T3 ? (C3 && i2.texStorage2D(3553, A3, x2, r4.width, r4.height), i2.texSubImage2D(3553, 0, 0, 0, r4.width, r4.height, p2, g2, r4.data)) : i2.texImage2D(3553, 0, x2, r4.width, r4.height, 0, p2, g2, r4.data);
            else if (n3.isCompressedTexture) {
              T3 && C3 && i2.texStorage2D(3553, A3, x2, w3[0].width, w3[0].height);
              for (let e3 = 0, t5 = w3.length; e3 < t5; e3++)
                f2 = w3[e3], n3.format !== b ? null !== p2 ? T3 ? i2.compressedTexSubImage2D(3553, e3, 0, 0, f2.width, f2.height, p2, f2.data) : i2.compressedTexImage2D(3553, e3, x2, f2.width, f2.height, 0, f2.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : T3 ? i2.texSubImage2D(3553, e3, 0, 0, f2.width, f2.height, p2, g2, f2.data) : i2.texImage2D(3553, e3, x2, f2.width, f2.height, 0, p2, g2, f2.data);
            } else if (n3.isDataArrayTexture)
              T3 ? (C3 && i2.texStorage3D(35866, A3, x2, r4.width, r4.height, r4.depth), i2.texSubImage3D(35866, 0, 0, 0, 0, r4.width, r4.height, r4.depth, p2, g2, r4.data)) : i2.texImage3D(35866, 0, x2, r4.width, r4.height, r4.depth, 0, p2, g2, r4.data);
            else if (n3.isData3DTexture)
              T3 ? (C3 && i2.texStorage3D(32879, A3, x2, r4.width, r4.height, r4.depth), i2.texSubImage3D(32879, 0, 0, 0, 0, r4.width, r4.height, r4.depth, p2, g2, r4.data)) : i2.texImage3D(32879, 0, x2, r4.width, r4.height, r4.depth, 0, p2, g2, r4.data);
            else if (n3.isFramebufferTexture) {
              if (C3)
                if (T3)
                  i2.texStorage2D(3553, A3, x2, r4.width, r4.height);
                else {
                  let e3 = r4.width, t5 = r4.height;
                  for (let n4 = 0; n4 < A3; n4++)
                    i2.texImage2D(3553, n4, x2, e3, t5, 0, p2, g2, null), e3 >>= 1, t5 >>= 1;
                }
            } else if (w3.length > 0 && d2) {
              T3 && C3 && i2.texStorage2D(3553, A3, x2, w3[0].width, w3[0].height);
              for (let e3 = 0, t5 = w3.length; e3 < t5; e3++)
                f2 = w3[e3], T3 ? i2.texSubImage2D(3553, e3, 0, 0, p2, g2, f2) : i2.texImage2D(3553, e3, x2, p2, g2, f2);
              n3.generateMipmaps = false;
            } else
              T3 ? (C3 && i2.texStorage2D(3553, A3, x2, r4.width, r4.height), i2.texSubImage2D(3553, 0, 0, 0, p2, g2, r4)) : i2.texImage2D(3553, 0, x2, p2, g2, r4);
            k2(n3, d2) && B2(a3), c2.__currentVersion = c2.version, n3.onUpdate && n3.onUpdate(n3);
          }
          t3.__version = n3.version;
        }
        function ne2(t3, r3, a3, o3, l2) {
          const h2 = s2.convert(a3.format, a3.encoding), c2 = s2.convert(a3.type), u2 = V2(a3.internalFormat, h2, c2, a3.encoding);
          n2.get(r3).__hasExternalTextures || (32879 === l2 || 35866 === l2 ? i2.texImage3D(l2, 0, u2, r3.width, r3.height, r3.depth, 0, h2, c2, null) : i2.texImage2D(l2, 0, u2, r3.width, r3.height, 0, h2, c2, null)), i2.bindFramebuffer(36160, t3), le2(r3) ? A2.framebufferTexture2DMultisampleEXT(36160, o3, l2, n2.get(a3).__webglTexture, 0, oe2(r3)) : e2.framebufferTexture2D(36160, o3, l2, n2.get(a3).__webglTexture, 0), i2.bindFramebuffer(36160, null);
        }
        function re2(t3, i3, n3) {
          if (e2.bindRenderbuffer(36161, t3), i3.depthBuffer && !i3.stencilBuffer) {
            let r3 = 33189;
            if (n3 || le2(i3)) {
              const t4 = i3.depthTexture;
              t4 && t4.isDepthTexture && (t4.type === v ? r3 = 36012 : t4.type === _ && (r3 = 33190));
              const n4 = oe2(i3);
              le2(i3) ? A2.renderbufferStorageMultisampleEXT(36161, n4, r3, i3.width, i3.height) : e2.renderbufferStorageMultisample(36161, n4, r3, i3.width, i3.height);
            } else
              e2.renderbufferStorage(36161, r3, i3.width, i3.height);
            e2.framebufferRenderbuffer(36160, 36096, 36161, t3);
          } else if (i3.depthBuffer && i3.stencilBuffer) {
            const r3 = oe2(i3);
            n3 && false === le2(i3) ? e2.renderbufferStorageMultisample(36161, r3, 35056, i3.width, i3.height) : le2(i3) ? A2.renderbufferStorageMultisampleEXT(36161, r3, 35056, i3.width, i3.height) : e2.renderbufferStorage(36161, 34041, i3.width, i3.height), e2.framebufferRenderbuffer(36160, 33306, 36161, t3);
          } else {
            const t4 = true === i3.isWebGLMultipleRenderTargets ? i3.texture : [i3.texture];
            for (let r3 = 0; r3 < t4.length; r3++) {
              const a3 = t4[r3], o3 = s2.convert(a3.format, a3.encoding), l2 = s2.convert(a3.type), h2 = V2(a3.internalFormat, o3, l2, a3.encoding), c2 = oe2(i3);
              n3 && false === le2(i3) ? e2.renderbufferStorageMultisample(36161, c2, h2, i3.width, i3.height) : le2(i3) ? A2.renderbufferStorageMultisampleEXT(36161, c2, h2, i3.width, i3.height) : e2.renderbufferStorage(36161, h2, i3.width, i3.height);
            }
          }
          e2.bindRenderbuffer(36161, null);
        }
        function ae2(t3) {
          const r3 = n2.get(t3), s3 = true === t3.isWebGLCubeRenderTarget;
          if (t3.depthTexture && !r3.__autoAllocateDepthBuffer) {
            if (s3)
              throw new Error("target.depthTexture not supported in Cube render targets");
            !function(t4, r4) {
              if (r4 && r4.isWebGLCubeRenderTarget)
                throw new Error("Depth Texture with cube render targets is not supported");
              if (i2.bindFramebuffer(36160, t4), !r4.depthTexture || !r4.depthTexture.isDepthTexture)
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              n2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), Z2(r4.depthTexture, 0);
              const s4 = n2.get(r4.depthTexture).__webglTexture, a3 = oe2(r4);
              if (r4.depthTexture.format === M)
                le2(r4) ? A2.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s4, 0, a3) : e2.framebufferTexture2D(36160, 36096, 3553, s4, 0);
              else {
                if (r4.depthTexture.format !== S)
                  throw new Error("Unknown depthTexture format");
                le2(r4) ? A2.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s4, 0, a3) : e2.framebufferTexture2D(36160, 33306, 3553, s4, 0);
              }
            }(r3.__webglFramebuffer, t3);
          } else if (s3) {
            r3.__webglDepthbuffer = [];
            for (let n3 = 0; n3 < 6; n3++)
              i2.bindFramebuffer(36160, r3.__webglFramebuffer[n3]), r3.__webglDepthbuffer[n3] = e2.createRenderbuffer(), re2(r3.__webglDepthbuffer[n3], t3, false);
          } else
            i2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = e2.createRenderbuffer(), re2(r3.__webglDepthbuffer, t3, false);
          i2.bindFramebuffer(36160, null);
        }
        function oe2(e3) {
          return Math.min(C2, e3.samples);
        }
        function le2(e3) {
          const i3 = n2.get(e3);
          return o2 && e3.samples > 0 && true === t2.has("WEBGL_multisampled_render_to_texture") && false !== i3.__useRenderToTexture;
        }
        function he2(e3, i3) {
          const n3 = e3.encoding, r3 = e3.format, s3 = e3.type;
          return true === e3.isCompressedTexture || true === e3.isVideoTexture || e3.format === G || n3 !== O && (n3 === U ? false === o2 ? true === t2.has("EXT_sRGB") && r3 === b ? (e3.format = G, e3.minFilter = m, e3.generateMipmaps = false) : i3 = ve.sRGBToLinear(i3) : r3 === b && s3 === g || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n3)), i3;
        }
        this.allocateTextureUnit = function() {
          const e3 = Y2;
          return e3 >= w2 && console.warn("THREE.WebGLTextures: Trying to use " + e3 + " texture units while this GPU supports only " + w2), Y2 += 1, e3;
        }, this.resetTextureUnits = function() {
          Y2 = 0;
        }, this.setTexture2D = Z2, this.setTexture2DArray = function(e3, t3) {
          const r3 = n2.get(e3);
          e3.version > 0 && r3.__version !== e3.version ? ie2(r3, e3, t3) : (i2.activeTexture(33984 + t3), i2.bindTexture(35866, r3.__webglTexture));
        }, this.setTexture3D = function(e3, t3) {
          const r3 = n2.get(e3);
          e3.version > 0 && r3.__version !== e3.version ? ie2(r3, e3, t3) : (i2.activeTexture(33984 + t3), i2.bindTexture(32879, r3.__webglTexture));
        }, this.setTextureCube = function(t3, r3) {
          const a3 = n2.get(t3);
          t3.version > 0 && a3.__version !== t3.version ? function(t4, n3, r4) {
            if (6 !== n3.image.length)
              return;
            const a4 = te2(t4, n3), l2 = n3.source;
            if (i2.activeTexture(33984 + r4), i2.bindTexture(34067, t4.__webglTexture), l2.version !== l2.__currentVersion || true === a4) {
              e2.pixelStorei(37440, n3.flipY), e2.pixelStorei(37441, n3.premultiplyAlpha), e2.pixelStorei(3317, n3.unpackAlignment), e2.pixelStorei(37443, 0);
              const t5 = n3.isCompressedTexture || n3.image[0].isCompressedTexture, r5 = n3.image[0] && n3.image[0].isDataTexture, h2 = [];
              for (let e3 = 0; e3 < 6; e3++)
                h2[e3] = t5 || r5 ? r5 ? n3.image[e3].image : n3.image[e3] : z2(n3.image[e3], false, true, T2), h2[e3] = he2(n3, h2[e3]);
              const c2 = h2[0], u2 = N2(c2) || o2, d2 = s2.convert(n3.format, n3.encoding), p2 = s2.convert(n3.type), m2 = V2(n3.internalFormat, d2, p2, n3.encoding), f2 = o2 && true !== n3.isVideoTexture, g2 = void 0 === l2.__currentVersion || true === a4;
              let _2, v2 = H2(n3, c2, u2);
              if ($2(34067, n3, u2), t5) {
                f2 && g2 && i2.texStorage2D(34067, v2, m2, c2.width, c2.height);
                for (let e3 = 0; e3 < 6; e3++) {
                  _2 = h2[e3].mipmaps;
                  for (let t6 = 0; t6 < _2.length; t6++) {
                    const r6 = _2[t6];
                    n3.format !== b ? null !== d2 ? f2 ? i2.compressedTexSubImage2D(34069 + e3, t6, 0, 0, r6.width, r6.height, d2, r6.data) : i2.compressedTexImage2D(34069 + e3, t6, m2, r6.width, r6.height, 0, r6.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : f2 ? i2.texSubImage2D(34069 + e3, t6, 0, 0, r6.width, r6.height, d2, p2, r6.data) : i2.texImage2D(34069 + e3, t6, m2, r6.width, r6.height, 0, d2, p2, r6.data);
                  }
                }
              } else {
                _2 = n3.mipmaps, f2 && g2 && (_2.length > 0 && v2++, i2.texStorage2D(34067, v2, m2, h2[0].width, h2[0].height));
                for (let e3 = 0; e3 < 6; e3++)
                  if (r5) {
                    f2 ? i2.texSubImage2D(34069 + e3, 0, 0, 0, h2[e3].width, h2[e3].height, d2, p2, h2[e3].data) : i2.texImage2D(34069 + e3, 0, m2, h2[e3].width, h2[e3].height, 0, d2, p2, h2[e3].data);
                    for (let t6 = 0; t6 < _2.length; t6++) {
                      const n4 = _2[t6].image[e3].image;
                      f2 ? i2.texSubImage2D(34069 + e3, t6 + 1, 0, 0, n4.width, n4.height, d2, p2, n4.data) : i2.texImage2D(34069 + e3, t6 + 1, m2, n4.width, n4.height, 0, d2, p2, n4.data);
                    }
                  } else {
                    f2 ? i2.texSubImage2D(34069 + e3, 0, 0, 0, d2, p2, h2[e3]) : i2.texImage2D(34069 + e3, 0, m2, d2, p2, h2[e3]);
                    for (let t6 = 0; t6 < _2.length; t6++) {
                      const n4 = _2[t6];
                      f2 ? i2.texSubImage2D(34069 + e3, t6 + 1, 0, 0, d2, p2, n4.image[e3]) : i2.texImage2D(34069 + e3, t6 + 1, m2, d2, p2, n4.image[e3]);
                    }
                  }
              }
              k2(n3, u2) && B2(34067), l2.__currentVersion = l2.version, n3.onUpdate && n3.onUpdate(n3);
            }
            t4.__version = n3.version;
          }(a3, t3, r3) : (i2.activeTexture(33984 + r3), i2.bindTexture(34067, a3.__webglTexture));
        }, this.rebindTextures = function(e3, t3, i3) {
          const r3 = n2.get(e3);
          void 0 !== t3 && ne2(r3.__webglFramebuffer, e3, e3.texture, 36064, 3553), void 0 !== i3 && ae2(e3);
        }, this.setupRenderTarget = function(t3) {
          const l2 = t3.texture, h2 = n2.get(t3), c2 = n2.get(l2);
          t3.addEventListener("dispose", X2), true !== t3.isWebGLMultipleRenderTargets && (void 0 === c2.__webglTexture && (c2.__webglTexture = e2.createTexture()), c2.__version = l2.version, a2.memory.textures++);
          const u2 = true === t3.isWebGLCubeRenderTarget, d2 = true === t3.isWebGLMultipleRenderTargets, p2 = N2(t3) || o2;
          if (u2) {
            h2.__webglFramebuffer = [];
            for (let t4 = 0; t4 < 6; t4++)
              h2.__webglFramebuffer[t4] = e2.createFramebuffer();
          } else {
            if (h2.__webglFramebuffer = e2.createFramebuffer(), d2)
              if (r2.drawBuffers) {
                const i3 = t3.texture;
                for (let t4 = 0, r3 = i3.length; t4 < r3; t4++) {
                  const r4 = n2.get(i3[t4]);
                  void 0 === r4.__webglTexture && (r4.__webglTexture = e2.createTexture(), a2.memory.textures++);
                }
              } else
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (o2 && t3.samples > 0 && false === le2(t3)) {
              const n3 = d2 ? l2 : [l2];
              h2.__webglMultisampledFramebuffer = e2.createFramebuffer(), h2.__webglColorRenderbuffer = [], i2.bindFramebuffer(36160, h2.__webglMultisampledFramebuffer);
              for (let i3 = 0; i3 < n3.length; i3++) {
                const r3 = n3[i3];
                h2.__webglColorRenderbuffer[i3] = e2.createRenderbuffer(), e2.bindRenderbuffer(36161, h2.__webglColorRenderbuffer[i3]);
                const a3 = s2.convert(r3.format, r3.encoding), o3 = s2.convert(r3.type), l3 = V2(r3.internalFormat, a3, o3, r3.encoding), c3 = oe2(t3);
                e2.renderbufferStorageMultisample(36161, c3, l3, t3.width, t3.height), e2.framebufferRenderbuffer(36160, 36064 + i3, 36161, h2.__webglColorRenderbuffer[i3]);
              }
              e2.bindRenderbuffer(36161, null), t3.depthBuffer && (h2.__webglDepthRenderbuffer = e2.createRenderbuffer(), re2(h2.__webglDepthRenderbuffer, t3, true)), i2.bindFramebuffer(36160, null);
            }
          }
          if (u2) {
            i2.bindTexture(34067, c2.__webglTexture), $2(34067, l2, p2);
            for (let e3 = 0; e3 < 6; e3++)
              ne2(h2.__webglFramebuffer[e3], t3, l2, 36064, 34069 + e3);
            k2(l2, p2) && B2(34067), i2.unbindTexture();
          } else if (d2) {
            const e3 = t3.texture;
            for (let r3 = 0, s3 = e3.length; r3 < s3; r3++) {
              const s4 = e3[r3], a3 = n2.get(s4);
              i2.bindTexture(3553, a3.__webglTexture), $2(3553, s4, p2), ne2(h2.__webglFramebuffer, t3, s4, 36064 + r3, 3553), k2(s4, p2) && B2(3553);
            }
            i2.unbindTexture();
          } else {
            let e3 = 3553;
            (t3.isWebGL3DRenderTarget || t3.isWebGLArrayRenderTarget) && (o2 ? e3 = t3.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), i2.bindTexture(e3, c2.__webglTexture), $2(e3, l2, p2), ne2(h2.__webglFramebuffer, t3, l2, 36064, e3), k2(l2, p2) && B2(e3), i2.unbindTexture();
          }
          t3.depthBuffer && ae2(t3);
        }, this.updateRenderTargetMipmap = function(e3) {
          const t3 = N2(e3) || o2, r3 = true === e3.isWebGLMultipleRenderTargets ? e3.texture : [e3.texture];
          for (let s3 = 0, a3 = r3.length; s3 < a3; s3++) {
            const a4 = r3[s3];
            if (k2(a4, t3)) {
              const t4 = e3.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = n2.get(a4).__webglTexture;
              i2.bindTexture(t4, r4), B2(t4), i2.unbindTexture();
            }
          }
        }, this.updateMultisampleRenderTarget = function(t3) {
          if (o2 && t3.samples > 0 && false === le2(t3)) {
            const r3 = t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture], s3 = t3.width, a3 = t3.height;
            let o3 = 16384;
            const l2 = [], h2 = t3.stencilBuffer ? 33306 : 36096, c2 = n2.get(t3), u2 = true === t3.isWebGLMultipleRenderTargets;
            if (u2)
              for (let t4 = 0; t4 < r3.length; t4++)
                i2.bindFramebuffer(36160, c2.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(36160, 36064 + t4, 36161, null), i2.bindFramebuffer(36160, c2.__webglFramebuffer), e2.framebufferTexture2D(36009, 36064 + t4, 3553, null, 0);
            i2.bindFramebuffer(36008, c2.__webglMultisampledFramebuffer), i2.bindFramebuffer(36009, c2.__webglFramebuffer);
            for (let i3 = 0; i3 < r3.length; i3++) {
              l2.push(36064 + i3), t3.depthBuffer && l2.push(h2);
              const d2 = void 0 !== c2.__ignoreDepthValues && c2.__ignoreDepthValues;
              if (false === d2 && (t3.depthBuffer && (o3 |= 256), t3.stencilBuffer && (o3 |= 1024)), u2 && e2.framebufferRenderbuffer(36008, 36064, 36161, c2.__webglColorRenderbuffer[i3]), true === d2 && (e2.invalidateFramebuffer(36008, [h2]), e2.invalidateFramebuffer(36009, [h2])), u2) {
                const t4 = n2.get(r3[i3]).__webglTexture;
                e2.framebufferTexture2D(36009, 36064, 3553, t4, 0);
              }
              e2.blitFramebuffer(0, 0, s3, a3, 0, 0, s3, a3, o3, 9728), P2 && e2.invalidateFramebuffer(36008, l2);
            }
            if (i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, null), u2)
              for (let t4 = 0; t4 < r3.length; t4++) {
                i2.bindFramebuffer(36160, c2.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(36160, 36064 + t4, 36161, c2.__webglColorRenderbuffer[t4]);
                const s4 = n2.get(r3[t4]).__webglTexture;
                i2.bindFramebuffer(36160, c2.__webglFramebuffer), e2.framebufferTexture2D(36009, 36064 + t4, 3553, s4, 0);
              }
            i2.bindFramebuffer(36009, c2.__webglMultisampledFramebuffer);
          }
        }, this.setupDepthRenderbuffer = ae2, this.setupFrameBufferTexture = ne2, this.useMultisampledRTT = le2;
      }
      function gs(e2, t2, i2) {
        const n2 = i2.isWebGL2;
        return { convert: function(i3, r2 = null) {
          let s2;
          if (i3 === g)
            return 5121;
          if (1017 === i3)
            return 32819;
          if (1018 === i3)
            return 32820;
          if (1010 === i3)
            return 5120;
          if (1011 === i3)
            return 5122;
          if (1012 === i3)
            return 5123;
          if (1013 === i3)
            return 5124;
          if (i3 === _)
            return 5125;
          if (i3 === v)
            return 5126;
          if (i3 === x)
            return n2 ? 5131 : (s2 = t2.get("OES_texture_half_float"), null !== s2 ? s2.HALF_FLOAT_OES : null);
          if (1021 === i3)
            return 6406;
          if (i3 === b)
            return 6408;
          if (1024 === i3)
            return 6409;
          if (1025 === i3)
            return 6410;
          if (i3 === M)
            return 6402;
          if (i3 === S)
            return 34041;
          if (1028 === i3)
            return 6403;
          if (1022 === i3)
            return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
          if (i3 === G)
            return s2 = t2.get("EXT_sRGB"), null !== s2 ? s2.SRGB_ALPHA_EXT : null;
          if (1029 === i3)
            return 36244;
          if (1030 === i3)
            return 33319;
          if (1031 === i3)
            return 33320;
          if (1033 === i3)
            return 36249;
          if (i3 === w || i3 === T || i3 === E || i3 === C)
            if (r2 === U) {
              if (s2 = t2.get("WEBGL_compressed_texture_s3tc_srgb"), null === s2)
                return null;
              if (i3 === w)
                return s2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (i3 === T)
                return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (i3 === E)
                return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (i3 === C)
                return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (s2 = t2.get("WEBGL_compressed_texture_s3tc"), null === s2)
                return null;
              if (i3 === w)
                return s2.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (i3 === T)
                return s2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (i3 === E)
                return s2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (i3 === C)
                return s2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
          if (35840 === i3 || 35841 === i3 || 35842 === i3 || 35843 === i3) {
            if (s2 = t2.get("WEBGL_compressed_texture_pvrtc"), null === s2)
              return null;
            if (35840 === i3)
              return s2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === i3)
              return s2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === i3)
              return s2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === i3)
              return s2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === i3)
            return s2 = t2.get("WEBGL_compressed_texture_etc1"), null !== s2 ? s2.COMPRESSED_RGB_ETC1_WEBGL : null;
          if (37492 === i3 || 37496 === i3) {
            if (s2 = t2.get("WEBGL_compressed_texture_etc"), null === s2)
              return null;
            if (37492 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ETC2 : s2.COMPRESSED_RGB8_ETC2;
            if (37496 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s2.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (37808 === i3 || 37809 === i3 || 37810 === i3 || 37811 === i3 || 37812 === i3 || 37813 === i3 || 37814 === i3 || 37815 === i3 || 37816 === i3 || 37817 === i3 || 37818 === i3 || 37819 === i3 || 37820 === i3 || 37821 === i3) {
            if (s2 = t2.get("WEBGL_compressed_texture_astc"), null === s2)
              return null;
            if (37808 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s2.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (37809 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s2.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (37810 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s2.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (37811 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s2.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (37812 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s2.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (37813 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s2.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (37814 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s2.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (37815 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s2.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (37816 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s2.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (37817 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s2.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (37818 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s2.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (37819 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s2.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (37820 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s2.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (37821 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s2.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }
          if (36492 === i3) {
            if (s2 = t2.get("EXT_texture_compression_bptc"), null === s2)
              return null;
            if (36492 === i3)
              return r2 === U ? s2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }
          return i3 === y ? n2 ? 34042 : (s2 = t2.get("WEBGL_depth_texture"), null !== s2 ? s2.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e2[i3] ? e2[i3] : null;
        } };
      }
      class _s extends Ri {
        constructor(e2 = []) {
          super(), this.isArrayCamera = true, this.cameras = e2;
        }
      }
      class vs extends Rt {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      const xs = { type: "move" };
      class ys {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return null === this._hand && (this._hand = new vs(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
        }
        getTargetRaySpace() {
          return null === this._targetRay && (this._targetRay = new vs(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Ae(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Ae()), this._targetRay;
        }
        getGripSpace() {
          return null === this._grip && (this._grip = new vs(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Ae(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Ae()), this._grip;
        }
        dispatchEvent(e2) {
          return null !== this._targetRay && this._targetRay.dispatchEvent(e2), null !== this._grip && this._grip.dispatchEvent(e2), null !== this._hand && this._hand.dispatchEvent(e2), this;
        }
        disconnect(e2) {
          return this.dispatchEvent({ type: "disconnected", data: e2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
        }
        update(e2, t2, i2) {
          let n2 = null, r2 = null, s2 = null;
          const a2 = this._targetRay, o2 = this._grip, l2 = this._hand;
          if (e2 && "visible-blurred" !== t2.session.visibilityState)
            if (null !== a2 && (n2 = t2.getPose(e2.targetRaySpace, i2), null !== n2 && (a2.matrix.fromArray(n2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), n2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(n2.linearVelocity)) : a2.hasLinearVelocity = false, n2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(n2.angularVelocity)) : a2.hasAngularVelocity = false, this.dispatchEvent(xs))), l2 && e2.hand) {
              s2 = true;
              for (const s3 of e2.hand.values()) {
                const e3 = t2.getJointPose(s3, i2);
                if (void 0 === l2.joints[s3.jointName]) {
                  const e4 = new vs();
                  e4.matrixAutoUpdate = false, e4.visible = false, l2.joints[s3.jointName] = e4, l2.add(e4);
                }
                const n4 = l2.joints[s3.jointName];
                null !== e3 && (n4.matrix.fromArray(e3.transform.matrix), n4.matrix.decompose(n4.position, n4.rotation, n4.scale), n4.jointRadius = e3.radius), n4.visible = null !== e3;
              }
              const n3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], a3 = n3.position.distanceTo(r3.position), o3 = 0.02, h2 = 5e-3;
              l2.inputState.pinching && a3 > o3 + h2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e2.handedness, target: this })) : !l2.inputState.pinching && a3 <= o3 - h2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e2.handedness, target: this }));
            } else
              null !== o2 && e2.gripSpace && (r2 = t2.getPose(e2.gripSpace, i2), null !== r2 && (o2.matrix.fromArray(r2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), r2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(r2.linearVelocity)) : o2.hasLinearVelocity = false, r2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(r2.angularVelocity)) : o2.hasAngularVelocity = false));
          return null !== a2 && (a2.visible = null !== n2), null !== o2 && (o2.visible = null !== r2), null !== l2 && (l2.visible = null !== s2), this;
        }
      }
      class bs extends Me {
        constructor(e2, t2, i2, n2, r2, s2, a2, o2, l2, h2) {
          if ((h2 = void 0 !== h2 ? h2 : M) !== M && h2 !== S)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          void 0 === i2 && h2 === M && (i2 = _), void 0 === i2 && h2 === S && (i2 = y), super(null, n2, r2, s2, a2, o2, h2, i2, l2), this.isDepthTexture = true, this.image = { width: e2, height: t2 }, this.magFilter = void 0 !== a2 ? a2 : u, this.minFilter = void 0 !== o2 ? o2 : u, this.flipY = false, this.generateMipmaps = false;
        }
      }
      class Ms extends H {
        constructor(e2, t2) {
          super();
          const i2 = this;
          let n2 = null, r2 = 1, s2 = null, a2 = "local-floor", o2 = null, l2 = null, h2 = null, c2 = null, u2 = null, d2 = null;
          const p2 = t2.getContextAttributes();
          let m2 = null, f2 = null;
          const v2 = [], x2 = /* @__PURE__ */ new Map(), w2 = new Ri();
          w2.layers.enable(1), w2.viewport = new Se();
          const T2 = new Ri();
          T2.layers.enable(2), T2.viewport = new Se();
          const E2 = [w2, T2], C2 = new _s();
          C2.layers.enable(1), C2.layers.enable(2);
          let A2 = null, P2 = null;
          function R2(e3) {
            const t3 = x2.get(e3.inputSource);
            void 0 !== t3 && t3.dispatchEvent({ type: e3.type, data: e3.inputSource });
          }
          function L2() {
            n2.removeEventListener("select", R2), n2.removeEventListener("selectstart", R2), n2.removeEventListener("selectend", R2), n2.removeEventListener("squeeze", R2), n2.removeEventListener("squeezestart", R2), n2.removeEventListener("squeezeend", R2), n2.removeEventListener("end", L2), n2.removeEventListener("inputsourceschange", I2), x2.forEach(function(e3, t3) {
              void 0 !== e3 && e3.disconnect(t3);
            }), x2.clear(), A2 = null, P2 = null, e2.setRenderTarget(m2), u2 = null, c2 = null, h2 = null, n2 = null, f2 = null, N2.stop(), i2.isPresenting = false, i2.dispatchEvent({ type: "sessionend" });
          }
          function I2(e3) {
            const t3 = n2.inputSources;
            for (let i3 = 0; i3 < t3.length; i3++) {
              const e4 = "right" === t3[i3].handedness ? 1 : 0;
              x2.set(t3[i3], v2[e4]);
            }
            for (let i3 = 0; i3 < e3.removed.length; i3++) {
              const t4 = e3.removed[i3], n3 = x2.get(t4);
              n3 && (n3.dispatchEvent({ type: "disconnected", data: t4 }), x2.delete(t4));
            }
            for (let i3 = 0; i3 < e3.added.length; i3++) {
              const t4 = e3.added[i3], n3 = x2.get(t4);
              n3 && n3.dispatchEvent({ type: "connected", data: t4 });
            }
          }
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(e3) {
            let t3 = v2[e3];
            return void 0 === t3 && (t3 = new ys(), v2[e3] = t3), t3.getTargetRaySpace();
          }, this.getControllerGrip = function(e3) {
            let t3 = v2[e3];
            return void 0 === t3 && (t3 = new ys(), v2[e3] = t3), t3.getGripSpace();
          }, this.getHand = function(e3) {
            let t3 = v2[e3];
            return void 0 === t3 && (t3 = new ys(), v2[e3] = t3), t3.getHandSpace();
          }, this.setFramebufferScaleFactor = function(e3) {
            r2 = e3, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(e3) {
            a2 = e3, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return o2 || s2;
          }, this.setReferenceSpace = function(e3) {
            o2 = e3;
          }, this.getBaseLayer = function() {
            return null !== c2 ? c2 : u2;
          }, this.getBinding = function() {
            return h2;
          }, this.getFrame = function() {
            return d2;
          }, this.getSession = function() {
            return n2;
          }, this.setSession = async function(l3) {
            if (n2 = l3, null !== n2) {
              if (m2 = e2.getRenderTarget(), n2.addEventListener("select", R2), n2.addEventListener("selectstart", R2), n2.addEventListener("selectend", R2), n2.addEventListener("squeeze", R2), n2.addEventListener("squeezestart", R2), n2.addEventListener("squeezeend", R2), n2.addEventListener("end", L2), n2.addEventListener("inputsourceschange", I2), true !== p2.xrCompatible && await t2.makeXRCompatible(), void 0 === n2.renderState.layers || false === e2.capabilities.isWebGL2) {
                const i3 = { antialias: void 0 !== n2.renderState.layers || p2.antialias, alpha: p2.alpha, depth: p2.depth, stencil: p2.stencil, framebufferScaleFactor: r2 };
                u2 = new XRWebGLLayer(n2, t2, i3), n2.updateRenderState({ baseLayer: u2 }), f2 = new we(u2.framebufferWidth, u2.framebufferHeight, { format: b, type: g, encoding: e2.outputEncoding });
              } else {
                let i3 = null, s3 = null, a3 = null;
                p2.depth && (a3 = p2.stencil ? 35056 : 33190, i3 = p2.stencil ? S : M, s3 = p2.stencil ? y : _);
                const o3 = { colorFormat: e2.outputEncoding === U ? 35907 : 32856, depthFormat: a3, scaleFactor: r2 };
                h2 = new XRWebGLBinding(n2, t2), c2 = h2.createProjectionLayer(o3), n2.updateRenderState({ layers: [c2] }), f2 = new we(c2.textureWidth, c2.textureHeight, { format: b, type: g, depthTexture: new bs(c2.textureWidth, c2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, i3), stencilBuffer: p2.stencil, encoding: e2.outputEncoding, samples: p2.antialias ? 4 : 0 });
                e2.properties.get(f2).__ignoreDepthValues = c2.ignoreDepthValues;
              }
              f2.isXRRenderTarget = true, this.setFoveation(1), o2 = null, s2 = await n2.requestReferenceSpace(a2), N2.setContext(n2), N2.start(), i2.isPresenting = true, i2.dispatchEvent({ type: "sessionstart" });
            }
          };
          const D2 = new Ae(), F2 = new Ae();
          function O2(e3, t3) {
            null === t3 ? e3.matrixWorld.copy(e3.matrix) : e3.matrixWorld.multiplyMatrices(t3.matrixWorld, e3.matrix), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
          }
          this.updateCamera = function(e3) {
            if (null === n2)
              return;
            C2.near = T2.near = w2.near = e3.near, C2.far = T2.far = w2.far = e3.far, A2 === C2.near && P2 === C2.far || (n2.updateRenderState({ depthNear: C2.near, depthFar: C2.far }), A2 = C2.near, P2 = C2.far);
            const t3 = e3.parent, i3 = C2.cameras;
            O2(C2, t3);
            for (let n3 = 0; n3 < i3.length; n3++)
              O2(i3[n3], t3);
            C2.matrixWorld.decompose(C2.position, C2.quaternion, C2.scale), e3.position.copy(C2.position), e3.quaternion.copy(C2.quaternion), e3.scale.copy(C2.scale), e3.matrix.copy(C2.matrix), e3.matrixWorld.copy(C2.matrixWorld);
            const r3 = e3.children;
            for (let n3 = 0, s3 = r3.length; n3 < s3; n3++)
              r3[n3].updateMatrixWorld(true);
            2 === i3.length ? function(e4, t4, i4) {
              D2.setFromMatrixPosition(t4.matrixWorld), F2.setFromMatrixPosition(i4.matrixWorld);
              const n3 = D2.distanceTo(F2), r4 = t4.projectionMatrix.elements, s3 = i4.projectionMatrix.elements, a3 = r4[14] / (r4[10] - 1), o3 = r4[14] / (r4[10] + 1), l3 = (r4[9] + 1) / r4[5], h3 = (r4[9] - 1) / r4[5], c3 = (r4[8] - 1) / r4[0], u3 = (s3[8] + 1) / s3[0], d3 = a3 * c3, p3 = a3 * u3, m3 = n3 / (-c3 + u3), f3 = m3 * -c3;
              t4.matrixWorld.decompose(e4.position, e4.quaternion, e4.scale), e4.translateX(f3), e4.translateZ(m3), e4.matrixWorld.compose(e4.position, e4.quaternion, e4.scale), e4.matrixWorldInverse.copy(e4.matrixWorld).invert();
              const g2 = a3 + m3, _2 = o3 + m3, v3 = d3 - f3, x3 = p3 + (n3 - f3), y2 = l3 * o3 / _2 * g2, b2 = h3 * o3 / _2 * g2;
              e4.projectionMatrix.makePerspective(v3, x3, y2, b2, g2, _2);
            }(C2, w2, T2) : C2.projectionMatrix.copy(w2.projectionMatrix);
          }, this.getCamera = function() {
            return C2;
          }, this.getFoveation = function() {
            return null !== c2 ? c2.fixedFoveation : null !== u2 ? u2.fixedFoveation : void 0;
          }, this.setFoveation = function(e3) {
            null !== c2 && (c2.fixedFoveation = e3), null !== u2 && void 0 !== u2.fixedFoveation && (u2.fixedFoveation = e3);
          };
          let z2 = null;
          const N2 = new Gi();
          N2.setAnimationLoop(function(t3, i3) {
            if (l2 = i3.getViewerPose(o2 || s2), d2 = i3, null !== l2) {
              const t4 = l2.views;
              null !== u2 && (e2.setRenderTargetFramebuffer(f2, u2.framebuffer), e2.setRenderTarget(f2));
              let i4 = false;
              t4.length !== C2.cameras.length && (C2.cameras.length = 0, i4 = true);
              for (let n3 = 0; n3 < t4.length; n3++) {
                const r4 = t4[n3];
                let s3 = null;
                if (null !== u2)
                  s3 = u2.getViewport(r4);
                else {
                  const t5 = h2.getViewSubImage(c2, r4);
                  s3 = t5.viewport, 0 === n3 && (e2.setRenderTargetTextures(f2, t5.colorTexture, c2.ignoreDepthValues ? void 0 : t5.depthStencilTexture), e2.setRenderTarget(f2));
                }
                let a3 = E2[n3];
                void 0 === a3 && (a3 = new Ri(), a3.layers.enable(n3), a3.viewport = new Se(), E2[n3] = a3), a3.matrix.fromArray(r4.transform.matrix), a3.projectionMatrix.fromArray(r4.projectionMatrix), a3.viewport.set(s3.x, s3.y, s3.width, s3.height), 0 === n3 && C2.matrix.copy(a3.matrix), true === i4 && C2.cameras.push(a3);
              }
            }
            const r3 = n2.inputSources;
            for (let e3 = 0; e3 < v2.length; e3++) {
              const t4 = r3[e3], n3 = x2.get(t4);
              void 0 !== n3 && n3.update(t4, i3, o2 || s2);
            }
            z2 && z2(t3, i3), d2 = null;
          }), this.setAnimationLoop = function(e3) {
            z2 = e3;
          }, this.dispose = function() {
          };
        }
      }
      function Ss(e2, t2) {
        function i2(i3, n2) {
          i3.opacity.value = n2.opacity, n2.color && i3.diffuse.value.copy(n2.color), n2.emissive && i3.emissive.value.copy(n2.emissive).multiplyScalar(n2.emissiveIntensity), n2.map && (i3.map.value = n2.map), n2.alphaMap && (i3.alphaMap.value = n2.alphaMap), n2.bumpMap && (i3.bumpMap.value = n2.bumpMap, i3.bumpScale.value = n2.bumpScale, 1 === n2.side && (i3.bumpScale.value *= -1)), n2.displacementMap && (i3.displacementMap.value = n2.displacementMap, i3.displacementScale.value = n2.displacementScale, i3.displacementBias.value = n2.displacementBias), n2.emissiveMap && (i3.emissiveMap.value = n2.emissiveMap), n2.normalMap && (i3.normalMap.value = n2.normalMap, i3.normalScale.value.copy(n2.normalScale), 1 === n2.side && i3.normalScale.value.negate()), n2.specularMap && (i3.specularMap.value = n2.specularMap), n2.alphaTest > 0 && (i3.alphaTest.value = n2.alphaTest);
          const r2 = t2.get(n2).envMap;
          if (r2 && (i3.envMap.value = r2, i3.flipEnvMap.value = r2.isCubeTexture && false === r2.isRenderTargetTexture ? -1 : 1, i3.reflectivity.value = n2.reflectivity, i3.ior.value = n2.ior, i3.refractionRatio.value = n2.refractionRatio), n2.lightMap) {
            i3.lightMap.value = n2.lightMap;
            const t3 = true !== e2.physicallyCorrectLights ? Math.PI : 1;
            i3.lightMapIntensity.value = n2.lightMapIntensity * t3;
          }
          let s2, a2;
          n2.aoMap && (i3.aoMap.value = n2.aoMap, i3.aoMapIntensity.value = n2.aoMapIntensity), n2.map ? s2 = n2.map : n2.specularMap ? s2 = n2.specularMap : n2.displacementMap ? s2 = n2.displacementMap : n2.normalMap ? s2 = n2.normalMap : n2.bumpMap ? s2 = n2.bumpMap : n2.roughnessMap ? s2 = n2.roughnessMap : n2.metalnessMap ? s2 = n2.metalnessMap : n2.alphaMap ? s2 = n2.alphaMap : n2.emissiveMap ? s2 = n2.emissiveMap : n2.clearcoatMap ? s2 = n2.clearcoatMap : n2.clearcoatNormalMap ? s2 = n2.clearcoatNormalMap : n2.clearcoatRoughnessMap ? s2 = n2.clearcoatRoughnessMap : n2.iridescenceMap ? s2 = n2.iridescenceMap : n2.iridescenceThicknessMap ? s2 = n2.iridescenceThicknessMap : n2.specularIntensityMap ? s2 = n2.specularIntensityMap : n2.specularColorMap ? s2 = n2.specularColorMap : n2.transmissionMap ? s2 = n2.transmissionMap : n2.thicknessMap ? s2 = n2.thicknessMap : n2.sheenColorMap ? s2 = n2.sheenColorMap : n2.sheenRoughnessMap && (s2 = n2.sheenRoughnessMap), void 0 !== s2 && (s2.isWebGLRenderTarget && (s2 = s2.texture), true === s2.matrixAutoUpdate && s2.updateMatrix(), i3.uvTransform.value.copy(s2.matrix)), n2.aoMap ? a2 = n2.aoMap : n2.lightMap && (a2 = n2.lightMap), void 0 !== a2 && (a2.isWebGLRenderTarget && (a2 = a2.texture), true === a2.matrixAutoUpdate && a2.updateMatrix(), i3.uv2Transform.value.copy(a2.matrix));
        }
        return { refreshFogUniforms: function(e3, t3) {
          e3.fogColor.value.copy(t3.color), t3.isFog ? (e3.fogNear.value = t3.near, e3.fogFar.value = t3.far) : t3.isFogExp2 && (e3.fogDensity.value = t3.density);
        }, refreshMaterialUniforms: function(e3, n2, r2, s2, a2) {
          n2.isMeshBasicMaterial || n2.isMeshLambertMaterial ? i2(e3, n2) : n2.isMeshToonMaterial ? (i2(e3, n2), function(e4, t3) {
            t3.gradientMap && (e4.gradientMap.value = t3.gradientMap);
          }(e3, n2)) : n2.isMeshPhongMaterial ? (i2(e3, n2), function(e4, t3) {
            e4.specular.value.copy(t3.specular), e4.shininess.value = Math.max(t3.shininess, 1e-4);
          }(e3, n2)) : n2.isMeshStandardMaterial ? (i2(e3, n2), function(e4, i3) {
            e4.roughness.value = i3.roughness, e4.metalness.value = i3.metalness, i3.roughnessMap && (e4.roughnessMap.value = i3.roughnessMap);
            i3.metalnessMap && (e4.metalnessMap.value = i3.metalnessMap);
            t2.get(i3).envMap && (e4.envMapIntensity.value = i3.envMapIntensity);
          }(e3, n2), n2.isMeshPhysicalMaterial && function(e4, t3, i3) {
            e4.ior.value = t3.ior, t3.sheen > 0 && (e4.sheenColor.value.copy(t3.sheenColor).multiplyScalar(t3.sheen), e4.sheenRoughness.value = t3.sheenRoughness, t3.sheenColorMap && (e4.sheenColorMap.value = t3.sheenColorMap), t3.sheenRoughnessMap && (e4.sheenRoughnessMap.value = t3.sheenRoughnessMap));
            t3.clearcoat > 0 && (e4.clearcoat.value = t3.clearcoat, e4.clearcoatRoughness.value = t3.clearcoatRoughness, t3.clearcoatMap && (e4.clearcoatMap.value = t3.clearcoatMap), t3.clearcoatRoughnessMap && (e4.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap), t3.clearcoatNormalMap && (e4.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), e4.clearcoatNormalMap.value = t3.clearcoatNormalMap, 1 === t3.side && e4.clearcoatNormalScale.value.negate()));
            t3.iridescence > 0 && (e4.iridescence.value = t3.iridescence, e4.iridescenceIOR.value = t3.iridescenceIOR, e4.iridescenceThicknessMinimum.value = t3.iridescenceThicknessRange[0], e4.iridescenceThicknessMaximum.value = t3.iridescenceThicknessRange[1], t3.iridescenceMap && (e4.iridescenceMap.value = t3.iridescenceMap), t3.iridescenceThicknessMap && (e4.iridescenceThicknessMap.value = t3.iridescenceThicknessMap));
            t3.transmission > 0 && (e4.transmission.value = t3.transmission, e4.transmissionSamplerMap.value = i3.texture, e4.transmissionSamplerSize.value.set(i3.width, i3.height), t3.transmissionMap && (e4.transmissionMap.value = t3.transmissionMap), e4.thickness.value = t3.thickness, t3.thicknessMap && (e4.thicknessMap.value = t3.thicknessMap), e4.attenuationDistance.value = t3.attenuationDistance, e4.attenuationColor.value.copy(t3.attenuationColor));
            e4.specularIntensity.value = t3.specularIntensity, e4.specularColor.value.copy(t3.specularColor), t3.specularIntensityMap && (e4.specularIntensityMap.value = t3.specularIntensityMap);
            t3.specularColorMap && (e4.specularColorMap.value = t3.specularColorMap);
          }(e3, n2, a2)) : n2.isMeshMatcapMaterial ? (i2(e3, n2), function(e4, t3) {
            t3.matcap && (e4.matcap.value = t3.matcap);
          }(e3, n2)) : n2.isMeshDepthMaterial ? i2(e3, n2) : n2.isMeshDistanceMaterial ? (i2(e3, n2), function(e4, t3) {
            e4.referencePosition.value.copy(t3.referencePosition), e4.nearDistance.value = t3.nearDistance, e4.farDistance.value = t3.farDistance;
          }(e3, n2)) : n2.isMeshNormalMaterial ? i2(e3, n2) : n2.isLineBasicMaterial ? (function(e4, t3) {
            e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity;
          }(e3, n2), n2.isLineDashedMaterial && function(e4, t3) {
            e4.dashSize.value = t3.dashSize, e4.totalSize.value = t3.dashSize + t3.gapSize, e4.scale.value = t3.scale;
          }(e3, n2)) : n2.isPointsMaterial ? function(e4, t3, i3, n3) {
            e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.size.value = t3.size * i3, e4.scale.value = 0.5 * n3, t3.map && (e4.map.value = t3.map);
            t3.alphaMap && (e4.alphaMap.value = t3.alphaMap);
            t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest);
            let r3;
            t3.map ? r3 = t3.map : t3.alphaMap && (r3 = t3.alphaMap);
            void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), e4.uvTransform.value.copy(r3.matrix));
          }(e3, n2, r2, s2) : n2.isSpriteMaterial ? function(e4, t3) {
            e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.rotation.value = t3.rotation, t3.map && (e4.map.value = t3.map);
            t3.alphaMap && (e4.alphaMap.value = t3.alphaMap);
            t3.alphaTest > 0 && (e4.alphaTest.value = t3.alphaTest);
            let i3;
            t3.map ? i3 = t3.map : t3.alphaMap && (i3 = t3.alphaMap);
            void 0 !== i3 && (true === i3.matrixAutoUpdate && i3.updateMatrix(), e4.uvTransform.value.copy(i3.matrix));
          }(e3, n2) : n2.isShadowMaterial ? (e3.color.value.copy(n2.color), e3.opacity.value = n2.opacity) : n2.isShaderMaterial && (n2.uniformsNeedUpdate = false);
        } };
      }
      function ws(e2 = {}) {
        this.isWebGLRenderer = true;
        const t2 = void 0 !== e2.canvas ? e2.canvas : function() {
          const e3 = se("canvas");
          return e3.style.display = "block", e3;
        }(), i2 = void 0 !== e2.context ? e2.context : null, n2 = void 0 === e2.depth || e2.depth, r2 = void 0 === e2.stencil || e2.stencil, s2 = void 0 !== e2.antialias && e2.antialias, a2 = void 0 === e2.premultipliedAlpha || e2.premultipliedAlpha, o2 = void 0 !== e2.preserveDrawingBuffer && e2.preserveDrawingBuffer, l2 = void 0 !== e2.powerPreference ? e2.powerPreference : "default", h2 = void 0 !== e2.failIfMajorPerformanceCaveat && e2.failIfMajorPerformanceCaveat;
        let c2;
        c2 = null !== i2 ? i2.getContextAttributes().alpha : void 0 !== e2.alpha && e2.alpha;
        let u2 = null, d2 = null;
        const p2 = [], m2 = [];
        this.domElement = t2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = O, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1, Object.defineProperties(this, { gammaFactor: { get: function() {
          return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
        }, set: function() {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        } } });
        const _2 = this;
        let y2 = false, M2 = 0, S2 = 0, w2 = null, T2 = -1, E2 = null;
        const C2 = new Se(), A2 = new Se();
        let P2 = null, R2 = t2.width, L2 = t2.height, I2 = 1, D2 = null, F2 = null;
        const U2 = new Se(0, 0, R2, L2), z2 = new Se(0, 0, R2, L2);
        let N2 = false;
        const k2 = new Vi();
        let B2 = false, V2 = false, G2 = null;
        const H2 = new st(), j2 = new ie(), W2 = new Ae(), X2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
        function q2() {
          return null === w2 ? I2 : 1;
        }
        let Y2, Z2, J2, K2, Q2, $2, te2, ne2, re2, ae2, oe2, le2, he2, ce2, ue2, de2, pe2, me2, fe2, ge2, _e2, ve2, xe2, ye2 = i2;
        function be2(e3, i3) {
          for (let n3 = 0; n3 < e3.length; n3++) {
            const r3 = e3[n3], s3 = t2.getContext(r3, i3);
            if (null !== s3)
              return s3;
          }
          return null;
        }
        try {
          const e3 = { alpha: true, depth: n2, stencil: r2, antialias: s2, premultipliedAlpha: a2, preserveDrawingBuffer: o2, powerPreference: l2, failIfMajorPerformanceCaveat: h2 };
          if ("setAttribute" in t2 && t2.setAttribute("data-engine", "three.js r141dev"), t2.addEventListener("webglcontextlost", Ee2, false), t2.addEventListener("webglcontextrestored", Ce2, false), t2.addEventListener("webglcontextcreationerror", Pe2, false), null === ye2) {
            const t3 = ["webgl2", "webgl", "experimental-webgl"];
            if (true === _2.isWebGL1Renderer && t3.shift(), ye2 = be2(t3, e3), null === ye2)
              throw be2(t3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
          void 0 === ye2.getShaderPrecisionFormat && (ye2.getShaderPrecisionFormat = function() {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
        } catch (Ve2) {
          throw console.error("THREE.WebGLRenderer: " + Ve2.message), Ve2;
        }
        function Me2() {
          Y2 = new xn(ye2), Z2 = new Ki(ye2, Y2, e2), Y2.init(Z2), ve2 = new gs(ye2, Y2, Z2), J2 = new ms(ye2, Y2, Z2), K2 = new Mn(), Q2 = new es(), $2 = new fs(ye2, Y2, J2, Q2, Z2, ve2, K2), te2 = new $i(_2), ne2 = new vn(_2), re2 = new Hi(ye2, Z2), xe2 = new Zi(ye2, Y2, re2, Z2), ae2 = new yn(ye2, re2, K2, xe2), oe2 = new Cn(ye2, ae2, re2, K2), fe2 = new En(ye2, Z2, $2), de2 = new Qi(Q2), le2 = new $r(_2, te2, ne2, Y2, Z2, xe2, de2), he2 = new Ss(_2, Q2), ce2 = new rs(), ue2 = new cs(Y2, Z2), me2 = new Yi(_2, te2, J2, oe2, c2, a2), pe2 = new ps(_2, oe2, Z2), ge2 = new Ji(ye2, Y2, K2, Z2), _e2 = new bn(ye2, Y2, K2, Z2), K2.programs = le2.programs, _2.capabilities = Z2, _2.extensions = Y2, _2.properties = Q2, _2.renderLists = ce2, _2.shadowMap = pe2, _2.state = J2, _2.info = K2;
        }
        Me2();
        const Te2 = new Ms(_2, ye2);
        function Ee2(e3) {
          e3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y2 = true;
        }
        function Ce2() {
          console.log("THREE.WebGLRenderer: Context Restored."), y2 = false;
          const e3 = K2.autoReset, t3 = pe2.enabled, i3 = pe2.autoUpdate, n3 = pe2.needsUpdate, r3 = pe2.type;
          Me2(), K2.autoReset = e3, pe2.enabled = t3, pe2.autoUpdate = i3, pe2.needsUpdate = n3, pe2.type = r3;
        }
        function Pe2(e3) {
          console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e3.statusMessage);
        }
        function Re2(e3) {
          const t3 = e3.target;
          t3.removeEventListener("dispose", Re2), function(e4) {
            (function(e5) {
              const t4 = Q2.get(e5).programs;
              void 0 !== t4 && (t4.forEach(function(e6) {
                le2.releaseProgram(e6);
              }), e5.isShaderMaterial && le2.releaseShaderCache(e5));
            })(e4), Q2.remove(e4);
          }(t3);
        }
        this.xr = Te2, this.getContext = function() {
          return ye2;
        }, this.getContextAttributes = function() {
          return ye2.getContextAttributes();
        }, this.forceContextLoss = function() {
          const e3 = Y2.get("WEBGL_lose_context");
          e3 && e3.loseContext();
        }, this.forceContextRestore = function() {
          const e3 = Y2.get("WEBGL_lose_context");
          e3 && e3.restoreContext();
        }, this.getPixelRatio = function() {
          return I2;
        }, this.setPixelRatio = function(e3) {
          void 0 !== e3 && (I2 = e3, this.setSize(R2, L2, false));
        }, this.getSize = function(e3) {
          return e3.set(R2, L2);
        }, this.setSize = function(e3, i3, n3) {
          Te2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R2 = e3, L2 = i3, t2.width = Math.floor(e3 * I2), t2.height = Math.floor(i3 * I2), false !== n3 && (t2.style.width = e3 + "px", t2.style.height = i3 + "px"), this.setViewport(0, 0, e3, i3));
        }, this.getDrawingBufferSize = function(e3) {
          return e3.set(R2 * I2, L2 * I2).floor();
        }, this.setDrawingBufferSize = function(e3, i3, n3) {
          R2 = e3, L2 = i3, I2 = n3, t2.width = Math.floor(e3 * n3), t2.height = Math.floor(i3 * n3), this.setViewport(0, 0, e3, i3);
        }, this.getCurrentViewport = function(e3) {
          return e3.copy(C2);
        }, this.getViewport = function(e3) {
          return e3.copy(U2);
        }, this.setViewport = function(e3, t3, i3, n3) {
          e3.isVector4 ? U2.set(e3.x, e3.y, e3.z, e3.w) : U2.set(e3, t3, i3, n3), J2.viewport(C2.copy(U2).multiplyScalar(I2).floor());
        }, this.getScissor = function(e3) {
          return e3.copy(z2);
        }, this.setScissor = function(e3, t3, i3, n3) {
          e3.isVector4 ? z2.set(e3.x, e3.y, e3.z, e3.w) : z2.set(e3, t3, i3, n3), J2.scissor(A2.copy(z2).multiplyScalar(I2).floor());
        }, this.getScissorTest = function() {
          return N2;
        }, this.setScissorTest = function(e3) {
          J2.setScissorTest(N2 = e3);
        }, this.setOpaqueSort = function(e3) {
          D2 = e3;
        }, this.setTransparentSort = function(e3) {
          F2 = e3;
        }, this.getClearColor = function(e3) {
          return e3.copy(me2.getClearColor());
        }, this.setClearColor = function() {
          me2.setClearColor.apply(me2, arguments);
        }, this.getClearAlpha = function() {
          return me2.getClearAlpha();
        }, this.setClearAlpha = function() {
          me2.setClearAlpha.apply(me2, arguments);
        }, this.clear = function(e3 = true, t3 = true, i3 = true) {
          let n3 = 0;
          e3 && (n3 |= 16384), t3 && (n3 |= 256), i3 && (n3 |= 1024), ye2.clear(n3);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.dispose = function() {
          t2.removeEventListener("webglcontextlost", Ee2, false), t2.removeEventListener("webglcontextrestored", Ce2, false), t2.removeEventListener("webglcontextcreationerror", Pe2, false), ce2.dispose(), ue2.dispose(), Q2.dispose(), te2.dispose(), ne2.dispose(), oe2.dispose(), xe2.dispose(), le2.dispose(), Te2.dispose(), Te2.removeEventListener("sessionstart", Ie2), Te2.removeEventListener("sessionend", De2), G2 && (G2.dispose(), G2 = null), Fe2.stop();
        }, this.renderBufferDirect = function(e3, t3, i3, n3, r3, s3) {
          null === t3 && (t3 = X2);
          const a3 = r3.isMesh && r3.matrixWorld.determinant() < 0, o3 = function(e4, t4, i4, n4, r4) {
            true !== t4.isScene && (t4 = X2);
            $2.resetTextureUnits();
            const s4 = t4.fog, a4 = n4.isMeshStandardMaterial ? t4.environment : null, o4 = null === w2 ? _2.outputEncoding : true === w2.isXRRenderTarget ? w2.texture.encoding : O, l4 = (n4.isMeshStandardMaterial ? ne2 : te2).get(n4.envMap || a4), h4 = true === n4.vertexColors && !!i4.attributes.color && 4 === i4.attributes.color.itemSize, c4 = !!n4.normalMap && !!i4.attributes.tangent, u4 = !!i4.morphAttributes.position, p4 = !!i4.morphAttributes.normal, m4 = !!i4.morphAttributes.color, f3 = n4.toneMapped ? _2.toneMapping : 0, g3 = i4.morphAttributes.position || i4.morphAttributes.normal || i4.morphAttributes.color, v3 = void 0 !== g3 ? g3.length : 0, x3 = Q2.get(n4), y4 = d2.state.lights, b3 = _2.extraProgramCacheKey;
            if (true === B2 && (true === V2 || e4 !== E2)) {
              const t5 = e4 === E2 && n4.id === T2;
              de2.setState(n4, e4, t5);
            }
            let M4 = false;
            n4.version === x3.__version ? x3.needsLights && x3.lightsStateVersion !== y4.state.version || x3.outputEncoding !== o4 || r4.isInstancedMesh && false === x3.instancing ? M4 = true : r4.isInstancedMesh || true !== x3.instancing ? r4.isSkinnedMesh && false === x3.skinning ? M4 = true : r4.isSkinnedMesh || true !== x3.skinning ? x3.envMap !== l4 || true === n4.fog && x3.fog !== s4 ? M4 = true : void 0 === x3.numClippingPlanes || x3.numClippingPlanes === de2.numPlanes && x3.numIntersection === de2.numIntersection ? (x3.vertexAlphas !== h4 || x3.vertexTangents !== c4 || x3.morphTargets !== u4 || x3.morphNormals !== p4 || x3.morphColors !== m4 || x3.toneMapping !== f3 || true === Z2.isWebGL2 && x3.morphTargetsCount !== v3 || b3 !== x3.extraProgramCacheKey) && (M4 = true) : M4 = true : M4 = true : M4 = true : (M4 = true, x3.__version = n4.version);
            let S3 = x3.currentProgram;
            true === M4 && (S3 = ke2(n4, t4, r4));
            let C3 = false, A3 = false, P3 = false;
            const R3 = S3.getUniforms(), D3 = x3.uniforms;
            J2.useProgram(S3.program) && (C3 = true, A3 = true, P3 = true);
            n4.id !== T2 && (T2 = n4.id, A3 = true);
            if (C3 || E2 !== e4) {
              if (R3.setValue(ye2, "projectionMatrix", e4.projectionMatrix), Z2.logarithmicDepthBuffer && R3.setValue(ye2, "logDepthBufFC", 2 / (Math.log(e4.far + 1) / Math.LN2)), E2 !== e4 && (E2 = e4, A3 = true, P3 = true), n4.isShaderMaterial || n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshStandardMaterial || n4.envMap) {
                const t5 = R3.map.cameraPosition;
                void 0 !== t5 && t5.setValue(ye2, W2.setFromMatrixPosition(e4.matrixWorld));
              }
              (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial) && R3.setValue(ye2, "isOrthographic", true === e4.isOrthographicCamera), (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial || n4.isShadowMaterial || r4.isSkinnedMesh) && R3.setValue(ye2, "viewMatrix", e4.matrixWorldInverse);
            }
            if (r4.isSkinnedMesh) {
              R3.setOptional(ye2, r4, "bindMatrix"), R3.setOptional(ye2, r4, "bindMatrixInverse");
              const e5 = r4.skeleton;
              e5 && (Z2.floatVertexTextures ? (null === e5.boneTexture && e5.computeBoneTexture(), R3.setValue(ye2, "boneTexture", e5.boneTexture, $2), R3.setValue(ye2, "boneTextureSize", e5.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
            }
            const F3 = i4.morphAttributes;
            (void 0 !== F3.position || void 0 !== F3.normal || void 0 !== F3.color && true === Z2.isWebGL2) && fe2.update(r4, i4, n4, S3);
            (A3 || x3.receiveShadow !== r4.receiveShadow) && (x3.receiveShadow = r4.receiveShadow, R3.setValue(ye2, "receiveShadow", r4.receiveShadow));
            A3 && (R3.setValue(ye2, "toneMappingExposure", _2.toneMappingExposure), x3.needsLights && (z3 = P3, (U3 = D3).ambientLightColor.needsUpdate = z3, U3.lightProbe.needsUpdate = z3, U3.directionalLights.needsUpdate = z3, U3.directionalLightShadows.needsUpdate = z3, U3.pointLights.needsUpdate = z3, U3.pointLightShadows.needsUpdate = z3, U3.spotLights.needsUpdate = z3, U3.spotLightShadows.needsUpdate = z3, U3.rectAreaLights.needsUpdate = z3, U3.hemisphereLights.needsUpdate = z3), s4 && true === n4.fog && he2.refreshFogUniforms(D3, s4), he2.refreshMaterialUniforms(D3, n4, I2, L2, G2), Lr.upload(ye2, x3.uniformsList, D3, $2));
            var U3, z3;
            n4.isShaderMaterial && true === n4.uniformsNeedUpdate && (Lr.upload(ye2, x3.uniformsList, D3, $2), n4.uniformsNeedUpdate = false);
            n4.isSpriteMaterial && R3.setValue(ye2, "center", r4.center);
            return R3.setValue(ye2, "modelViewMatrix", r4.modelViewMatrix), R3.setValue(ye2, "normalMatrix", r4.normalMatrix), R3.setValue(ye2, "modelMatrix", r4.matrixWorld), S3;
          }(e3, t3, i3, n3, r3);
          J2.setMaterial(n3, a3);
          let l3 = i3.index;
          const h3 = i3.attributes.position;
          if (null === l3) {
            if (void 0 === h3 || 0 === h3.count)
              return;
          } else if (0 === l3.count)
            return;
          let c3, u3 = 1;
          true === n3.wireframe && (l3 = ae2.getWireframeAttribute(i3), u3 = 2), xe2.setup(r3, n3, o3, i3, l3);
          let p3 = ge2;
          null !== l3 && (c3 = re2.get(l3), p3 = _e2, p3.setIndex(c3));
          const m3 = null !== l3 ? l3.count : h3.count, f2 = i3.drawRange.start * u3, g2 = i3.drawRange.count * u3, v2 = null !== s3 ? s3.start * u3 : 0, x2 = null !== s3 ? s3.count * u3 : 1 / 0, y3 = Math.max(f2, v2), b2 = Math.min(m3, f2 + g2, v2 + x2) - 1, M3 = Math.max(0, b2 - y3 + 1);
          if (0 !== M3) {
            if (r3.isMesh)
              true === n3.wireframe ? (J2.setLineWidth(n3.wireframeLinewidth * q2()), p3.setMode(1)) : p3.setMode(4);
            else if (r3.isLine) {
              let e4 = n3.linewidth;
              void 0 === e4 && (e4 = 1), J2.setLineWidth(e4 * q2()), r3.isLineSegments ? p3.setMode(1) : r3.isLineLoop ? p3.setMode(2) : p3.setMode(3);
            } else
              r3.isPoints ? p3.setMode(0) : r3.isSprite && p3.setMode(4);
            if (r3.isInstancedMesh)
              p3.renderInstances(y3, M3, r3.count);
            else if (i3.isInstancedBufferGeometry) {
              const e4 = Math.min(i3.instanceCount, i3._maxInstanceCount);
              p3.renderInstances(y3, M3, e4);
            } else
              p3.render(y3, M3);
          }
        }, this.compile = function(e3, t3) {
          d2 = ue2.get(e3), d2.init(), m2.push(d2), e3.traverseVisible(function(e4) {
            e4.isLight && e4.layers.test(t3.layers) && (d2.pushLight(e4), e4.castShadow && d2.pushShadow(e4));
          }), d2.setupLights(_2.physicallyCorrectLights), e3.traverse(function(t4) {
            const i3 = t4.material;
            if (i3)
              if (Array.isArray(i3))
                for (let n3 = 0; n3 < i3.length; n3++) {
                  ke2(i3[n3], e3, t4);
                }
              else
                ke2(i3, e3, t4);
          }), m2.pop(), d2 = null;
        };
        let Le2 = null;
        function Ie2() {
          Fe2.stop();
        }
        function De2() {
          Fe2.start();
        }
        const Fe2 = new Gi();
        function Oe2(e3, t3, i3, n3) {
          if (false === e3.visible)
            return;
          if (e3.layers.test(t3.layers)) {
            if (e3.isGroup)
              i3 = e3.renderOrder;
            else if (e3.isLOD)
              true === e3.autoUpdate && e3.update(t3);
            else if (e3.isLight)
              d2.pushLight(e3), e3.castShadow && d2.pushShadow(e3);
            else if (e3.isSprite) {
              if (!e3.frustumCulled || k2.intersectsSprite(e3)) {
                n3 && W2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(H2);
                const t4 = oe2.update(e3), r4 = e3.material;
                r4.visible && u2.push(e3, t4, r4, i3, W2.z, null);
              }
            } else if ((e3.isMesh || e3.isLine || e3.isPoints) && (e3.isSkinnedMesh && e3.skeleton.frame !== K2.render.frame && (e3.skeleton.update(), e3.skeleton.frame = K2.render.frame), !e3.frustumCulled || k2.intersectsObject(e3))) {
              n3 && W2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(H2);
              const t4 = oe2.update(e3), r4 = e3.material;
              if (Array.isArray(r4)) {
                const n4 = t4.groups;
                for (let s3 = 0, a3 = n4.length; s3 < a3; s3++) {
                  const a4 = n4[s3], o3 = r4[a4.materialIndex];
                  o3 && o3.visible && u2.push(e3, t4, o3, i3, W2.z, a4);
                }
              } else
                r4.visible && u2.push(e3, t4, r4, i3, W2.z, null);
            }
          }
          const r3 = e3.children;
          for (let s3 = 0, a3 = r3.length; s3 < a3; s3++)
            Oe2(r3[s3], t3, i3, n3);
        }
        function Ue2(e3, t3, i3, n3) {
          const r3 = e3.opaque, a3 = e3.transmissive, o3 = e3.transparent;
          d2.setupLightsView(i3), a3.length > 0 && function(e4, t4, i4) {
            const n4 = Z2.isWebGL2;
            null === G2 && (G2 = new we(1, 1, { generateMipmaps: true, type: Y2.has("EXT_color_buffer_half_float") ? x : g, minFilter: f, samples: n4 && true === s2 ? 4 : 0 }));
            _2.getDrawingBufferSize(j2), n4 ? G2.setSize(j2.x, j2.y) : G2.setSize(ee(j2.x), ee(j2.y));
            const r4 = _2.getRenderTarget();
            _2.setRenderTarget(G2), _2.clear();
            const a4 = _2.toneMapping;
            _2.toneMapping = 0, ze2(e4, t4, i4), _2.toneMapping = a4, $2.updateMultisampleRenderTarget(G2), $2.updateRenderTargetMipmap(G2), _2.setRenderTarget(r4);
          }(r3, t3, i3), n3 && J2.viewport(C2.copy(n3)), r3.length > 0 && ze2(r3, t3, i3), a3.length > 0 && ze2(a3, t3, i3), o3.length > 0 && ze2(o3, t3, i3), J2.buffers.depth.setTest(true), J2.buffers.depth.setMask(true), J2.buffers.color.setMask(true), J2.setPolygonOffset(false);
        }
        function ze2(e3, t3, i3) {
          const n3 = true === t3.isScene ? t3.overrideMaterial : null;
          for (let r3 = 0, s3 = e3.length; r3 < s3; r3++) {
            const s4 = e3[r3], a3 = s4.object, o3 = s4.geometry, l3 = null === n3 ? s4.material : n3, h3 = s4.group;
            a3.layers.test(i3.layers) && Ne2(a3, t3, i3, o3, l3, h3);
          }
        }
        function Ne2(e3, t3, i3, n3, r3, s3) {
          e3.onBeforeRender(_2, t3, i3, n3, r3, s3), e3.modelViewMatrix.multiplyMatrices(i3.matrixWorldInverse, e3.matrixWorld), e3.normalMatrix.getNormalMatrix(e3.modelViewMatrix), r3.onBeforeRender(_2, t3, i3, n3, e3, s3), true === r3.transparent && 2 === r3.side ? (r3.side = 1, r3.needsUpdate = true, _2.renderBufferDirect(i3, t3, n3, r3, e3, s3), r3.side = 0, r3.needsUpdate = true, _2.renderBufferDirect(i3, t3, n3, r3, e3, s3), r3.side = 2) : _2.renderBufferDirect(i3, t3, n3, r3, e3, s3), e3.onAfterRender(_2, t3, i3, n3, r3, s3);
        }
        function ke2(e3, t3, i3) {
          true !== t3.isScene && (t3 = X2);
          const n3 = Q2.get(e3), r3 = d2.state.lights, s3 = d2.state.shadowsArray, a3 = r3.state.version, o3 = le2.getParameters(e3, r3.state, s3, t3, i3), l3 = le2.getProgramCacheKey(o3);
          let h3 = n3.programs;
          n3.environment = e3.isMeshStandardMaterial ? t3.environment : null, n3.fog = t3.fog, n3.envMap = (e3.isMeshStandardMaterial ? ne2 : te2).get(e3.envMap || n3.environment), void 0 === h3 && (e3.addEventListener("dispose", Re2), h3 = /* @__PURE__ */ new Map(), n3.programs = h3);
          let c3 = h3.get(l3);
          if (void 0 !== c3) {
            if (n3.currentProgram === c3 && n3.lightsStateVersion === a3)
              return Be2(e3, o3), c3;
          } else
            o3.uniforms = le2.getUniforms(e3), e3.onBuild(i3, o3, _2), e3.onBeforeCompile(o3, _2), c3 = le2.acquireProgram(o3, l3), h3.set(l3, c3), n3.uniforms = o3.uniforms;
          const u3 = n3.uniforms;
          (e3.isShaderMaterial || e3.isRawShaderMaterial) && true !== e3.clipping || (u3.clippingPlanes = de2.uniform), Be2(e3, o3), n3.needsLights = function(e4) {
            return e4.isMeshLambertMaterial || e4.isMeshToonMaterial || e4.isMeshPhongMaterial || e4.isMeshStandardMaterial || e4.isShadowMaterial || e4.isShaderMaterial && true === e4.lights;
          }(e3), n3.lightsStateVersion = a3, n3.needsLights && (u3.ambientLightColor.value = r3.state.ambient, u3.lightProbe.value = r3.state.probe, u3.directionalLights.value = r3.state.directional, u3.directionalLightShadows.value = r3.state.directionalShadow, u3.spotLights.value = r3.state.spot, u3.spotLightShadows.value = r3.state.spotShadow, u3.rectAreaLights.value = r3.state.rectArea, u3.ltc_1.value = r3.state.rectAreaLTC1, u3.ltc_2.value = r3.state.rectAreaLTC2, u3.pointLights.value = r3.state.point, u3.pointLightShadows.value = r3.state.pointShadow, u3.hemisphereLights.value = r3.state.hemi, u3.directionalShadowMap.value = r3.state.directionalShadowMap, u3.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, u3.spotShadowMap.value = r3.state.spotShadowMap, u3.spotShadowMatrix.value = r3.state.spotShadowMatrix, u3.pointShadowMap.value = r3.state.pointShadowMap, u3.pointShadowMatrix.value = r3.state.pointShadowMatrix);
          const p3 = c3.getUniforms(), m3 = Lr.seqWithValue(p3.seq, u3);
          return n3.currentProgram = c3, n3.uniformsList = m3, c3;
        }
        function Be2(e3, t3) {
          const i3 = Q2.get(e3);
          i3.outputEncoding = t3.outputEncoding, i3.instancing = t3.instancing, i3.skinning = t3.skinning, i3.morphTargets = t3.morphTargets, i3.morphNormals = t3.morphNormals, i3.morphColors = t3.morphColors, i3.morphTargetsCount = t3.morphTargetsCount, i3.numClippingPlanes = t3.numClippingPlanes, i3.numIntersection = t3.numClipIntersection, i3.vertexAlphas = t3.vertexAlphas, i3.vertexTangents = t3.vertexTangents, i3.toneMapping = t3.toneMapping, i3.extraProgramCacheKey = t3.extraProgramCacheKey;
        }
        Fe2.setAnimationLoop(function(e3) {
          Le2 && Le2(e3);
        }), "undefined" != typeof self && Fe2.setContext(self), this.setAnimationLoop = function(e3) {
          Le2 = e3, Te2.setAnimationLoop(e3), null === e3 ? Fe2.stop() : Fe2.start();
        }, Te2.addEventListener("sessionstart", Ie2), Te2.addEventListener("sessionend", De2), this.render = function(e3, t3) {
          if (void 0 !== t3 && true !== t3.isCamera)
            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          if (true === y2)
            return;
          true === e3.autoUpdate && e3.updateMatrixWorld(), null === t3.parent && t3.updateMatrixWorld(), true === Te2.enabled && true === Te2.isPresenting && (true === Te2.cameraAutoUpdate && Te2.updateCamera(t3), t3 = Te2.getCamera()), true === e3.isScene && e3.onBeforeRender(_2, e3, t3, w2), d2 = ue2.get(e3, m2.length), d2.init(), m2.push(d2), H2.multiplyMatrices(t3.projectionMatrix, t3.matrixWorldInverse), k2.setFromProjectionMatrix(H2), V2 = this.localClippingEnabled, B2 = de2.init(this.clippingPlanes, V2, t3), u2 = ce2.get(e3, p2.length), u2.init(), p2.push(u2), Oe2(e3, t3, 0, _2.sortObjects), u2.finish(), true === _2.sortObjects && u2.sort(D2, F2), true === B2 && de2.beginShadows();
          const i3 = d2.state.shadowsArray;
          if (pe2.render(i3, e3, t3), true === B2 && de2.endShadows(), true === this.info.autoReset && this.info.reset(), me2.render(u2, e3), d2.setupLights(_2.physicallyCorrectLights), t3.isArrayCamera) {
            const i4 = t3.cameras;
            for (let t4 = 0, n3 = i4.length; t4 < n3; t4++) {
              const n4 = i4[t4];
              Ue2(u2, e3, n4, n4.viewport);
            }
          } else
            Ue2(u2, e3, t3);
          null !== w2 && ($2.updateMultisampleRenderTarget(w2), $2.updateRenderTargetMipmap(w2)), true === e3.isScene && e3.onAfterRender(_2, e3, t3), xe2.resetDefaultState(), T2 = -1, E2 = null, m2.pop(), d2 = m2.length > 0 ? m2[m2.length - 1] : null, p2.pop(), u2 = p2.length > 0 ? p2[p2.length - 1] : null;
        }, this.getActiveCubeFace = function() {
          return M2;
        }, this.getActiveMipmapLevel = function() {
          return S2;
        }, this.getRenderTarget = function() {
          return w2;
        }, this.setRenderTargetTextures = function(e3, t3, i3) {
          Q2.get(e3.texture).__webglTexture = t3, Q2.get(e3.depthTexture).__webglTexture = i3;
          const n3 = Q2.get(e3);
          n3.__hasExternalTextures = true, n3.__hasExternalTextures && (n3.__autoAllocateDepthBuffer = void 0 === i3, n3.__autoAllocateDepthBuffer || true === Y2.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n3.__useRenderToTexture = false));
        }, this.setRenderTargetFramebuffer = function(e3, t3) {
          const i3 = Q2.get(e3);
          i3.__webglFramebuffer = t3, i3.__useDefaultFramebuffer = void 0 === t3;
        }, this.setRenderTarget = function(e3, t3 = 0, i3 = 0) {
          w2 = e3, M2 = t3, S2 = i3;
          let n3 = true;
          if (e3) {
            const t4 = Q2.get(e3);
            void 0 !== t4.__useDefaultFramebuffer ? (J2.bindFramebuffer(36160, null), n3 = false) : void 0 === t4.__webglFramebuffer ? $2.setupRenderTarget(e3) : t4.__hasExternalTextures && $2.rebindTextures(e3, Q2.get(e3.texture).__webglTexture, Q2.get(e3.depthTexture).__webglTexture);
          }
          let r3 = null, s3 = false, a3 = false;
          if (e3) {
            const i4 = e3.texture;
            (i4.isData3DTexture || i4.isDataArrayTexture) && (a3 = true);
            const n4 = Q2.get(e3).__webglFramebuffer;
            e3.isWebGLCubeRenderTarget ? (r3 = n4[t3], s3 = true) : r3 = Z2.isWebGL2 && e3.samples > 0 && false === $2.useMultisampledRTT(e3) ? Q2.get(e3).__webglMultisampledFramebuffer : n4, C2.copy(e3.viewport), A2.copy(e3.scissor), P2 = e3.scissorTest;
          } else
            C2.copy(U2).multiplyScalar(I2).floor(), A2.copy(z2).multiplyScalar(I2).floor(), P2 = N2;
          if (J2.bindFramebuffer(36160, r3) && Z2.drawBuffers && n3 && J2.drawBuffers(e3, r3), J2.viewport(C2), J2.scissor(A2), J2.setScissorTest(P2), s3) {
            const n4 = Q2.get(e3.texture);
            ye2.framebufferTexture2D(36160, 36064, 34069 + t3, n4.__webglTexture, i3);
          } else if (a3) {
            const n4 = Q2.get(e3.texture), r4 = t3 || 0;
            ye2.framebufferTextureLayer(36160, 36064, n4.__webglTexture, i3 || 0, r4);
          }
          T2 = -1;
        }, this.readRenderTargetPixels = function(e3, t3, i3, n3, r3, s3, a3) {
          if (!e3 || !e3.isWebGLRenderTarget)
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let o3 = Q2.get(e3).__webglFramebuffer;
          if (e3.isWebGLCubeRenderTarget && void 0 !== a3 && (o3 = o3[a3]), o3) {
            J2.bindFramebuffer(36160, o3);
            try {
              const a4 = e3.texture, o4 = a4.format, l3 = a4.type;
              if (o4 !== b && ve2.convert(o4) !== ye2.getParameter(35739))
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              const h3 = l3 === x && (Y2.has("EXT_color_buffer_half_float") || Z2.isWebGL2 && Y2.has("EXT_color_buffer_float"));
              if (!(l3 === g || ve2.convert(l3) === ye2.getParameter(35738) || l3 === v && (Z2.isWebGL2 || Y2.has("OES_texture_float") || Y2.has("WEBGL_color_buffer_float")) || h3))
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              t3 >= 0 && t3 <= e3.width - n3 && i3 >= 0 && i3 <= e3.height - r3 && ye2.readPixels(t3, i3, n3, r3, ve2.convert(o4), ve2.convert(l3), s3);
            } finally {
              const e4 = null !== w2 ? Q2.get(w2).__webglFramebuffer : null;
              J2.bindFramebuffer(36160, e4);
            }
          }
        }, this.copyFramebufferToTexture = function(e3, t3, i3 = 0) {
          const n3 = Math.pow(2, -i3), r3 = Math.floor(t3.image.width * n3), s3 = Math.floor(t3.image.height * n3);
          $2.setTexture2D(t3, 0), ye2.copyTexSubImage2D(3553, i3, 0, 0, e3.x, e3.y, r3, s3), J2.unbindTexture();
        }, this.copyTextureToTexture = function(e3, t3, i3, n3 = 0) {
          const r3 = t3.image.width, s3 = t3.image.height, a3 = ve2.convert(i3.format), o3 = ve2.convert(i3.type);
          $2.setTexture2D(i3, 0), ye2.pixelStorei(37440, i3.flipY), ye2.pixelStorei(37441, i3.premultiplyAlpha), ye2.pixelStorei(3317, i3.unpackAlignment), t3.isDataTexture ? ye2.texSubImage2D(3553, n3, e3.x, e3.y, r3, s3, a3, o3, t3.image.data) : t3.isCompressedTexture ? ye2.compressedTexSubImage2D(3553, n3, e3.x, e3.y, t3.mipmaps[0].width, t3.mipmaps[0].height, a3, t3.mipmaps[0].data) : ye2.texSubImage2D(3553, n3, e3.x, e3.y, a3, o3, t3.image), 0 === n3 && i3.generateMipmaps && ye2.generateMipmap(3553), J2.unbindTexture();
        }, this.copyTextureToTexture3D = function(e3, t3, i3, n3, r3 = 0) {
          if (_2.isWebGL1Renderer)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          const s3 = e3.max.x - e3.min.x + 1, a3 = e3.max.y - e3.min.y + 1, o3 = e3.max.z - e3.min.z + 1, l3 = ve2.convert(n3.format), h3 = ve2.convert(n3.type);
          let c3;
          if (n3.isData3DTexture)
            $2.setTexture3D(n3, 0), c3 = 32879;
          else {
            if (!n3.isDataArrayTexture)
              return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            $2.setTexture2DArray(n3, 0), c3 = 35866;
          }
          ye2.pixelStorei(37440, n3.flipY), ye2.pixelStorei(37441, n3.premultiplyAlpha), ye2.pixelStorei(3317, n3.unpackAlignment);
          const u3 = ye2.getParameter(3314), d3 = ye2.getParameter(32878), p3 = ye2.getParameter(3316), m3 = ye2.getParameter(3315), f2 = ye2.getParameter(32877), g2 = i3.isCompressedTexture ? i3.mipmaps[0] : i3.image;
          ye2.pixelStorei(3314, g2.width), ye2.pixelStorei(32878, g2.height), ye2.pixelStorei(3316, e3.min.x), ye2.pixelStorei(3315, e3.min.y), ye2.pixelStorei(32877, e3.min.z), i3.isDataTexture || i3.isData3DTexture ? ye2.texSubImage3D(c3, r3, t3.x, t3.y, t3.z, s3, a3, o3, l3, h3, g2.data) : i3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ye2.compressedTexSubImage3D(c3, r3, t3.x, t3.y, t3.z, s3, a3, o3, l3, g2.data)) : ye2.texSubImage3D(c3, r3, t3.x, t3.y, t3.z, s3, a3, o3, l3, h3, g2), ye2.pixelStorei(3314, u3), ye2.pixelStorei(32878, d3), ye2.pixelStorei(3316, p3), ye2.pixelStorei(3315, m3), ye2.pixelStorei(32877, f2), 0 === r3 && n3.generateMipmaps && ye2.generateMipmap(c3), J2.unbindTexture();
        }, this.initTexture = function(e3) {
          $2.setTexture2D(e3, 0), J2.unbindTexture();
        }, this.resetState = function() {
          M2 = 0, S2 = 0, w2 = null, J2.reset(), xe2.reset();
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
      (class extends ws {
      }).prototype.isWebGL1Renderer = true;
      class Ts {
        constructor(e2, t2 = 1, i2 = 1e3) {
          this.isFog = true, this.name = "", this.color = new ge(e2), this.near = t2, this.far = i2;
        }
        clone() {
          return new Ts(this.color, this.near, this.far);
        }
        toJSON() {
          return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
        }
      }
      class Es extends Rt {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        copy(e2, t2) {
          return super.copy(e2, t2), null !== e2.background && (this.background = e2.background.clone()), null !== e2.environment && (this.environment = e2.environment.clone()), null !== e2.fog && (this.fog = e2.fog.clone()), null !== e2.overrideMaterial && (this.overrideMaterial = e2.overrideMaterial.clone()), this.autoUpdate = e2.autoUpdate, this.matrixAutoUpdate = e2.matrixAutoUpdate, this;
        }
        toJSON(e2) {
          const t2 = super.toJSON(e2);
          return null !== this.fog && (t2.object.fog = this.fog.toJSON()), t2;
        }
      }
      class Cs {
        constructor(e2, t2) {
          this.isInterleavedBuffer = true, this.array = e2, this.stride = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.usage = B, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Y();
        }
        onUploadCallback() {
        }
        set needsUpdate(e2) {
          true === e2 && this.version++;
        }
        setUsage(e2) {
          return this.usage = e2, this;
        }
        copy(e2) {
          return this.array = new e2.array.constructor(e2.array), this.count = e2.count, this.stride = e2.stride, this.usage = e2.usage, this;
        }
        copyAt(e2, t2, i2) {
          e2 *= this.stride, i2 *= t2.stride;
          for (let n2 = 0, r2 = this.stride; n2 < r2; n2++)
            this.array[e2 + n2] = t2.array[i2 + n2];
          return this;
        }
        set(e2, t2 = 0) {
          return this.array.set(e2, t2), this;
        }
        clone(e2) {
          void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Y()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t2 = new this.array.constructor(e2.arrayBuffers[this.array.buffer._uuid]), i2 = new this.constructor(t2, this.stride);
          return i2.setUsage(this.usage), i2;
        }
        onUpload(e2) {
          return this.onUploadCallback = e2, this;
        }
        toJSON(e2) {
          return void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Y()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
        }
      }
      const As = new Ae();
      class Ps {
        constructor(e2, t2, i2, n2 = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = e2, this.itemSize = t2, this.offset = i2, this.normalized = true === n2;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e2) {
          this.data.needsUpdate = e2;
        }
        applyMatrix4(e2) {
          for (let t2 = 0, i2 = this.data.count; t2 < i2; t2++)
            As.fromBufferAttribute(this, t2), As.applyMatrix4(e2), this.setXYZ(t2, As.x, As.y, As.z);
          return this;
        }
        applyNormalMatrix(e2) {
          for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
            As.fromBufferAttribute(this, t2), As.applyNormalMatrix(e2), this.setXYZ(t2, As.x, As.y, As.z);
          return this;
        }
        transformDirection(e2) {
          for (let t2 = 0, i2 = this.count; t2 < i2; t2++)
            As.fromBufferAttribute(this, t2), As.transformDirection(e2), this.setXYZ(t2, As.x, As.y, As.z);
          return this;
        }
        setX(e2, t2) {
          return this.data.array[e2 * this.data.stride + this.offset] = t2, this;
        }
        setY(e2, t2) {
          return this.data.array[e2 * this.data.stride + this.offset + 1] = t2, this;
        }
        setZ(e2, t2) {
          return this.data.array[e2 * this.data.stride + this.offset + 2] = t2, this;
        }
        setW(e2, t2) {
          return this.data.array[e2 * this.data.stride + this.offset + 3] = t2, this;
        }
        getX(e2) {
          return this.data.array[e2 * this.data.stride + this.offset];
        }
        getY(e2) {
          return this.data.array[e2 * this.data.stride + this.offset + 1];
        }
        getZ(e2) {
          return this.data.array[e2 * this.data.stride + this.offset + 2];
        }
        getW(e2) {
          return this.data.array[e2 * this.data.stride + this.offset + 3];
        }
        setXY(e2, t2, i2) {
          return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = i2, this;
        }
        setXYZ(e2, t2, i2, n2) {
          return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = i2, this.data.array[e2 + 2] = n2, this;
        }
        setXYZW(e2, t2, i2, n2, r2) {
          return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = i2, this.data.array[e2 + 2] = n2, this.data.array[e2 + 3] = r2, this;
        }
        clone(e2) {
          if (void 0 === e2) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const e3 = [];
            for (let t2 = 0; t2 < this.count; t2++) {
              const i2 = t2 * this.data.stride + this.offset;
              for (let t3 = 0; t3 < this.itemSize; t3++)
                e3.push(this.data.array[i2 + t3]);
            }
            return new qt(new this.array.constructor(e3), this.itemSize, this.normalized);
          }
          return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.clone(e2)), new Ps(e2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e2) {
          if (void 0 === e2) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const e3 = [];
            for (let t2 = 0; t2 < this.count; t2++) {
              const i2 = t2 * this.data.stride + this.offset;
              for (let t3 = 0; t3 < this.itemSize; t3++)
                e3.push(this.data.array[i2 + t3]);
            }
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: e3, normalized: this.normalized };
          }
          return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.toJSON(e2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
        }
      }
      const Rs = new Ae(), Ls = new Se(), Is = new Se(), Ds = new Ae(), Fs = new st();
      class Os extends Mi {
        constructor(e2, t2) {
          super(e2, t2), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new st(), this.bindMatrixInverse = new st();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.bindMode = e2.bindMode, this.bindMatrix.copy(e2.bindMatrix), this.bindMatrixInverse.copy(e2.bindMatrixInverse), this.skeleton = e2.skeleton, this;
        }
        bind(e2, t2) {
          this.skeleton = e2, void 0 === t2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e2 = new Se(), t2 = this.geometry.attributes.skinWeight;
          for (let i2 = 0, n2 = t2.count; i2 < n2; i2++) {
            e2.fromBufferAttribute(t2, i2);
            const n3 = 1 / e2.manhattanLength();
            n3 !== 1 / 0 ? e2.multiplyScalar(n3) : e2.set(1, 0, 0, 0), t2.setXYZW(i2, e2.x, e2.y, e2.z, e2.w);
          }
        }
        updateMatrixWorld(e2) {
          super.updateMatrixWorld(e2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        boneTransform(e2, t2) {
          const i2 = this.skeleton, n2 = this.geometry;
          Ls.fromBufferAttribute(n2.attributes.skinIndex, e2), Is.fromBufferAttribute(n2.attributes.skinWeight, e2), Rs.copy(t2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
          for (let r2 = 0; r2 < 4; r2++) {
            const e3 = Is.getComponent(r2);
            if (0 !== e3) {
              const n3 = Ls.getComponent(r2);
              Fs.multiplyMatrices(i2.bones[n3].matrixWorld, i2.boneInverses[n3]), t2.addScaledVector(Ds.copy(Rs).applyMatrix4(Fs), e3);
            }
          }
          return t2.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class Us extends Rt {
        constructor() {
          super(), this.isBone = true, this.type = "Bone";
        }
      }
      class zs extends Me {
        constructor(e2 = null, t2 = 1, i2 = 1, n2, r2, s2, a2, o2, l2 = 1003, h2 = 1003, c2, u2) {
          super(null, s2, a2, o2, l2, h2, n2, r2, c2, u2), this.isDataTexture = true, this.image = { data: e2, width: t2, height: i2 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      const Ns = new st(), ks = new st();
      class Bs {
        constructor(e2 = [], t2 = []) {
          this.uuid = Y(), this.bones = e2.slice(0), this.boneInverses = t2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
        }
        init() {
          const e2 = this.bones, t2 = this.boneInverses;
          if (this.boneMatrices = new Float32Array(16 * e2.length), 0 === t2.length)
            this.calculateInverses();
          else if (e2.length !== t2.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let e3 = 0, t3 = this.bones.length; e3 < t3; e3++)
              this.boneInverses.push(new st());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
            const t3 = new st();
            this.bones[e2] && t3.copy(this.bones[e2].matrixWorld).invert(), this.boneInverses.push(t3);
          }
        }
        pose() {
          for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
            const t3 = this.bones[e2];
            t3 && t3.matrixWorld.copy(this.boneInverses[e2]).invert();
          }
          for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
            const t3 = this.bones[e2];
            t3 && (t3.parent && t3.parent.isBone ? (t3.matrix.copy(t3.parent.matrixWorld).invert(), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
          }
        }
        update() {
          const e2 = this.bones, t2 = this.boneInverses, i2 = this.boneMatrices, n2 = this.boneTexture;
          for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
            const n3 = e2[r2] ? e2[r2].matrixWorld : ks;
            Ns.multiplyMatrices(n3, t2[r2]), Ns.toArray(i2, 16 * r2);
          }
          null !== n2 && (n2.needsUpdate = true);
        }
        clone() {
          return new Bs(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e2 = Math.sqrt(4 * this.bones.length);
          e2 = $(e2), e2 = Math.max(e2, 4);
          const t2 = new Float32Array(e2 * e2 * 4);
          t2.set(this.boneMatrices);
          const i2 = new zs(t2, e2, e2, b, v);
          return i2.needsUpdate = true, this.boneMatrices = t2, this.boneTexture = i2, this.boneTextureSize = e2, this;
        }
        getBoneByName(e2) {
          for (let t2 = 0, i2 = this.bones.length; t2 < i2; t2++) {
            const i3 = this.bones[t2];
            if (i3.name === e2)
              return i3;
          }
        }
        dispose() {
          null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e2, t2) {
          this.uuid = e2.uuid;
          for (let i2 = 0, n2 = e2.bones.length; i2 < n2; i2++) {
            const n3 = e2.bones[i2];
            let r2 = t2[n3];
            void 0 === r2 && (console.warn("THREE.Skeleton: No bone found with UUID:", n3), r2 = new Us()), this.bones.push(r2), this.boneInverses.push(new st().fromArray(e2.boneInverses[i2]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
          e2.uuid = this.uuid;
          const t2 = this.bones, i2 = this.boneInverses;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            const r3 = t2[n2];
            e2.bones.push(r3.uuid);
            const s2 = i2[n2];
            e2.boneInverses.push(s2.toArray());
          }
          return e2;
        }
      }
      class Vs extends qt {
        constructor(e2, t2, i2, n2 = 1) {
          "number" == typeof i2 && (n2 = i2, i2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e2, t2, i2), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n2;
        }
        copy(e2) {
          return super.copy(e2), this.meshPerAttribute = e2.meshPerAttribute, this;
        }
        toJSON() {
          const e2 = super.toJSON();
          return e2.meshPerAttribute = this.meshPerAttribute, e2.isInstancedBufferAttribute = true, e2;
        }
      }
      const Gs = new st(), Hs = new st(), js = [], Ws = new Mi();
      class Xs extends Mi {
        constructor(e2, t2, i2) {
          super(e2, t2), this.isInstancedMesh = true, this.instanceMatrix = new Vs(new Float32Array(16 * i2), 16), this.instanceColor = null, this.count = i2, this.frustumCulled = false;
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.instanceMatrix.copy(e2.instanceMatrix), null !== e2.instanceColor && (this.instanceColor = e2.instanceColor.clone()), this.count = e2.count, this;
        }
        getColorAt(e2, t2) {
          t2.fromArray(this.instanceColor.array, 3 * e2);
        }
        getMatrixAt(e2, t2) {
          t2.fromArray(this.instanceMatrix.array, 16 * e2);
        }
        raycast(e2, t2) {
          const i2 = this.matrixWorld, n2 = this.count;
          if (Ws.geometry = this.geometry, Ws.material = this.material, void 0 !== Ws.material)
            for (let r2 = 0; r2 < n2; r2++) {
              this.getMatrixAt(r2, Gs), Hs.multiplyMatrices(i2, Gs), Ws.matrixWorld = Hs, Ws.raycast(e2, js);
              for (let e3 = 0, i3 = js.length; e3 < i3; e3++) {
                const i4 = js[e3];
                i4.instanceId = r2, i4.object = this, t2.push(i4);
              }
              js.length = 0;
            }
        }
        setColorAt(e2, t2) {
          null === this.instanceColor && (this.instanceColor = new Vs(new Float32Array(3 * this.instanceMatrix.count), 3)), t2.toArray(this.instanceColor.array, 3 * e2);
        }
        setMatrixAt(e2, t2) {
          t2.toArray(this.instanceMatrix.array, 16 * e2);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class qs extends Ht {
        constructor(e2) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new ge(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.linewidth = e2.linewidth, this.linecap = e2.linecap, this.linejoin = e2.linejoin, this.fog = e2.fog, this;
        }
      }
      const Ys = new Ae(), Zs = new Ae(), Js = new st(), Ks = new rt(), Qs = new Je();
      class $s extends Rt {
        constructor(e2 = new ri(), t2 = new qs()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = e2, this.material = t2, this.updateMorphTargets();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
        }
        computeLineDistances() {
          const e2 = this.geometry;
          if (null === e2.index) {
            const t2 = e2.attributes.position, i2 = [0];
            for (let e3 = 1, n2 = t2.count; e3 < n2; e3++)
              Ys.fromBufferAttribute(t2, e3 - 1), Zs.fromBufferAttribute(t2, e3), i2[e3] = i2[e3 - 1], i2[e3] += Ys.distanceTo(Zs);
            e2.setAttribute("lineDistance", new Jt(i2, 1));
          } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e2, t2) {
          const i2 = this.geometry, n2 = this.matrixWorld, r2 = e2.params.Line.threshold, s2 = i2.drawRange;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), Qs.copy(i2.boundingSphere), Qs.applyMatrix4(n2), Qs.radius += r2, false === e2.ray.intersectsSphere(Qs))
            return;
          Js.copy(n2).invert(), Ks.copy(e2.ray).applyMatrix4(Js);
          const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = a2 * a2, l2 = new Ae(), h2 = new Ae(), c2 = new Ae(), u2 = new Ae(), d2 = this.isLineSegments ? 2 : 1, p2 = i2.index, m2 = i2.attributes.position;
          if (null !== p2) {
            for (let i3 = Math.max(0, s2.start), n3 = Math.min(p2.count, s2.start + s2.count) - 1; i3 < n3; i3 += d2) {
              const n4 = p2.getX(i3), r3 = p2.getX(i3 + 1);
              l2.fromBufferAttribute(m2, n4), h2.fromBufferAttribute(m2, r3);
              if (Ks.distanceSqToSegment(l2, h2, u2, c2) > o2)
                continue;
              u2.applyMatrix4(this.matrixWorld);
              const s3 = e2.ray.origin.distanceTo(u2);
              s3 < e2.near || s3 > e2.far || t2.push({ distance: s3, point: c2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
            }
          } else {
            for (let i3 = Math.max(0, s2.start), n3 = Math.min(m2.count, s2.start + s2.count) - 1; i3 < n3; i3 += d2) {
              l2.fromBufferAttribute(m2, i3), h2.fromBufferAttribute(m2, i3 + 1);
              if (Ks.distanceSqToSegment(l2, h2, u2, c2) > o2)
                continue;
              u2.applyMatrix4(this.matrixWorld);
              const n4 = e2.ray.origin.distanceTo(u2);
              n4 < e2.near || n4 > e2.far || t2.push({ distance: n4, point: c2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
            }
          }
        }
        updateMorphTargets() {
          const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
          if (t2.length > 0) {
            const i2 = e2[t2[0]];
            if (void 0 !== i2) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
                const t4 = i2[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
              }
            }
          }
        }
      }
      const ea = new Ae(), ta = new Ae();
      class ia extends $s {
        constructor(e2, t2) {
          super(e2, t2), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const e2 = this.geometry;
          if (null === e2.index) {
            const t2 = e2.attributes.position, i2 = [];
            for (let e3 = 0, n2 = t2.count; e3 < n2; e3 += 2)
              ea.fromBufferAttribute(t2, e3), ta.fromBufferAttribute(t2, e3 + 1), i2[e3] = 0 === e3 ? 0 : i2[e3 - 1], i2[e3 + 1] = i2[e3] + ea.distanceTo(ta);
            e2.setAttribute("lineDistance", new Jt(i2, 1));
          } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class na extends $s {
        constructor(e2, t2) {
          super(e2, t2), this.isLineLoop = true, this.type = "LineLoop";
        }
      }
      class ra extends Ht {
        constructor(e2) {
          super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new ge(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.size = e2.size, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
        }
      }
      const sa = new st(), aa = new rt(), oa = new Je(), la = new Ae();
      class ha extends Rt {
        constructor(e2 = new ri(), t2 = new ra()) {
          super(), this.isPoints = true, this.type = "Points", this.geometry = e2, this.material = t2, this.updateMorphTargets();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.material = e2.material, this.geometry = e2.geometry, this;
        }
        raycast(e2, t2) {
          const i2 = this.geometry, n2 = this.matrixWorld, r2 = e2.params.Points.threshold, s2 = i2.drawRange;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), oa.copy(i2.boundingSphere), oa.applyMatrix4(n2), oa.radius += r2, false === e2.ray.intersectsSphere(oa))
            return;
          sa.copy(n2).invert(), aa.copy(e2.ray).applyMatrix4(sa);
          const a2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o2 = a2 * a2, l2 = i2.index, h2 = i2.attributes.position;
          if (null !== l2) {
            for (let i3 = Math.max(0, s2.start), r3 = Math.min(l2.count, s2.start + s2.count); i3 < r3; i3++) {
              const r4 = l2.getX(i3);
              la.fromBufferAttribute(h2, r4), ca(la, r4, o2, n2, e2, t2, this);
            }
          } else {
            for (let i3 = Math.max(0, s2.start), r3 = Math.min(h2.count, s2.start + s2.count); i3 < r3; i3++)
              la.fromBufferAttribute(h2, i3), ca(la, i3, o2, n2, e2, t2, this);
          }
        }
        updateMorphTargets() {
          const e2 = this.geometry.morphAttributes, t2 = Object.keys(e2);
          if (t2.length > 0) {
            const i2 = e2[t2[0]];
            if (void 0 !== i2) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e3 = 0, t3 = i2.length; e3 < t3; e3++) {
                const t4 = i2[e3].name || String(e3);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[t4] = e3;
              }
            }
          }
        }
      }
      function ca(e2, t2, i2, n2, r2, s2, a2) {
        const o2 = aa.distanceSqToPoint(e2);
        if (o2 < i2) {
          const i3 = new Ae();
          aa.closestPointToPoint(e2, i3), i3.applyMatrix4(n2);
          const l2 = r2.ray.origin.distanceTo(i3);
          if (l2 < r2.near || l2 > r2.far)
            return;
          s2.push({ distance: l2, distanceToRay: Math.sqrt(o2), point: i3, index: t2, face: null, object: a2 });
        }
      }
      class ua extends Me {
        constructor(e2, t2, i2) {
          super({ width: e2, height: t2 }), this.isFramebufferTexture = true, this.format = i2, this.magFilter = u, this.minFilter = u, this.generateMipmaps = false, this.needsUpdate = true;
        }
      }
      class da extends Me {
        constructor(e2, t2, i2, n2, r2, s2, a2, o2, l2) {
          super(e2, t2, i2, n2, r2, s2, a2, o2, l2), this.isCanvasTexture = true, this.needsUpdate = true;
        }
      }
      new Ae();
      class pa extends ri {
        constructor(e2 = 1, t2 = 1, i2 = 1, n2 = 8, r2 = 1, s2 = false, a2 = 0, o2 = 2 * Math.PI) {
          super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e2, radiusBottom: t2, height: i2, radialSegments: n2, heightSegments: r2, openEnded: s2, thetaStart: a2, thetaLength: o2 };
          const l2 = this;
          n2 = Math.floor(n2), r2 = Math.floor(r2);
          const h2 = [], c2 = [], u2 = [], d2 = [];
          let p2 = 0;
          const m2 = [], f2 = i2 / 2;
          let g2 = 0;
          function _2(i3) {
            const r3 = p2, s3 = new ie(), m3 = new Ae();
            let _3 = 0;
            const v2 = true === i3 ? e2 : t2, x2 = true === i3 ? 1 : -1;
            for (let e3 = 1; e3 <= n2; e3++)
              c2.push(0, f2 * x2, 0), u2.push(0, x2, 0), d2.push(0.5, 0.5), p2++;
            const y2 = p2;
            for (let e3 = 0; e3 <= n2; e3++) {
              const t3 = e3 / n2 * o2 + a2, i4 = Math.cos(t3), r4 = Math.sin(t3);
              m3.x = v2 * r4, m3.y = f2 * x2, m3.z = v2 * i4, c2.push(m3.x, m3.y, m3.z), u2.push(0, x2, 0), s3.x = 0.5 * i4 + 0.5, s3.y = 0.5 * r4 * x2 + 0.5, d2.push(s3.x, s3.y), p2++;
            }
            for (let e3 = 0; e3 < n2; e3++) {
              const t3 = r3 + e3, n3 = y2 + e3;
              true === i3 ? h2.push(n3, n3 + 1, t3) : h2.push(n3 + 1, n3, t3), _3 += 3;
            }
            l2.addGroup(g2, _3, true === i3 ? 1 : 2), g2 += _3;
          }
          !function() {
            const s3 = new Ae(), _3 = new Ae();
            let v2 = 0;
            const x2 = (t2 - e2) / i2;
            for (let l3 = 0; l3 <= r2; l3++) {
              const h3 = [], g3 = l3 / r2, v3 = g3 * (t2 - e2) + e2;
              for (let e3 = 0; e3 <= n2; e3++) {
                const t3 = e3 / n2, r3 = t3 * o2 + a2, l4 = Math.sin(r3), m3 = Math.cos(r3);
                _3.x = v3 * l4, _3.y = -g3 * i2 + f2, _3.z = v3 * m3, c2.push(_3.x, _3.y, _3.z), s3.set(l4, x2, m3).normalize(), u2.push(s3.x, s3.y, s3.z), d2.push(t3, 1 - g3), h3.push(p2++);
              }
              m2.push(h3);
            }
            for (let e3 = 0; e3 < n2; e3++)
              for (let t3 = 0; t3 < r2; t3++) {
                const i3 = m2[t3][e3], n3 = m2[t3 + 1][e3], r3 = m2[t3 + 1][e3 + 1], s4 = m2[t3][e3 + 1];
                h2.push(i3, n3, s4), h2.push(n3, r3, s4), v2 += 6;
              }
            l2.addGroup(g2, v2, 0), g2 += v2;
          }(), false === s2 && (e2 > 0 && _2(true), t2 > 0 && _2(false)), this.setIndex(h2), this.setAttribute("position", new Jt(c2, 3)), this.setAttribute("normal", new Jt(u2, 3)), this.setAttribute("uv", new Jt(d2, 2));
        }
        static fromJSON(e2) {
          return new pa(e2.radiusTop, e2.radiusBottom, e2.height, e2.radialSegments, e2.heightSegments, e2.openEnded, e2.thetaStart, e2.thetaLength);
        }
      }
      class ma extends ri {
        constructor(e2 = [], t2 = [], i2 = 1, n2 = 0) {
          super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e2, indices: t2, radius: i2, detail: n2 };
          const r2 = [], s2 = [];
          function a2(e3, t3, i3, n3) {
            const r3 = n3 + 1, s3 = [];
            for (let a3 = 0; a3 <= r3; a3++) {
              s3[a3] = [];
              const n4 = e3.clone().lerp(i3, a3 / r3), o3 = t3.clone().lerp(i3, a3 / r3), l3 = r3 - a3;
              for (let e4 = 0; e4 <= l3; e4++)
                s3[a3][e4] = 0 === e4 && a3 === r3 ? n4 : n4.clone().lerp(o3, e4 / l3);
            }
            for (let a3 = 0; a3 < r3; a3++)
              for (let e4 = 0; e4 < 2 * (r3 - a3) - 1; e4++) {
                const t4 = Math.floor(e4 / 2);
                e4 % 2 == 0 ? (o2(s3[a3][t4 + 1]), o2(s3[a3 + 1][t4]), o2(s3[a3][t4])) : (o2(s3[a3][t4 + 1]), o2(s3[a3 + 1][t4 + 1]), o2(s3[a3 + 1][t4]));
              }
          }
          function o2(e3) {
            r2.push(e3.x, e3.y, e3.z);
          }
          function l2(t3, i3) {
            const n3 = 3 * t3;
            i3.x = e2[n3 + 0], i3.y = e2[n3 + 1], i3.z = e2[n3 + 2];
          }
          function h2(e3, t3, i3, n3) {
            n3 < 0 && 1 === e3.x && (s2[t3] = e3.x - 1), 0 === i3.x && 0 === i3.z && (s2[t3] = n3 / 2 / Math.PI + 0.5);
          }
          function c2(e3) {
            return Math.atan2(e3.z, -e3.x);
          }
          !function(e3) {
            const i3 = new Ae(), n3 = new Ae(), r3 = new Ae();
            for (let s3 = 0; s3 < t2.length; s3 += 3)
              l2(t2[s3 + 0], i3), l2(t2[s3 + 1], n3), l2(t2[s3 + 2], r3), a2(i3, n3, r3, e3);
          }(n2), function(e3) {
            const t3 = new Ae();
            for (let i3 = 0; i3 < r2.length; i3 += 3)
              t3.x = r2[i3 + 0], t3.y = r2[i3 + 1], t3.z = r2[i3 + 2], t3.normalize().multiplyScalar(e3), r2[i3 + 0] = t3.x, r2[i3 + 1] = t3.y, r2[i3 + 2] = t3.z;
          }(i2), function() {
            const e3 = new Ae();
            for (let i3 = 0; i3 < r2.length; i3 += 3) {
              e3.x = r2[i3 + 0], e3.y = r2[i3 + 1], e3.z = r2[i3 + 2];
              const n3 = c2(e3) / 2 / Math.PI + 0.5, a3 = (t3 = e3, Math.atan2(-t3.y, Math.sqrt(t3.x * t3.x + t3.z * t3.z)) / Math.PI + 0.5);
              s2.push(n3, 1 - a3);
            }
            var t3;
            (function() {
              const e4 = new Ae(), t4 = new Ae(), i3 = new Ae(), n3 = new Ae(), a3 = new ie(), o3 = new ie(), l3 = new ie();
              for (let u2 = 0, d2 = 0; u2 < r2.length; u2 += 9, d2 += 6) {
                e4.set(r2[u2 + 0], r2[u2 + 1], r2[u2 + 2]), t4.set(r2[u2 + 3], r2[u2 + 4], r2[u2 + 5]), i3.set(r2[u2 + 6], r2[u2 + 7], r2[u2 + 8]), a3.set(s2[d2 + 0], s2[d2 + 1]), o3.set(s2[d2 + 2], s2[d2 + 3]), l3.set(s2[d2 + 4], s2[d2 + 5]), n3.copy(e4).add(t4).add(i3).divideScalar(3);
                const p2 = c2(n3);
                h2(a3, d2 + 0, e4, p2), h2(o3, d2 + 2, t4, p2), h2(l3, d2 + 4, i3, p2);
              }
            })(), function() {
              for (let e4 = 0; e4 < s2.length; e4 += 6) {
                const t4 = s2[e4 + 0], i3 = s2[e4 + 2], n3 = s2[e4 + 4], r3 = Math.max(t4, i3, n3), a3 = Math.min(t4, i3, n3);
                r3 > 0.9 && a3 < 0.1 && (t4 < 0.2 && (s2[e4 + 0] += 1), i3 < 0.2 && (s2[e4 + 2] += 1), n3 < 0.2 && (s2[e4 + 4] += 1));
              }
            }();
          }(), this.setAttribute("position", new Jt(r2, 3)), this.setAttribute("normal", new Jt(r2.slice(), 3)), this.setAttribute("uv", new Jt(s2, 2)), 0 === n2 ? this.computeVertexNormals() : this.normalizeNormals();
        }
        static fromJSON(e2) {
          return new ma(e2.vertices, e2.indices, e2.radius, e2.details);
        }
      }
      new Ae(), new Ae(), new Ae(), new Vt();
      class fa extends ma {
        constructor(e2 = 1, t2 = 0) {
          super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e2, t2), this.type = "OctahedronGeometry", this.parameters = { radius: e2, detail: t2 };
        }
        static fromJSON(e2) {
          return new fa(e2.radius, e2.detail);
        }
      }
      class ga extends ri {
        constructor(e2 = 1, t2 = 32, i2 = 16, n2 = 0, r2 = 2 * Math.PI, s2 = 0, a2 = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = { radius: e2, widthSegments: t2, heightSegments: i2, phiStart: n2, phiLength: r2, thetaStart: s2, thetaLength: a2 }, t2 = Math.max(3, Math.floor(t2)), i2 = Math.max(2, Math.floor(i2));
          const o2 = Math.min(s2 + a2, Math.PI);
          let l2 = 0;
          const h2 = [], c2 = new Ae(), u2 = new Ae(), d2 = [], p2 = [], m2 = [], f2 = [];
          for (let g2 = 0; g2 <= i2; g2++) {
            const d3 = [], _2 = g2 / i2;
            let v2 = 0;
            0 == g2 && 0 == s2 ? v2 = 0.5 / t2 : g2 == i2 && o2 == Math.PI && (v2 = -0.5 / t2);
            for (let i3 = 0; i3 <= t2; i3++) {
              const o3 = i3 / t2;
              c2.x = -e2 * Math.cos(n2 + o3 * r2) * Math.sin(s2 + _2 * a2), c2.y = e2 * Math.cos(s2 + _2 * a2), c2.z = e2 * Math.sin(n2 + o3 * r2) * Math.sin(s2 + _2 * a2), p2.push(c2.x, c2.y, c2.z), u2.copy(c2).normalize(), m2.push(u2.x, u2.y, u2.z), f2.push(o3 + v2, 1 - _2), d3.push(l2++);
            }
            h2.push(d3);
          }
          for (let g2 = 0; g2 < i2; g2++)
            for (let e3 = 0; e3 < t2; e3++) {
              const t3 = h2[g2][e3 + 1], n3 = h2[g2][e3], r3 = h2[g2 + 1][e3], a3 = h2[g2 + 1][e3 + 1];
              (0 !== g2 || s2 > 0) && d2.push(t3, n3, a3), (g2 !== i2 - 1 || o2 < Math.PI) && d2.push(n3, r3, a3);
            }
          this.setIndex(d2), this.setAttribute("position", new Jt(p2, 3)), this.setAttribute("normal", new Jt(m2, 3)), this.setAttribute("uv", new Jt(f2, 2));
        }
        static fromJSON(e2) {
          return new ga(e2.radius, e2.widthSegments, e2.heightSegments, e2.phiStart, e2.phiLength, e2.thetaStart, e2.thetaLength);
        }
      }
      class _a extends ri {
        constructor(e2 = 1, t2 = 0.4, i2 = 8, n2 = 6, r2 = 2 * Math.PI) {
          super(), this.type = "TorusGeometry", this.parameters = { radius: e2, tube: t2, radialSegments: i2, tubularSegments: n2, arc: r2 }, i2 = Math.floor(i2), n2 = Math.floor(n2);
          const s2 = [], a2 = [], o2 = [], l2 = [], h2 = new Ae(), c2 = new Ae(), u2 = new Ae();
          for (let d2 = 0; d2 <= i2; d2++)
            for (let s3 = 0; s3 <= n2; s3++) {
              const p2 = s3 / n2 * r2, m2 = d2 / i2 * Math.PI * 2;
              c2.x = (e2 + t2 * Math.cos(m2)) * Math.cos(p2), c2.y = (e2 + t2 * Math.cos(m2)) * Math.sin(p2), c2.z = t2 * Math.sin(m2), a2.push(c2.x, c2.y, c2.z), h2.x = e2 * Math.cos(p2), h2.y = e2 * Math.sin(p2), u2.subVectors(c2, h2).normalize(), o2.push(u2.x, u2.y, u2.z), l2.push(s3 / n2), l2.push(d2 / i2);
            }
          for (let d2 = 1; d2 <= i2; d2++)
            for (let e3 = 1; e3 <= n2; e3++) {
              const t3 = (n2 + 1) * d2 + e3 - 1, i3 = (n2 + 1) * (d2 - 1) + e3 - 1, r3 = (n2 + 1) * (d2 - 1) + e3, a3 = (n2 + 1) * d2 + e3;
              s2.push(t3, i3, a3), s2.push(i3, r3, a3);
            }
          this.setIndex(s2), this.setAttribute("position", new Jt(a2, 3)), this.setAttribute("normal", new Jt(o2, 3)), this.setAttribute("uv", new Jt(l2, 2));
        }
        static fromJSON(e2) {
          return new _a(e2.radius, e2.tube, e2.radialSegments, e2.tubularSegments, e2.arc);
        }
      }
      class va extends Ai {
        constructor(e2) {
          super(e2), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
        }
      }
      class xa extends Ht {
        constructor(e2) {
          super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new ge(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.defines = { STANDARD: "" }, this.color.copy(e2.color), this.roughness = e2.roughness, this.metalness = e2.metalness, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.roughnessMap = e2.roughnessMap, this.metalnessMap = e2.metalnessMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.envMapIntensity = e2.envMapIntensity, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
        }
      }
      class ya extends xa {
        constructor(e2) {
          super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ie(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
            return Z(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          }, set: function(e3) {
            this.ior = (1 + 0.4 * e3) / (1 - 0.4 * e3);
          } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ge(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new ge(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ge(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e2);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e2) {
          this._sheen > 0 != e2 > 0 && this.version++, this._sheen = e2;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e2) {
          this._clearcoat > 0 != e2 > 0 && this.version++, this._clearcoat = e2;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e2) {
          this._iridescence > 0 != e2 > 0 && this.version++, this._iridescence = e2;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e2) {
          this._transmission > 0 != e2 > 0 && this.version++, this._transmission = e2;
        }
        copy(e2) {
          return super.copy(e2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e2.clearcoat, this.clearcoatMap = e2.clearcoatMap, this.clearcoatRoughness = e2.clearcoatRoughness, this.clearcoatRoughnessMap = e2.clearcoatRoughnessMap, this.clearcoatNormalMap = e2.clearcoatNormalMap, this.clearcoatNormalScale.copy(e2.clearcoatNormalScale), this.ior = e2.ior, this.iridescence = e2.iridescence, this.iridescenceMap = e2.iridescenceMap, this.iridescenceIOR = e2.iridescenceIOR, this.iridescenceThicknessRange = [...e2.iridescenceThicknessRange], this.iridescenceThicknessMap = e2.iridescenceThicknessMap, this.sheen = e2.sheen, this.sheenColor.copy(e2.sheenColor), this.sheenColorMap = e2.sheenColorMap, this.sheenRoughness = e2.sheenRoughness, this.sheenRoughnessMap = e2.sheenRoughnessMap, this.transmission = e2.transmission, this.transmissionMap = e2.transmissionMap, this.thickness = e2.thickness, this.thicknessMap = e2.thicknessMap, this.attenuationDistance = e2.attenuationDistance, this.attenuationColor.copy(e2.attenuationColor), this.specularIntensity = e2.specularIntensity, this.specularIntensityMap = e2.specularIntensityMap, this.specularColor.copy(e2.specularColor), this.specularColorMap = e2.specularColorMap, this;
        }
      }
      class ba extends Ht {
        constructor(e2) {
          super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new ge(16777215), this.specular = new ge(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.specular.copy(e2.specular), this.shininess = e2.shininess, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
        }
      }
      const Ma = { ShadowMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new ge(0), this.transparent = true, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.fog = e2.fog, this;
        }
      }, SpriteMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new ge(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.rotation = e2.rotation, this.sizeAttenuation = e2.sizeAttenuation, this.fog = e2.fog, this;
        }
      }, RawShaderMaterial: va, ShaderMaterial: Ai, PointsMaterial: ra, MeshPhysicalMaterial: ya, MeshStandardMaterial: xa, MeshPhongMaterial: ba, MeshToonMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ge(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.gradientMap = e2.gradientMap, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
        }
      }, MeshNormalMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.flatShading = e2.flatShading, this;
        }
      }, MeshLambertMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new ge(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.fog = e2.fog, this;
        }
      }, MeshDepthMaterial: us, MeshDistanceMaterial: ds, MeshBasicMaterial: jt, MeshMatcapMaterial: class extends Ht {
        constructor(e2) {
          super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ge(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.defines = { MATCAP: "" }, this.color.copy(e2.color), this.matcap = e2.matcap, this.map = e2.map, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.alphaMap = e2.alphaMap, this.flatShading = e2.flatShading, this.fog = e2.fog, this;
        }
      }, LineDashedMaterial: class extends qs {
        constructor(e2) {
          super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.scale = e2.scale, this.dashSize = e2.dashSize, this.gapSize = e2.gapSize, this;
        }
      }, LineBasicMaterial: qs, Material: Ht };
      Ht.fromType = function(e2) {
        return new Ma[e2]();
      };
      const Sa = { arraySlice: function(e2, t2, i2) {
        return Sa.isTypedArray(e2) ? new e2.constructor(e2.subarray(t2, void 0 !== i2 ? i2 : e2.length)) : e2.slice(t2, i2);
      }, convertArray: function(e2, t2, i2) {
        return !e2 || !i2 && e2.constructor === t2 ? e2 : "number" == typeof t2.BYTES_PER_ELEMENT ? new t2(e2) : Array.prototype.slice.call(e2);
      }, isTypedArray: function(e2) {
        return ArrayBuffer.isView(e2) && !(e2 instanceof DataView);
      }, getKeyframeOrder: function(e2) {
        const t2 = e2.length, i2 = new Array(t2);
        for (let n2 = 0; n2 !== t2; ++n2)
          i2[n2] = n2;
        return i2.sort(function(t3, i3) {
          return e2[t3] - e2[i3];
        }), i2;
      }, sortedArray: function(e2, t2, i2) {
        const n2 = e2.length, r2 = new e2.constructor(n2);
        for (let s2 = 0, a2 = 0; a2 !== n2; ++s2) {
          const n3 = i2[s2] * t2;
          for (let i3 = 0; i3 !== t2; ++i3)
            r2[a2++] = e2[n3 + i3];
        }
        return r2;
      }, flattenJSON: function(e2, t2, i2, n2) {
        let r2 = 1, s2 = e2[0];
        for (; void 0 !== s2 && void 0 === s2[n2]; )
          s2 = e2[r2++];
        if (void 0 === s2)
          return;
        let a2 = s2[n2];
        if (void 0 !== a2)
          if (Array.isArray(a2))
            do {
              a2 = s2[n2], void 0 !== a2 && (t2.push(s2.time), i2.push.apply(i2, a2)), s2 = e2[r2++];
            } while (void 0 !== s2);
          else if (void 0 !== a2.toArray)
            do {
              a2 = s2[n2], void 0 !== a2 && (t2.push(s2.time), a2.toArray(i2, i2.length)), s2 = e2[r2++];
            } while (void 0 !== s2);
          else
            do {
              a2 = s2[n2], void 0 !== a2 && (t2.push(s2.time), i2.push(a2)), s2 = e2[r2++];
            } while (void 0 !== s2);
      }, subclip: function(e2, t2, i2, n2, r2 = 30) {
        const s2 = e2.clone();
        s2.name = t2;
        const a2 = [];
        for (let l2 = 0; l2 < s2.tracks.length; ++l2) {
          const e3 = s2.tracks[l2], t3 = e3.getValueSize(), o3 = [], h2 = [];
          for (let s3 = 0; s3 < e3.times.length; ++s3) {
            const a3 = e3.times[s3] * r2;
            if (!(a3 < i2 || a3 >= n2)) {
              o3.push(e3.times[s3]);
              for (let i3 = 0; i3 < t3; ++i3)
                h2.push(e3.values[s3 * t3 + i3]);
            }
          }
          0 !== o3.length && (e3.times = Sa.convertArray(o3, e3.times.constructor), e3.values = Sa.convertArray(h2, e3.values.constructor), a2.push(e3));
        }
        s2.tracks = a2;
        let o2 = 1 / 0;
        for (let l2 = 0; l2 < s2.tracks.length; ++l2)
          o2 > s2.tracks[l2].times[0] && (o2 = s2.tracks[l2].times[0]);
        for (let l2 = 0; l2 < s2.tracks.length; ++l2)
          s2.tracks[l2].shift(-1 * o2);
        return s2.resetDuration(), s2;
      }, makeClipAdditive: function(e2, t2 = 0, i2 = e2, n2 = 30) {
        n2 <= 0 && (n2 = 30);
        const r2 = i2.tracks.length, s2 = t2 / n2;
        for (let a2 = 0; a2 < r2; ++a2) {
          const t3 = i2.tracks[a2], n3 = t3.ValueTypeName;
          if ("bool" === n3 || "string" === n3)
            continue;
          const r3 = e2.tracks.find(function(e3) {
            return e3.name === t3.name && e3.ValueTypeName === n3;
          });
          if (void 0 === r3)
            continue;
          let o2 = 0;
          const l2 = t3.getValueSize();
          t3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o2 = l2 / 3);
          let h2 = 0;
          const c2 = r3.getValueSize();
          r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h2 = c2 / 3);
          const u2 = t3.times.length - 1;
          let d2;
          if (s2 <= t3.times[0]) {
            const e3 = o2, i3 = l2 - o2;
            d2 = Sa.arraySlice(t3.values, e3, i3);
          } else if (s2 >= t3.times[u2]) {
            const e3 = u2 * l2 + o2, i3 = e3 + l2 - o2;
            d2 = Sa.arraySlice(t3.values, e3, i3);
          } else {
            const e3 = t3.createInterpolant(), i3 = o2, n4 = l2 - o2;
            e3.evaluate(s2), d2 = Sa.arraySlice(e3.resultBuffer, i3, n4);
          }
          if ("quaternion" === n3) {
            new Ce().fromArray(d2).normalize().conjugate().toArray(d2);
          }
          const p2 = r3.times.length;
          for (let e3 = 0; e3 < p2; ++e3) {
            const t4 = e3 * c2 + h2;
            if ("quaternion" === n3)
              Ce.multiplyQuaternionsFlat(r3.values, t4, d2, 0, r3.values, t4);
            else {
              const e4 = c2 - 2 * h2;
              for (let i3 = 0; i3 < e4; ++i3)
                r3.values[t4 + i3] -= d2[i3];
            }
          }
        }
        return e2.blendMode = 2501, e2;
      } };
      class wa {
        constructor(e2, t2, i2, n2) {
          this.parameterPositions = e2, this._cachedIndex = 0, this.resultBuffer = void 0 !== n2 ? n2 : new t2.constructor(i2), this.sampleValues = t2, this.valueSize = i2, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e2) {
          const t2 = this.parameterPositions;
          let i2 = this._cachedIndex, n2 = t2[i2], r2 = t2[i2 - 1];
          e: {
            t: {
              let s2;
              i: {
                n:
                  if (!(e2 < n2)) {
                    for (let s3 = i2 + 2; ; ) {
                      if (void 0 === n2) {
                        if (e2 < r2)
                          break n;
                        return i2 = t2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
                      }
                      if (i2 === s3)
                        break;
                      if (r2 = n2, n2 = t2[++i2], e2 < n2)
                        break t;
                    }
                    s2 = t2.length;
                    break i;
                  }
                if (e2 >= r2)
                  break e;
                {
                  const a2 = t2[1];
                  e2 < a2 && (i2 = 2, r2 = a2);
                  for (let s3 = i2 - 2; ; ) {
                    if (void 0 === r2)
                      return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i2 === s3)
                      break;
                    if (n2 = r2, r2 = t2[--i2 - 1], e2 >= r2)
                      break t;
                  }
                  s2 = i2, i2 = 0;
                }
              }
              for (; i2 < s2; ) {
                const n3 = i2 + s2 >>> 1;
                e2 < t2[n3] ? s2 = n3 : i2 = n3 + 1;
              }
              if (n2 = t2[i2], r2 = t2[i2 - 1], void 0 === r2)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (void 0 === n2)
                return i2 = t2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
            }
            this._cachedIndex = i2, this.intervalChanged_(i2, r2, n2);
          }
          return this.interpolate_(i2, r2, e2, n2);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e2) {
          const t2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = e2 * n2;
          for (let s2 = 0; s2 !== n2; ++s2)
            t2[s2] = i2[r2 + s2];
          return t2;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      class Ta extends wa {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: L, endingEnd: L };
        }
        intervalChanged_(e2, t2, i2) {
          const n2 = this.parameterPositions;
          let r2 = e2 - 2, s2 = e2 + 1, a2 = n2[r2], o2 = n2[s2];
          if (void 0 === a2)
            switch (this.getSettings_().endingStart) {
              case I:
                r2 = e2, a2 = 2 * t2 - i2;
                break;
              case D:
                r2 = n2.length - 2, a2 = t2 + n2[r2] - n2[r2 + 1];
                break;
              default:
                r2 = e2, a2 = i2;
            }
          if (void 0 === o2)
            switch (this.getSettings_().endingEnd) {
              case I:
                s2 = e2, o2 = 2 * i2 - t2;
                break;
              case D:
                s2 = 1, o2 = i2 + n2[1] - n2[0];
                break;
              default:
                s2 = e2 - 1, o2 = t2;
            }
          const l2 = 0.5 * (i2 - t2), h2 = this.valueSize;
          this._weightPrev = l2 / (t2 - a2), this._weightNext = l2 / (o2 - i2), this._offsetPrev = r2 * h2, this._offsetNext = s2 * h2;
        }
        interpolate_(e2, t2, i2, n2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = e2 * a2, l2 = o2 - a2, h2 = this._offsetPrev, c2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (i2 - t2) / (n2 - t2), m2 = p2 * p2, f2 = m2 * p2, g2 = -u2 * f2 + 2 * u2 * m2 - u2 * p2, _2 = (1 + u2) * f2 + (-1.5 - 2 * u2) * m2 + (-0.5 + u2) * p2 + 1, v2 = (-1 - d2) * f2 + (1.5 + d2) * m2 + 0.5 * p2, x2 = d2 * f2 - d2 * m2;
          for (let y2 = 0; y2 !== a2; ++y2)
            r2[y2] = g2 * s2[h2 + y2] + _2 * s2[l2 + y2] + v2 * s2[o2 + y2] + x2 * s2[c2 + y2];
          return r2;
        }
      }
      class Ea extends wa {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2);
        }
        interpolate_(e2, t2, i2, n2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = e2 * a2, l2 = o2 - a2, h2 = (i2 - t2) / (n2 - t2), c2 = 1 - h2;
          for (let u2 = 0; u2 !== a2; ++u2)
            r2[u2] = s2[l2 + u2] * c2 + s2[o2 + u2] * h2;
          return r2;
        }
      }
      class Ca extends wa {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2);
        }
        interpolate_(e2) {
          return this.copySampleValue_(e2 - 1);
        }
      }
      class Aa {
        constructor(e2, t2, i2, n2) {
          if (void 0 === e2)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t2 || 0 === t2.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e2);
          this.name = e2, this.times = Sa.convertArray(t2, this.TimeBufferType), this.values = Sa.convertArray(i2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
        }
        static toJSON(e2) {
          const t2 = e2.constructor;
          let i2;
          if (t2.toJSON !== this.toJSON)
            i2 = t2.toJSON(e2);
          else {
            i2 = { name: e2.name, times: Sa.convertArray(e2.times, Array), values: Sa.convertArray(e2.values, Array) };
            const t3 = e2.getInterpolation();
            t3 !== e2.DefaultInterpolation && (i2.interpolation = t3);
          }
          return i2.type = e2.ValueTypeName, i2;
        }
        InterpolantFactoryMethodDiscrete(e2) {
          return new Ca(this.times, this.values, this.getValueSize(), e2);
        }
        InterpolantFactoryMethodLinear(e2) {
          return new Ea(this.times, this.values, this.getValueSize(), e2);
        }
        InterpolantFactoryMethodSmooth(e2) {
          return new Ta(this.times, this.values, this.getValueSize(), e2);
        }
        setInterpolation(e2) {
          let t2;
          switch (e2) {
            case A:
              t2 = this.InterpolantFactoryMethodDiscrete;
              break;
            case P:
              t2 = this.InterpolantFactoryMethodLinear;
              break;
            case R:
              t2 = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t2) {
            const t3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
              if (e2 === this.DefaultInterpolation)
                throw new Error(t3);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", t3), this;
          }
          return this.createInterpolant = t2, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return A;
            case this.InterpolantFactoryMethodLinear:
              return P;
            case this.InterpolantFactoryMethodSmooth:
              return R;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e2) {
          if (0 !== e2) {
            const t2 = this.times;
            for (let i2 = 0, n2 = t2.length; i2 !== n2; ++i2)
              t2[i2] += e2;
          }
          return this;
        }
        scale(e2) {
          if (1 !== e2) {
            const t2 = this.times;
            for (let i2 = 0, n2 = t2.length; i2 !== n2; ++i2)
              t2[i2] *= e2;
          }
          return this;
        }
        trim(e2, t2) {
          const i2 = this.times, n2 = i2.length;
          let r2 = 0, s2 = n2 - 1;
          for (; r2 !== n2 && i2[r2] < e2; )
            ++r2;
          for (; -1 !== s2 && i2[s2] > t2; )
            --s2;
          if (++s2, 0 !== r2 || s2 !== n2) {
            r2 >= s2 && (s2 = Math.max(s2, 1), r2 = s2 - 1);
            const e3 = this.getValueSize();
            this.times = Sa.arraySlice(i2, r2, s2), this.values = Sa.arraySlice(this.values, r2 * e3, s2 * e3);
          }
          return this;
        }
        validate() {
          let e2 = true;
          const t2 = this.getValueSize();
          t2 - Math.floor(t2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e2 = false);
          const i2 = this.times, n2 = this.values, r2 = i2.length;
          0 === r2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e2 = false);
          let s2 = null;
          for (let a2 = 0; a2 !== r2; a2++) {
            const t3 = i2[a2];
            if ("number" == typeof t3 && isNaN(t3)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a2, t3), e2 = false;
              break;
            }
            if (null !== s2 && s2 > t3) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, a2, t3, s2), e2 = false;
              break;
            }
            s2 = t3;
          }
          if (void 0 !== n2 && Sa.isTypedArray(n2))
            for (let a2 = 0, o2 = n2.length; a2 !== o2; ++a2) {
              const t3 = n2[a2];
              if (isNaN(t3)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a2, t3), e2 = false;
                break;
              }
            }
          return e2;
        }
        optimize() {
          const e2 = Sa.arraySlice(this.times), t2 = Sa.arraySlice(this.values), i2 = this.getValueSize(), n2 = this.getInterpolation() === R, r2 = e2.length - 1;
          let s2 = 1;
          for (let a2 = 1; a2 < r2; ++a2) {
            let r3 = false;
            const o2 = e2[a2];
            if (o2 !== e2[a2 + 1] && (1 !== a2 || o2 !== e2[0]))
              if (n2)
                r3 = true;
              else {
                const e3 = a2 * i2, n3 = e3 - i2, s3 = e3 + i2;
                for (let a3 = 0; a3 !== i2; ++a3) {
                  const i3 = t2[e3 + a3];
                  if (i3 !== t2[n3 + a3] || i3 !== t2[s3 + a3]) {
                    r3 = true;
                    break;
                  }
                }
              }
            if (r3) {
              if (a2 !== s2) {
                e2[s2] = e2[a2];
                const n3 = a2 * i2, r4 = s2 * i2;
                for (let e3 = 0; e3 !== i2; ++e3)
                  t2[r4 + e3] = t2[n3 + e3];
              }
              ++s2;
            }
          }
          if (r2 > 0) {
            e2[s2] = e2[r2];
            for (let e3 = r2 * i2, n3 = s2 * i2, a2 = 0; a2 !== i2; ++a2)
              t2[n3 + a2] = t2[e3 + a2];
            ++s2;
          }
          return s2 !== e2.length ? (this.times = Sa.arraySlice(e2, 0, s2), this.values = Sa.arraySlice(t2, 0, s2 * i2)) : (this.times = e2, this.values = t2), this;
        }
        clone() {
          const e2 = Sa.arraySlice(this.times, 0), t2 = Sa.arraySlice(this.values, 0), i2 = new (0, this.constructor)(this.name, e2, t2);
          return i2.createInterpolant = this.createInterpolant, i2;
        }
      }
      Aa.prototype.TimeBufferType = Float32Array, Aa.prototype.ValueBufferType = Float32Array, Aa.prototype.DefaultInterpolation = P;
      class Pa extends Aa {
      }
      Pa.prototype.ValueTypeName = "bool", Pa.prototype.ValueBufferType = Array, Pa.prototype.DefaultInterpolation = A, Pa.prototype.InterpolantFactoryMethodLinear = void 0, Pa.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Ra extends Aa {
      }
      Ra.prototype.ValueTypeName = "color";
      class La extends Aa {
      }
      La.prototype.ValueTypeName = "number";
      class Ia extends wa {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2);
        }
        interpolate_(e2, t2, i2, n2) {
          const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = (i2 - t2) / (n2 - t2);
          let l2 = e2 * a2;
          for (let h2 = l2 + a2; l2 !== h2; l2 += 4)
            Ce.slerpFlat(r2, 0, s2, l2 - a2, s2, l2, o2);
          return r2;
        }
      }
      class Da extends Aa {
        InterpolantFactoryMethodLinear(e2) {
          return new Ia(this.times, this.values, this.getValueSize(), e2);
        }
      }
      Da.prototype.ValueTypeName = "quaternion", Da.prototype.DefaultInterpolation = P, Da.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Fa extends Aa {
      }
      Fa.prototype.ValueTypeName = "string", Fa.prototype.ValueBufferType = Array, Fa.prototype.DefaultInterpolation = A, Fa.prototype.InterpolantFactoryMethodLinear = void 0, Fa.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Oa extends Aa {
      }
      Oa.prototype.ValueTypeName = "vector";
      class Ua {
        constructor(e2, t2 = -1, i2, n2 = 2500) {
          this.name = e2, this.tracks = i2, this.duration = t2, this.blendMode = n2, this.uuid = Y(), this.duration < 0 && this.resetDuration();
        }
        static parse(e2) {
          const t2 = [], i2 = e2.tracks, n2 = 1 / (e2.fps || 1);
          for (let s2 = 0, a2 = i2.length; s2 !== a2; ++s2)
            t2.push(za(i2[s2]).scale(n2));
          const r2 = new this(e2.name, e2.duration, t2, e2.blendMode);
          return r2.uuid = e2.uuid, r2;
        }
        static toJSON(e2) {
          const t2 = [], i2 = e2.tracks, n2 = { name: e2.name, duration: e2.duration, tracks: t2, uuid: e2.uuid, blendMode: e2.blendMode };
          for (let r2 = 0, s2 = i2.length; r2 !== s2; ++r2)
            t2.push(Aa.toJSON(i2[r2]));
          return n2;
        }
        static CreateFromMorphTargetSequence(e2, t2, i2, n2) {
          const r2 = t2.length, s2 = [];
          for (let a2 = 0; a2 < r2; a2++) {
            let e3 = [], o2 = [];
            e3.push((a2 + r2 - 1) % r2, a2, (a2 + 1) % r2), o2.push(0, 1, 0);
            const l2 = Sa.getKeyframeOrder(e3);
            e3 = Sa.sortedArray(e3, 1, l2), o2 = Sa.sortedArray(o2, 1, l2), n2 || 0 !== e3[0] || (e3.push(r2), o2.push(o2[0])), s2.push(new La(".morphTargetInfluences[" + t2[a2].name + "]", e3, o2).scale(1 / i2));
          }
          return new this(e2, -1, s2);
        }
        static findByName(e2, t2) {
          let i2 = e2;
          if (!Array.isArray(e2)) {
            const t3 = e2;
            i2 = t3.geometry && t3.geometry.animations || t3.animations;
          }
          for (let n2 = 0; n2 < i2.length; n2++)
            if (i2[n2].name === t2)
              return i2[n2];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e2, t2, i2) {
          const n2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
          for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
            const t3 = e2[a2], i3 = t3.name.match(r2);
            if (i3 && i3.length > 1) {
              const e3 = i3[1];
              let r3 = n2[e3];
              r3 || (n2[e3] = r3 = []), r3.push(t3);
            }
          }
          const s2 = [];
          for (const a2 in n2)
            s2.push(this.CreateFromMorphTargetSequence(a2, n2[a2], t2, i2));
          return s2;
        }
        static parseAnimation(e2, t2) {
          if (!e2)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i2 = function(e3, t3, i3, n3, r3) {
            if (0 !== i3.length) {
              const s3 = [], a3 = [];
              Sa.flattenJSON(i3, s3, a3, n3), 0 !== s3.length && r3.push(new e3(t3, s3, a3));
            }
          }, n2 = [], r2 = e2.name || "default", s2 = e2.fps || 30, a2 = e2.blendMode;
          let o2 = e2.length || -1;
          const l2 = e2.hierarchy || [];
          for (let h2 = 0; h2 < l2.length; h2++) {
            const e3 = l2[h2].keys;
            if (e3 && 0 !== e3.length)
              if (e3[0].morphTargets) {
                const t3 = {};
                let i3;
                for (i3 = 0; i3 < e3.length; i3++)
                  if (e3[i3].morphTargets)
                    for (let n3 = 0; n3 < e3[i3].morphTargets.length; n3++)
                      t3[e3[i3].morphTargets[n3]] = -1;
                for (const r3 in t3) {
                  const t4 = [], s3 = [];
                  for (let n3 = 0; n3 !== e3[i3].morphTargets.length; ++n3) {
                    const n4 = e3[i3];
                    t4.push(n4.time), s3.push(n4.morphTarget === r3 ? 1 : 0);
                  }
                  n2.push(new La(".morphTargetInfluence[" + r3 + "]", t4, s3));
                }
                o2 = t3.length * s2;
              } else {
                const r3 = ".bones[" + t2[h2].name + "]";
                i2(Oa, r3 + ".position", e3, "pos", n2), i2(Da, r3 + ".quaternion", e3, "rot", n2), i2(Oa, r3 + ".scale", e3, "scl", n2);
              }
          }
          if (0 === n2.length)
            return null;
          return new this(r2, o2, n2, a2);
        }
        resetDuration() {
          let e2 = 0;
          for (let t2 = 0, i2 = this.tracks.length; t2 !== i2; ++t2) {
            const i3 = this.tracks[t2];
            e2 = Math.max(e2, i3.times[i3.times.length - 1]);
          }
          return this.duration = e2, this;
        }
        trim() {
          for (let e2 = 0; e2 < this.tracks.length; e2++)
            this.tracks[e2].trim(0, this.duration);
          return this;
        }
        validate() {
          let e2 = true;
          for (let t2 = 0; t2 < this.tracks.length; t2++)
            e2 = e2 && this.tracks[t2].validate();
          return e2;
        }
        optimize() {
          for (let e2 = 0; e2 < this.tracks.length; e2++)
            this.tracks[e2].optimize();
          return this;
        }
        clone() {
          const e2 = [];
          for (let t2 = 0; t2 < this.tracks.length; t2++)
            e2.push(this.tracks[t2].clone());
          return new this.constructor(this.name, this.duration, e2, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function za(e2) {
        if (void 0 === e2.type)
          throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const t2 = function(e3) {
          switch (e3.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return La;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Oa;
            case "color":
              return Ra;
            case "quaternion":
              return Da;
            case "bool":
            case "boolean":
              return Pa;
            case "string":
              return Fa;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e3);
        }(e2.type);
        if (void 0 === e2.times) {
          const t3 = [], i2 = [];
          Sa.flattenJSON(e2.keys, t3, i2, "value"), e2.times = t3, e2.values = i2;
        }
        return void 0 !== t2.parse ? t2.parse(e2) : new t2(e2.name, e2.times, e2.values, e2.interpolation);
      }
      const Na = { enabled: false, files: {}, add: function(e2, t2) {
        false !== this.enabled && (this.files[e2] = t2);
      }, get: function(e2) {
        if (false !== this.enabled)
          return this.files[e2];
      }, remove: function(e2) {
        delete this.files[e2];
      }, clear: function() {
        this.files = {};
      } };
      class ka {
        constructor(e2, t2, i2) {
          const n2 = this;
          let r2, s2 = false, a2 = 0, o2 = 0;
          const l2 = [];
          this.onStart = void 0, this.onLoad = e2, this.onProgress = t2, this.onError = i2, this.itemStart = function(e3) {
            o2++, false === s2 && void 0 !== n2.onStart && n2.onStart(e3, a2, o2), s2 = true;
          }, this.itemEnd = function(e3) {
            a2++, void 0 !== n2.onProgress && n2.onProgress(e3, a2, o2), a2 === o2 && (s2 = false, void 0 !== n2.onLoad && n2.onLoad());
          }, this.itemError = function(e3) {
            void 0 !== n2.onError && n2.onError(e3);
          }, this.resolveURL = function(e3) {
            return r2 ? r2(e3) : e3;
          }, this.setURLModifier = function(e3) {
            return r2 = e3, this;
          }, this.addHandler = function(e3, t3) {
            return l2.push(e3, t3), this;
          }, this.removeHandler = function(e3) {
            const t3 = l2.indexOf(e3);
            return -1 !== t3 && l2.splice(t3, 2), this;
          }, this.getHandler = function(e3) {
            for (let t3 = 0, i3 = l2.length; t3 < i3; t3 += 2) {
              const i4 = l2[t3], n3 = l2[t3 + 1];
              if (i4.global && (i4.lastIndex = 0), i4.test(e3))
                return n3;
            }
            return null;
          };
        }
      }
      const Ba = new ka();
      class Va {
        constructor(e2) {
          this.manager = void 0 !== e2 ? e2 : Ba, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(e2, t2) {
          const i2 = this;
          return new Promise(function(n2, r2) {
            i2.load(e2, n2, t2, r2);
          });
        }
        parse() {
        }
        setCrossOrigin(e2) {
          return this.crossOrigin = e2, this;
        }
        setWithCredentials(e2) {
          return this.withCredentials = e2, this;
        }
        setPath(e2) {
          return this.path = e2, this;
        }
        setResourcePath(e2) {
          return this.resourcePath = e2, this;
        }
        setRequestHeader(e2) {
          return this.requestHeader = e2, this;
        }
      }
      const Ga = {};
      class Ha extends Va {
        constructor(e2) {
          super(e2);
        }
        load(e2, t2, i2, n2) {
          void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
          const r2 = Na.get(e2);
          if (void 0 !== r2)
            return this.manager.itemStart(e2), setTimeout(() => {
              t2 && t2(r2), this.manager.itemEnd(e2);
            }, 0), r2;
          if (void 0 !== Ga[e2])
            return void Ga[e2].push({ onLoad: t2, onProgress: i2, onError: n2 });
          Ga[e2] = [], Ga[e2].push({ onLoad: t2, onProgress: i2, onError: n2 });
          const s2 = new Request(e2, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a2 = this.mimeType, o2 = this.responseType;
          fetch(s2).then((t3) => {
            if (200 === t3.status || 0 === t3.status) {
              if (0 === t3.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t3.body || void 0 === t3.body.getReader)
                return t3;
              const i3 = Ga[e2], n3 = t3.body.getReader(), r3 = t3.headers.get("Content-Length"), s3 = r3 ? parseInt(r3) : 0, a3 = 0 !== s3;
              let o3 = 0;
              const l2 = new ReadableStream({ start(e3) {
                !function t4() {
                  n3.read().then(({ done: n4, value: r4 }) => {
                    if (n4)
                      e3.close();
                    else {
                      o3 += r4.byteLength;
                      const n5 = new ProgressEvent("progress", { lengthComputable: a3, loaded: o3, total: s3 });
                      for (let e4 = 0, t5 = i3.length; e4 < t5; e4++) {
                        const t6 = i3[e4];
                        t6.onProgress && t6.onProgress(n5);
                      }
                      e3.enqueue(r4), t4();
                    }
                  });
                }();
              } });
              return new Response(l2);
            }
            throw Error(`fetch for "${t3.url}" responded with ${t3.status}: ${t3.statusText}`);
          }).then((e3) => {
            switch (o2) {
              case "arraybuffer":
                return e3.arrayBuffer();
              case "blob":
                return e3.blob();
              case "document":
                return e3.text().then((e4) => new DOMParser().parseFromString(e4, a2));
              case "json":
                return e3.json();
              default:
                if (void 0 === a2)
                  return e3.text();
                {
                  const t3 = /charset="?([^;"\s]*)"?/i.exec(a2), i3 = t3 && t3[1] ? t3[1].toLowerCase() : void 0, n3 = new TextDecoder(i3);
                  return e3.arrayBuffer().then((e4) => n3.decode(e4));
                }
            }
          }).then((t3) => {
            Na.add(e2, t3);
            const i3 = Ga[e2];
            delete Ga[e2];
            for (let e3 = 0, n3 = i3.length; e3 < n3; e3++) {
              const n4 = i3[e3];
              n4.onLoad && n4.onLoad(t3);
            }
          }).catch((t3) => {
            const i3 = Ga[e2];
            if (void 0 === i3)
              throw this.manager.itemError(e2), t3;
            delete Ga[e2];
            for (let e3 = 0, n3 = i3.length; e3 < n3; e3++) {
              const n4 = i3[e3];
              n4.onError && n4.onError(t3);
            }
            this.manager.itemError(e2);
          }).finally(() => {
            this.manager.itemEnd(e2);
          }), this.manager.itemStart(e2);
        }
        setResponseType(e2) {
          return this.responseType = e2, this;
        }
        setMimeType(e2) {
          return this.mimeType = e2, this;
        }
      }
      class ja extends Va {
        constructor(e2) {
          super(e2);
        }
        load(e2, t2, i2, n2) {
          void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
          const r2 = this, s2 = Na.get(e2);
          if (void 0 !== s2)
            return r2.manager.itemStart(e2), setTimeout(function() {
              t2 && t2(s2), r2.manager.itemEnd(e2);
            }, 0), s2;
          const a2 = se("img");
          function o2() {
            h2(), Na.add(e2, this), t2 && t2(this), r2.manager.itemEnd(e2);
          }
          function l2(t3) {
            h2(), n2 && n2(t3), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
          }
          function h2() {
            a2.removeEventListener("load", o2, false), a2.removeEventListener("error", l2, false);
          }
          return a2.addEventListener("load", o2, false), a2.addEventListener("error", l2, false), "data:" !== e2.slice(0, 5) && void 0 !== this.crossOrigin && (a2.crossOrigin = this.crossOrigin), r2.manager.itemStart(e2), a2.src = e2, a2;
        }
      }
      class Wa extends Va {
        constructor(e2) {
          super(e2);
        }
        load(e2, t2, i2, n2) {
          const r2 = new Di(), s2 = new ja(this.manager);
          s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
          let a2 = 0;
          function o2(i3) {
            s2.load(e2[i3], function(e3) {
              r2.images[i3] = e3, a2++, 6 === a2 && (r2.needsUpdate = true, t2 && t2(r2));
            }, void 0, n2);
          }
          for (let l2 = 0; l2 < e2.length; ++l2)
            o2(l2);
          return r2;
        }
      }
      class Xa extends Va {
        constructor(e2) {
          super(e2);
        }
        load(e2, t2, i2, n2) {
          const r2 = this, s2 = new zs(), a2 = new Ha(this.manager);
          return a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setPath(this.path), a2.setWithCredentials(r2.withCredentials), a2.load(e2, function(e3) {
            const i3 = r2.parse(e3);
            i3 && (void 0 !== i3.image ? s2.image = i3.image : void 0 !== i3.data && (s2.image.width = i3.width, s2.image.height = i3.height, s2.image.data = i3.data), s2.wrapS = void 0 !== i3.wrapS ? i3.wrapS : h, s2.wrapT = void 0 !== i3.wrapT ? i3.wrapT : h, s2.magFilter = void 0 !== i3.magFilter ? i3.magFilter : m, s2.minFilter = void 0 !== i3.minFilter ? i3.minFilter : m, s2.anisotropy = void 0 !== i3.anisotropy ? i3.anisotropy : 1, void 0 !== i3.encoding && (s2.encoding = i3.encoding), void 0 !== i3.flipY && (s2.flipY = i3.flipY), void 0 !== i3.format && (s2.format = i3.format), void 0 !== i3.type && (s2.type = i3.type), void 0 !== i3.mipmaps && (s2.mipmaps = i3.mipmaps, s2.minFilter = f), 1 === i3.mipmapCount && (s2.minFilter = m), void 0 !== i3.generateMipmaps && (s2.generateMipmaps = i3.generateMipmaps), s2.needsUpdate = true, t2 && t2(s2, i3));
          }, i2, n2), s2;
        }
      }
      class qa extends Va {
        constructor(e2) {
          super(e2);
        }
        load(e2, t2, i2, n2) {
          const r2 = new Me(), s2 = new ja(this.manager);
          return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(e2, function(e3) {
            r2.image = e3, r2.needsUpdate = true, void 0 !== t2 && t2(r2);
          }, i2, n2), r2;
        }
      }
      class Ya extends Rt {
        constructor(e2, t2 = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new ge(e2), this.intensity = t2;
        }
        dispose() {
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.color.copy(e2.color), this.intensity = e2.intensity, this;
        }
        toJSON(e2) {
          const t2 = super.toJSON(e2);
          return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, void 0 !== this.groundColor && (t2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t2.object.distance = this.distance), void 0 !== this.angle && (t2.object.angle = this.angle), void 0 !== this.decay && (t2.object.decay = this.decay), void 0 !== this.penumbra && (t2.object.penumbra = this.penumbra), void 0 !== this.shadow && (t2.object.shadow = this.shadow.toJSON()), t2;
        }
      }
      class Za extends Ya {
        constructor(e2, t2, i2) {
          super(e2, i2), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.groundColor = new ge(t2);
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.groundColor.copy(e2.groundColor), this;
        }
      }
      const Ja = new st(), Ka = new Ae(), Qa = new Ae();
      class $a {
        constructor(e2) {
          this.camera = e2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ie(512, 512), this.map = null, this.mapPass = null, this.matrix = new st(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Vi(), this._frameExtents = new ie(1, 1), this._viewportCount = 1, this._viewports = [new Se(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e2) {
          const t2 = this.camera, i2 = this.matrix;
          Ka.setFromMatrixPosition(e2.matrixWorld), t2.position.copy(Ka), Qa.setFromMatrixPosition(e2.target.matrixWorld), t2.lookAt(Qa), t2.updateMatrixWorld(), Ja.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ja), i2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i2.multiply(t2.projectionMatrix), i2.multiply(t2.matrixWorldInverse);
        }
        getViewport(e2) {
          return this._viewports[e2];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e2) {
          return this.camera = e2.camera.clone(), this.bias = e2.bias, this.radius = e2.radius, this.mapSize.copy(e2.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e2 = {};
          return 0 !== this.bias && (e2.bias = this.bias), 0 !== this.normalBias && (e2.normalBias = this.normalBias), 1 !== this.radius && (e2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e2.mapSize = this.mapSize.toArray()), e2.camera = this.camera.toJSON(false).object, delete e2.camera.matrix, e2;
        }
      }
      class eo extends $a {
        constructor() {
          super(new Ri(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
        }
        updateMatrices(e2) {
          const t2 = this.camera, i2 = 2 * q * e2.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, r2 = e2.distance || t2.far;
          i2 === t2.fov && n2 === t2.aspect && r2 === t2.far || (t2.fov = i2, t2.aspect = n2, t2.far = r2, t2.updateProjectionMatrix()), super.updateMatrices(e2);
        }
        copy(e2) {
          return super.copy(e2), this.focus = e2.focus, this;
        }
      }
      class to extends Ya {
        constructor(e2, t2, i2 = 0, n2 = Math.PI / 3, r2 = 0, s2 = 1) {
          super(e2, t2), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.target = new Rt(), this.distance = i2, this.angle = n2, this.penumbra = r2, this.decay = s2, this.shadow = new eo();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e2) {
          this.intensity = e2 / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.distance = e2.distance, this.angle = e2.angle, this.penumbra = e2.penumbra, this.decay = e2.decay, this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
        }
      }
      const io = new st(), no = new Ae(), ro = new Ae();
      class so extends $a {
        constructor() {
          super(new Ri(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new ie(4, 2), this._viewportCount = 6, this._viewports = [new Se(2, 1, 1, 1), new Se(0, 1, 1, 1), new Se(3, 1, 1, 1), new Se(1, 1, 1, 1), new Se(3, 0, 1, 1), new Se(1, 0, 1, 1)], this._cubeDirections = [new Ae(1, 0, 0), new Ae(-1, 0, 0), new Ae(0, 0, 1), new Ae(0, 0, -1), new Ae(0, 1, 0), new Ae(0, -1, 0)], this._cubeUps = [new Ae(0, 1, 0), new Ae(0, 1, 0), new Ae(0, 1, 0), new Ae(0, 1, 0), new Ae(0, 0, 1), new Ae(0, 0, -1)];
        }
        updateMatrices(e2, t2 = 0) {
          const i2 = this.camera, n2 = this.matrix, r2 = e2.distance || i2.far;
          r2 !== i2.far && (i2.far = r2, i2.updateProjectionMatrix()), no.setFromMatrixPosition(e2.matrixWorld), i2.position.copy(no), ro.copy(i2.position), ro.add(this._cubeDirections[t2]), i2.up.copy(this._cubeUps[t2]), i2.lookAt(ro), i2.updateMatrixWorld(), n2.makeTranslation(-no.x, -no.y, -no.z), io.multiplyMatrices(i2.projectionMatrix, i2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(io);
        }
      }
      class ao extends Ya {
        constructor(e2, t2, i2 = 0, n2 = 1) {
          super(e2, t2), this.isPointLight = true, this.type = "PointLight", this.distance = i2, this.decay = n2, this.shadow = new so();
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e2) {
          this.intensity = e2 / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e2, t2) {
          return super.copy(e2, t2), this.distance = e2.distance, this.decay = e2.decay, this.shadow = e2.shadow.clone(), this;
        }
      }
      class oo extends $a {
        constructor() {
          super(new en(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      class lo extends Ya {
        constructor(e2, t2) {
          super(e2, t2), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.target = new Rt(), this.shadow = new oo();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e2) {
          return super.copy(e2), this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
        }
      }
      class ho {
        static decodeText(e2) {
          if ("undefined" != typeof TextDecoder)
            return new TextDecoder().decode(e2);
          let t2 = "";
          for (let i2 = 0, n2 = e2.length; i2 < n2; i2++)
            t2 += String.fromCharCode(e2[i2]);
          try {
            return decodeURIComponent(escape(t2));
          } catch (rl2) {
            return t2;
          }
        }
        static extractUrlBase(e2) {
          const t2 = e2.lastIndexOf("/");
          return -1 === t2 ? "./" : e2.slice(0, t2 + 1);
        }
        static resolveURL(e2, t2) {
          return "string" != typeof e2 || "" === e2 ? "" : (/^https?:\/\//i.test(t2) && /^\//.test(e2) && (t2 = t2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e2) || /^data:.*,.*$/i.test(e2) || /^blob:.*$/i.test(e2) ? e2 : t2 + e2);
        }
      }
      class co extends ri {
        constructor() {
          super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(e2) {
          return super.copy(e2), this.instanceCount = e2.instanceCount, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e2 = super.toJSON(this);
          return e2.instanceCount = this.instanceCount, e2.isInstancedBufferGeometry = true, e2;
        }
      }
      class uo extends Va {
        constructor(e2) {
          super(e2), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
        }
        setOptions(e2) {
          return this.options = e2, this;
        }
        load(e2, t2, i2, n2) {
          void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
          const r2 = this, s2 = Na.get(e2);
          if (void 0 !== s2)
            return r2.manager.itemStart(e2), setTimeout(function() {
              t2 && t2(s2), r2.manager.itemEnd(e2);
            }, 0), s2;
          const a2 = {};
          a2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a2.headers = this.requestHeader, fetch(e2, a2).then(function(e3) {
            return e3.blob();
          }).then(function(e3) {
            return createImageBitmap(e3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
          }).then(function(i3) {
            Na.add(e2, i3), t2 && t2(i3), r2.manager.itemEnd(e2);
          }).catch(function(t3) {
            n2 && n2(t3), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
          }), r2.manager.itemStart(e2);
        }
      }
      class po {
        constructor(e2 = true) {
          this.autoStart = e2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = mo(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e2 = 0;
          if (this.autoStart && !this.running)
            return this.start(), 0;
          if (this.running) {
            const t2 = mo();
            e2 = (t2 - this.oldTime) / 1e3, this.oldTime = t2, this.elapsedTime += e2;
          }
          return e2;
        }
      }
      function mo() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      class fo {
        constructor(e2, t2, i2) {
          let n2, r2, s2;
          switch (this.binding = e2, this.valueSize = i2, t2) {
            case "quaternion":
              n2 = this._slerp, r2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i2), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              n2 = this._select, r2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i2);
              break;
            default:
              n2 = this._lerp, r2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i2);
          }
          this._mixBufferRegion = n2, this._mixBufferRegionAdditive = r2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e2, t2) {
          const i2 = this.buffer, n2 = this.valueSize, r2 = e2 * n2 + n2;
          let s2 = this.cumulativeWeight;
          if (0 === s2) {
            for (let e3 = 0; e3 !== n2; ++e3)
              i2[r2 + e3] = i2[e3];
            s2 = t2;
          } else {
            s2 += t2;
            const e3 = t2 / s2;
            this._mixBufferRegion(i2, r2, 0, e3, n2);
          }
          this.cumulativeWeight = s2;
        }
        accumulateAdditive(e2) {
          const t2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t2, n2, 0, e2, i2), this.cumulativeWeightAdditive += e2;
        }
        apply(e2) {
          const t2 = this.valueSize, i2 = this.buffer, n2 = e2 * t2 + t2, r2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, a2 = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
            const e3 = t2 * this._origIndex;
            this._mixBufferRegion(i2, n2, e3, 1 - r2, t2);
          }
          s2 > 0 && this._mixBufferRegionAdditive(i2, n2, this._addIndex * t2, 1, t2);
          for (let o2 = t2, l2 = t2 + t2; o2 !== l2; ++o2)
            if (i2[o2] !== i2[o2 + t2]) {
              a2.setValue(i2, n2);
              break;
            }
        }
        saveOriginalState() {
          const e2 = this.binding, t2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._origIndex;
          e2.getValue(t2, n2);
          for (let r2 = i2, s2 = n2; r2 !== s2; ++r2)
            t2[r2] = t2[n2 + r2 % i2];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const e2 = 3 * this.valueSize;
          this.binding.setValue(this.buffer, e2);
        }
        _setAdditiveIdentityNumeric() {
          const e2 = this._addIndex * this.valueSize, t2 = e2 + this.valueSize;
          for (let i2 = e2; i2 < t2; i2++)
            this.buffer[i2] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const e2 = this._origIndex * this.valueSize, t2 = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++)
            this.buffer[t2 + i2] = this.buffer[e2 + i2];
        }
        _select(e2, t2, i2, n2, r2) {
          if (n2 >= 0.5)
            for (let s2 = 0; s2 !== r2; ++s2)
              e2[t2 + s2] = e2[i2 + s2];
        }
        _slerp(e2, t2, i2, n2) {
          Ce.slerpFlat(e2, t2, e2, t2, e2, i2, n2);
        }
        _slerpAdditive(e2, t2, i2, n2, r2) {
          const s2 = this._workIndex * r2;
          Ce.multiplyQuaternionsFlat(e2, s2, e2, t2, e2, i2), Ce.slerpFlat(e2, t2, e2, t2, e2, s2, n2);
        }
        _lerp(e2, t2, i2, n2, r2) {
          const s2 = 1 - n2;
          for (let a2 = 0; a2 !== r2; ++a2) {
            const r3 = t2 + a2;
            e2[r3] = e2[r3] * s2 + e2[i2 + a2] * n2;
          }
        }
        _lerpAdditive(e2, t2, i2, n2, r2) {
          for (let s2 = 0; s2 !== r2; ++s2) {
            const r3 = t2 + s2;
            e2[r3] = e2[r3] + e2[i2 + s2] * n2;
          }
        }
      }
      const go = "\\[\\]\\.:\\/", _o = new RegExp("[\\[\\]\\.:\\/]", "g"), vo = "[^\\[\\]\\.:\\/]", xo = "[^" + go.replace("\\.", "") + "]", yo = /((?:WC+[\/:])*)/.source.replace("WC", vo), bo = /(WCOD+)?/.source.replace("WCOD", xo), Mo = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vo), So = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vo), wo = new RegExp("^" + yo + bo + Mo + So + "$"), To = ["material", "materials", "bones"];
      class Eo {
        constructor(e2, t2, i2) {
          this.path = t2, this.parsedPath = i2 || Eo.parseTrackName(t2), this.node = Eo.findNode(e2, this.parsedPath.nodeName) || e2, this.rootNode = e2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e2, t2, i2) {
          return e2 && e2.isAnimationObjectGroup ? new Eo.Composite(e2, t2, i2) : new Eo(e2, t2, i2);
        }
        static sanitizeNodeName(e2) {
          return e2.replace(/\s/g, "_").replace(_o, "");
        }
        static parseTrackName(e2) {
          const t2 = wo.exec(e2);
          if (null === t2)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e2);
          const i2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] }, n2 = i2.nodeName && i2.nodeName.lastIndexOf(".");
          if (void 0 !== n2 && -1 !== n2) {
            const e3 = i2.nodeName.substring(n2 + 1);
            -1 !== To.indexOf(e3) && (i2.nodeName = i2.nodeName.substring(0, n2), i2.objectName = e3);
          }
          if (null === i2.propertyName || 0 === i2.propertyName.length)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e2);
          return i2;
        }
        static findNode(e2, t2) {
          if (void 0 === t2 || "" === t2 || "." === t2 || -1 === t2 || t2 === e2.name || t2 === e2.uuid)
            return e2;
          if (e2.skeleton) {
            const i2 = e2.skeleton.getBoneByName(t2);
            if (void 0 !== i2)
              return i2;
          }
          if (e2.children) {
            const i2 = function(e3) {
              for (let n3 = 0; n3 < e3.length; n3++) {
                const r2 = e3[n3];
                if (r2.name === t2 || r2.uuid === t2)
                  return r2;
                const s2 = i2(r2.children);
                if (s2)
                  return s2;
              }
              return null;
            }, n2 = i2(e2.children);
            if (n2)
              return n2;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(e2, t2) {
          e2[t2] = this.targetObject[this.propertyName];
        }
        _getValue_array(e2, t2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
            e2[t2++] = i2[n2];
        }
        _getValue_arrayElement(e2, t2) {
          e2[t2] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e2, t2) {
          this.resolvedProperty.toArray(e2, t2);
        }
        _setValue_direct(e2, t2) {
          this.targetObject[this.propertyName] = e2[t2];
        }
        _setValue_direct_setNeedsUpdate(e2, t2) {
          this.targetObject[this.propertyName] = e2[t2], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e2, t2) {
          this.targetObject[this.propertyName] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(e2, t2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
            i2[n2] = e2[t2++];
        }
        _setValue_array_setNeedsUpdate(e2, t2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
            i2[n2] = e2[t2++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e2, t2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2)
            i2[n2] = e2[t2++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(e2, t2) {
          this.resolvedProperty[this.propertyIndex] = e2[t2];
        }
        _setValue_arrayElement_setNeedsUpdate(e2, t2) {
          this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e2, t2) {
          this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(e2, t2) {
          this.resolvedProperty.fromArray(e2, t2);
        }
        _setValue_fromArray_setNeedsUpdate(e2, t2) {
          this.resolvedProperty.fromArray(e2, t2), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e2, t2) {
          this.resolvedProperty.fromArray(e2, t2), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(e2, t2) {
          this.bind(), this.getValue(e2, t2);
        }
        _setValue_unbound(e2, t2) {
          this.bind(), this.setValue(e2, t2);
        }
        bind() {
          let e2 = this.node;
          const t2 = this.parsedPath, i2 = t2.objectName, n2 = t2.propertyName;
          let r2 = t2.propertyIndex;
          if (e2 || (e2 = Eo.findNode(this.rootNode, t2.nodeName) || this.rootNode, this.node = e2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e2)
            return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          if (i2) {
            let n3 = t2.objectIndex;
            switch (i2) {
              case "materials":
                if (!e2.material)
                  return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e2.material.materials)
                  return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                e2 = e2.material.materials;
                break;
              case "bones":
                if (!e2.skeleton)
                  return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                e2 = e2.skeleton.bones;
                for (let t3 = 0; t3 < e2.length; t3++)
                  if (e2[t3].name === n3) {
                    n3 = t3;
                    break;
                  }
                break;
              default:
                if (void 0 === e2[i2])
                  return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                e2 = e2[i2];
            }
            if (void 0 !== n3) {
              if (void 0 === e2[n3])
                return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e2);
              e2 = e2[n3];
            }
          }
          const s2 = e2[n2];
          if (void 0 === s2) {
            const i3 = t2.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i3 + "." + n2 + " but it wasn't found.", e2);
          }
          let a2 = this.Versioning.None;
          this.targetObject = e2, void 0 !== e2.needsUpdate ? a2 = this.Versioning.NeedsUpdate : void 0 !== e2.matrixWorldNeedsUpdate && (a2 = this.Versioning.MatrixWorldNeedsUpdate);
          let o2 = this.BindingType.Direct;
          if (void 0 !== r2) {
            if ("morphTargetInfluences" === n2) {
              if (!e2.geometry)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (!e2.geometry.morphAttributes)
                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              void 0 !== e2.morphTargetDictionary[r2] && (r2 = e2.morphTargetDictionary[r2]);
            }
            o2 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = r2;
          } else
            void 0 !== s2.fromArray && void 0 !== s2.toArray ? (o2 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (o2 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = n2;
          this.getValue = this.GetterByBindingType[o2], this.setValue = this.SetterByBindingTypeAndVersioning[o2][a2];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      Eo.Composite = class {
        constructor(e2, t2, i2) {
          const n2 = i2 || Eo.parseTrackName(t2);
          this._targetGroup = e2, this._bindings = e2.subscribe_(t2, n2);
        }
        getValue(e2, t2) {
          this.bind();
          const i2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[i2];
          void 0 !== n2 && n2.getValue(e2, t2);
        }
        setValue(e2, t2) {
          const i2 = this._bindings;
          for (let n2 = this._targetGroup.nCachedObjects_, r2 = i2.length; n2 !== r2; ++n2)
            i2[n2].setValue(e2, t2);
        }
        bind() {
          const e2 = this._bindings;
          for (let t2 = this._targetGroup.nCachedObjects_, i2 = e2.length; t2 !== i2; ++t2)
            e2[t2].bind();
        }
        unbind() {
          const e2 = this._bindings;
          for (let t2 = this._targetGroup.nCachedObjects_, i2 = e2.length; t2 !== i2; ++t2)
            e2[t2].unbind();
        }
      }, Eo.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Eo.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Eo.prototype.GetterByBindingType = [Eo.prototype._getValue_direct, Eo.prototype._getValue_array, Eo.prototype._getValue_arrayElement, Eo.prototype._getValue_toArray], Eo.prototype.SetterByBindingTypeAndVersioning = [[Eo.prototype._setValue_direct, Eo.prototype._setValue_direct_setNeedsUpdate, Eo.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Eo.prototype._setValue_array, Eo.prototype._setValue_array_setNeedsUpdate, Eo.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Eo.prototype._setValue_arrayElement, Eo.prototype._setValue_arrayElement_setNeedsUpdate, Eo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Eo.prototype._setValue_fromArray, Eo.prototype._setValue_fromArray_setNeedsUpdate, Eo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
      class Co {
        constructor(e2, t2, i2 = null, n2 = t2.blendMode) {
          this._mixer = e2, this._clip = t2, this._localRoot = i2, this.blendMode = n2;
          const r2 = t2.tracks, s2 = r2.length, a2 = new Array(s2), o2 = { endingStart: L, endingEnd: L };
          for (let l2 = 0; l2 !== s2; ++l2) {
            const e3 = r2[l2].createInterpolant(null);
            a2[l2] = e3, e3.settings = o2;
          }
          this._interpolantSettings = o2, this._interpolants = a2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e2) {
          return this._startTime = e2, this;
        }
        setLoop(e2, t2) {
          return this.loop = e2, this.repetitions = t2, this;
        }
        setEffectiveWeight(e2) {
          return this.weight = e2, this._effectiveWeight = this.enabled ? e2 : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e2) {
          return this._scheduleFading(e2, 0, 1);
        }
        fadeOut(e2) {
          return this._scheduleFading(e2, 1, 0);
        }
        crossFadeFrom(e2, t2, i2) {
          if (e2.fadeOut(t2), this.fadeIn(t2), i2) {
            const i3 = this._clip.duration, n2 = e2._clip.duration, r2 = n2 / i3, s2 = i3 / n2;
            e2.warp(1, r2, t2), this.warp(s2, 1, t2);
          }
          return this;
        }
        crossFadeTo(e2, t2, i2) {
          return e2.crossFadeFrom(this, t2, i2);
        }
        stopFading() {
          const e2 = this._weightInterpolant;
          return null !== e2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
        }
        setEffectiveTimeScale(e2) {
          return this.timeScale = e2, this._effectiveTimeScale = this.paused ? 0 : e2, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e2) {
          return this.timeScale = this._clip.duration / e2, this.stopWarping();
        }
        syncWith(e2) {
          return this.time = e2.time, this.timeScale = e2.timeScale, this.stopWarping();
        }
        halt(e2) {
          return this.warp(this._effectiveTimeScale, 0, e2);
        }
        warp(e2, t2, i2) {
          const n2 = this._mixer, r2 = n2.time, s2 = this.timeScale;
          let a2 = this._timeScaleInterpolant;
          null === a2 && (a2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = a2);
          const o2 = a2.parameterPositions, l2 = a2.sampleValues;
          return o2[0] = r2, o2[1] = r2 + i2, l2[0] = e2 / s2, l2[1] = t2 / s2, this;
        }
        stopWarping() {
          const e2 = this._timeScaleInterpolant;
          return null !== e2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e2)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e2, t2, i2, n2) {
          if (!this.enabled)
            return void this._updateWeight(e2);
          const r2 = this._startTime;
          if (null !== r2) {
            const n3 = (e2 - r2) * i2;
            if (n3 < 0 || 0 === i2)
              return;
            this._startTime = null, t2 = i2 * n3;
          }
          t2 *= this._updateTimeScale(e2);
          const s2 = this._updateTime(t2), a2 = this._updateWeight(e2);
          if (a2 > 0) {
            const e3 = this._interpolants, t3 = this._propertyBindings;
            if (2501 === this.blendMode)
              for (let i3 = 0, n3 = e3.length; i3 !== n3; ++i3)
                e3[i3].evaluate(s2), t3[i3].accumulateAdditive(a2);
            else
              for (let i3 = 0, r3 = e3.length; i3 !== r3; ++i3)
                e3[i3].evaluate(s2), t3[i3].accumulate(n2, a2);
          }
        }
        _updateWeight(e2) {
          let t2 = 0;
          if (this.enabled) {
            t2 = this.weight;
            const i2 = this._weightInterpolant;
            if (null !== i2) {
              const n2 = i2.evaluate(e2)[0];
              t2 *= n2, e2 > i2.parameterPositions[1] && (this.stopFading(), 0 === n2 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = t2, t2;
        }
        _updateTimeScale(e2) {
          let t2 = 0;
          if (!this.paused) {
            t2 = this.timeScale;
            const i2 = this._timeScaleInterpolant;
            if (null !== i2) {
              t2 *= i2.evaluate(e2)[0], e2 > i2.parameterPositions[1] && (this.stopWarping(), 0 === t2 ? this.paused = true : this.timeScale = t2);
            }
          }
          return this._effectiveTimeScale = t2, t2;
        }
        _updateTime(e2) {
          const t2 = this._clip.duration, i2 = this.loop;
          let n2 = this.time + e2, r2 = this._loopCount;
          const s2 = 2202 === i2;
          if (0 === e2)
            return -1 === r2 ? n2 : s2 && 1 == (1 & r2) ? t2 - n2 : n2;
          if (2200 === i2) {
            -1 === r2 && (this._loopCount = 0, this._setEndings(true, true, false));
            e: {
              if (n2 >= t2)
                n2 = t2;
              else {
                if (!(n2 < 0)) {
                  this.time = n2;
                  break e;
                }
                n2 = 0;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 < 0 ? -1 : 1 });
            }
          } else {
            if (-1 === r2 && (e2 >= 0 ? (r2 = 0, this._setEndings(true, 0 === this.repetitions, s2)) : this._setEndings(0 === this.repetitions, true, s2)), n2 >= t2 || n2 < 0) {
              const i3 = Math.floor(n2 / t2);
              n2 -= t2 * i3, r2 += Math.abs(i3);
              const a2 = this.repetitions - r2;
              if (a2 <= 0)
                this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = e2 > 0 ? t2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e2 > 0 ? 1 : -1 });
              else {
                if (1 === a2) {
                  const t3 = e2 < 0;
                  this._setEndings(t3, !t3, s2);
                } else
                  this._setEndings(false, false, s2);
                this._loopCount = r2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i3 });
              }
            } else
              this.time = n2;
            if (s2 && 1 == (1 & r2))
              return t2 - n2;
          }
          return n2;
        }
        _setEndings(e2, t2, i2) {
          const n2 = this._interpolantSettings;
          i2 ? (n2.endingStart = I, n2.endingEnd = I) : (n2.endingStart = e2 ? this.zeroSlopeAtStart ? I : L : D, n2.endingEnd = t2 ? this.zeroSlopeAtEnd ? I : L : D);
        }
        _scheduleFading(e2, t2, i2) {
          const n2 = this._mixer, r2 = n2.time;
          let s2 = this._weightInterpolant;
          null === s2 && (s2 = n2._lendControlInterpolant(), this._weightInterpolant = s2);
          const a2 = s2.parameterPositions, o2 = s2.sampleValues;
          return a2[0] = r2, o2[0] = t2, a2[1] = r2 + e2, o2[1] = i2, this;
        }
      }
      const Ao = new Float32Array(1);
      class Po extends H {
        constructor(e2) {
          super(), this._root = e2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e2, t2) {
          const i2 = e2._localRoot || this._root, n2 = e2._clip.tracks, r2 = n2.length, s2 = e2._propertyBindings, a2 = e2._interpolants, o2 = i2.uuid, l2 = this._bindingsByRootAndName;
          let h2 = l2[o2];
          void 0 === h2 && (h2 = {}, l2[o2] = h2);
          for (let c2 = 0; c2 !== r2; ++c2) {
            const e3 = n2[c2], r3 = e3.name;
            let l3 = h2[r3];
            if (void 0 !== l3)
              ++l3.referenceCount, s2[c2] = l3;
            else {
              if (l3 = s2[c2], void 0 !== l3) {
                null === l3._cacheIndex && (++l3.referenceCount, this._addInactiveBinding(l3, o2, r3));
                continue;
              }
              const n3 = t2 && t2._propertyBindings[c2].binding.parsedPath;
              l3 = new fo(Eo.create(i2, r3, n3), e3.ValueTypeName, e3.getValueSize()), ++l3.referenceCount, this._addInactiveBinding(l3, o2, r3), s2[c2] = l3;
            }
            a2[c2].resultBuffer = l3.buffer;
          }
        }
        _activateAction(e2) {
          if (!this._isActiveAction(e2)) {
            if (null === e2._cacheIndex) {
              const t3 = (e2._localRoot || this._root).uuid, i2 = e2._clip.uuid, n2 = this._actionsByClip[i2];
              this._bindAction(e2, n2 && n2.knownActions[0]), this._addInactiveAction(e2, i2, t3);
            }
            const t2 = e2._propertyBindings;
            for (let e3 = 0, i2 = t2.length; e3 !== i2; ++e3) {
              const i3 = t2[e3];
              0 == i3.useCount++ && (this._lendBinding(i3), i3.saveOriginalState());
            }
            this._lendAction(e2);
          }
        }
        _deactivateAction(e2) {
          if (this._isActiveAction(e2)) {
            const t2 = e2._propertyBindings;
            for (let e3 = 0, i2 = t2.length; e3 !== i2; ++e3) {
              const i3 = t2[e3];
              0 == --i3.useCount && (i3.restoreOriginalState(), this._takeBackBinding(i3));
            }
            this._takeBackAction(e2);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const e2 = this;
          this.stats = { actions: { get total() {
            return e2._actions.length;
          }, get inUse() {
            return e2._nActiveActions;
          } }, bindings: { get total() {
            return e2._bindings.length;
          }, get inUse() {
            return e2._nActiveBindings;
          } }, controlInterpolants: { get total() {
            return e2._controlInterpolants.length;
          }, get inUse() {
            return e2._nActiveControlInterpolants;
          } } };
        }
        _isActiveAction(e2) {
          const t2 = e2._cacheIndex;
          return null !== t2 && t2 < this._nActiveActions;
        }
        _addInactiveAction(e2, t2, i2) {
          const n2 = this._actions, r2 = this._actionsByClip;
          let s2 = r2[t2];
          if (void 0 === s2)
            s2 = { knownActions: [e2], actionByRoot: {} }, e2._byClipCacheIndex = 0, r2[t2] = s2;
          else {
            const t3 = s2.knownActions;
            e2._byClipCacheIndex = t3.length, t3.push(e2);
          }
          e2._cacheIndex = n2.length, n2.push(e2), s2.actionByRoot[i2] = e2;
        }
        _removeInactiveAction(e2) {
          const t2 = this._actions, i2 = t2[t2.length - 1], n2 = e2._cacheIndex;
          i2._cacheIndex = n2, t2[n2] = i2, t2.pop(), e2._cacheIndex = null;
          const r2 = e2._clip.uuid, s2 = this._actionsByClip, a2 = s2[r2], o2 = a2.knownActions, l2 = o2[o2.length - 1], h2 = e2._byClipCacheIndex;
          l2._byClipCacheIndex = h2, o2[h2] = l2, o2.pop(), e2._byClipCacheIndex = null;
          delete a2.actionByRoot[(e2._localRoot || this._root).uuid], 0 === o2.length && delete s2[r2], this._removeInactiveBindingsForAction(e2);
        }
        _removeInactiveBindingsForAction(e2) {
          const t2 = e2._propertyBindings;
          for (let i2 = 0, n2 = t2.length; i2 !== n2; ++i2) {
            const e3 = t2[i2];
            0 == --e3.referenceCount && this._removeInactiveBinding(e3);
          }
        }
        _lendAction(e2) {
          const t2 = this._actions, i2 = e2._cacheIndex, n2 = this._nActiveActions++, r2 = t2[n2];
          e2._cacheIndex = n2, t2[n2] = e2, r2._cacheIndex = i2, t2[i2] = r2;
        }
        _takeBackAction(e2) {
          const t2 = this._actions, i2 = e2._cacheIndex, n2 = --this._nActiveActions, r2 = t2[n2];
          e2._cacheIndex = n2, t2[n2] = e2, r2._cacheIndex = i2, t2[i2] = r2;
        }
        _addInactiveBinding(e2, t2, i2) {
          const n2 = this._bindingsByRootAndName, r2 = this._bindings;
          let s2 = n2[t2];
          void 0 === s2 && (s2 = {}, n2[t2] = s2), s2[i2] = e2, e2._cacheIndex = r2.length, r2.push(e2);
        }
        _removeInactiveBinding(e2) {
          const t2 = this._bindings, i2 = e2.binding, n2 = i2.rootNode.uuid, r2 = i2.path, s2 = this._bindingsByRootAndName, a2 = s2[n2], o2 = t2[t2.length - 1], l2 = e2._cacheIndex;
          o2._cacheIndex = l2, t2[l2] = o2, t2.pop(), delete a2[r2], 0 === Object.keys(a2).length && delete s2[n2];
        }
        _lendBinding(e2) {
          const t2 = this._bindings, i2 = e2._cacheIndex, n2 = this._nActiveBindings++, r2 = t2[n2];
          e2._cacheIndex = n2, t2[n2] = e2, r2._cacheIndex = i2, t2[i2] = r2;
        }
        _takeBackBinding(e2) {
          const t2 = this._bindings, i2 = e2._cacheIndex, n2 = --this._nActiveBindings, r2 = t2[n2];
          e2._cacheIndex = n2, t2[n2] = e2, r2._cacheIndex = i2, t2[i2] = r2;
        }
        _lendControlInterpolant() {
          const e2 = this._controlInterpolants, t2 = this._nActiveControlInterpolants++;
          let i2 = e2[t2];
          return void 0 === i2 && (i2 = new Ea(new Float32Array(2), new Float32Array(2), 1, Ao), i2.__cacheIndex = t2, e2[t2] = i2), i2;
        }
        _takeBackControlInterpolant(e2) {
          const t2 = this._controlInterpolants, i2 = e2.__cacheIndex, n2 = --this._nActiveControlInterpolants, r2 = t2[n2];
          e2.__cacheIndex = n2, t2[n2] = e2, r2.__cacheIndex = i2, t2[i2] = r2;
        }
        clipAction(e2, t2, i2) {
          const n2 = t2 || this._root, r2 = n2.uuid;
          let s2 = "string" == typeof e2 ? Ua.findByName(n2, e2) : e2;
          const a2 = null !== s2 ? s2.uuid : e2, o2 = this._actionsByClip[a2];
          let l2 = null;
          if (void 0 === i2 && (i2 = null !== s2 ? s2.blendMode : F), void 0 !== o2) {
            const e3 = o2.actionByRoot[r2];
            if (void 0 !== e3 && e3.blendMode === i2)
              return e3;
            l2 = o2.knownActions[0], null === s2 && (s2 = l2._clip);
          }
          if (null === s2)
            return null;
          const h2 = new Co(this, s2, t2, i2);
          return this._bindAction(h2, l2), this._addInactiveAction(h2, a2, r2), h2;
        }
        existingAction(e2, t2) {
          const i2 = t2 || this._root, n2 = i2.uuid, r2 = "string" == typeof e2 ? Ua.findByName(i2, e2) : e2, s2 = r2 ? r2.uuid : e2, a2 = this._actionsByClip[s2];
          return void 0 !== a2 && a2.actionByRoot[n2] || null;
        }
        stopAllAction() {
          const e2 = this._actions;
          for (let t2 = this._nActiveActions - 1; t2 >= 0; --t2)
            e2[t2].stop();
          return this;
        }
        update(e2) {
          e2 *= this.timeScale;
          const t2 = this._actions, i2 = this._nActiveActions, n2 = this.time += e2, r2 = Math.sign(e2), s2 = this._accuIndex ^= 1;
          for (let l2 = 0; l2 !== i2; ++l2) {
            t2[l2]._update(n2, e2, r2, s2);
          }
          const a2 = this._bindings, o2 = this._nActiveBindings;
          for (let l2 = 0; l2 !== o2; ++l2)
            a2[l2].apply(s2);
          return this;
        }
        setTime(e2) {
          this.time = 0;
          for (let t2 = 0; t2 < this._actions.length; t2++)
            this._actions[t2].time = 0;
          return this.update(e2);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e2) {
          const t2 = this._actions, i2 = e2.uuid, n2 = this._actionsByClip, r2 = n2[i2];
          if (void 0 !== r2) {
            const e3 = r2.knownActions;
            for (let i3 = 0, n3 = e3.length; i3 !== n3; ++i3) {
              const n4 = e3[i3];
              this._deactivateAction(n4);
              const r3 = n4._cacheIndex, s2 = t2[t2.length - 1];
              n4._cacheIndex = null, n4._byClipCacheIndex = null, s2._cacheIndex = r3, t2[r3] = s2, t2.pop(), this._removeInactiveBindingsForAction(n4);
            }
            delete n2[i2];
          }
        }
        uncacheRoot(e2) {
          const t2 = e2.uuid, i2 = this._actionsByClip;
          for (const r2 in i2) {
            const e3 = i2[r2].actionByRoot[t2];
            void 0 !== e3 && (this._deactivateAction(e3), this._removeInactiveAction(e3));
          }
          const n2 = this._bindingsByRootAndName[t2];
          if (void 0 !== n2)
            for (const r2 in n2) {
              const e3 = n2[r2];
              e3.restoreOriginalState(), this._removeInactiveBinding(e3);
            }
        }
        uncacheAction(e2, t2) {
          const i2 = this.existingAction(e2, t2);
          null !== i2 && (this._deactivateAction(i2), this._removeInactiveAction(i2));
        }
      }
      class Ro {
        constructor(e2, t2, i2 = 0, n2 = 1 / 0) {
          this.ray = new rt(e2, t2), this.near = i2, this.far = n2, this.camera = null, this.layers = new gt(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
        }
        set(e2, t2) {
          this.ray.set(e2, t2);
        }
        setFromCamera(e2, t2) {
          t2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e2.x, e2.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : t2.isOrthographicCamera ? (this.ray.origin.set(e2.x, e2.y, (t2.near + t2.far) / (t2.near - t2.far)).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : console.error("THREE.Raycaster: Unsupported camera type: " + t2.type);
        }
        intersectObject(e2, t2 = true, i2 = []) {
          return Io(e2, this, i2, t2), i2.sort(Lo), i2;
        }
        intersectObjects(e2, t2 = true, i2 = []) {
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++)
            Io(e2[n2], this, i2, t2);
          return i2.sort(Lo), i2;
        }
      }
      function Lo(e2, t2) {
        return e2.distance - t2.distance;
      }
      function Io(e2, t2, i2, n2) {
        if (e2.layers.test(t2.layers) && e2.raycast(t2, i2), true === n2) {
          const n3 = e2.children;
          for (let e3 = 0, r2 = n3.length; e3 < r2; e3++)
            Io(n3[e3], t2, i2, true);
        }
      }
      const Do = new ie();
      class Fo {
        constructor(e2 = new ie(1 / 0, 1 / 0), t2 = new ie(-1 / 0, -1 / 0)) {
          this.isBox2 = true, this.min = e2, this.max = t2;
        }
        set(e2, t2) {
          return this.min.copy(e2), this.max.copy(t2), this;
        }
        setFromPoints(e2) {
          this.makeEmpty();
          for (let t2 = 0, i2 = e2.length; t2 < i2; t2++)
            this.expandByPoint(e2[t2]);
          return this;
        }
        setFromCenterAndSize(e2, t2) {
          const i2 = Do.copy(t2).multiplyScalar(0.5);
          return this.min.copy(e2).sub(i2), this.max.copy(e2).add(i2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e2) {
          return this.min.copy(e2.min), this.max.copy(e2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e2) {
          return this.isEmpty() ? e2.set(0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e2) {
          return this.isEmpty() ? e2.set(0, 0) : e2.subVectors(this.max, this.min);
        }
        expandByPoint(e2) {
          return this.min.min(e2), this.max.max(e2), this;
        }
        expandByVector(e2) {
          return this.min.sub(e2), this.max.add(e2), this;
        }
        expandByScalar(e2) {
          return this.min.addScalar(-e2), this.max.addScalar(e2), this;
        }
        containsPoint(e2) {
          return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y);
        }
        containsBox(e2) {
          return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y;
        }
        getParameter(e2, t2) {
          return t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(e2) {
          return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y);
        }
        clampPoint(e2, t2) {
          return t2.copy(e2).clamp(this.min, this.max);
        }
        distanceToPoint(e2) {
          return Do.copy(e2).clamp(this.min, this.max).sub(e2).length();
        }
        intersect(e2) {
          return this.min.max(e2.min), this.max.min(e2.max), this;
        }
        union(e2) {
          return this.min.min(e2.min), this.max.max(e2.max), this;
        }
        translate(e2) {
          return this.min.add(e2), this.max.add(e2), this;
        }
        equals(e2) {
          return e2.min.equals(this.min) && e2.max.equals(this.max);
        }
      }
      class Oo extends ia {
        constructor(e2, t2 = 16776960) {
          const i2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new ri();
          n2.setIndex(new qt(i2, 1)), n2.setAttribute("position", new Jt([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(n2, new qs({ color: t2, toneMapped: false })), this.box = e2, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
        }
        updateMatrixWorld(e2) {
          const t2 = this.box;
          t2.isEmpty() || (t2.getCenter(this.position), t2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e2));
        }
      }
      class Uo {
        static toHalfFloat(e2) {
          Math.abs(e2) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e2 = Z(e2, -65504, 65504), No[0] = e2;
          const t2 = ko[0], i2 = t2 >> 23 & 511;
          return Bo[i2] + ((8388607 & t2) >> Vo[i2]);
        }
        static fromHalfFloat(e2) {
          const t2 = e2 >> 10;
          return ko[0] = Go[jo[t2] + (1023 & e2)] + Ho[t2], No[0];
        }
      }
      const zo = new ArrayBuffer(4), No = new Float32Array(zo), ko = new Uint32Array(zo), Bo = new Uint32Array(512), Vo = new Uint32Array(512);
      for (let Yb = 0; Yb < 256; ++Yb) {
        const e2 = Yb - 127;
        e2 < -27 ? (Bo[Yb] = 0, Bo[256 | Yb] = 32768, Vo[Yb] = 24, Vo[256 | Yb] = 24) : e2 < -14 ? (Bo[Yb] = 1024 >> -e2 - 14, Bo[256 | Yb] = 1024 >> -e2 - 14 | 32768, Vo[Yb] = -e2 - 1, Vo[256 | Yb] = -e2 - 1) : e2 <= 15 ? (Bo[Yb] = e2 + 15 << 10, Bo[256 | Yb] = e2 + 15 << 10 | 32768, Vo[Yb] = 13, Vo[256 | Yb] = 13) : e2 < 128 ? (Bo[Yb] = 31744, Bo[256 | Yb] = 64512, Vo[Yb] = 24, Vo[256 | Yb] = 24) : (Bo[Yb] = 31744, Bo[256 | Yb] = 64512, Vo[Yb] = 13, Vo[256 | Yb] = 13);
      }
      const Go = new Uint32Array(2048), Ho = new Uint32Array(64), jo = new Uint32Array(64);
      for (let Yb = 1; Yb < 1024; ++Yb) {
        let e2 = Yb << 13, t2 = 0;
        for (; 0 == (8388608 & e2); )
          e2 <<= 1, t2 -= 8388608;
        e2 &= -8388609, t2 += 947912704, Go[Yb] = e2 | t2;
      }
      for (let Yb = 1024; Yb < 2048; ++Yb)
        Go[Yb] = 939524096 + (Yb - 1024 << 13);
      for (let Yb = 1; Yb < 31; ++Yb)
        Ho[Yb] = Yb << 23;
      Ho[31] = 1199570944, Ho[32] = 2147483648;
      for (let Yb = 33; Yb < 63; ++Yb)
        Ho[Yb] = 2147483648 + (Yb - 32 << 23);
      Ho[63] = 3347054592;
      for (let Yb = 1; Yb < 64; ++Yb)
        32 !== Yb && (jo[Yb] = 1024);
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: t } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = t);
      var Wo, Xo, qo, Yo = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, Zo = { exports: {} };
      Xo = Yo, qo = function() {
        function e2(e3) {
          var t2 = [];
          if (0 === e3.length)
            return "";
          if ("string" != typeof e3[0])
            throw new TypeError("Url must be a string. Received " + e3[0]);
          if (e3[0].match(/^[^/:]+:\/*$/) && e3.length > 1) {
            var i2 = e3.shift();
            e3[0] = i2 + e3[0];
          }
          e3[0].match(/^file:\/\/\//) ? e3[0] = e3[0].replace(/^([^/:]+):\/*/, "$1:///") : e3[0] = e3[0].replace(/^([^/:]+):\/*/, "$1://");
          for (var n2 = 0; n2 < e3.length; n2++) {
            var r2 = e3[n2];
            if ("string" != typeof r2)
              throw new TypeError("Url must be a string. Received " + r2);
            "" !== r2 && (n2 > 0 && (r2 = r2.replace(/^[\/]+/, "")), r2 = n2 < e3.length - 1 ? r2.replace(/[\/]+$/, "") : r2.replace(/[\/]+$/, "/"), t2.push(r2));
          }
          var s2 = t2.join("/"), a2 = (s2 = s2.replace(/\/(\?|&|#[^!])/g, "$1")).split("?");
          return s2 = a2.shift() + (a2.length > 0 ? "?" : "") + a2.join("&");
        }
        return function() {
          return e2("object" == typeof arguments[0] ? arguments[0] : [].slice.call(arguments));
        };
      }, (Wo = Zo).exports ? Wo.exports = qo() : Xo.urljoin = qo();
      const Jo = Zo.exports;
      let Ko = null;
      function Qo() {
        if (null !== Ko)
          return Ko;
        let e2 = "";
        if (e2 = "string" == typeof MAPV_BASE_URL ? MAPV_BASE_URL : "https://mapv-three.bj.bcebos.com", !e2)
          throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");
        return Ko = e2, e2;
      }
      function $o(...e2) {
        return Jo(Qo(), ...e2);
      }
      const el = Object.freeze(Object.defineProperty({ __proto__: null, getBaseUrl: Qo, getAssetUrl: $o }, Symbol.toStringTag, { value: "Module" }));
      class tl extends vs {
        constructor() {
          super(), __publicField(this, "isEmptySky", true), __publicField(this, "_addDefaultEnvMap", false), __publicField(this, "_time", 21600), __publicField(this, "_startTimestamp", new Date().getTime()), __publicField(this, "_timeAnimation", false), __publicField(this, "_timeAnimationSpeed", 1), __publicField(this, "_skyLightIntensity", 0.5), __publicField(this, "_skyLightAttenuationRatio", 0.2), __publicField(this, "_sunIntensityBias", 0), __publicField(this, "_sunIntensityScale", 0.8), __publicField(this, "_weather", "partlyCloudy"), __publicField(this, "_timeChangedListeners", []), __publicField(this, "_sunDirection", new Ae()), __publicField(this, "_sunLightColorDay", new ge(16777215)), __publicField(this, "_sunLightColorSunset", new ge(15090944)), __publicField(this, "_sunLightColorCurrent", new ge(16777215)), __publicField(this, "_sunRadian", null), __publicField(this, "_skyLightColorDay", new ge(16777215)), __publicField(this, "_skyLightColorNight", new ge(16777215)), __publicField(this, "_groundLightColorDay", new ge(16777215)), __publicField(this, "_groundLightColorNight", new ge(16758093)), __publicField(this, "_lightNeedsUpdate", false), __publicField(this, "_sunNeedsUpdate", false), __publicField(this, "_affectWorld", false), __publicField(this, "updateSunLightShadowCamera", () => {
            const e3 = this.engine;
            if (!e3.renderer.shadowMap.enabled) {
              const e4 = this.sunLight;
              return e4.position.copy(this._sunDirection), e4.target.position.set(0, 0, 0), e4.updateMatrix(), e4.updateMatrixWorld(), e4.target.updateMatrix(), void e4.target.updateMatrixWorld();
            }
            const t3 = this._sunDirection, i2 = [t3.x, t3.y, t3.z], n2 = this.sunLight, [r2, s2] = e3.map.getProjectionCenter();
            let a2 = e3.map.getCameraDistance(), o2 = 1e3;
            const l2 = o2 * i2[0], h2 = o2 * i2[1], c2 = o2 * i2[2];
            n2.position.set(r2 + l2, s2 + h2, c2), n2.target.position.set(r2, s2, 0), n2.shadow.camera.left = -a2, n2.shadow.camera.bottom = -a2, n2.shadow.camera.right = a2, n2.shadow.camera.top = a2, n2.shadow.camera.near = 1, n2.shadow.camera.far = a2 > 2e4 ? 1 : 2e3, n2.updateMatrix(), n2.updateMatrixWorld(), n2.target.updateMatrix(), n2.target.updateMatrixWorld(), n2.shadow.camera.updateProjectionMatrix();
            const u2 = te.mapLinear(e3.rendering.camera.position.z, 1, 500, -8e-5, -1e-3);
            n2.shadow.bias = u2 < -1e-3 ? -1e-3 : u2;
          });
          const e2 = this.sunLight = new lo(16777215, 0.6), t2 = this.skyLight = new Za(16755200, 255, this._skyLightIntensity);
          t2.position.set(0, 0, 1), e2.castShadow = true, e2.shadow.mapSize = new ie(1024, 1024), e2.shadow.bias = -1e-4, this.add(e2), this.add(e2.target), this.add(t2), e2.matrixAutoUpdate = false, e2.target.matrixAutoUpdate = false, this.renderOrder = -100;
        }
        afterAddToEngine(e2) {
          if (this.engine = e2, !this.isDynamicSky && !this.isStaticSky && this._addDefaultEnvMap) {
            const t2 = new qa().load($o("assets/textures/sky/partlyCloudy_default.jpg"));
            t2.mapping = a, t2.encoding = U, e2.rendering.scene.environment = t2;
          }
        }
        set time(e2) {
          this._time = e2;
          const t2 = this._sunRadian = (e2 / 86400 - 0.25) * Math.PI * 2, i2 = Math.cos(t2), n2 = Math.sin(t2);
          this._sunDirection.set(i2, 0, n2), this._lightNeedsUpdate = true, this.onTimeChanged(this._time);
          for (const r2 of this._timeChangedListeners)
            r2(e2);
        }
        get time() {
          return this._time;
        }
        get weather() {
          return this._weather;
        }
        set weather(e2) {
          this._weather = e2, this.onWeatherChanged(e2);
        }
        get timeAnimation() {
          return this._timeAnimation;
        }
        set timeAnimation(e2) {
          e2 && (this._startTimestamp = new Date().getTime() - this.time / 86400 * (86400 / this._timeAnimationSpeed)), this._timeAnimation = e2;
        }
        get timeAnimationSpeed() {
          return this._timeAnimationSpeed;
        }
        set timeAnimationSpeed(e2) {
          this._timeAnimationSpeed = e2;
        }
        tickTime() {
          const e2 = new Date().getTime() - this._startTimestamp, t2 = 86400 / this._timeAnimationSpeed;
          this.time = e2 % t2 / t2 * 86400;
        }
        onBeforeScenePrepareRender() {
          this._timeAnimation && this.tickTime(), this._lightNeedsUpdate && this.updateLight(), this.updateSunLightShadowCamera();
        }
        updateLight() {
          const e2 = this._sunDirection.z, t2 = e2 > 0.5 ? 1 : e2 < 0 ? 0 : 2 * e2;
          this.sunLight.intensity = this._sunIntensityBias + this._sunIntensityScale * t2;
          const i2 = this.sunsetRatio = e2 > 0.259 ? 0 : e2 < 0 ? 1 : 1 - e2 / 0.259;
          this.skyLight.intensity = this._skyLightIntensity * te.clamp(1 - i2, this._skyLightAttenuationRatio, 1), this._sunLightColorCurrent.lerpColors(this._sunLightColorDay, this._sunLightColorSunset, i2), this.sunLight.color.copy(this._sunLightColorCurrent), this.skyLight.color.lerpColors(this._skyLightColorDay, this._skyLightColorNight, i2), this.skyLight.groundColor.lerpColors(this._groundLightColorDay, this._groundLightColorNight, i2);
        }
        addTimeChangedListener(e2) {
          -1 === this._timeChangedListeners.indexOf(e2) && this._timeChangedListeners.push(e2);
        }
        removeTimeChangedListener(e2) {
          const t2 = this._timeChangedListeners.indexOf(e2);
          -1 !== t2 && this._timeChangedListeners.splice(t2, 1);
        }
        onTimeChanged(e2) {
        }
        onWeatherChanged(e2) {
        }
        dispose() {
        }
        get sunIntensityBias() {
          return this._sunIntensityBias;
        }
        set sunIntensityBias(e2) {
          this._sunIntensityBias = e2, this._lightNeedsUpdate = true;
        }
        get sunIntensityScale() {
          return this._sunIntensityScale;
        }
        set sunIntensityScale(e2) {
          this._sunIntensityScale = e2, this._lightNeedsUpdate = true;
        }
        get skyLightIntensity() {
          return this._skyLightIntensity;
        }
        set skyLightIntensity(e2) {
          this._skyLightIntensity = e2, this._lightNeedsUpdate = true;
        }
        get skyLightAttenuationRatio() {
          return this._skyLightAttenuationRatio;
        }
        set skyLightAttenuationRatio(e2) {
          this._skyLightAttenuationRatio = e2, this._lightNeedsUpdate = true;
        }
        get sunDirection() {
          return this._sunDirection;
        }
        get affectWorld() {
          return this._affectWorld;
        }
      }
      var il, nl, rl, sl = { types: { Boolean: "boolean", STRING: "string", NUMBER: "number", OBJECT: "object" }, ensureTypedArg: function(e2, t2, i2) {
        return typeof e2 === t2 ? e2 : i2;
      }, ensureArrayTypedArg: function(e2, t2, i2) {
        if (Array.isArray(e2)) {
          for (var n2 = e2.length - 1; n2 >= 0; --n2)
            if (typeof e2[n2] !== t2)
              return i2;
          return e2;
        }
        return this.ensureTypedArg(e2, t2, i2);
      }, ensureInstanceOf: function(e2, t2, i2) {
        return void 0 !== e2 ? e2 : i2;
      }, ensureArrayInstanceOf: function(e2, t2, i2) {
        if (Array.isArray(e2)) {
          for (var n2 = e2.length - 1; n2 >= 0; --n2)
            if (void 0 !== t2 && e2[n2] instanceof t2 == 0)
              return i2;
          return e2;
        }
        return this.ensureInstanceOf(e2, t2, i2);
      }, ensureValueOverLifetimeCompliance: function(e2, t2, i2) {
        t2 = t2 || 3, i2 = i2 || 3, false === Array.isArray(e2._value) && (e2._value = [e2._value]), false === Array.isArray(e2._spread) && (e2._spread = [e2._spread]);
        var n2 = this.clamp(e2._value.length, t2, i2), r2 = this.clamp(e2._spread.length, t2, i2), s2 = Math.max(n2, r2);
        e2._value.length !== s2 && (e2._value = this.interpolateArray(e2._value, s2)), e2._spread.length !== s2 && (e2._spread = this.interpolateArray(e2._spread, s2));
      }, interpolateArray: function(e2, t2) {
        for (var i2 = e2.length, n2 = ["function" == typeof e2[0].clone ? e2[0].clone() : e2[0]], r2 = (i2 - 1) / (t2 - 1), s2 = 1; s2 < t2 - 1; ++s2) {
          var a2 = s2 * r2, o2 = Math.floor(a2), l2 = Math.ceil(a2), h2 = a2 - o2;
          n2[s2] = this.lerpTypeAgnostic(e2[o2], e2[l2], h2);
        }
        return n2.push("function" == typeof e2[i2 - 1].clone ? e2[i2 - 1].clone() : e2[i2 - 1]), n2;
      }, clamp: function(e2, t2, i2) {
        return Math.max(t2, Math.min(e2, i2));
      }, zeroToEpsilon: function(e2, t2) {
        var i2 = 1e-5, n2 = e2;
        return n2 = t2 ? Math.random() * i2 * 10 : i2, e2 < 0 && e2 > -1e-5 && (n2 = -n2), n2;
      }, lerpTypeAgnostic: function(e2, t2, i2) {
        var n2, r2 = this.types;
        return typeof e2 === r2.NUMBER && typeof t2 === r2.NUMBER ? e2 + (t2 - e2) * i2 : e2 instanceof ie && t2 instanceof ie ? ((n2 = e2.clone()).x = this.lerp(e2.x, t2.x, i2), n2.y = this.lerp(e2.y, t2.y, i2), n2) : e2 instanceof Ae && t2 instanceof Ae ? ((n2 = e2.clone()).x = this.lerp(e2.x, t2.x, i2), n2.y = this.lerp(e2.y, t2.y, i2), n2.z = this.lerp(e2.z, t2.z, i2), n2) : e2 instanceof Se && t2 instanceof Se ? ((n2 = e2.clone()).x = this.lerp(e2.x, t2.x, i2), n2.y = this.lerp(e2.y, t2.y, i2), n2.z = this.lerp(e2.z, t2.z, i2), n2.w = this.lerp(e2.w, t2.w, i2), n2) : e2 instanceof ge && t2 instanceof ge ? ((n2 = e2.clone()).r = this.lerp(e2.r, t2.r, i2), n2.g = this.lerp(e2.g, t2.g, i2), n2.b = this.lerp(e2.b, t2.b, i2), n2) : void console.warn("Invalid argument types, or argument types do not match:", e2, t2);
      }, lerp: function(e2, t2, i2) {
        return e2 + (t2 - e2) * i2;
      }, roundToNearestMultiple: function(e2, t2) {
        var i2;
        return 0 === t2 || 0 == (i2 = Math.abs(e2) % t2) ? e2 : e2 < 0 ? -(Math.abs(e2) - i2) : e2 + t2 - i2;
      }, arrayValuesAreEqual: function(e2) {
        for (var t2 = 0; t2 < e2.length - 1; ++t2)
          if (e2[t2] !== e2[t2 + 1])
            return false;
        return true;
      }, randomFloat: function(e2, t2) {
        return e2 + t2 * (Math.random() - 0.5);
      }, randomVector3: function(e2, t2, i2, n2, r2) {
        var s2 = i2.x + (Math.random() * n2.x - 0.5 * n2.x), a2 = i2.y + (Math.random() * n2.y - 0.5 * n2.y), o2 = i2.z + (Math.random() * n2.z - 0.5 * n2.z);
        r2 && (s2 = 0.5 * -r2.x + this.roundToNearestMultiple(s2, r2.x), a2 = 0.5 * -r2.y + this.roundToNearestMultiple(a2, r2.y), o2 = 0.5 * -r2.z + this.roundToNearestMultiple(o2, r2.z)), e2.typedArray.setVec3Components(t2, s2, a2, o2);
      }, randomColor: function(e2, t2, i2, n2) {
        var r2 = i2.r + Math.random() * n2.x, s2 = i2.g + Math.random() * n2.y, a2 = i2.b + Math.random() * n2.z;
        r2 = this.clamp(r2, 0, 1), s2 = this.clamp(s2, 0, 1), a2 = this.clamp(a2, 0, 1), e2.typedArray.setVec3Components(t2, r2, s2, a2);
      }, randomColorAsHex: (nl = new ge(), function(e2, t2, i2, n2) {
        for (var r2 = i2.length, s2 = [], a2 = 0; a2 < r2; ++a2) {
          var o2 = n2[a2];
          nl.copy(i2[a2]), nl.r += Math.random() * o2.x - 0.5 * o2.x, nl.g += Math.random() * o2.y - 0.5 * o2.y, nl.b += Math.random() * o2.z - 0.5 * o2.z, nl.r = this.clamp(nl.r, 0, 1), nl.g = this.clamp(nl.g, 0, 1), nl.b = this.clamp(nl.b, 0, 1), s2.push(nl.getHex());
        }
        e2.typedArray.setVec4Components(t2, s2[0], s2[1], s2[2], s2[3]);
      }), randomVector3OnLine: function(e2, t2, i2, n2) {
        var r2 = i2.clone();
        r2.lerp(n2, Math.random()), e2.typedArray.setVec3Components(t2, r2.x, r2.y, r2.z);
      }, randomVector3OnSphere: function(e2, t2, i2, n2, r2, s2, a2, o2) {
        var l2 = 2 * Math.random() - 1, h2 = 6.2832 * Math.random(), c2 = Math.sqrt(1 - l2 * l2), u2 = this.randomFloat(n2, r2), d2 = 0, p2 = 0, m2 = 0;
        a2 && (u2 = Math.round(u2 / a2) * a2), d2 = c2 * Math.cos(h2) * u2, p2 = c2 * Math.sin(h2) * u2, m2 = l2 * u2, d2 *= s2.x, p2 *= s2.y, m2 *= s2.z, d2 += i2.x, p2 += i2.y, m2 += i2.z, e2.typedArray.setVec3Components(t2, d2, p2, m2);
      }, seededRandom: function(e2) {
        var t2 = 1e4 * Math.sin(e2);
        return t2 - (0 | t2);
      }, randomVector3OnDisc: function(e2, t2, i2, n2, r2, s2, a2) {
        var o2 = 6.2832 * Math.random(), l2 = Math.abs(this.randomFloat(n2, r2)), h2 = 0, c2 = 0, u2 = 0;
        a2 && (l2 = Math.round(l2 / a2) * a2), h2 = Math.cos(o2) * l2, c2 = Math.sin(o2) * l2, h2 *= s2.x, c2 *= s2.y, h2 += i2.x, c2 += i2.y, u2 += i2.z, e2.typedArray.setVec3Components(t2, h2, c2, u2);
      }, randomDirectionVector3OnSphere: (il = new Ae(), function(e2, t2, i2, n2, r2, s2, a2, o2) {
        il.copy(s2), il.x -= i2, il.y -= n2, il.z -= r2, il.normalize().multiplyScalar(-this.randomFloat(a2, o2)), e2.typedArray.setVec3Components(t2, il.x, il.y, il.z);
      }), randomDirectionVector3OnDisc: (rl = new Ae(), function(e2, t2, i2, n2, r2, s2, a2, o2) {
        rl.copy(s2), rl.x -= i2, rl.y -= n2, rl.z -= r2, rl.normalize().multiplyScalar(-this.randomFloat(a2, o2)), e2.typedArray.setVec3Components(t2, rl.x, rl.y, 0);
      }), getPackedRotationAxis: function() {
        var e2 = new Ae(), t2 = new Ae(), i2 = new ge(), n2 = new Ae(1, 1, 1);
        return function(r2, s2) {
          return e2.copy(r2).normalize(), t2.copy(s2).normalize(), e2.x += 0.5 * -s2.x + Math.random() * s2.x, e2.y += 0.5 * -s2.y + Math.random() * s2.y, e2.z += 0.5 * -s2.z + Math.random() * s2.z, e2.normalize().add(n2).multiplyScalar(0.5), i2.setRGB(e2.x, e2.y, e2.z), i2.getHex();
        };
      }() }, al = { BOX: 1, SPHERE: 2, DISC: 3, LINE: 4 }, ol = 4, ll = function() {
        function e2(e3, t3, i2, n2) {
          this.componentSize = i2 || 1, this.size = t3 || 1, this.TypedArrayConstructor = e3 || Float32Array, this.array = new e3(t3 * this.componentSize), this.indexOffset = n2 || 0;
        }
        var t2 = e2.prototype;
        return t2.setSize = function(e3, t3) {
          var i2 = this.array.length;
          return t3 || (e3 *= this.componentSize), e3 < i2 ? this.shrink(e3) : e3 > i2 ? this.grow(e3) : void console.info("TypedArray is already of size:", e3 + ".", "Will not resize.");
        }, t2.shrink = function(e3) {
          return this.array = this.array.subarray(0, e3), this.size = e3, this;
        }, t2.grow = function(e3) {
          var t3 = new this.TypedArrayConstructor(e3);
          return t3.set(this.array), this.array = t3, this.size = e3, this;
        }, t2.splice = function(e3, t3) {
          for (var i2 = e3 * this.componentSize, n2 = t3 * this.componentSize, r2 = [], s2 = this.array.length, a2 = 0; a2 < s2; ++a2)
            (a2 < i2 || a2 > n2) && r2.push(this.array[a2]);
          return this.setFromArray(0, r2), this;
        }, t2.setFromArray = function(e3, t3) {
          var i2 = e3 + t3.length;
          return i2 > this.array.length ? this.grow(i2) : i2 < this.array.length && this.shrink(i2), this.array.set(t3, this.indexOffset + e3), this;
        }, t2.setVec2 = function(e3, t3) {
          return this.setVec2Components(e3, t3.x, t3.y);
        }, t2.setVec2Components = function(e3, t3, i2) {
          var n2 = this.array, r2 = this.indexOffset + e3 * this.componentSize;
          return n2[r2] = t3, n2[r2 + 1] = i2, this;
        }, t2.setVec3 = function(e3, t3) {
          return this.setVec3Components(e3, t3.x, t3.y, t3.z);
        }, t2.setVec3Components = function(e3, t3, i2, n2) {
          var r2 = this.array, s2 = this.indexOffset + e3 * this.componentSize;
          return r2[s2] = t3, r2[s2 + 1] = i2, r2[s2 + 2] = n2, this;
        }, t2.setVec4 = function(e3, t3) {
          return this.setVec4Components(e3, t3.x, t3.y, t3.z, t3.w);
        }, t2.setVec4Components = function(e3, t3, i2, n2, r2) {
          var s2 = this.array, a2 = this.indexOffset + e3 * this.componentSize;
          return s2[a2] = t3, s2[a2 + 1] = i2, s2[a2 + 2] = n2, s2[a2 + 3] = r2, this;
        }, t2.setMat3 = function(e3, t3) {
          return this.setFromArray(this.indexOffset + e3 * this.componentSize, t3.elements);
        }, t2.setMat4 = function(e3, t3) {
          return this.setFromArray(this.indexOffset + e3 * this.componentSize, t3.elements);
        }, t2.setColor = function(e3, t3) {
          return this.setVec3Components(e3, t3.r, t3.g, t3.b);
        }, t2.setNumber = function(e3, t3) {
          return this.array[this.indexOffset + e3 * this.componentSize] = t3, this;
        }, t2.getValueAtIndex = function(e3) {
          return this.array[this.indexOffset + e3];
        }, t2.getComponentValueAtIndex = function(e3) {
          return this.array.subarray(this.indexOffset + e3 * this.componentSize);
        }, e2;
      }(), hl = function() {
        function e2(t3, i2, n2) {
          var r2 = e2.typeSizeMap;
          this.type = "string" == typeof t3 && r2.hasOwnProperty(t3) ? t3 : "f", this.componentSize = r2[this.type], this.arrayType = n2 || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!i2, this.updateMin = 0, this.updateMax = 0;
        }
        var t2 = e2.prototype;
        return t2.setUpdateRange = function(e3, t3) {
          this.updateMin = Math.min(e3 * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(t3 * this.componentSize, this.updateMax * this.componentSize);
        }, t2.flagUpdate = function() {
          var e3 = this.bufferAttribute, t3 = e3.updateRange;
          t3.offset = this.updateMin, t3.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), e3.needsUpdate = true;
        }, t2.resetUpdateRange = function() {
          this.updateMin = 0, this.updateMax = 0;
        }, t2.resetDynamic = function() {
          this.bufferAttribute.useage = this.dynamicBuffer ? 35048 : B;
        }, t2.splice = function(e3, t3) {
          this.typedArray.splice(e3, t3), this.forceUpdateAll();
        }, t2.forceUpdateAll = function() {
          this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.usage = B, this.bufferAttribute.needsUpdate = true;
        }, t2._ensureTypedArray = function(e3) {
          null !== this.typedArray && this.typedArray.size === e3 * this.componentSize || (null !== this.typedArray && this.typedArray.size !== e3 ? this.typedArray.setSize(e3) : null === this.typedArray && (this.typedArray = new ll(this.arrayType, e3, this.componentSize)));
        }, t2._createBufferAttribute = function(e3) {
          if (this._ensureTypedArray(e3), null !== this.bufferAttribute)
            return this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize, void (this.bufferAttribute.needsUpdate = true);
          this.bufferAttribute = new qt(this.typedArray.array, this.componentSize), this.bufferAttribute.usage = this.dynamicBuffer ? 35048 : B;
        }, t2.getLength = function() {
          return null === this.typedArray ? 0 : this.typedArray.array.length;
        }, e2;
      }();
      hl.typeSizeMap = { f: 1, v2: 2, v3: 3, v4: 4, c: 3, m3: 9, m4: 16 };
      var cl = { defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join("\n"), uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D tex;", "uniform vec4 textureAnimation;", "uniform float scale;"].join("\n"), attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join("\n"), varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join("\n"), branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join("\n"), unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join("\n"), unpackRotationAxis: ["vec3 unpackRotationAxis( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   c *= vec3( 2.0 );", "   c -= vec3( 1.0 );", "   return c;", "}"].join("\n"), floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join("\n"), colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join("\n"), paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join("\n"), forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join("\n"), rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      if( rotation.y == 0.0 ) {", "           return pos;", "      }", "", "      vec3 axis = unpackRotationAxis( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = rotationCenter - pos;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );", "   }", "#endif"].join("\n"), rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( tex, vUv );"].join("\n") }, ul = { vertex: [cl.defines, cl.uniforms, cl.attributes, cl.varyings, Wi.common, Wi.logdepthbuf_pars_vertex, Wi.fog_pars_fragment, cl.branchAvoidanceFunctions, cl.unpackColor, cl.unpackRotationAxis, cl.floatOverLifetime, cl.colorOverLifetime, cl.paramFetchingFunctions, cl.forceFetchingFunctions, cl.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPosition.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPosition;", Wi.logdepthbuf_vertex, "}"].join("\n"), fragment: [cl.uniforms, Wi.common, Wi.fog_pars_fragment, Wi.logdepthbuf_pars_fragment, cl.varyings, cl.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", cl.rotateTexture, Wi.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", Wi.fog_fragment, "}"].join("\n") }, dl = function() {
        function e2(e3) {
          var t3 = sl.types, i2 = ol;
          for (var n2 in (e3 = sl.ensureTypedArg(e3, t3.OBJECT, {})).position = sl.ensureTypedArg(e3.position, t3.OBJECT, {}), e3.velocity = sl.ensureTypedArg(e3.velocity, t3.OBJECT, {}), e3.acceleration = sl.ensureTypedArg(e3.acceleration, t3.OBJECT, {}), e3.radius = sl.ensureTypedArg(e3.radius, t3.OBJECT, {}), e3.drag = sl.ensureTypedArg(e3.drag, t3.OBJECT, {}), e3.rotation = sl.ensureTypedArg(e3.rotation, t3.OBJECT, {}), e3.color = sl.ensureTypedArg(e3.color, t3.OBJECT, {}), e3.opacity = sl.ensureTypedArg(e3.opacity, t3.OBJECT, {}), e3.size = sl.ensureTypedArg(e3.size, t3.OBJECT, {}), e3.angle = sl.ensureTypedArg(e3.angle, t3.OBJECT, {}), e3.wiggle = sl.ensureTypedArg(e3.wiggle, t3.OBJECT, {}), e3.maxAge = sl.ensureTypedArg(e3.maxAge, t3.OBJECT, {}), e3.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."), this.uuid = te.generateUUID(), this.type = sl.ensureTypedArg(e3.type, t3.NUMBER, al.BOX), this.position = { _value: sl.ensureInstanceOf(e3.position.value, Ae, new Ae()), _spread: sl.ensureInstanceOf(e3.position.spread, Ae, new Ae()), _spreadClamp: sl.ensureInstanceOf(e3.position.spreadClamp, Ae, new Ae()), _distribution: sl.ensureTypedArg(e3.position.distribution, t3.NUMBER, this.type), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false), _radius: sl.ensureTypedArg(e3.position.radius, t3.NUMBER, 10), _radiusScale: sl.ensureInstanceOf(e3.position.radiusScale, Ae, new Ae(1, 1, 1)), _distributionClamp: sl.ensureTypedArg(e3.position.distributionClamp, t3.NUMBER, 0) }, this.velocity = { _value: sl.ensureInstanceOf(e3.velocity.value, Ae, new Ae()), _spread: sl.ensureInstanceOf(e3.velocity.spread, Ae, new Ae()), _distribution: sl.ensureTypedArg(e3.velocity.distribution, t3.NUMBER, this.type), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.acceleration = { _value: sl.ensureInstanceOf(e3.acceleration.value, Ae, new Ae()), _spread: sl.ensureInstanceOf(e3.acceleration.spread, Ae, new Ae()), _distribution: sl.ensureTypedArg(e3.acceleration.distribution, t3.NUMBER, this.type), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.drag = { _value: sl.ensureTypedArg(e3.drag.value, t3.NUMBER, 0), _spread: sl.ensureTypedArg(e3.drag.spread, t3.NUMBER, 0), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.wiggle = { _value: sl.ensureTypedArg(e3.wiggle.value, t3.NUMBER, 0), _spread: sl.ensureTypedArg(e3.wiggle.spread, t3.NUMBER, 0) }, this.rotation = { _axis: sl.ensureInstanceOf(e3.rotation.axis, Ae, new Ae(0, 1, 0)), _axisSpread: sl.ensureInstanceOf(e3.rotation.axisSpread, Ae, new Ae()), _angle: sl.ensureTypedArg(e3.rotation.angle, t3.NUMBER, 0), _angleSpread: sl.ensureTypedArg(e3.rotation.angleSpread, t3.NUMBER, 0), _static: sl.ensureTypedArg(e3.rotation.static, t3.BOOLEAN, false), _center: sl.ensureInstanceOf(e3.rotation.center, Ae, this.position._value.clone()), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.maxAge = { _value: sl.ensureTypedArg(e3.maxAge.value, t3.NUMBER, 2), _spread: sl.ensureTypedArg(e3.maxAge.spread, t3.NUMBER, 0) }, this.color = { _value: sl.ensureArrayInstanceOf(e3.color.value, ge, new ge()), _spread: sl.ensureArrayInstanceOf(e3.color.spread, Ae, new Ae()), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.opacity = { _value: sl.ensureArrayTypedArg(e3.opacity.value, t3.NUMBER, 1), _spread: sl.ensureArrayTypedArg(e3.opacity.spread, t3.NUMBER, 0), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.size = { _value: sl.ensureArrayTypedArg(e3.size.value, t3.NUMBER, 1), _spread: sl.ensureArrayTypedArg(e3.size.spread, t3.NUMBER, 0), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.angle = { _value: sl.ensureArrayTypedArg(e3.angle.value, t3.NUMBER, 0), _spread: sl.ensureArrayTypedArg(e3.angle.spread, t3.NUMBER, 0), _randomise: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) }, this.particleCount = sl.ensureTypedArg(e3.particleCount, t3.NUMBER, 100), this.duration = sl.ensureTypedArg(e3.duration, t3.NUMBER, null), this.isStatic = sl.ensureTypedArg(e3.isStatic, t3.BOOLEAN, false), this.activeMultiplier = sl.ensureTypedArg(e3.activeMultiplier, t3.NUMBER, 1), this.direction = sl.ensureTypedArg(e3.direction, t3.NUMBER, 1), this.alive = sl.ensureTypedArg(e3.alive, t3.BOOLEAN, true), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = { position: sl.ensureTypedArg(e3.position.randomise, t3.BOOLEAN, false) || sl.ensureTypedArg(e3.radius.randomise, t3.BOOLEAN, false), velocity: sl.ensureTypedArg(e3.velocity.randomise, t3.BOOLEAN, false), acceleration: sl.ensureTypedArg(e3.acceleration.randomise, t3.BOOLEAN, false) || sl.ensureTypedArg(e3.drag.randomise, t3.BOOLEAN, false), rotation: sl.ensureTypedArg(e3.rotation.randomise, t3.BOOLEAN, false), rotationCenter: sl.ensureTypedArg(e3.rotation.randomise, t3.BOOLEAN, false), size: sl.ensureTypedArg(e3.size.randomise, t3.BOOLEAN, false), color: sl.ensureTypedArg(e3.color.randomise, t3.BOOLEAN, false), opacity: sl.ensureTypedArg(e3.opacity.randomise, t3.BOOLEAN, false), angle: sl.ensureTypedArg(e3.angle.randomise, t3.BOOLEAN, false) }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = { maxAge: "params", position: "position", velocity: "velocity", acceleration: "acceleration", drag: "acceleration", wiggle: "params", rotation: "rotation", size: "size", color: "color", opacity: "opacity", angle: "angle" }, this.updateMap)
            this.updateMap.hasOwnProperty(n2) && (this.updateCounts[this.updateMap[n2]] = 0, this.updateFlags[this.updateMap[n2]] = false, this._createGetterSetters(this[n2], n2));
          this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, sl.ensureValueOverLifetimeCompliance(this.color, i2, i2), sl.ensureValueOverLifetimeCompliance(this.opacity, i2, i2), sl.ensureValueOverLifetimeCompliance(this.size, i2, i2), sl.ensureValueOverLifetimeCompliance(this.angle, i2, i2);
        }
        var t2 = e2.prototype;
        return t2._createGetterSetters = function(e3, t3) {
          var i2 = this;
          Object.keys(e3).forEach(function(n2) {
            var r2 = n2.replace("_", "");
            Object.defineProperty(e3, r2, { get: function() {
              return this[n2];
            }, set: function(e4) {
              var r3 = i2.updateMap[t3], s2 = this[n2], a2 = ol;
              "_rotationCenter" === n2 ? (i2.updateFlags.rotationCenter = true, this.updateCounts.rotationCenter = 0) : "_randomise" === prop ? i2.resetFlags[r3] = e4 : (i2.updateFlags[r3] = true, i2.updateCounts[r3] = 0), i2.group._updateDefines(), this[n2] = e4, Array.isArray(s2) && sl.ensureValueOverLifetimeCompliance(i2[t3], a2, a2);
            } });
          });
        }, t2._setBufferUpdateRanges = function(e3) {
          this.attributeKeys = e3, this.attributeCount = e3.length;
          for (var t3 = this.attributeCount - 1; t3 >= 0; --t3)
            this.bufferUpdateRanges[e3[t3]] = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
        }, t2._calculatePPSValue = function(e3) {
          var t3 = this.particleCount;
          this.duration ? this.particlesPerSecond = t3 / (e3 < this.duration ? e3 : this.duration) : this.particlesPerSecond = t3 / e3;
        }, t2._setAttributeOffset = function(e3) {
          this.attributeOffset = e3, this.activationIndex = e3, this.activationEnd = e3 + this.particleCount;
        }, t2._assignValue = function(e3, t3) {
          switch (e3) {
            case "position":
              this._assignPositionValue(t3);
              break;
            case "velocity":
            case "acceleration":
              this._assignForceValue(t3, e3);
              break;
            case "size":
            case "opacity":
              this._assignAbsLifetimeValue(t3, e3);
              break;
            case "angle":
              this._assignAngleValue(t3);
              break;
            case "params":
              this._assignParamsValue(t3);
              break;
            case "rotation":
              this._assignRotationValue(t3);
              break;
            case "color":
              this._assignColorValue(t3);
          }
        }, t2._assignPositionValue = function(e3) {
          var t3 = al, i2 = this.position, n2 = this.attributes.position, r2 = i2._value, s2 = i2._spread;
          switch (i2.distribution) {
            case t3.BOX:
              sl.randomVector3(n2, e3, r2, s2, i2._spreadClamp);
              break;
            case t3.SPHERE:
              sl.randomVector3OnSphere(n2, e3, r2, i2._radius, i2._spread.x, i2._radiusScale, i2._spreadClamp.x, i2._distributionClamp || this.particleCount);
              break;
            case t3.DISC:
              sl.randomVector3OnDisc(n2, e3, r2, i2._radius, i2._spread.x, i2._radiusScale, i2._spreadClamp.x);
              break;
            case t3.LINE:
              sl.randomVector3OnLine(n2, e3, r2, s2);
          }
        }, t2._assignForceValue = function(e3, t3) {
          var i2, n2, r2, s2, a2, o2 = al, l2 = this[t3], h2 = l2._value, c2 = l2._spread;
          switch (l2._distribution) {
            case o2.BOX:
              sl.randomVector3(this.attributes[t3], e3, h2, c2);
              break;
            case o2.SPHERE:
              n2 = (i2 = this.attributes.position.typedArray.array)[a2 = 3 * e3], r2 = i2[a2 + 1], s2 = i2[a2 + 2], sl.randomDirectionVector3OnSphere(this.attributes[t3], e3, n2, r2, s2, this.position._value, l2._value.x, l2._spread.x);
              break;
            case o2.DISC:
              n2 = (i2 = this.attributes.position.typedArray.array)[a2 = 3 * e3], r2 = i2[a2 + 1], s2 = i2[a2 + 2], sl.randomDirectionVector3OnDisc(this.attributes[t3], e3, n2, r2, s2, this.position._value, l2._value.x, l2._spread.x);
              break;
            case o2.LINE:
              sl.randomVector3OnLine(this.attributes[t3], e3, h2, c2);
          }
          if ("acceleration" === t3) {
            var u2 = sl.clamp(sl.randomFloat(this.drag._value, this.drag._spread), 0, 1);
            this.attributes.acceleration.typedArray.array[4 * e3 + 3] = u2;
          }
        }, t2._assignAbsLifetimeValue = function(e3, t3) {
          var i2, n2 = this.attributes[t3].typedArray, r2 = this[t3];
          sl.arrayValuesAreEqual(r2._value) && sl.arrayValuesAreEqual(r2._spread) ? (i2 = Math.abs(sl.randomFloat(r2._value[0], r2._spread[0])), n2.setVec4Components(e3, i2, i2, i2, i2)) : n2.setVec4Components(e3, Math.abs(sl.randomFloat(r2._value[0], r2._spread[0])), Math.abs(sl.randomFloat(r2._value[1], r2._spread[1])), Math.abs(sl.randomFloat(r2._value[2], r2._spread[2])), Math.abs(sl.randomFloat(r2._value[3], r2._spread[3])));
        }, t2._assignAngleValue = function(e3) {
          var t3, i2 = this.attributes.angle.typedArray, n2 = this.angle;
          sl.arrayValuesAreEqual(n2._value) && sl.arrayValuesAreEqual(n2._spread) ? (t3 = sl.randomFloat(n2._value[0], n2._spread[0]), i2.setVec4Components(e3, t3, t3, t3, t3)) : i2.setVec4Components(e3, sl.randomFloat(n2._value[0], n2._spread[0]), sl.randomFloat(n2._value[1], n2._spread[1]), sl.randomFloat(n2._value[2], n2._spread[2]), sl.randomFloat(n2._value[3], n2._spread[3]));
        }, t2._assignParamsValue = function(e3) {
          this.attributes.params.typedArray.setVec4Components(e3, this.isStatic ? 1 : 0, 0, Math.abs(sl.randomFloat(this.maxAge._value, this.maxAge._spread)), sl.randomFloat(this.wiggle._value, this.wiggle._spread));
        }, t2._assignRotationValue = function(e3) {
          this.attributes.rotation.typedArray.setVec3Components(e3, sl.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), sl.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1), this.attributes.rotationCenter.typedArray.setVec3(e3, this.rotation._center);
        }, t2._assignColorValue = function(e3) {
          sl.randomColorAsHex(this.attributes.color, e3, this.color._value, this.color._spread);
        }, t2._resetParticle = function(e3) {
          for (var t3, i2, n2 = this.resetFlags, r2 = this.updateFlags, s2 = this.updateCounts, a2 = this.attributeKeys, o2 = this.attributeCount - 1; o2 >= 0; --o2)
            i2 = r2[t3 = a2[o2]], true !== n2[t3] && true !== i2 || (this._assignValue(t3, e3), this._updateAttributeUpdateRange(t3, e3), true === i2 && s2[t3] === this.particleCount ? (r2[t3] = false, s2[t3] = 0) : true === i2 && ++s2[t3]);
        }, t2._updateAttributeUpdateRange = function(e3, t3) {
          var i2 = this.bufferUpdateRanges[e3];
          i2.min = Math.min(t3, i2.min), i2.max = Math.max(t3, i2.max);
        }, t2._resetBufferRanges = function() {
          for (var e3, t3 = this.bufferUpdateRanges, i2 = this.bufferUpdateKeys, n2 = this.bufferUpdateCount - 1; n2 >= 0; --n2)
            t3[e3 = i2[n2]].min = Number.POSITIVE_INFINITY, t3[e3].max = Number.NEGATIVE_INFINITY;
        }, t2._onRemove = function() {
          this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0;
        }, t2._decrementParticleCount = function() {
          --this.activeParticleCount;
        }, t2._incrementParticleCount = function() {
          ++this.activeParticleCount;
        }, t2._checkParticleAges = function(e3, t3, i2, n2) {
          for (var r2, s2, a2, o2, l2 = t3 - 1; l2 >= e3; --l2)
            0 !== (o2 = i2[r2 = 4 * l2]) && (a2 = i2[r2 + 1], s2 = i2[r2 + 2], 1 === this.direction ? (a2 += n2) >= s2 && (a2 = 0, o2 = 0, this._decrementParticleCount()) : (a2 -= n2) <= 0 && (a2 = s2, o2 = 0, this._decrementParticleCount()), i2[r2] = o2, i2[r2 + 1] = a2, this._updateAttributeUpdateRange("params", l2));
        }, t2._activateParticles = function(e3, t3, i2, n2) {
          for (var r2, s2, a2 = this.direction, o2 = e3; o2 < t3; ++o2)
            0 !== i2[r2 = 4 * o2] && 1 !== this.particleCount || (this._incrementParticleCount(), i2[r2] = 1, this._resetParticle(o2), s2 = n2 * (o2 - e3), i2[r2 + 1] = -1 === a2 ? i2[r2 + 2] - s2 : s2, this._updateAttributeUpdateRange("params", o2));
        }, t2.update = function(e3) {
          if (!this.isStatic) {
            null === this.paramsArray && (this.paramsArray = this.attributes.params.typedArray.array);
            var t3 = this.attributeOffset, i2 = t3 + this.particleCount, n2 = this.paramsArray, r2 = this.particlesPerSecond * this.activeMultiplier * e3, s2 = this.activationIndex;
            if (this._resetBufferRanges(), this._checkParticleAges(t3, i2, n2, e3), false !== this.alive) {
              if (null !== this.duration && this.age > this.duration)
                return this.alive = false, void (this.age = 0);
              var a2 = 1 === this.particleCount ? s2 : 0 | s2, o2 = Math.min(a2 + r2, this.activationEnd), l2 = o2 - this.activationIndex | 0, h2 = l2 > 0 ? e3 / l2 : 0;
              this._activateParticles(a2, o2, n2, h2), this.activationIndex += r2, this.activationIndex > i2 && (this.activationIndex = t3), this.age += e3;
            } else
              this.age = 0;
          }
        }, t2.reset = function(e3) {
          if (this.age = 0, this.alive = false, true === e3) {
            for (var t3, i2 = this.attributeOffset, n2 = i2 + this.particleCount, r2 = this.paramsArray, s2 = this.attributes.params.bufferAttribute, a2 = n2 - 1; a2 >= i2; --a2)
              r2[t3 = 4 * a2] = 0, r2[t3 + 1] = 0;
            s2.updateRange.offset = 0, s2.updateRange.count = -1, s2.needsUpdate = true;
          }
          return this;
        }, t2.enable = function() {
          return this.alive = true, this;
        }, t2.disable = function() {
          return this.alive = false, this;
        }, t2.remove = function() {
          return null !== this.group ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this;
        }, e2;
      }(), pl = function() {
        function e2(e3) {
          var t3 = sl.types;
          (e3 = sl.ensureTypedArg(e3, t3.OBJECT, {})).texture = sl.ensureTypedArg(e3.texture, t3.OBJECT, {}), this.uuid = te.generateUUID(), this.fixedTimeStep = sl.ensureTypedArg(e3.fixedTimeStep, t3.NUMBER, 0.0167), this.texture = e3.texture.value || null, this.textureFrames = e3.texture.frames || new ie(1, 1), this.textureFrameCount = sl.ensureTypedArg(e3.texture.frameCount, t3.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = sl.ensureTypedArg(e3.texture.loop, t3.NUMBER, 1), this.textureFrames.max(new ie(1, 1)), this.hasPerspective = sl.ensureTypedArg(e3.hasPerspective, t3.BOOLEAN, true), this.colorize = sl.ensureTypedArg(e3.colorize, t3.BOOLEAN, true), this.maxParticleCount = sl.ensureTypedArg(e3.maxParticleCount, t3.NUMBER, null), this.blending = sl.ensureTypedArg(e3.blending, t3.NUMBER, 2), this.transparent = sl.ensureTypedArg(e3.transparent, t3.BOOLEAN, true), this.alphaTest = parseFloat(sl.ensureTypedArg(e3.alphaTest, t3.NUMBER, 0)), this.depthWrite = sl.ensureTypedArg(e3.depthWrite, t3.BOOLEAN, false), this.depthTest = sl.ensureTypedArg(e3.depthTest, t3.BOOLEAN, true), this.fog = sl.ensureTypedArg(e3.fog, t3.BOOLEAN, true), this.scale = sl.ensureTypedArg(e3.scale, t3.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = false, this._attributesNeedDynamicReset = false, this.particleCount = 0, this.uniforms = { tex: { type: "t", value: this.texture }, textureAnimation: { type: "v4", value: new Se(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1)) }, fogColor: { type: "c", value: this.fog ? new ge() : null }, fogNear: { type: "f", value: 10 }, fogFar: { type: "f", value: 200 }, fogDensity: { type: "f", value: 0.5 }, deltaTime: { type: "f", value: 0 }, runTime: { type: "f", value: 0 }, scale: { type: "f", value: this.scale } }, this.defines = { HAS_PERSPECTIVE: this.hasPerspective, COLORIZE: this.colorize, VALUE_OVER_LIFETIME_LENGTH: ol, SHOULD_ROTATE_TEXTURE: false, SHOULD_ROTATE_PARTICLES: false, SHOULD_WIGGLE_PARTICLES: false, SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1 }, this.attributes = { position: new hl("v3", true), acceleration: new hl("v4", true), velocity: new hl("v3", true), rotation: new hl("v4", true), rotationCenter: new hl("v3", true), params: new hl("v4", true), size: new hl("v4", true), angle: new hl("v4", true), color: new hl("v4", true), opacity: new hl("v4", true) }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new Ai({ uniforms: this.uniforms, vertexShader: ul.vertex, fragmentShader: ul.fragment, blending: this.blending, transparent: this.transparent, alphaTest: this.alphaTest, depthWrite: this.depthWrite, depthTest: this.depthTest, defines: this.defines, fog: this.fog }), this.geometry = new ri(), this.mesh = new ha(this.geometry, this.material), null === this.maxParticleCount && console.warn("Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
        }
        var t2 = e2.prototype;
        return t2._updateDefines = function() {
          for (var e3, t3 = this.emitters, i2 = this.defines, n2 = t3.length - 1; n2 >= 0; --n2)
            e3 = t3[n2], i2.SHOULD_CALCULATE_SPRITE || (i2.SHOULD_ROTATE_TEXTURE = i2.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, e3.angle.value), Math.max.apply(null, e3.angle.spread))), i2.SHOULD_ROTATE_PARTICLES = i2.SHOULD_ROTATE_PARTICLES || !!Math.max(e3.rotation.angle, e3.rotation.angleSpread), i2.SHOULD_WIGGLE_PARTICLES = i2.SHOULD_WIGGLE_PARTICLES || !!Math.max(e3.wiggle.value, e3.wiggle.spread);
          this.material.needsUpdate = true;
        }, t2._applyAttributesToGeometry = function() {
          var e3, t3, i2 = this.attributes, n2 = this.geometry, r2 = n2.attributes;
          Object.keys(i2).forEach(function(s2) {
            e3 = i2[s2], (t3 = r2[s2]) ? t3.array = e3.typedArray.array : n2.setAttribute(s2, e3.bufferAttribute), e3.bufferAttribute.needsUpdate = true;
          }), this.geometry.setDrawRange(0, this.particleCount);
        }, t2.addEmitter = function(e3) {
          if (e3 instanceof dl != 0)
            if (this.emitterIDs.indexOf(e3.uuid) > -1)
              console.error("Emitter already exists in this group. Will not add again.");
            else {
              if (null === e3.group) {
                var t3 = this.attributes, i2 = this.particleCount, n2 = i2 + e3.particleCount;
                for (var r2 in this.particleCount = n2, null !== this.maxParticleCount && this.particleCount > this.maxParticleCount && console.warn("Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), e3._calculatePPSValue(e3.maxAge._value + e3.maxAge._spread), e3._setBufferUpdateRanges(this.attributeKeys), e3._setAttributeOffset(i2), e3.group = this, e3.attributes = this.attributes, t3)
                  t3.hasOwnProperty(r2) && t3[r2]._createBufferAttribute(null !== this.maxParticleCount ? this.maxParticleCount : this.particleCount);
                for (var s2 = i2; s2 < n2; ++s2)
                  e3._assignPositionValue(s2), e3._assignForceValue(s2, "velocity"), e3._assignForceValue(s2, "acceleration"), e3._assignAbsLifetimeValue(s2, "opacity"), e3._assignAbsLifetimeValue(s2, "size"), e3._assignAngleValue(s2), e3._assignRotationValue(s2), e3._assignParamsValue(s2), e3._assignColorValue(s2);
                return this._applyAttributesToGeometry(), this.emitters.push(e3), this.emitterIDs.push(e3.uuid), this._updateDefines(e3), this.material.needsUpdate = true, this.geometry.needsUpdate = true, this._attributesNeedRefresh = true, this;
              }
              console.error("Emitter already belongs to another group. Will not add to requested group.");
            }
          else
            console.error("`emitter` argument must be instance of Emitter. Was provided with:", e3);
        }, t2.removeEmitter = function(e3) {
          var t3 = this.emitterIDs.indexOf(e3, this.uuid);
          if (e3 instanceof dl != 0)
            if (-1 !== t3) {
              for (var i2 = e3.attributeOffset, n2 = i2 + e3.particleCount, r2 = this.attributes.params.typedArray, s2 = i2; s2 < n2; ++s2)
                r2.array[4 * s2] = 0, r2.array[4 * s2 + 1] = 0;
              for (var a2 in this.emitters.splice(t3, 1), this.emitterIDs.splice(t3, 1), this.attributes)
                this.attributes.hasOwnProperty(a2) && this.attributes[a2].splice(i2, n2);
              this.particleCount -= e3.particleCount, e3._onRemove(), this._attributesNeedRefresh = true;
            } else
              console.error("Emitter does not exist in this group. Will not remove.");
          else
            console.error("`emitter` argument must be instance of Emitter. Was provided with:", e3);
        }, t2.getFromPool = function() {
          var e3 = this._pool, t3 = this._createNewWhenPoolEmpty;
          if (e3.length)
            return e3.pop();
          if (t3) {
            var i2 = new dl(this._poolCreationSettings);
            return this.addEmitter(i2), i2;
          }
          return null;
        }, t2.releaseIntoPool = function(e3) {
          if (e3 instanceof dl != 0)
            return e3.reset(), this._pool.unshift(e3), this;
          console.error("Argument is not instanceof Emitter:", e3);
        }, t2.getPool = function() {
          return this._pool;
        }, t2.addPool = function(e3, t3, i2) {
          var n2;
          this._poolCreationSettings = t3, this._createNewWhenPoolEmpty = !!i2;
          for (var r2 = 0; r2 < e3; ++r2)
            n2 = Array.isArray(t3) ? new dl(t3[r2]) : new dl(t3), this.addEmitter(n2), this.releaseIntoPool(n2);
          return this;
        }, t2._triggerSingleEmitter = function(e3) {
          var t3 = this.getFromPool(), i2 = this;
          if (null !== t3)
            return e3 instanceof Ae && (t3.position.value.copy(e3), t3.position.value = t3.position.value), t3.enable(), setTimeout(function() {
              t3.disable(), i2.releaseIntoPool(t3);
            }, 1e3 * Math.max(t3.duration, t3.maxAge.value + t3.maxAge.spread)), this;
          console.log("Group pool ran out.");
        }, t2.triggerPoolEmitter = function(e3, t3) {
          if ("number" == typeof e3 && e3 > 1)
            for (var i2 = 0; i2 < e3; ++i2)
              this._triggerSingleEmitter(t3);
          else
            this._triggerSingleEmitter(t3);
          return this;
        }, t2._updateUniforms = function(e3) {
          this.uniforms.runTime.value += e3, this.uniforms.deltaTime.value = e3;
        }, t2._resetBufferRanges = function() {
          for (var e3 = this.attributeKeys, t3 = this.attributes, i2 = this.attributeCount - 1; i2 >= 0; --i2)
            t3[e3[i2]].resetUpdateRange();
        }, t2._updateBuffers = function(e3) {
          for (var t3, i2, n2, r2 = this.attributeKeys, s2 = this.attributes, a2 = e3.bufferUpdateRanges, o2 = this.attributeCount - 1; o2 >= 0; --o2)
            i2 = a2[t3 = r2[o2]], (n2 = s2[t3]).setUpdateRange(i2.min, i2.max), n2.flagUpdate();
        }, t2.update = function(e3) {
          var t3, i2 = this.emitters, n2 = i2.length, r2 = e3 || this.fixedTimeStep, s2 = this.attributeKeys, a2 = this.attributes;
          if (this._updateUniforms(r2), this._resetBufferRanges(), 0 !== n2 || false !== this._attributesNeedRefresh || false !== this._attributesNeedDynamicReset) {
            for (var o2, l2 = 0; l2 < n2; ++l2)
              (o2 = i2[l2]).update(r2), this._updateBuffers(o2);
            if (true === this._attributesNeedDynamicReset) {
              for (t3 = this.attributeCount - 1; t3 >= 0; --t3)
                a2[s2[t3]].resetDynamic();
              this._attributesNeedDynamicReset = false;
            }
            if (true === this._attributesNeedRefresh) {
              for (t3 = this.attributeCount - 1; t3 >= 0; --t3)
                a2[s2[t3]].forceUpdateAll();
              this._attributesNeedRefresh = false, this._attributesNeedDynamicReset = true;
            }
          }
        }, t2.dispose = function() {
          return this.geometry.dispose(), this.material.dispose(), this;
        }, e2;
      }();
      class ml extends Rt {
        constructor(e2, t2) {
          super(), __publicField(this, "update", () => {
            this._system.update(this._clock.getDelta());
          }), __publicField(this, "createSnow", () => new qa().load($o("assets/textures/sky/others/snow.png"))), __publicField(this, "createEmitter", () => new dl({ maxAge: { value: 10 }, position: { value: new Ae(0, 100, 150), spread: new Ae(1e3, 1e3, 500) }, acceleration: { value: new Ae(0, 0, -10), spread: new Ae(3, 3, 0) }, velocity: { value: new Ae(0, 0, -10), spread: new Ae(5, 5, 0) }, size: { value: 10 }, particleCount: 1e4 })), this._renderer = e2, this._camera = t2, this._clock = new po();
          const i2 = this._system = new pl({ texture: { value: this.createSnow() } }), n2 = this._emitter = this.createEmitter(t2, e2);
          i2.addEmitter(n2), this.add(i2.mesh);
        }
        dispose() {
        }
      }
      class fl extends Rt {
        constructor(e2, t2) {
          super(), __publicField(this, "update", () => {
            this._system.update(this._clock.getDelta());
          }), __publicField(this, "createRain", () => new qa().load($o("assets/textures/sky/others/trace_01.png"))), __publicField(this, "createEmitter", () => new dl({ maxAge: { value: 10 }, position: { value: new Ae(0, 100, 250), spread: new Ae(1e3, 1e3, 500) }, acceleration: { value: new Ae(0, 0, -20), spread: new Ae(3, 3, 0) }, velocity: { value: new Ae(0, 10, -20), spread: new Ae(3, 3, 0) }, size: { value: 50 }, particleCount: 2e4 })), this._clock = new po();
          const i2 = this._system = new pl({ texture: { value: this.createRain() } }), n2 = this._emitter = this.createEmitter(t2, e2);
          i2.addEmitter(n2), this.add(i2.mesh);
        }
        dispose() {
        }
      }
      class gl extends Rt {
        constructor(e2) {
          super(), __publicField(this, "_engine"), __publicField(this, "_sky"), __publicField(this, "_snow"), __publicField(this, "_rain"), __publicField(this, "_weather", ""), __publicField(this, "_currentConverageTextureType", null), __publicField(this, "_tCoverageIntensity", null), __publicField(this, "_skyGroundColorBlue", new ge(1657983)), __publicField(this, "_skyGroundColorGray", new ge(11184810)), __publicField(this, "_weatherChangedListeners", []), __publicField(this, "_sunLightScale", 0.5), __publicField(this, "_skyLightScale", 1), __publicField(this, "transitionDuration", 1e3), __publicField(this, "_transitionStartTime", 0), __publicField(this, "_transitionStartState", null), __publicField(this, "_transitionEndState", null), __publicField(this, "_inTransition", false), __publicField(this, "handleBeforeRender", (e3) => {
            if (this._snow) {
              this._engine.map.getProjectionCenter();
              const e4 = this._engine.camera.position;
              this._snow.position.copy(e4), this._snow.update();
            }
            if (this._rain) {
              const e4 = this._engine.camera.position;
              this._rain.position.copy(e4), this._rain.update();
            }
            if (this._inTransition) {
              const t2 = (Date.now() - this._transitionStartTime) / this.transitionDuration;
              t2 > 1 && (this._inTransition = false), this._updateWeatherTransitionState(t2), e3.requestRender();
            }
          }), __publicField(this, "_updateWeatherTransitionState", (e3) => {
            e3 < 0 && (e3 = 0), e3 > 1 && (e3 = 1);
            const t2 = this._transitionStartState, i2 = this._transitionEndState;
            this.sunIntensityScale = te.lerp(t2.sunIntensityScale, i2.sunIntensityScale, e3) * this._sunLightScale, this.skyLightIntensity = te.lerp(t2.skyLightIntensity, i2.skyLightIntensity, e3) * this._skyLightScale, this.cloudIntensity = te.lerp(t2.cloudIntensity, i2.cloudIntensity, e3), this.fogDensity = te.lerp(t2.fogDensity, i2.fogDensity, e3), this.mixGrayFactor = te.lerp(t2.mixGrayFactor, i2.mixGrayFactor, e3), this.coverageIntensity = te.lerp(t2.coverageIntensity, i2.coverageIntensity, e3);
          }), __publicField(this, "beforeRemoveFromEngine", (e3) => {
            e3.removeBeforeRenderListener(this.handleBeforeRender);
          }), this._sky = e2;
        }
        get weather() {
          return this._weather;
        }
        set weather(e2) {
          if (e2 && e2 !== this._weather) {
            this._weather = e2, this.updateWeather(e2);
            for (const t2 of this._weatherChangedListeners)
              t2(e2);
          }
        }
        afterAddToEngine(e2) {
          this._engine = e2, e2.addBeforeRenderListener(this.handleBeforeRender), this.updateWeather(this._weather);
        }
        getCoverageTexture(e2) {
          if (null === this._tCoverageIntensity || e2 !== this._currentConverageTextureType) {
            this._tCoverageIntensity && this._tCoverageIntensity.dispose();
            let t2 = "assets/textures/realistic/TexturesCom_Snow_Plain_3x3_512_noise.jpg";
            "rain" === e2 && (t2 = "assets/textures/realistic/TexturesCom_Ground_MudWet_512_roughness.jpg"), this._tCoverageIntensity = new qa().load($o(t2), () => {
              this._engine.requestRender();
            });
          }
          return this._tCoverageIntensity;
        }
        updateWeather(e2) {
          const t2 = this._engine;
          let i2 = 1, n2 = 0.2, r2 = 0.5, s2 = 0, a2 = null, o2 = 0, l2 = 0, h2 = false, c2 = false;
          if (this._transitionStartState = { sunIntensityScale: this.sunIntensityScale / this._sunLightScale, cloudIntensity: this.cloudIntensity, skyLightIntensity: this.skyLightIntensity / this._skyLightScale, coverageIntensity: this.coverageIntensity, fogDensity: this.fogDensity, mixGrayFactor: this.mixGrayFactor }, "clear" === e2)
            i2 = 1.5, n2 = 0, r2 = 0.8, o2 = 0, l2 = 0.1;
          else if ("partlyCloudy" === e2)
            i2 = 1.3, n2 = 0.7, r2 = 0.9, o2 = 0.05, l2 = 0.2;
          else if ("cloudy" === e2)
            i2 = 0, n2 = 1.2, r2 = 1, o2 = 0.5, l2 = 0.3;
          else if ("overcast" === e2)
            i2 = 0, n2 = 1.8, r2 = 0.4, o2 = 0.75, l2 = 0.4;
          else if ("foggy" === e2)
            i2 = 0, n2 = 0, r2 = 0.4, o2 = 1, l2 = 1;
          else if ("rainy" === e2)
            i2 = 0, n2 = 0, r2 = 0.4, c2 = true, o2 = 1, l2 = 0.5;
          else {
            if ("snowy" !== e2)
              return;
            i2 = 0, n2 = 0, r2 = 0.4, s2 = 1, a2 = this.getCoverageTexture("snow"), h2 = true, o2 = 1, l2 = 0.5;
          }
          if (this._transitionEndState = { sunIntensityScale: i2, cloudIntensity: n2, skyLightIntensity: r2, coverageIntensity: s2, fogDensity: l2, mixGrayFactor: o2 }, this.tCoverageIntensity = a2, this._sky.isStaticSky && (["overcast", "foggy", "rainy", "snowy"].includes(e2) ? this._sky.weather = "overcast" : this._sky.weather = e2), h2) {
            if (!this._snow) {
              const e3 = this._snow = new ml(t2.renderer, t2.camera);
              this.add(e3);
            }
          } else
            this._snow && (this.remove(this._snow), this._snow.dispose(), this._snow = null);
          if (c2) {
            if (!this._rain) {
              const e3 = this._rain = new fl(t2.renderer, t2.camera);
              this.add(e3);
            }
          } else
            this._rain && (this.remove(this._rain), this._rain.dispose(), this._rain = null);
          this.transitionDuration <= 0 ? this._updateWeatherTransitionState(1) : (this._transitionStartTime = Date.now(), this._inTransition = true, t2.requestRender());
        }
        addWeatherChangedListener(e2) {
          -1 === this._weatherChangedListeners.indexOf(e2) && this._weatherChangedListeners.push(e2);
        }
        removeWeatherChangedListener(e2) {
          const t2 = this._weatherChangedListeners.indexOf(e2);
          -1 !== t2 && this._weatherChangedListeners.splice(t2, 1);
        }
        get sunIntensityScale() {
          return this._sky.sunIntensityScale;
        }
        set sunIntensityScale(e2) {
          this._sky.sunIntensityScale = e2;
        }
        get cloudIntensity() {
          return this._sky.cloudIntensity;
        }
        set cloudIntensity(e2) {
          this._sky.cloudIntensity = e2;
        }
        get skyLightIntensity() {
          return this._sky.skyLightIntensity;
        }
        set skyLightIntensity(e2) {
          this._sky.skyLightIntensity = e2;
        }
        get groundColor() {
          return this._sky.groundColor;
        }
        set groundColor(e2) {
          this._sky.groundColor = e2;
        }
        get mixGrayFactor() {
          return this._sky.mixGrayFactor;
        }
        set mixGrayFactor(e2) {
          this._sky.mixGrayFactor = e2;
        }
        get coverageIntensity() {
          return this._engine.rendering.composition.coverageIntensity;
        }
        set coverageIntensity(e2) {
          this._engine.rendering.composition.coverageIntensity = e2;
        }
        get tCoverageIntensity() {
          return this._engine.rendering.composition.tCoverageIntensity;
        }
        set tCoverageIntensity(e2) {
          this._engine.rendering.composition.tCoverageIntensity = e2;
        }
        get tRelectionEnhancement() {
          return this._engine.rendering.ssr.tEnhancement;
        }
        set tRelectionEnhancement(e2) {
          this._engine.rendering.ssr.tEnhancement = e2;
        }
        set fogDensity(e2) {
          this._engine.rendering.fog.density = e2;
        }
        get fogDensity() {
          return this._engine.rendering.fog.density;
        }
        get skyLightScale() {
          return this._skyLightScale;
        }
        set skyLightScale(e2) {
          this._skyLightScale = e2;
        }
        get sunLightScale() {
          return this._sunLightScale;
        }
        set sunLightScale(e2) {
          this._sunLightScale = e2;
        }
      }
      class _l {
        constructor(e2) {
          __publicField(this, "_rendering"), __publicField(this, "_useMrt", false), __publicField(this, "_mainMrt", null), __publicField(this, "_renderPass", null), __publicField(this, "_needsPrepare", true), __publicField(this, "_antialias", true), __publicField(this, "_msaaSamples", 4), __publicField(this, "cleanup", () => {
            this.useMrt && (this._mainMrt && this._mainMrt.dispose(), this._mainMrt = null);
          }), this._rendering = e2;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          e2 !== this._useMrt && (this._useMrt = e2, this._needsPrepare = true);
        }
        _init() {
          const e2 = this._rendering, t2 = e2.resolution;
          if (this.cleanup(), this._useMrt) {
            const i2 = this._tDepth = new bs();
            i2.format = S, i2.type = y;
            const n2 = this._mainMrt = new Ee(t2.x * e2.pixelRatio, t2.y * e2.pixelRatio, 4, { samples: this._antialias ? this._msaaSamples : 0 });
            n2.stencilBuffer = true, n2.depthTexture = i2, n2.depthBuffer = true;
            for (let t3 = 0, r2 = n2.texture.length; t3 < r2; t3++)
              n2.texture[t3].minFilter = u, n2.texture[t3].magFilter = u, n2.texture[t3].encoding = e2.outputEncoding, n2.texture[t3].format = b;
            n2.texture.isTexture = true, n2.texture.encoding = e2.outputEncoding, this._tDiffuse = n2.texture[0], this._tEmissive = n2.texture[1], this._tNormal = n2.texture[2], this._tSpecular = n2.texture[3];
          }
        }
        render() {
          this._needsPrepare && (this._needsPrepare = false, this._init());
          const e2 = this._rendering, t2 = e2.renderer;
          this._useMrt ? (t2.setRenderTarget(this._mainMrt), t2.render(e2.scene, e2.camera)) : e2.postprocessing.enabled && e2.postprocessing.composer ? (t2.setRenderTarget(e2.postprocessing.composer.readBuffer), t2.render(e2.scene, e2.camera)) : (t2.setRenderTarget(null), t2.render(e2.scene, e2.camera));
        }
        dispose() {
          this.cleanup();
        }
        getTextures() {
          if (this._useMrt) {
            return [this._tDiffuse, this._tEmissive, this._tNormal, this._tDepth, this._tSpecular];
          }
          return [];
        }
        setSize(e2, t2) {
          const i2 = this._rendering;
          this._mainMrt && this._mainMrt.setSize(e2 * i2.pixelRatio, t2 * i2.pixelRatio);
        }
        get tDiffuse() {
          return this._tDiffuse;
        }
        get tNormal() {
          return this._tNormal;
        }
        get tDepth() {
          return this._tDepth;
        }
        get tSpecular() {
          return this._tSpecular;
        }
        get tEmissive() {
          return this._tEmissive;
        }
        get antialias() {
          return this._antialias;
        }
        set antialias(e2) {
          this._antialias = !!e2, e2 ? this._useMrt && (this._mainMrt.samples = this._msaaSamples) : this._useMrt && (this._mainMrt.samples = 0);
        }
      }
      class vl {
        constructor(e2) {
          __publicField(this, "_rendering"), this._rendering = e2;
        }
        get enabled() {
          return this._rendering.renderer.shadowMap.enabled;
        }
        set enabled(e2) {
          this._rendering.renderer.shadowMap.enabled = e2, e2 && (this._rendering.renderer.shadowMap.toneMapping = 2, this._rendering.renderer.shadowMap.toneMappingExposure = 0);
        }
      }
      class xl {
        constructor(e2) {
          __publicField(this, "_needsCreate", false), __publicField(this, "_fogStartFactor", 0.5), __publicField(this, "_rendering"), __publicField(this, "_enabled", false), __publicField(this, "_density", 1), __publicField(this, "_color", new ge(16777215)), __publicField(this, "_skyColorStartFactor", 0.5), __publicField(this, "_altitudeBottom", 0), __publicField(this, "_altitudeTop", 1e3), __publicField(this, "createFog", () => {
            const e3 = this._rendering;
            if (e3.useMrt) {
              const t2 = e3.composition;
              t2.useFog = true, t2.fogDensity = this._density, t2.fogSkyColorStartFactor = this._skyColorStartFactor, t2.fogAltitudeTop = this._altitudeTop, t2.fogAltitudeBottom = this._altitudeBottom;
            } else {
              e3.scene.fog = new Ts(this._color, 1, 1e3);
            }
          }), __publicField(this, "destoryFog", () => {
            const e3 = this._rendering;
            if (e3.useMrt) {
              e3.composition.useFog = false;
            } else {
              e3.scene.fog = null;
            }
          }), this._rendering = e2;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e2) {
          e2 !== this._enabled && (this._enabled = e2, e2 ? this._needsCreate = true : this.destoryFog());
        }
        set color(e2) {
          this._color = e2;
          const t2 = this._rendering, i2 = t2.useMrt;
          if (this._enabled)
            if (i2) {
              t2.composition.fogColor = e2;
            } else
              t2.scene.fog && (t2.scene.fog.color = e2);
        }
        get color() {
          return this._color;
        }
        get density() {
          return this._density;
        }
        set density(e2) {
          this._density = e2;
          const t2 = this._rendering, i2 = t2.useMrt;
          if (this._enabled)
            if (i2) {
              t2.composition.fogDensity = this._density;
            } else
              t2.scene.fog && (t2.scene.fog.density = e2);
        }
        get skyColorStartFactor() {
          return this._skyColorStartFactor;
        }
        set skyColorStartFactor(e2) {
          this._skyColorStartFactor = e2;
          const t2 = this._rendering, i2 = t2.useMrt;
          if (this._enabled && i2) {
            t2.composition.fogSkyColorStartFactor = this._skyColorStartFactor;
          }
        }
        get altitudeTop() {
          return this._altitudeTop;
        }
        set altitudeTop(e2) {
          this._altitudeTop = e2;
          const t2 = this._rendering, i2 = t2.useMrt;
          if (this._enabled && i2) {
            t2.composition.fogAltitudeTop = this._altitudeTop;
          }
        }
        get altitudeBottom() {
          return this._altitudeBottom;
        }
        set altitudeBottom(e2) {
          this._altitudeBottom = e2;
          const t2 = this._rendering, i2 = t2.useMrt;
          if (this._enabled && i2) {
            t2.composition.fogAltitudeBottom = this._altitudeBottom;
          }
        }
        render() {
          if (this._enabled)
            if (this._needsCreate && (this._needsCreate = false, this.createFog(), this._rendering.requestRender()), this._rendering.useMrt)
              this._rendering.scene.fog && (this._rendering.scene.fog = null, this._rendering.requestRender());
            else {
              let e2 = this._rendering.scene.fog;
              e2 || (this.createFog(), e2 = this._rendering.scene.fog, this._rendering.requestRender());
              const t2 = this._rendering.camera.far;
              e2.near = this._fogStartFactor * t2, e2.far = t2;
            }
        }
      }
      class yl {
        constructor() {
          this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
        }
        setSize() {
        }
        render() {
          console.error("THREE.Pass: .render() must be implemented in derived pass.");
        }
      }
      const bl = new en(-1, 1, 1, -1, 0, 1), Ml = new ri();
      Ml.setAttribute("position", new Jt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Ml.setAttribute("uv", new Jt([0, 2, 0, 0, 2, 0], 2));
      class Sl {
        constructor(e2) {
          this._mesh = new Mi(Ml, e2);
        }
        dispose() {
          this._mesh.geometry.dispose();
        }
        render(e2) {
          e2.render(this._mesh, bl);
        }
        get material() {
          return this._mesh.material;
        }
        set material(e2) {
          this._mesh.material = e2;
        }
      }
      const wl = { uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform float opacity;\n\n		uniform sampler2D tDiffuse;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			gl_FragColor = texture2D( tDiffuse, vUv );\n			gl_FragColor.a *= opacity;\n\n\n		}" }, Tl = { shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new ge(0) }, defaultOpacity: { value: 0 } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform vec3 defaultColor;\n		uniform float defaultOpacity;\n		uniform float luminosityThreshold;\n		uniform float smoothWidth;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 texel = texture2D( tDiffuse, vUv );\n\n			vec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n			float v = dot( texel.xyz, luma );\n\n			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n			gl_FragColor = mix( outputColor, texel, alpha );\n\n		}" };
      class El extends yl {
        constructor(e2, t2, i2, n2) {
          super(), this.strength = void 0 !== t2 ? t2 : 1, this.radius = i2, this.threshold = n2, this.resolution = void 0 !== e2 ? new ie(e2.x, e2.y) : new ie(256, 256), this.clearColor = new ge(0, 0, 0);
          const r2 = { minFilter: m, magFilter: m, format: b, type: x };
          this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
          let s2 = Math.round(this.resolution.x / 2), a2 = Math.round(this.resolution.y / 2);
          this.renderTargetBright = new we(s2, a2, r2), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
          for (let c2 = 0; c2 < this.nMips; c2++) {
            const e3 = new we(s2, a2, r2);
            e3.texture.name = "UnrealBloomPass.h" + c2, e3.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(e3);
            const t3 = new we(s2, a2, r2);
            t3.texture.name = "UnrealBloomPass.v" + c2, t3.texture.generateMipmaps = false, this.renderTargetsVertical.push(t3), s2 = Math.round(s2 / 2), a2 = Math.round(a2 / 2);
          }
          void 0 === Tl && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
          const o2 = Tl;
          this.highPassUniforms = Ci.clone(o2.uniforms), this.highPassUniforms.luminosityThreshold.value = n2, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new Ai({ uniforms: this.highPassUniforms, vertexShader: o2.vertexShader, fragmentShader: o2.fragmentShader, defines: {} }), this.separableBlurMaterials = [];
          const l2 = [3, 5, 7, 9, 11];
          s2 = Math.round(this.resolution.x / 2), a2 = Math.round(this.resolution.y / 2);
          for (let c2 = 0; c2 < this.nMips; c2++)
            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l2[c2])), this.separableBlurMaterials[c2].uniforms.texSize.value = new ie(s2, a2), s2 = Math.round(s2 / 2), a2 = Math.round(a2 / 2);
          this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t2, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.needsUpdate = true;
          this.compositeMaterial.uniforms.bloomFactors.value = [1, 0.8, 0.6, 0.4, 0.2], this.bloomTintColors = [new Ae(1, 1, 1), new Ae(1, 1, 1), new Ae(1, 1, 1), new Ae(1, 1, 1), new Ae(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === wl && console.error("THREE.UnrealBloomPass relies on CopyShader");
          const h2 = wl;
          this.copyUniforms = Ci.clone(h2.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new Ai({ uniforms: this.copyUniforms, vertexShader: h2.vertexShader, fragmentShader: h2.fragmentShader, blending: 2, depthTest: false, depthWrite: false, transparent: true }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new ge(), this.oldClearAlpha = 1, this.basic = new jt(), this.fsQuad = new Sl(null);
        }
        dispose() {
          for (let e2 = 0; e2 < this.renderTargetsHorizontal.length; e2++)
            this.renderTargetsHorizontal[e2].dispose();
          for (let e2 = 0; e2 < this.renderTargetsVertical.length; e2++)
            this.renderTargetsVertical[e2].dispose();
          this.renderTargetBright.dispose();
        }
        setSize(e2, t2) {
          let i2 = Math.round(e2 / 2), n2 = Math.round(t2 / 2);
          this.renderTargetBright.setSize(i2, n2);
          for (let r2 = 0; r2 < this.nMips; r2++)
            this.renderTargetsHorizontal[r2].setSize(i2, n2), this.renderTargetsVertical[r2].setSize(i2, n2), this.separableBlurMaterials[r2].uniforms.texSize.value = new ie(i2, n2), i2 = Math.round(i2 / 2), n2 = Math.round(n2 / 2);
        }
        render(e2, t2, i2, n2, r2) {
          e2.getClearColor(this._oldClearColor), this.oldClearAlpha = e2.getClearAlpha();
          const s2 = e2.autoClear;
          e2.autoClear = false, e2.setClearColor(this.clearColor, 0), r2 && e2.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = t2, e2.setRenderTarget(null), e2.clear(), this.fsQuad.render(e2)), this.highPassUniforms.tDiffuse.value = t2, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e2.setRenderTarget(this.renderTargetBright), e2.clear(), this.fsQuad.render(e2);
          let a2 = this.renderTargetBright;
          for (let o2 = 0; o2 < this.nMips; o2++)
            this.fsQuad.material = this.separableBlurMaterials[o2], this.separableBlurMaterials[o2].uniforms.colorTexture.value = a2.texture, this.separableBlurMaterials[o2].uniforms.direction.value = El.BlurDirectionX, e2.setRenderTarget(this.renderTargetsHorizontal[o2]), e2.clear(), this.fsQuad.render(e2), this.separableBlurMaterials[o2].uniforms.colorTexture.value = this.renderTargetsHorizontal[o2].texture, this.separableBlurMaterials[o2].uniforms.direction.value = El.BlurDirectionY, e2.setRenderTarget(this.renderTargetsVertical[o2]), e2.clear(), this.fsQuad.render(e2), a2 = this.renderTargetsVertical[o2];
          this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e2.setRenderTarget(this.renderTargetsHorizontal[0]), e2.clear(), this.fsQuad.render(e2), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r2 && e2.state.buffers.stencil.setTest(true), this.renderToScreen ? (e2.setRenderTarget(null), this.fsQuad.render(e2)) : (e2.setRenderTarget(i2), this.fsQuad.render(e2)), e2.setClearColor(this._oldClearColor, this.oldClearAlpha), e2.autoClear = s2;
        }
        getSeperableBlurMaterial(e2) {
          return new Ai({ defines: { KERNEL_RADIUS: e2, SIGMA: e2 }, uniforms: { colorTexture: { value: null }, texSize: { value: new ie(0.5, 0.5) }, direction: { value: new ie(0.5, 0.5) } }, vertexShader: "varying vec2 vUv;\n                  void main() {\n                      vUv = uv;\n                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                  }", fragmentShader: "#include <common>\n                  varying vec2 vUv;\n                  uniform sampler2D colorTexture;\n                  uniform vec2 texSize;\n                  uniform vec2 direction;\n                  float gaussianPdf(in float x, in float sigma) {\n                      return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n                  }\n                  void main() {\n            vec2 invSize = 1.0 / texSize;            float fSigma = float(SIGMA);            float weightSum = gaussianPdf(0.0, fSigma);            float alphaSum = 0.0;            vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;            for( int i = 1; i < KERNEL_RADIUS; i ++ ) {              float x = float(i);              float w = gaussianPdf(x, fSigma);              vec2 uvOffset = direction * invSize * x;              vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);              vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);              diffuseSum += (sample1.rgb + sample2.rgb) * w;              alphaSum += (sample1.a + sample2.a) * w;              weightSum += 2.0 * w;            }            gl_FragColor = vec4(diffuseSum/weightSum, alphaSum/weightSum);\n          }" });
        }
        getCompositeMaterial(e2) {
          return new Ai({ defines: { NUM_MIPS: e2 }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: "varying vec2 vUv;\n                  void main() {\n                      vUv = uv;\n                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                  }", fragmentShader: "varying vec2 vUv;\n                  uniform sampler2D blurTexture1;\n                  uniform sampler2D blurTexture2;\n                  uniform sampler2D blurTexture3;\n                  uniform sampler2D blurTexture4;\n                  uniform sampler2D blurTexture5;\n                  uniform sampler2D dirtTexture;\n                  uniform float bloomStrength;\n                  uniform float bloomRadius;\n                  uniform float bloomFactors[NUM_MIPS];\n                  uniform vec3 bloomTintColors[NUM_MIPS];\n                  float lerpBloomFactor(const in float factor) {\n                      float mirrorFactor = 1.2 - factor;\n                      return mix(factor, mirrorFactor, bloomRadius);\n                  }\n                  void main() {\n                      gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n                          lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n                          lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n                          lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n                          lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                  }" });
        }
      }
      El.BlurDirectionX = new ie(1, 0), El.BlurDirectionY = new ie(0, 1);
      const Cl = new ge(), Al = new ge(0);
      let Pl = 0;
      class Rl {
        constructor(e2) {
          __publicField(this, "_rendering"), __publicField(this, "_strength", 3), __publicField(this, "_threshold", 0), __publicField(this, "_radius", 0.5), __publicField(this, "_needsSetTexture", false), __publicField(this, "_enabled", false), __publicField(this, "_renderPass", null), __publicField(this, "_useMrt", false), this._rendering = e2;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          e2 !== this._useMrt && (this._useMrt = e2, e2 || this.dispose());
        }
        set enabled(e2) {
          (e2 = !!e2) !== this._enabled && (this._enabled = e2, e2 || this.dispose());
        }
        get enabled() {
          return this._enabled;
        }
        _init() {
          const e2 = this._rendering, t2 = e2.resolution, i2 = new ie(t2.x, t2.y), n2 = e2.pixelRatio;
          this._renderPass = new El(i2, this._strength, this._radius, this._threshold), this._bloomRenderTarget = new we(i2.x * n2, i2.y * n2, { type: x }), e2.composition.tBloom = this._bloomRenderTarget.texture;
        }
        render() {
          if (!this._enabled || !this._useMrt)
            return;
          this._enabled && !this._renderPass && this._init();
          const e2 = this._rendering, t2 = e2.main.tEmissive, i2 = e2.renderer;
          i2.setRenderTarget(this._bloomRenderTarget), i2.getClearColor(Cl), Pl = i2.getClearAlpha(), i2.setClearColor(Al), i2.setClearAlpha(0), i2.clear(), i2.setClearColor(Cl), i2.setClearAlpha(Pl), this._renderPass.render(e2.renderer, t2, this._bloomRenderTarget);
        }
        dispose() {
          this._rendering.composition.tBloom = null, this._renderPass && (this._renderPass.dispose(), this._renderPass = null), this._bloomRenderTarget && (this._bloomRenderTarget.dispose(), this._bloomRenderTarget = null);
        }
        getTextures() {
          const e2 = [];
          return this._bloomRenderTarget && e2.push(this._bloomRenderTarget.texture), e2;
        }
        setSize(e2, t2) {
          this._rendering, this._bloomRenderTarget && this._bloomRenderTarget.setSize(e2, t2);
        }
        get tBloom() {
          return this._bloomRenderTarget && this._bloomRenderTarget.texture || null;
        }
        get strength() {
          return this._strength;
        }
        set strength(e2) {
          this._strength = e2, this._renderPass && (this._renderPass.strength = e2);
        }
        get radius() {
          return this._radius;
        }
        set radius(e2) {
          this._radius = e2, this._renderPass && (this._renderPass.radius = e2);
        }
        get threshold() {
          return this._threshold;
        }
        set threshold(e2) {
          this._threshold = e2, this._renderPass && (this._renderPass.threshold = e2);
        }
      }
      var Ll = { exports: {} }, Il = { exports: {} }, Dl = function(e2) {
        return !(!e2 || "string" == typeof e2) && (e2 instanceof Array || Array.isArray(e2) || e2.length >= 0 && (e2.splice instanceof Function || Object.getOwnPropertyDescriptor(e2, e2.length - 1) && "String" !== e2.constructor.name));
      }, Fl = Array.prototype.concat, Ol = Array.prototype.slice, Ul = Il.exports = function(e2) {
        for (var t2 = [], i2 = 0, n2 = e2.length; i2 < n2; i2++) {
          var r2 = e2[i2];
          Dl(r2) ? t2 = Fl.call(t2, Ol.call(r2)) : t2.push(r2);
        }
        return t2;
      };
      Ul.wrap = function(e2) {
        return function() {
          return e2(Ul(arguments));
        };
      };
      var zl = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Nl = Il.exports, kl = Object.hasOwnProperty, Bl = /* @__PURE__ */ Object.create(null);
      for (var Vl in zl)
        kl.call(zl, Vl) && (Bl[zl[Vl]] = Vl);
      var Gl = Ll.exports = { to: {}, get: {} };
      function Hl(e2, t2, i2) {
        return Math.min(Math.max(t2, e2), i2);
      }
      function jl(e2) {
        var t2 = Math.round(e2).toString(16).toUpperCase();
        return t2.length < 2 ? "0" + t2 : t2;
      }
      Gl.get = function(e2) {
        var t2, i2;
        switch (e2.substring(0, 3).toLowerCase()) {
          case "hsl":
            t2 = Gl.get.hsl(e2), i2 = "hsl";
            break;
          case "hwb":
            t2 = Gl.get.hwb(e2), i2 = "hwb";
            break;
          default:
            t2 = Gl.get.rgb(e2), i2 = "rgb";
        }
        return t2 ? { model: i2, value: t2 } : null;
      }, Gl.get.rgb = function(e2) {
        if (!e2)
          return null;
        var t2, i2, n2, r2 = [0, 0, 0, 1];
        if (t2 = e2.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
          for (n2 = t2[2], t2 = t2[1], i2 = 0; i2 < 3; i2++) {
            var s2 = 2 * i2;
            r2[i2] = parseInt(t2.slice(s2, s2 + 2), 16);
          }
          n2 && (r2[3] = parseInt(n2, 16) / 255);
        } else if (t2 = e2.match(/^#([a-f0-9]{3,4})$/i)) {
          for (n2 = (t2 = t2[1])[3], i2 = 0; i2 < 3; i2++)
            r2[i2] = parseInt(t2[i2] + t2[i2], 16);
          n2 && (r2[3] = parseInt(n2 + n2, 16) / 255);
        } else if (t2 = e2.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)) {
          for (i2 = 0; i2 < 3; i2++)
            r2[i2] = parseInt(t2[i2 + 1], 0);
          t2[4] && (t2[5] ? r2[3] = 0.01 * parseFloat(t2[4]) : r2[3] = parseFloat(t2[4]));
        } else {
          if (!(t2 = e2.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)))
            return (t2 = e2.match(/^(\w+)$/)) ? "transparent" === t2[1] ? [0, 0, 0, 0] : kl.call(zl, t2[1]) ? ((r2 = zl[t2[1]])[3] = 1, r2) : null : null;
          for (i2 = 0; i2 < 3; i2++)
            r2[i2] = Math.round(2.55 * parseFloat(t2[i2 + 1]));
          t2[4] && (t2[5] ? r2[3] = 0.01 * parseFloat(t2[4]) : r2[3] = parseFloat(t2[4]));
        }
        for (i2 = 0; i2 < 3; i2++)
          r2[i2] = Hl(r2[i2], 0, 255);
        return r2[3] = Hl(r2[3], 0, 1), r2;
      }, Gl.get.hsl = function(e2) {
        if (!e2)
          return null;
        var t2 = e2.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
        if (t2) {
          var i2 = parseFloat(t2[4]);
          return [(parseFloat(t2[1]) % 360 + 360) % 360, Hl(parseFloat(t2[2]), 0, 100), Hl(parseFloat(t2[3]), 0, 100), Hl(isNaN(i2) ? 1 : i2, 0, 1)];
        }
        return null;
      }, Gl.get.hwb = function(e2) {
        if (!e2)
          return null;
        var t2 = e2.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
        if (t2) {
          var i2 = parseFloat(t2[4]);
          return [(parseFloat(t2[1]) % 360 + 360) % 360, Hl(parseFloat(t2[2]), 0, 100), Hl(parseFloat(t2[3]), 0, 100), Hl(isNaN(i2) ? 1 : i2, 0, 1)];
        }
        return null;
      }, Gl.to.hex = function() {
        var e2 = Nl(arguments);
        return "#" + jl(e2[0]) + jl(e2[1]) + jl(e2[2]) + (e2[3] < 1 ? jl(Math.round(255 * e2[3])) : "");
      }, Gl.to.rgb = function() {
        var e2 = Nl(arguments);
        return e2.length < 4 || 1 === e2[3] ? "rgb(" + Math.round(e2[0]) + ", " + Math.round(e2[1]) + ", " + Math.round(e2[2]) + ")" : "rgba(" + Math.round(e2[0]) + ", " + Math.round(e2[1]) + ", " + Math.round(e2[2]) + ", " + e2[3] + ")";
      }, Gl.to.rgb.percent = function() {
        var e2 = Nl(arguments), t2 = Math.round(e2[0] / 255 * 100), i2 = Math.round(e2[1] / 255 * 100), n2 = Math.round(e2[2] / 255 * 100);
        return e2.length < 4 || 1 === e2[3] ? "rgb(" + t2 + "%, " + i2 + "%, " + n2 + "%)" : "rgba(" + t2 + "%, " + i2 + "%, " + n2 + "%, " + e2[3] + ")";
      }, Gl.to.hsl = function() {
        var e2 = Nl(arguments);
        return e2.length < 4 || 1 === e2[3] ? "hsl(" + e2[0] + ", " + e2[1] + "%, " + e2[2] + "%)" : "hsla(" + e2[0] + ", " + e2[1] + "%, " + e2[2] + "%, " + e2[3] + ")";
      }, Gl.to.hwb = function() {
        var e2 = Nl(arguments), t2 = "";
        return e2.length >= 4 && 1 !== e2[3] && (t2 = ", " + e2[3]), "hwb(" + e2[0] + ", " + e2[1] + "%, " + e2[2] + "%" + t2 + ")";
      }, Gl.to.keyword = function(e2) {
        return Bl[e2.slice(0, 3)];
      };
      const Wl = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Xl = {};
      for (const Yb of Object.keys(Wl))
        Xl[Wl[Yb]] = Yb;
      const ql = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      var Yl = ql;
      for (const Yb of Object.keys(ql)) {
        if (!("channels" in ql[Yb]))
          throw new Error("missing channels property: " + Yb);
        if (!("labels" in ql[Yb]))
          throw new Error("missing channel labels property: " + Yb);
        if (ql[Yb].labels.length !== ql[Yb].channels)
          throw new Error("channel and label counts mismatch: " + Yb);
        const { channels: e2, labels: t2 } = ql[Yb];
        delete ql[Yb].channels, delete ql[Yb].labels, Object.defineProperty(ql[Yb], "channels", { value: e2 }), Object.defineProperty(ql[Yb], "labels", { value: t2 });
      }
      ql.rgb.hsl = function(e2) {
        const t2 = e2[0] / 255, i2 = e2[1] / 255, n2 = e2[2] / 255, r2 = Math.min(t2, i2, n2), s2 = Math.max(t2, i2, n2), a2 = s2 - r2;
        let o2, l2;
        s2 === r2 ? o2 = 0 : t2 === s2 ? o2 = (i2 - n2) / a2 : i2 === s2 ? o2 = 2 + (n2 - t2) / a2 : n2 === s2 && (o2 = 4 + (t2 - i2) / a2), o2 = Math.min(60 * o2, 360), o2 < 0 && (o2 += 360);
        const h2 = (r2 + s2) / 2;
        return l2 = s2 === r2 ? 0 : h2 <= 0.5 ? a2 / (s2 + r2) : a2 / (2 - s2 - r2), [o2, 100 * l2, 100 * h2];
      }, ql.rgb.hsv = function(e2) {
        let t2, i2, n2, r2, s2;
        const a2 = e2[0] / 255, o2 = e2[1] / 255, l2 = e2[2] / 255, h2 = Math.max(a2, o2, l2), c2 = h2 - Math.min(a2, o2, l2), u2 = function(e3) {
          return (h2 - e3) / 6 / c2 + 0.5;
        };
        return 0 === c2 ? (r2 = 0, s2 = 0) : (s2 = c2 / h2, t2 = u2(a2), i2 = u2(o2), n2 = u2(l2), a2 === h2 ? r2 = n2 - i2 : o2 === h2 ? r2 = 1 / 3 + t2 - n2 : l2 === h2 && (r2 = 2 / 3 + i2 - t2), r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1)), [360 * r2, 100 * s2, 100 * h2];
      }, ql.rgb.hwb = function(e2) {
        const t2 = e2[0], i2 = e2[1];
        let n2 = e2[2];
        const r2 = ql.rgb.hsl(e2)[0], s2 = 1 / 255 * Math.min(t2, Math.min(i2, n2));
        return n2 = 1 - 1 / 255 * Math.max(t2, Math.max(i2, n2)), [r2, 100 * s2, 100 * n2];
      }, ql.rgb.cmyk = function(e2) {
        const t2 = e2[0] / 255, i2 = e2[1] / 255, n2 = e2[2] / 255, r2 = Math.min(1 - t2, 1 - i2, 1 - n2);
        return [100 * ((1 - t2 - r2) / (1 - r2) || 0), 100 * ((1 - i2 - r2) / (1 - r2) || 0), 100 * ((1 - n2 - r2) / (1 - r2) || 0), 100 * r2];
      }, ql.rgb.keyword = function(e2) {
        const t2 = Xl[e2];
        if (t2)
          return t2;
        let i2, n2 = 1 / 0;
        for (const a2 of Object.keys(Wl)) {
          const t3 = (s2 = Wl[a2], ((r2 = e2)[0] - s2[0]) ** 2 + (r2[1] - s2[1]) ** 2 + (r2[2] - s2[2]) ** 2);
          t3 < n2 && (n2 = t3, i2 = a2);
        }
        var r2, s2;
        return i2;
      }, ql.keyword.rgb = function(e2) {
        return Wl[e2];
      }, ql.rgb.xyz = function(e2) {
        let t2 = e2[0] / 255, i2 = e2[1] / 255, n2 = e2[2] / 255;
        t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, i2 = i2 > 0.04045 ? ((i2 + 0.055) / 1.055) ** 2.4 : i2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92;
        return [100 * (0.4124 * t2 + 0.3576 * i2 + 0.1805 * n2), 100 * (0.2126 * t2 + 0.7152 * i2 + 0.0722 * n2), 100 * (0.0193 * t2 + 0.1192 * i2 + 0.9505 * n2)];
      }, ql.rgb.lab = function(e2) {
        const t2 = ql.rgb.xyz(e2);
        let i2 = t2[0], n2 = t2[1], r2 = t2[2];
        i2 /= 95.047, n2 /= 100, r2 /= 108.883, i2 = i2 > 8856e-6 ? i2 ** (1 / 3) : 7.787 * i2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
        return [116 * n2 - 16, 500 * (i2 - n2), 200 * (n2 - r2)];
      }, ql.hsl.rgb = function(e2) {
        const t2 = e2[0] / 360, i2 = e2[1] / 100, n2 = e2[2] / 100;
        let r2, s2, a2;
        if (0 === i2)
          return a2 = 255 * n2, [a2, a2, a2];
        r2 = n2 < 0.5 ? n2 * (1 + i2) : n2 + i2 - n2 * i2;
        const o2 = 2 * n2 - r2, l2 = [0, 0, 0];
        for (let h2 = 0; h2 < 3; h2++)
          s2 = t2 + 1 / 3 * -(h2 - 1), s2 < 0 && s2++, s2 > 1 && s2--, a2 = 6 * s2 < 1 ? o2 + 6 * (r2 - o2) * s2 : 2 * s2 < 1 ? r2 : 3 * s2 < 2 ? o2 + (r2 - o2) * (2 / 3 - s2) * 6 : o2, l2[h2] = 255 * a2;
        return l2;
      }, ql.hsl.hsv = function(e2) {
        const t2 = e2[0];
        let i2 = e2[1] / 100, n2 = e2[2] / 100, r2 = i2;
        const s2 = Math.max(n2, 0.01);
        n2 *= 2, i2 *= n2 <= 1 ? n2 : 2 - n2, r2 *= s2 <= 1 ? s2 : 2 - s2;
        return [t2, 100 * (0 === n2 ? 2 * r2 / (s2 + r2) : 2 * i2 / (n2 + i2)), 100 * ((n2 + i2) / 2)];
      }, ql.hsv.rgb = function(e2) {
        const t2 = e2[0] / 60, i2 = e2[1] / 100;
        let n2 = e2[2] / 100;
        const r2 = Math.floor(t2) % 6, s2 = t2 - Math.floor(t2), a2 = 255 * n2 * (1 - i2), o2 = 255 * n2 * (1 - i2 * s2), l2 = 255 * n2 * (1 - i2 * (1 - s2));
        switch (n2 *= 255, r2) {
          case 0:
            return [n2, l2, a2];
          case 1:
            return [o2, n2, a2];
          case 2:
            return [a2, n2, l2];
          case 3:
            return [a2, o2, n2];
          case 4:
            return [l2, a2, n2];
          case 5:
            return [n2, a2, o2];
        }
      }, ql.hsv.hsl = function(e2) {
        const t2 = e2[0], i2 = e2[1] / 100, n2 = e2[2] / 100, r2 = Math.max(n2, 0.01);
        let s2, a2;
        a2 = (2 - i2) * n2;
        const o2 = (2 - i2) * r2;
        return s2 = i2 * r2, s2 /= o2 <= 1 ? o2 : 2 - o2, s2 = s2 || 0, a2 /= 2, [t2, 100 * s2, 100 * a2];
      }, ql.hwb.rgb = function(e2) {
        const t2 = e2[0] / 360;
        let i2 = e2[1] / 100, n2 = e2[2] / 100;
        const r2 = i2 + n2;
        let s2;
        r2 > 1 && (i2 /= r2, n2 /= r2);
        const a2 = Math.floor(6 * t2), o2 = 1 - n2;
        s2 = 6 * t2 - a2, 0 != (1 & a2) && (s2 = 1 - s2);
        const l2 = i2 + s2 * (o2 - i2);
        let h2, c2, u2;
        switch (a2) {
          default:
          case 6:
          case 0:
            h2 = o2, c2 = l2, u2 = i2;
            break;
          case 1:
            h2 = l2, c2 = o2, u2 = i2;
            break;
          case 2:
            h2 = i2, c2 = o2, u2 = l2;
            break;
          case 3:
            h2 = i2, c2 = l2, u2 = o2;
            break;
          case 4:
            h2 = l2, c2 = i2, u2 = o2;
            break;
          case 5:
            h2 = o2, c2 = i2, u2 = l2;
        }
        return [255 * h2, 255 * c2, 255 * u2];
      }, ql.cmyk.rgb = function(e2) {
        const t2 = e2[0] / 100, i2 = e2[1] / 100, n2 = e2[2] / 100, r2 = e2[3] / 100;
        return [255 * (1 - Math.min(1, t2 * (1 - r2) + r2)), 255 * (1 - Math.min(1, i2 * (1 - r2) + r2)), 255 * (1 - Math.min(1, n2 * (1 - r2) + r2))];
      }, ql.xyz.rgb = function(e2) {
        const t2 = e2[0] / 100, i2 = e2[1] / 100, n2 = e2[2] / 100;
        let r2, s2, a2;
        return r2 = 3.2406 * t2 + -1.5372 * i2 + -0.4986 * n2, s2 = -0.9689 * t2 + 1.8758 * i2 + 0.0415 * n2, a2 = 0.0557 * t2 + -0.204 * i2 + 1.057 * n2, r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : 12.92 * r2, s2 = s2 > 31308e-7 ? 1.055 * s2 ** (1 / 2.4) - 0.055 : 12.92 * s2, a2 = a2 > 31308e-7 ? 1.055 * a2 ** (1 / 2.4) - 0.055 : 12.92 * a2, r2 = Math.min(Math.max(0, r2), 1), s2 = Math.min(Math.max(0, s2), 1), a2 = Math.min(Math.max(0, a2), 1), [255 * r2, 255 * s2, 255 * a2];
      }, ql.xyz.lab = function(e2) {
        let t2 = e2[0], i2 = e2[1], n2 = e2[2];
        t2 /= 95.047, i2 /= 100, n2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, i2 = i2 > 8856e-6 ? i2 ** (1 / 3) : 7.787 * i2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116;
        return [116 * i2 - 16, 500 * (t2 - i2), 200 * (i2 - n2)];
      }, ql.lab.xyz = function(e2) {
        let t2, i2, n2;
        i2 = (e2[0] + 16) / 116, t2 = e2[1] / 500 + i2, n2 = i2 - e2[2] / 200;
        const r2 = i2 ** 3, s2 = t2 ** 3, a2 = n2 ** 3;
        return i2 = r2 > 8856e-6 ? r2 : (i2 - 16 / 116) / 7.787, t2 = s2 > 8856e-6 ? s2 : (t2 - 16 / 116) / 7.787, n2 = a2 > 8856e-6 ? a2 : (n2 - 16 / 116) / 7.787, t2 *= 95.047, i2 *= 100, n2 *= 108.883, [t2, i2, n2];
      }, ql.lab.lch = function(e2) {
        const t2 = e2[0], i2 = e2[1], n2 = e2[2];
        let r2;
        r2 = 360 * Math.atan2(n2, i2) / 2 / Math.PI, r2 < 0 && (r2 += 360);
        return [t2, Math.sqrt(i2 * i2 + n2 * n2), r2];
      }, ql.lch.lab = function(e2) {
        const t2 = e2[0], i2 = e2[1], n2 = e2[2] / 360 * 2 * Math.PI;
        return [t2, i2 * Math.cos(n2), i2 * Math.sin(n2)];
      }, ql.rgb.ansi16 = function(e2, t2 = null) {
        const [i2, n2, r2] = e2;
        let s2 = null === t2 ? ql.rgb.hsv(e2)[2] : t2;
        if (s2 = Math.round(s2 / 50), 0 === s2)
          return 30;
        let a2 = 30 + (Math.round(r2 / 255) << 2 | Math.round(n2 / 255) << 1 | Math.round(i2 / 255));
        return 2 === s2 && (a2 += 60), a2;
      }, ql.hsv.ansi16 = function(e2) {
        return ql.rgb.ansi16(ql.hsv.rgb(e2), e2[2]);
      }, ql.rgb.ansi256 = function(e2) {
        const t2 = e2[0], i2 = e2[1], n2 = e2[2];
        if (t2 === i2 && i2 === n2)
          return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(i2 / 255 * 5) + Math.round(n2 / 255 * 5);
      }, ql.ansi16.rgb = function(e2) {
        let t2 = e2 % 10;
        if (0 === t2 || 7 === t2)
          return e2 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
        const i2 = 0.5 * (1 + ~~(e2 > 50));
        return [(1 & t2) * i2 * 255, (t2 >> 1 & 1) * i2 * 255, (t2 >> 2 & 1) * i2 * 255];
      }, ql.ansi256.rgb = function(e2) {
        if (e2 >= 232) {
          const t3 = 10 * (e2 - 232) + 8;
          return [t3, t3, t3];
        }
        let t2;
        e2 -= 16;
        return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t2 = e2 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
      }, ql.rgb.hex = function(e2) {
        const t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
        return "000000".substring(t2.length) + t2;
      }, ql.hex.rgb = function(e2) {
        const t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t2)
          return [0, 0, 0];
        let i2 = t2[0];
        3 === t2[0].length && (i2 = i2.split("").map((e3) => e3 + e3).join(""));
        const n2 = parseInt(i2, 16);
        return [n2 >> 16 & 255, n2 >> 8 & 255, 255 & n2];
      }, ql.rgb.hcg = function(e2) {
        const t2 = e2[0] / 255, i2 = e2[1] / 255, n2 = e2[2] / 255, r2 = Math.max(Math.max(t2, i2), n2), s2 = Math.min(Math.min(t2, i2), n2), a2 = r2 - s2;
        let o2, l2;
        return o2 = a2 < 1 ? s2 / (1 - a2) : 0, l2 = a2 <= 0 ? 0 : r2 === t2 ? (i2 - n2) / a2 % 6 : r2 === i2 ? 2 + (n2 - t2) / a2 : 4 + (t2 - i2) / a2, l2 /= 6, l2 %= 1, [360 * l2, 100 * a2, 100 * o2];
      }, ql.hsl.hcg = function(e2) {
        const t2 = e2[1] / 100, i2 = e2[2] / 100, n2 = i2 < 0.5 ? 2 * t2 * i2 : 2 * t2 * (1 - i2);
        let r2 = 0;
        return n2 < 1 && (r2 = (i2 - 0.5 * n2) / (1 - n2)), [e2[0], 100 * n2, 100 * r2];
      }, ql.hsv.hcg = function(e2) {
        const t2 = e2[1] / 100, i2 = e2[2] / 100, n2 = t2 * i2;
        let r2 = 0;
        return n2 < 1 && (r2 = (i2 - n2) / (1 - n2)), [e2[0], 100 * n2, 100 * r2];
      }, ql.hcg.rgb = function(e2) {
        const t2 = e2[0] / 360, i2 = e2[1] / 100, n2 = e2[2] / 100;
        if (0 === i2)
          return [255 * n2, 255 * n2, 255 * n2];
        const r2 = [0, 0, 0], s2 = t2 % 1 * 6, a2 = s2 % 1, o2 = 1 - a2;
        let l2 = 0;
        switch (Math.floor(s2)) {
          case 0:
            r2[0] = 1, r2[1] = a2, r2[2] = 0;
            break;
          case 1:
            r2[0] = o2, r2[1] = 1, r2[2] = 0;
            break;
          case 2:
            r2[0] = 0, r2[1] = 1, r2[2] = a2;
            break;
          case 3:
            r2[0] = 0, r2[1] = o2, r2[2] = 1;
            break;
          case 4:
            r2[0] = a2, r2[1] = 0, r2[2] = 1;
            break;
          default:
            r2[0] = 1, r2[1] = 0, r2[2] = o2;
        }
        return l2 = (1 - i2) * n2, [255 * (i2 * r2[0] + l2), 255 * (i2 * r2[1] + l2), 255 * (i2 * r2[2] + l2)];
      }, ql.hcg.hsv = function(e2) {
        const t2 = e2[1] / 100, i2 = t2 + e2[2] / 100 * (1 - t2);
        let n2 = 0;
        return i2 > 0 && (n2 = t2 / i2), [e2[0], 100 * n2, 100 * i2];
      }, ql.hcg.hsl = function(e2) {
        const t2 = e2[1] / 100, i2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
        let n2 = 0;
        return i2 > 0 && i2 < 0.5 ? n2 = t2 / (2 * i2) : i2 >= 0.5 && i2 < 1 && (n2 = t2 / (2 * (1 - i2))), [e2[0], 100 * n2, 100 * i2];
      }, ql.hcg.hwb = function(e2) {
        const t2 = e2[1] / 100, i2 = t2 + e2[2] / 100 * (1 - t2);
        return [e2[0], 100 * (i2 - t2), 100 * (1 - i2)];
      }, ql.hwb.hcg = function(e2) {
        const t2 = e2[1] / 100, i2 = 1 - e2[2] / 100, n2 = i2 - t2;
        let r2 = 0;
        return n2 < 1 && (r2 = (i2 - n2) / (1 - n2)), [e2[0], 100 * n2, 100 * r2];
      }, ql.apple.rgb = function(e2) {
        return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
      }, ql.rgb.apple = function(e2) {
        return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
      }, ql.gray.rgb = function(e2) {
        return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
      }, ql.gray.hsl = function(e2) {
        return [0, 0, e2[0]];
      }, ql.gray.hsv = ql.gray.hsl, ql.gray.hwb = function(e2) {
        return [0, 100, e2[0]];
      }, ql.gray.cmyk = function(e2) {
        return [0, 0, 0, e2[0]];
      }, ql.gray.lab = function(e2) {
        return [e2[0], 0, 0];
      }, ql.gray.hex = function(e2) {
        const t2 = 255 & Math.round(e2[0] / 100 * 255), i2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
        return "000000".substring(i2.length) + i2;
      }, ql.rgb.gray = function(e2) {
        return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
      };
      const Zl = Yl;
      function Jl(e2) {
        const t2 = function() {
          const e3 = {}, t3 = Object.keys(Zl);
          for (let i3 = t3.length, n2 = 0; n2 < i3; n2++)
            e3[t3[n2]] = { distance: -1, parent: null };
          return e3;
        }(), i2 = [e2];
        for (t2[e2].distance = 0; i2.length; ) {
          const e3 = i2.pop(), n2 = Object.keys(Zl[e3]);
          for (let r2 = n2.length, s2 = 0; s2 < r2; s2++) {
            const r3 = n2[s2], a2 = t2[r3];
            -1 === a2.distance && (a2.distance = t2[e3].distance + 1, a2.parent = e3, i2.unshift(r3));
          }
        }
        return t2;
      }
      function Kl(e2, t2) {
        return function(i2) {
          return t2(e2(i2));
        };
      }
      function Ql(e2, t2) {
        const i2 = [t2[e2].parent, e2];
        let n2 = Zl[t2[e2].parent][e2], r2 = t2[e2].parent;
        for (; t2[r2].parent; )
          i2.unshift(t2[r2].parent), n2 = Kl(Zl[t2[r2].parent][r2], n2), r2 = t2[r2].parent;
        return n2.conversion = i2, n2;
      }
      const $l = Yl, eh = function(e2) {
        const t2 = Jl(e2), i2 = {}, n2 = Object.keys(t2);
        for (let r2 = n2.length, s2 = 0; s2 < r2; s2++) {
          const e3 = n2[s2];
          null !== t2[e3].parent && (i2[e3] = Ql(e3, t2));
        }
        return i2;
      }, th = {};
      Object.keys($l).forEach((e2) => {
        th[e2] = {}, Object.defineProperty(th[e2], "channels", { value: $l[e2].channels }), Object.defineProperty(th[e2], "labels", { value: $l[e2].labels });
        const t2 = eh(e2);
        Object.keys(t2).forEach((i2) => {
          const n2 = t2[i2];
          th[e2][i2] = function(e3) {
            const t3 = function(...t4) {
              const i3 = t4[0];
              if (null == i3)
                return i3;
              i3.length > 1 && (t4 = i3);
              const n3 = e3(t4);
              if ("object" == typeof n3)
                for (let e4 = n3.length, r2 = 0; r2 < e4; r2++)
                  n3[r2] = Math.round(n3[r2]);
              return n3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(n2), th[e2][i2].raw = function(e3) {
            const t3 = function(...t4) {
              const i3 = t4[0];
              return null == i3 ? i3 : (i3.length > 1 && (t4 = i3), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(n2);
        });
      });
      var ih = th;
      const nh = Ll.exports, rh = ih, sh = ["keyword", "gray", "hex"], ah = {};
      for (const Yb of Object.keys(rh))
        ah[[...rh[Yb].labels].sort().join("")] = Yb;
      const oh = {};
      function lh(e2, t2) {
        if (!(this instanceof lh))
          return new lh(e2, t2);
        if (t2 && t2 in sh && (t2 = null), t2 && !(t2 in rh))
          throw new Error("Unknown model: " + t2);
        let i2, n2;
        if (null == e2)
          this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
        else if (e2 instanceof lh)
          this.model = e2.model, this.color = [...e2.color], this.valpha = e2.valpha;
        else if ("string" == typeof e2) {
          const t3 = nh.get(e2);
          if (null === t3)
            throw new Error("Unable to parse color from string: " + e2);
          this.model = t3.model, n2 = rh[this.model].channels, this.color = t3.value.slice(0, n2), this.valpha = "number" == typeof t3.value[n2] ? t3.value[n2] : 1;
        } else if (e2.length > 0) {
          this.model = t2 || "rgb", n2 = rh[this.model].channels;
          const i3 = Array.prototype.slice.call(e2, 0, n2);
          this.color = dh(i3, n2), this.valpha = "number" == typeof e2[n2] ? e2[n2] : 1;
        } else if ("number" == typeof e2)
          this.model = "rgb", this.color = [e2 >> 16 & 255, e2 >> 8 & 255, 255 & e2], this.valpha = 1;
        else {
          this.valpha = 1;
          const t3 = Object.keys(e2);
          "alpha" in e2 && (t3.splice(t3.indexOf("alpha"), 1), this.valpha = "number" == typeof e2.alpha ? e2.alpha : 0);
          const n3 = t3.sort().join("");
          if (!(n3 in ah))
            throw new Error("Unable to parse color from object: " + JSON.stringify(e2));
          this.model = ah[n3];
          const { labels: r2 } = rh[this.model], s2 = [];
          for (i2 = 0; i2 < r2.length; i2++)
            s2.push(e2[r2[i2]]);
          this.color = dh(s2);
        }
        if (oh[this.model])
          for (n2 = rh[this.model].channels, i2 = 0; i2 < n2; i2++) {
            const e3 = oh[this.model][i2];
            e3 && (this.color[i2] = e3(this.color[i2]));
          }
        this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
      }
      lh.prototype = { toString() {
        return this.string();
      }, toJSON() {
        return this[this.model]();
      }, string(e2) {
        let t2 = this.model in nh.to ? this : this.rgb();
        t2 = t2.round("number" == typeof e2 ? e2 : 1);
        const i2 = 1 === t2.valpha ? t2.color : [...t2.color, this.valpha];
        return nh.to[t2.model](i2);
      }, percentString(e2) {
        const t2 = this.rgb().round("number" == typeof e2 ? e2 : 1), i2 = 1 === t2.valpha ? t2.color : [...t2.color, this.valpha];
        return nh.to.rgb.percent(i2);
      }, array() {
        return 1 === this.valpha ? [...this.color] : [...this.color, this.valpha];
      }, object() {
        const e2 = {}, { channels: t2 } = rh[this.model], { labels: i2 } = rh[this.model];
        for (let n2 = 0; n2 < t2; n2++)
          e2[i2[n2]] = this.color[n2];
        return 1 !== this.valpha && (e2.alpha = this.valpha), e2;
      }, unitArray() {
        const e2 = this.rgb().color;
        return e2[0] /= 255, e2[1] /= 255, e2[2] /= 255, 1 !== this.valpha && e2.push(this.valpha), e2;
      }, unitObject() {
        const e2 = this.rgb().object();
        return e2.r /= 255, e2.g /= 255, e2.b /= 255, 1 !== this.valpha && (e2.alpha = this.valpha), e2;
      }, round(e2) {
        return e2 = Math.max(e2 || 0, 0), new lh([...this.color.map(hh(e2)), this.valpha], this.model);
      }, alpha(e2) {
        return void 0 !== e2 ? new lh([...this.color, Math.max(0, Math.min(1, e2))], this.model) : this.valpha;
      }, red: ch("rgb", 0, uh(255)), green: ch("rgb", 1, uh(255)), blue: ch("rgb", 2, uh(255)), hue: ch(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (e2) => (e2 % 360 + 360) % 360), saturationl: ch("hsl", 1, uh(100)), lightness: ch("hsl", 2, uh(100)), saturationv: ch("hsv", 1, uh(100)), value: ch("hsv", 2, uh(100)), chroma: ch("hcg", 1, uh(100)), gray: ch("hcg", 2, uh(100)), white: ch("hwb", 1, uh(100)), wblack: ch("hwb", 2, uh(100)), cyan: ch("cmyk", 0, uh(100)), magenta: ch("cmyk", 1, uh(100)), yellow: ch("cmyk", 2, uh(100)), black: ch("cmyk", 3, uh(100)), x: ch("xyz", 0, uh(95.047)), y: ch("xyz", 1, uh(100)), z: ch("xyz", 2, uh(108.833)), l: ch("lab", 0, uh(100)), a: ch("lab", 1), b: ch("lab", 2), keyword(e2) {
        return void 0 !== e2 ? new lh(e2) : rh[this.model].keyword(this.color);
      }, hex(e2) {
        return void 0 !== e2 ? new lh(e2) : nh.to.hex(this.rgb().round().color);
      }, hexa(e2) {
        if (void 0 !== e2)
          return new lh(e2);
        const t2 = this.rgb().round().color;
        let i2 = Math.round(255 * this.valpha).toString(16).toUpperCase();
        return 1 === i2.length && (i2 = "0" + i2), nh.to.hex(t2) + i2;
      }, rgbNumber() {
        const e2 = this.rgb().color;
        return (255 & e2[0]) << 16 | (255 & e2[1]) << 8 | 255 & e2[2];
      }, luminosity() {
        const e2 = this.rgb().color, t2 = [];
        for (const [i2, n2] of e2.entries()) {
          const e3 = n2 / 255;
          t2[i2] = e3 <= 0.04045 ? e3 / 12.92 : ((e3 + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * t2[0] + 0.7152 * t2[1] + 0.0722 * t2[2];
      }, contrast(e2) {
        const t2 = this.luminosity(), i2 = e2.luminosity();
        return t2 > i2 ? (t2 + 0.05) / (i2 + 0.05) : (i2 + 0.05) / (t2 + 0.05);
      }, level(e2) {
        const t2 = this.contrast(e2);
        return t2 >= 7 ? "AAA" : t2 >= 4.5 ? "AA" : "";
      }, isDark() {
        const e2 = this.rgb().color;
        return (2126 * e2[0] + 7152 * e2[1] + 722 * e2[2]) / 1e4 < 128;
      }, isLight() {
        return !this.isDark();
      }, negate() {
        const e2 = this.rgb();
        for (let t2 = 0; t2 < 3; t2++)
          e2.color[t2] = 255 - e2.color[t2];
        return e2;
      }, lighten(e2) {
        const t2 = this.hsl();
        return t2.color[2] += t2.color[2] * e2, t2;
      }, darken(e2) {
        const t2 = this.hsl();
        return t2.color[2] -= t2.color[2] * e2, t2;
      }, saturate(e2) {
        const t2 = this.hsl();
        return t2.color[1] += t2.color[1] * e2, t2;
      }, desaturate(e2) {
        const t2 = this.hsl();
        return t2.color[1] -= t2.color[1] * e2, t2;
      }, whiten(e2) {
        const t2 = this.hwb();
        return t2.color[1] += t2.color[1] * e2, t2;
      }, blacken(e2) {
        const t2 = this.hwb();
        return t2.color[2] += t2.color[2] * e2, t2;
      }, grayscale() {
        const e2 = this.rgb().color, t2 = 0.3 * e2[0] + 0.59 * e2[1] + 0.11 * e2[2];
        return lh.rgb(t2, t2, t2);
      }, fade(e2) {
        return this.alpha(this.valpha - this.valpha * e2);
      }, opaquer(e2) {
        return this.alpha(this.valpha + this.valpha * e2);
      }, rotate(e2) {
        const t2 = this.hsl();
        let i2 = t2.color[0];
        return i2 = (i2 + e2) % 360, i2 = i2 < 0 ? 360 + i2 : i2, t2.color[0] = i2, t2;
      }, mix(e2, t2) {
        if (!e2 || !e2.rgb)
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof e2);
        const i2 = e2.rgb(), n2 = this.rgb(), r2 = void 0 === t2 ? 0.5 : t2, s2 = 2 * r2 - 1, a2 = i2.alpha() - n2.alpha(), o2 = ((s2 * a2 == -1 ? s2 : (s2 + a2) / (1 + s2 * a2)) + 1) / 2, l2 = 1 - o2;
        return lh.rgb(o2 * i2.red() + l2 * n2.red(), o2 * i2.green() + l2 * n2.green(), o2 * i2.blue() + l2 * n2.blue(), i2.alpha() * r2 + n2.alpha() * (1 - r2));
      } };
      for (const Yb of Object.keys(rh)) {
        if (sh.includes(Yb))
          continue;
        const { channels: e2 } = rh[Yb];
        lh.prototype[Yb] = function(...e3) {
          return this.model === Yb ? new lh(this) : e3.length > 0 ? new lh(e3, Yb) : new lh([...(t2 = rh[this.model][Yb].raw(this.color), Array.isArray(t2) ? t2 : [t2]), this.valpha], Yb);
          var t2;
        }, lh[Yb] = function(...t2) {
          let i2 = t2[0];
          return "number" == typeof i2 && (i2 = dh(t2, e2)), new lh(i2, Yb);
        };
      }
      function hh(e2) {
        return function(t2) {
          return function(e3, t3) {
            return Number(e3.toFixed(t3));
          }(t2, e2);
        };
      }
      function ch(e2, t2, i2) {
        e2 = Array.isArray(e2) ? e2 : [e2];
        for (const n2 of e2)
          (oh[n2] || (oh[n2] = []))[t2] = i2;
        return e2 = e2[0], function(n2) {
          let r2;
          return void 0 !== n2 ? (i2 && (n2 = i2(n2)), r2 = this[e2](), r2.color[t2] = n2, r2) : (r2 = this[e2]().color[t2], i2 && (r2 = i2(r2)), r2);
        };
      }
      function uh(e2) {
        return function(t2) {
          return Math.max(0, Math.min(e2, t2));
        };
      }
      function dh(e2, t2) {
        for (let i2 = 0; i2 < t2; i2++)
          "number" != typeof e2[i2] && (e2[i2] = 0);
        return e2;
      }
      const ph = lh;
      function mh(e2) {
        if (!e2)
          return new Se();
        if (e2.isColor)
          return [e2.r, e2.g, e2.b, 1];
        const t2 = gh(e2);
        return new Se(t2[0], t2[1], t2[2], t2[3]);
      }
      function fh(e2) {
        if (!e2)
          return new Ae();
        const t2 = gh(e2);
        return new Ae(t2[0], t2[1], t2[2]);
      }
      function gh(e2) {
        if (!e2)
          return [1, 1, 1, 1];
        const t2 = ph(e2), i2 = t2.unitArray();
        return [i2[0], i2[1], i2[2], i2[3] || t2.valpha];
      }
      function _h(e2) {
        if (!e2)
          return [1, 1, 1];
        const t2 = ph(e2).unitArray();
        return [t2[0], t2[1], t2[2]];
      }
      const vh = Object.freeze(Object.defineProperty({ __proto__: null, colorToVec4: mh, colorToVec3: fh, colorToArr4: gh, colorToArr3: _h }, Symbol.toStringTag, { value: "Module" })), xh = { mvt_emissive: { value: null }, mvt_emissiveIntensity: { value: 1 } }, yh = { selectedObjectColor: { value: [1, 1, 0, 0.5] }, selectedObjectIndex: { value: -1 }, selectedObjectColorMode: { value: 0 } }, bh = { keepSize: { value: false }, zoomUnits: { value: 1 } }, Mh = (e2, t2 = []) => {
        for (let i2 of t2)
          Object.defineProperty(e2, i2, { get: function() {
            return this.uniforms[i2].value;
          }, set: function(e3) {
            this.uniforms[i2].value = e3;
          } });
      }, Sh = (e2, t2 = []) => {
        for (let i2 of t2)
          Object.defineProperty(e2, i2, { get: function() {
            return this.uniforms[i2].value;
          }, set: function(e3) {
            this.uniforms[i2].value = mh(e3);
          } });
      }, wh = (e2, t2 = []) => {
        for (let [i2, n2, r2] of t2)
          Object.defineProperty(e2, i2, { get: function() {
            return this.uniforms[n2].value;
          }, set: function(e3) {
            this.uniforms[n2].value = r2 ? r2(e3) : e3;
          } });
      }, Th = (e2, t2 = []) => {
        for (let [i2, n2] of t2)
          Object.defineProperty(e2, i2, { get: function() {
            return !!this.defines[n2];
          }, set: function(e3) {
            this[i2] !== e3 && (e3 ? this.defines[n2] = true : delete this.defines[n2], this.needsUpdate = true);
          } });
      }, Eh = (e2) => {
        Object.defineProperties(e2, { selectedObjectColor: { get: function() {
          return this.uniforms.selectedObjectColor.value;
        }, set: function(e3) {
          this.uniforms.selectedObjectColor.value = e3;
        } }, selectedObjectColorMode: { get: function() {
          return this.uniforms.selectedObjectColorMode.value;
        }, set: function(e3) {
          this.uniforms.selectedObjectColorMode.value = e3;
        } }, selectedObjectIndex: { get: function() {
          return this.uniforms.selectedObjectIndex.value;
        }, set: function(e3) {
          this.uniforms.selectedObjectIndex.value = e3;
        } }, selective: { get: function() {
          return !!this.defines.MVT_ENABLE_SELECTIVE;
        }, set: function(e3) {
          this.selective !== e3 && (e3 ? this.defines.MVT_ENABLE_SELECTIVE = true : delete this.defines.MVT_ENABLE_SELECTIVE, this.needsUpdate = true);
        } } });
      }, Ch = (e2) => {
        Object.defineProperties(e2, { keepSize: { get: function() {
          return this.uniforms.keepSize.value;
        }, set: function(e3) {
          this.uniforms.keepSize.value = e3;
        } }, zoomUnits: { get: function() {
          return this.uniforms.zoomUnits.value;
        }, set: function(e3) {
          this.uniforms.zoomUnits.value = e3;
        } }, zoomUnitsUniform: { get: function() {
          return this.uniforms.zoomUnits;
        }, set: function(e3) {
          this.uniforms.zoomUnits = e3;
        } } });
      }, Ah = (e2) => {
        Object.defineProperties(e2, { emissiveEnabled: { get: function() {
          return this.defines.MVT_EMISSIVE_UNIFORM || false;
        }, set: function(e3) {
          e3 ? this.defines.MVT_EMISSIVE_UNIFORM = true : delete this.defines.MVT_EMISSIVE_UNIFORM;
        } }, emissive: { get: function() {
          return this.uniforms.mvt_emissive.value;
        }, set: function(e3) {
          e3 ? this.defines.MVT_EMISSIVE_COLOR = true : delete this.defines.MVT_EMISSIVE_COLOR, this.uniforms.mvt_emissive.value = e3;
        } }, emissiveIntensity: { get: function() {
          return this.uniforms.mvt_emissiveIntensity.value;
        }, set: function(e3) {
          this.uniforms.mvt_emissiveIntensity.value = e3;
        } } });
      }, Ph = (e2) => {
        const t2 = e2 && e2.source && e2.source.data && e2.source.data.height || null;
        if (null === t2)
          return null;
        const i2 = Math.log2(t2) - 2, n2 = 1 / t2;
        return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i2), 112)), texelHeight: n2, maxMip: i2 };
      }, Rh = { tDiffuse: { value: null }, tNormal: { value: null }, tMetalness: { value: null }, tEnhancement: { value: null }, tEnhancementScale: { value: new ie(20, 20) }, tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new ie() }, cameraProjectionMatrix: { value: new st() }, cameraInverseProjectionMatrix: { value: new st() }, mvt_viewInverseMatrix: { value: new st() }, mvt_normalInverseMatrix: { value: new ne() }, opacity: { value: 0.5 }, maxDistance: { value: 180 }, cameraRange: { value: 0 }, thickness: { value: 0.018 }, logDepthBufFC: { value: 1 }, threshold: { value: 0.35 } };
      class Lh extends Ai {
        constructor(e2) {
          super(), this.vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}", this.fragmentShader = 'precision highp sampler2D;\n#define GLSLIFY 1\nvarying vec2 vUv;\nuniform sampler2D tDepth;\nuniform sampler2D tNormal;\nuniform sampler2D tMetalness;\nuniform sampler2D tDiffuse;\n\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nuniform sampler2D tEnhancement;\nuniform vec2 tEnhancementScale;\nuniform mat4 mvt_viewInverseMatrix;\nuniform mat3 mvt_normalInverseMatrix;\n#endif\n\nuniform float cameraRange;\nuniform vec2 resolution;\nuniform float opacity;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float maxDistance;\nuniform float thickness;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float threshold; // 控制反射最低阈值，低于此致的不计算，可提高性能\n\n#include <packing>\nfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n    //x0: point, x1: linePointA, x2: linePointB\n    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);\n}\nfloat pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {\n    // https://mathworld.wolfram.com/Point-PlaneDistance.html\n    //// https://en.wikipedia.org/wiki/Plane_(geometry)\n    //// http://paulbourke.net/geometry/pointlineplane/\n    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;\n    float x0 = point.x, y0 = point.y, z0 = point.z;\n    float x = planePoint.x, y = planePoint.y, z = planePoint.z;\n    float d = -(a * x + b * y + c * z);\n    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);\n    return distance;\n}\n// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer\nfloat linearize_depth(in float depth) {\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(const in vec2 uv) {\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepth(const in vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n    return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;\n    #else\n    return texture2D(tDepth, uv).x;\n    #endif\n\n}\nfloat getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n}\nvec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {\n    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc\n    clipPosition *= clipW; //clip\n    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view\n}\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nvec3 getWorldPositionFromDepth(float depth) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;\n    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n#endif\nvec3 getViewNormal(const in vec2 uv) {\n    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);\n}\nvec2 viewPositionToXY(vec3 viewPosition) {\n    vec2 xy;\n    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);\n    xy = clip.xy;//clip\n    float clipW = clip.w;\n    xy /= clipW;//NDC\n    xy = (xy + 1.) / 2.;//uv\n    xy *= resolution;//screen\n    return xy;\n}\nvoid main() {\n\n    float depth = getDepth(vUv);\n    vec3 viewNormal = getViewNormal(vUv);\n    #ifdef SELECTIVE\n    // 完全没反射的表面直接剔除\n    float intensity = texture2D(tMetalness, vUv).x;\n\n    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\n        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));\n        if (dirAlpha > 0.5) {\n            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, \n                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);\n            float enhancement = texture2D(tEnhancement, enhancementUv).x;\n            intensity += (1.0 - enhancement);\n        }\n        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);\n        // return;\n    #endif\n\n    if(intensity < threshold)\n        return;\n    intensity -= threshold;\n    intensity *= 1.0 / (1.0 - threshold);\n    #endif\n\n    \n    float viewZ = getViewZ(depth);\n    // z值已经超过相机远端距离\n    if(-viewZ >= cameraFar)\n        return;\n\n    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n    // 相机视图下的当前片元坐标\n    vec3 viewPosition = getViewPosition(vUv, depth, clipW);\n\n    // 起点的屏幕坐标\n    vec2 d0 = gl_FragCoord.xy;\n    vec2 d1;\n\n    #ifdef PERSPECTIVE_CAMERA\n    // 入射光方向，相机在原点，方向即为坐标的单位向量\n    vec3 viewIncidentDir = normalize(viewPosition);\n    // 反射光方向\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #else\n    vec3 viewIncidentDir = vec3(0, 0, -1);\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #endif\n\n    // 反射光线最长距离由输入的最大反射距离和入射角决定\n    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);\n    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n    // maxDistance/maxReflectRayLen=cos(theta)\n    // maxDistance/maxReflectRayLen==dot(a,b)\n    // maxReflectRayLen==maxDistance/dot(a,b)\n\n    // 反射最远距离下的坐标点\n    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;\n    #ifdef PERSPECTIVE_CAMERA\n    if(d1viewPosition.z > -cameraNear) {\n            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n        // 应该是处理反射点溢出相机视野外的情况\n        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;\n        d1viewPosition = viewPosition + viewReflectDir * t;\n    }\n    #endif\n    // 反射最远点在屏幕上的位置\n    d1 = viewPositionToXY(d1viewPosition);\n\n    // 屏幕像素距离\n    float totalLen = length(d1 - d0);\n    float xLen = d1.x - d0.x;\n    float yLen = d1.y - d0.y;\n    // 最大步数取xy方向较大的一个方向，每次步进一个像素\n    float totalStep = max(abs(xLen), abs(yLen));\n    // x方向每次步进的大小\n    float xSpan = xLen / totalStep;\n    // y方向每次步进的大小\n    float ySpan = yLen / totalStep;\n    // 步进次数最大是屏幕对角线距离（应该是横向或者纵向的最大值），实际次数要远小于这个\n    for(float i = 0.; i < float(MAX_STEP); i++) {\n        if(i >= totalStep)\n            break;\n        // march到的当前屏幕像素\n        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);\n        // 跑到屏幕外march失败\n        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)\n            break;\n        // 当前百分比\n        float s = length(xy - d0) / totalLen;\n        // 当前uv\n        vec2 uv = xy / resolution;\n        // 计算当前点的各项参数，和一开始一样\n        float d = getDepth(uv);\n        float vZ = getViewZ(d);\n        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);\n        // return;\n        if(-vZ >= cameraFar)\n            continue;\n        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];\n        // 得到当前点的viewposition\n        vec3 vP = getViewPosition(uv, d, cW);\n\n        // 得到当前反射线的z\n        #ifdef PERSPECTIVE_CAMERA\n            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n        float recipVPZ = 1. / viewPosition.z;\n        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));\n        #else\n        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);\n        #endif\n\n        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.\n        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164\n        // 反射线的z小于当前点的z,否则就是被遮挡住了\n        if(viewReflectRayZ <= vZ) {\n\n            bool hit;\n            #ifdef INFINITE_THICK\n            hit = true;\n            #else\n            // 点到射线的距离\n            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);\n\n            // minThickness没看懂，和横向邻接点的viewx差值，大约代表了此处一个像素和实际距离的比例，乘3.0？\n            float minThickness;\n            vec2 xyNeighbor = xy;\n            xyNeighbor.x += 1.;\n            vec2 uvNeighbor = xyNeighbor / resolution;\n            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);\n            minThickness = vPNeighbor.x - vP.x;\n            minThickness *= 3.;\n            float tk = max(minThickness, thickness);\n            // 当距离小于阈值时才算是真正相交\n            hit = away <= tk;\n            #endif\n\n            if(hit) {\n                vec3 vN = getViewNormal(uv);\n                // 相交到物体的反面了，march无效\n                if(dot(viewReflectDir, vN) >= 0.)\n                    continue;\n                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);\n                // march距离超过最大\n                if(distance > maxDistance)\n                    break;\n                float op = opacity;\n                // 随着距离减弱反射，防止反射突然消失\n                #ifdef DISTANCE_ATTENUATION\n                float ratio = 1. - (distance / maxDistance);\n                float attenuation = ratio * ratio;\n                op = opacity * attenuation;\n                #endif\n                // 菲涅尔反射定律，与视野角度偏离越大，颜色权重越大\n                #ifdef FRESNEL\n                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;\n                op *= fresnelCoe;\n                #endif\n                // 读取反射颜色赋给当前片元\n                vec4 reflectColor = texture2D(tDiffuse, uv);\n                gl_FragColor.xyz = reflectColor.xyz;\n                gl_FragColor.a = op;\n                #ifdef SELECTIVE\n                gl_FragColor.a *= intensity;\n                #endif\n                break;\n            }\n        }\n    }\n}', this.uniforms = Ci.clone(Rh), this.defines = { MAX_STEP: 0, PERSPECTIVE_CAMERA: true, DISTANCE_ATTENUATION: true, FRESNEL: true, INFINITE_THICK: false, SELECTIVE: false }, Mh(this, ["tDiffuse", "tNormal", "tDepth", "tMetalness", "cameraNear", "cameraFar", "threshold", "thickness", "opacity", "tEnhancementScale"]), Th(this, []), Object.defineProperties(this, { tEnhancement: { get: function() {
            return this.uniforms.tEnhancement.value;
          }, set: function(e3) {
            e3 ? (this.uniforms.tEnhancement.value = e3, this.defines.MVT_SSR_USE_ENHANCEMENT_MAP = true) : (this.uniforms.tEnhancement.value = null, delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP);
          } } }), this.setValues(e2);
        }
        dispose() {
          let e2 = ["tEnhancement", "tDiffuse", "tNormal", "tDepth", "tMetalness"];
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this.uniforms[i2] && this.uniforms[i2].value && this.uniforms[i2].value.dispose();
          }
          super.dispose();
        }
      }
      class Ih extends yl {
        constructor(e2, { tDiffuse: t2, tDepth: i2, tNormal: n2, tMetalness: r2, resolution: s2 }) {
          super();
          const a2 = this.material = new Lh();
          a2.uniforms.tDiffuse.value = t2, a2.uniforms.tDepth.value = i2, a2.uniforms.tNormal.value = n2, a2.uniforms.tMetalness.value = r2, a2.uniforms.resolution.value = s2, a2.defines.MAX_STEP = Math.sqrt(s2.x * s2.x + s2.y * s2.y), a2.defines.DISTANCE_ATTENUATION = true, a2.defines.SELECTIVE = true, this.renderTarget = e2, this.fsQuad = new Sl(null);
        }
        render(e2, t2) {
          const i2 = this.material;
          i2.uniforms.cameraProjectionMatrix.value.copy(t2.projectionMatrix), i2.uniforms.cameraInverseProjectionMatrix.value.copy(t2.projectionMatrixInverse), i2.uniforms.mvt_viewInverseMatrix.value.copy(t2.matrixWorld), i2.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(t2.matrixWorldInverse), i2.uniforms.cameraNear.value = t2.near, i2.uniforms.cameraFar.value = t2.far, this.fsQuad.material = i2, e2.setRenderTarget(this.renderTarget), this.fsQuad.render(e2);
        }
        dispose() {
          this.material.dispose(), this.fsQuad.dispose();
        }
      }
      class Dh {
        constructor(e2) {
          __publicField(this, "_rendering"), __publicField(this, "_enabled", false), __publicField(this, "_renderPass", null), __publicField(this, "_threshold", 0.5), __publicField(this, "_thickness", 0.018), __publicField(this, "_opacity", 0.5), __publicField(this, "_useMrt", false), this._rendering = e2;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          e2 !== this._useMrt && (this._useMrt = e2, e2 || this.dispose());
        }
        set enabled(e2) {
          (e2 = !!e2) !== this._enabled && (this._enabled = e2, e2 || this.dispose());
        }
        get enabled() {
          return this._enabled;
        }
        _init() {
          const e2 = this._rendering, t2 = e2.resolution, i2 = this._ssrRenderTarget = new we(t2.x, t2.y, { encoding: e2.outputEncoding }), n2 = this._renderPass = new Ih(i2, { tDiffuse: e2.main.tDiffuse, tNormal: e2.main.tNormal, tMetalness: e2.main.tSpecular, tDepth: e2.main.tDepth, resolution: t2 });
          n2.material.threshold = this._threshold, n2.material.thickness = this._thickness, n2.material.opacity = this._opacity, e2.composition.tReflection = i2.texture, console.log("ssr init");
        }
        render() {
          if (!this._enabled || !this._useMrt)
            return;
          this._enabled && !this._renderPass && this._init();
          const e2 = this._rendering;
          this._renderPass.render(e2.renderer, e2.camera);
        }
        dispose() {
          this._rendering.composition.tReflection = null, this._renderPass && (this._renderPass.dispose(), this._renderPass = null), this._ssrRenderTarget && (this._ssrRenderTarget.dispose(), this._ssrRenderTarget = null);
        }
        getTextures() {
          const e2 = [];
          return this._ssrRenderTarget && e2.push(this._ssrRenderTarget.texture), e2;
        }
        setSize(e2, t2) {
          this._ssrRenderTarget && this._ssrRenderTarget.setSize(e2, t2);
        }
        get tReflection() {
          return this._ssrRenderTarget && this._ssrRenderTarget.texture || null;
        }
        get threshold() {
          return this._threshold;
        }
        set threshold(e2) {
          this._threshold = e2, this._renderPass && (this._renderPass.material.threshold = e2);
        }
        get thickness() {
          return this._thickness;
        }
        set thickness(e2) {
          this._thickness = e2, this._renderPass && (this._renderPass.material.thickness = e2);
        }
        get opacity() {
          return this._opacity;
        }
        set opacity(e2) {
          this._opacity = e2, this._renderPass && (this._renderPass.material.opacity = e2);
        }
        set tEnhancement(e2) {
          this._renderPass && (this._renderPass.material.tEnhancement = e2);
        }
        get tEnhancement() {
          return this._renderPass ? this._renderPass.material.tEnhancement : null;
        }
        set tEnhancementScale(e2) {
          this._renderPass && (this._renderPass.material.tEnhancementScale = e2);
        }
        get tEnhancementScale() {
          return this._renderPass ? this._renderPass.material.tEnhancementScale : null;
        }
      }
      const Fh = { tDiffuse: { value: null }, tBloom: { value: null }, tNormal: { value: null }, tReflection: { value: null }, tDepth: { value: null }, tEnv: { value: null }, tCount: { value: 0 }, tDebug1: { value: null }, tDebug2: { value: null }, tDebug3: { value: null }, tDebug4: { value: null }, debugDimension: { value: new ie(0.25, 0.2) }, debugOffset: { value: new ie(0, 0) }, mvt_normalInverseMatrix: { value: new ne() }, mvt_projectionInverseMatrix: { value: new st() }, mvt_viewInverseMatrix: { value: new st() }, mvt_projectionMatrix: { value: new st() }, coverageColor: { value: new ge(16777215) }, coverageSacle: { value: new ie(20, 20) }, coverageIntensity: { value: 0 }, tCoverageIntensity: { value: null }, resolution: { value: [1, 1] }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, logDepthBufFC: { value: 1 }, fogColor: { value: new ge(16777215) }, fogDensity: { value: 1 }, fogAltitudeBottom: { value: 0 }, fogAltitudeTop: { value: 1e3 }, fogSkyColorStartFactor: { value: 0.3 }, adjustBrightnessFactor: { value: 0 }, adjustContrastFactor: { value: 0 }, adjustSaturationFactor: { value: 0 } };
      class Oh extends Ai {
        constructor(e2) {
          super(), this.vertexShader = "#define GLSLIFY 1\n// attribute vec3 position;\n// attribute vec2 uv;\nvarying vec2 vUv;\n// uniform mat4 modelViewMatrix;\n// uniform mat4 projectionMatrix;\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}", this.fragmentShader = "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n#include <common>\n#include <packing>\n#include <cube_uv_reflection_fragment>\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\n\n#if defined(MVT_POST_ENABLE_BLOOM)\n    uniform sampler2D tBloom;\n#endif\n\n#if defined(MVT_POST_ENABLE_REFLECTION)\n    uniform sampler2D tReflection;\n#endif\n\n#if defined(MVT_POST_ENABLE_COVERAGE)\n    #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)\n        uniform sampler2D tCoverageIntensity; \n    #endif\n    uniform vec2 coverageSacle;\n    uniform float coverageIntensity;\n    // 覆盖层颜色\n    uniform vec3 coverageColor;\n#endif\n\n// 加前缀防止被three.js本身变量覆盖\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat3 mvt_normalInverseMatrix;\nuniform mat4 mvt_projectionMatrix;\nuniform mat4 mvt_projectionInverseMatrix;\nuniform mat4 mvt_viewInverseMatrix;\n\n#if defined(MVT_POST_USE_FOG)\n    uniform vec3 fogColor;\n    uniform float fogDensity;\n    uniform float fogSkyColorStartFactor;\n    uniform float fogAltitudeBottom;\n    uniform float fogAltitudeTop;\n#endif\n\n#if defined(ENVMAP_TYPE_CUBE_UV)\n    uniform sampler2D tEnv;\n#elif defined(ENVMAP_TYPE_CUBE)\n    uniform samplerCube tEnv;\n#endif\n\n#ifdef MVT_POST_ENABLE_COLOR_ADJUST\n    uniform float adjustBrightnessFactor;\n    uniform float adjustContrastFactor; \n    uniform float adjustSaturationFactor; \n#endif\n\n#ifdef MVT_MRT_POST_DEBUG\n    uniform vec2 debugDimension;\n    uniform vec2 debugOffset;\n    uniform int tCount;\n    uniform sampler2D tDebug1;\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1\n        uniform sampler2D tDebug2;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2\n        uniform sampler2D tDebug3;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3\n        uniform sampler2D tDebug4;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4\n        uniform sampler2D tDebug5;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5\n        uniform sampler2D tDebug6;\n    #endif\n#endif\n\nvarying vec2 vUv;\n\nfloat linearize_depth(in float depth){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(const in vec2 uv){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepth(vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n        return linearize_depth(reconstruct_depth(uv));\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\nvec3 getWorldPositionFromDepth(float depth) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = mvt_projectionInverseMatrix * clipSpacePosition;\n    \n    // viewSpacePosition /= viewSpacePosition.w;\n    // return viewSpacePosition.xyz;\n    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\nfloat getNoramlLength(vec3 normal) {\n    if (normal.x < 0. || normal.y < 0. || normal.z < 0.) {\n        return 0.;\n    }\n    return length(normal);\n}\nvoid renderOutputColor() {\n    vec4 outColor = texture2D(tDiffuse, vUv);\n\n    // bloom\n    #if defined(MVT_POST_ENABLE_BLOOM)\n    outColor += vec4( 1.0 ) * texture2D(tBloom, vUv);\n    #endif\n\n    // reflection\n    #if defined(MVT_POST_ENABLE_REFLECTION)\n    vec4 reflectionColor = texture2D( tReflection, vUv );\n    outColor.xyz = mix(outColor.xyz, reflectionColor.xyz, reflectionColor.w);\n    #endif\n\n    vec4 viewNormal = texture2D(tNormal, vUv);\n    vec3 normal = unpackRGBToNormal(viewNormal.xyz);\n    float normalLength = getNoramlLength(normal);\n    \n    #if (defined(MVT_POST_ENABLE_COVERAGE) && defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)) || defined(MVT_POST_USE_FOG)\n        float depth = getDepth(vUv);\n        vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n    #endif\n\n    #if defined(MVT_POST_ENABLE_COVERAGE)\n    if (coverageIntensity > 0.0 && normalLength > 0.5) {\n        float dirAlpha = dot(normal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));\n        if (dirAlpha > 0.2) {\n            float coverageAlpha = clamp(0.0, 1.0, dirAlpha) * coverageIntensity;\n            vec3 coverageFinalColor = vec3(coverageColor);\n            #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)\n                \n                vec2 coverageUv = vec2(mod(worldSpacePosition.x, coverageSacle.x) / coverageSacle.x, \n                    mod(worldSpacePosition.y, coverageSacle.y) / coverageSacle.y);\n                coverageAlpha *= texture2D(tCoverageIntensity, coverageUv).x;\n            #endif\n            // outColor.xyz = vec3(coverageAlpha, 0.0, 0.0);\n            outColor.xyz = mix(outColor.xyz, coverageFinalColor, coverageAlpha);\n        }\n    }\n    #endif\n\n    #if defined(MVT_POST_USE_FOG)\n        vec3 cameraPosition = mvt_viewInverseMatrix[3].xyz;\n        if (cameraPosition.z < 5000.) {\n            float fogFactorMultiplier = clamp((5000. - cameraPosition.z) / 2000., 0., 1.);\n            float fogDepth = texture2D(tDepth, vUv).x;\n            float fogHeight = fogAltitudeTop - fogAltitudeBottom;\n            float fogHeightRatio = (clamp(worldSpacePosition.z, fogAltitudeBottom, fogAltitudeTop) - fogAltitudeBottom) / fogHeight;\n            // 混合大气雾，只混合除去天空的部分\n            // if (normalLength > 0.00001) {\n                #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)\n                    vec3 worldViewDir = normalize(worldSpacePosition.xyz - cameraPosition);\n                    // worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);\n                    // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));\n                    #if defined(ENVMAP_TYPE_CUBE_UV)\n                        vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;\n                    #else\n                        vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;\n                    #endif\n                    float skyColorDepth = 1.0 - fogSkyColorStartFactor;\n                    float skyColrFactor = clamp(fogDepth - fogSkyColorStartFactor, 0.0, skyColorDepth) / skyColorDepth;\n                    skyColrFactor = skyColrFactor * skyColrFactor * skyColrFactor;\n                    skyColrFactor *= 1.0 - fogHeightRatio;\n                    outColor.xyz = mix(outColor.xyz, skyColor, skyColrFactor * fogFactorMultiplier);\n\n                    // outColor.xyz = vec3(abs(normal.xyz)); //vec3(0.0, 0.0, normalLength);\n                    // outColor.xyz = vec3(mod(worldSpacePosition.x, 1000.0), mod(worldSpacePosition.y, 1000.0), 0.0);\n                    // outColor.xyz = skyColor;\n                    // skyColor = vec3(0.0, 0.0, 1.0);\n                    // outColor.xyz = vec3(clamp(fogDepth - 0.95, 0.0, 0.05) * 20.0, 0.0, 0.0);\n                    // fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);\n                    // fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));\n                #endif\n            // }\n            float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n            // fogFactor *= clamp(worldSpacePosition.z, 1.0, 0.0);\n            // 高度衰减系数\n            float heightAttenuation = fogHeightRatio;\n            heightAttenuation = clamp(heightAttenuation - (fogDensity - 0.5), 0.0, 1.0);\n            fogFactor = clamp(fogFactor - heightAttenuation, 0.0, 1.0);\n            // vec3 fogCompseColor = vec3(fogColor);\n            // #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)\n            //     vec3 worldViewDir = normalize(worldSpacePosition.xyz - mvt_viewInverseMatrix[3].xyz);\n            //     worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);\n            //     // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));\n            //     #if defined(ENVMAP_TYPE_CUBE_UV)\n            //         vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;\n            //     #else\n            //         vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;\n            //     #endif\n            //     // skyColor = vec3(0.0, 0.0, 1.0);\n            //     fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);\n            //     fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));\n            // #endif\n            \n            // outColor.xyz = skyColor;\n            outColor.xyz = mix(outColor.xyz, fogColor, fogFactor * fogFactorMultiplier);\n        }\n    #endif\n\n    #ifdef MVT_POST_ENABLE_COLOR_ADJUST\n        // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n        vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));\n        outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + adjustSaturationFactor);\n\n        outColor.xyz = 0.5 + (1.0 + adjustContrastFactor) * (outColor.xyz - 0.5);\n        outColor.xyz = outColor.xyz + adjustBrightnessFactor;\n    #endif\n\n    gl_FragColor = outColor;\n}\n\n#ifdef MVT_MRT_POST_DEBUG\nvoid renderDebugColor(float u, float v) {\n    vec4 color;\n    \n    if (u < 1.0) {\n        color = texture2D(tDebug1, vec2(mod(u, 1.0), v));\n    }\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1\n    else if (u < 2.0) {\n        color = texture2D(tDebug2, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2\n    else if (u < 3.0) {\n        color = texture2D(tDebug3, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3\n    else if (u < 4.0) {\n        color = texture2D(tDebug4, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4\n    else if (u < 5.0) {\n        color = texture2D(tDebug5, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5\n    else if (u < 6.0) {\n        color = texture2D(tDebug6, vec2(mod(u, 1.0), v));\n    }\n    #endif\n\n    gl_FragColor = color;\n}\n#endif\n\nvoid main() {\n\n    #ifdef MVT_MRT_POST_DEBUG\n        float u = (debugOffset.x + vUv.x) / debugDimension.x;\n        float v = (debugOffset.y + vUv.y) / debugDimension.y;\n        if (v >= 0.0 && v <= 1.0 && u >= 0.0 && u <= 1.0 * float(tCount)) {\n            renderDebugColor(u, v);\n        }\n        else {\n            renderOutputColor();\n        }\n    #else\n        renderOutputColor();\n    #endif\n    // #include <tonemapping_fragment>\n    #include <encodings_fragment>\n}", this.uniforms = Ci.clone(Fh), this.defines = { MVT_POST_ENABLE_BLOOM: false, MVT_POST_DEBUG_TEXTURE_COUNT: 0, MVT_POST_USE_FOG: false, MVT_POST_ENABLE_COLOR_ADJUST: false, CUBEUV_TEXEL_WIDTH: 3255208333333333e-19, CUBEUV_TEXEL_HEIGHT: 244140625e-12, CUBEUV_MAX_MIP: "10.0" }, Mh(this, ["tDiffuse", "tNormal", "tDepth", "debugDimension", "debugOffset", "fogColor", "fogDensity", "fogAltitudeBottom", "fogAltitudeTop", "fogSkyColorStartFactor", "adjustBrightnessFactor", "adjustContrastFactor", "adjustSaturationFactor"]), Object.defineProperties(this, { tBloom: { get: function() {
            return this.uniforms.tBloom.value;
          }, set: function(e3) {
            e3 ? (this.uniforms.tBloom.value = e3, this.defines.MVT_POST_ENABLE_BLOOM = true) : (this.uniforms.tBloom.value = null, delete this.defines.MVT_POST_ENABLE_BLOOM), this.needsUpdate = true;
          } }, tReflection: { get: function() {
            return this.uniforms.tReflection.value;
          }, set: function(e3) {
            e3 ? (this.uniforms.tReflection.value = e3, this.defines.MVT_POST_ENABLE_REFLECTION = true) : (this.uniforms.tReflection.value = null, delete this.defines.MVT_POST_ENABLE_REFLECTION), this.needsUpdate = true;
          } }, coverageIntensity: { get: function() {
            return this.uniforms.coverageIntensity.value;
          }, set: function(e3) {
            this.uniforms.coverageIntensity.value = e3, e3 > 0 ? this.defines.MVT_POST_ENABLE_COVERAGE = true : delete this.defines.MVT_POST_ENABLE_COVERAGE, (0 === e3 && this._lastCoverageIntensity > 0 || e3 > 0 && 0 === this._lastCoverageIntensity) && (this.needsUpdate = true), this._lastCoverageIntensity = e3;
          } }, tCoverageIntensity: { get: function() {
            return this.uniforms.tCoverageIntensity.value;
          }, set: function(e3) {
            e3 ? (this.uniforms.tCoverageIntensity.value = e3, this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP = true) : (this.uniforms.tCoverageIntensity.value = null, delete this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP), this.needsUpdate = true;
          } }, debugTextures: { get: function() {
            return null;
          }, set: function(e3) {
            if (Array.isArray(e3)) {
              this.defines.MVT_MRT_POST_DEBUG = true;
              const t2 = e3.length;
              this.uniforms.tCount.value = t2, this.defines.MVT_POST_DEBUG_TEXTURE_COUNT = t2, this.uniforms.tDebug1.value = e3[0] || null, this.uniforms.tDebug2.value = e3[1] || null, this.uniforms.tDebug3.value = e3[2] || null, this.uniforms.tDebug4.value = e3[3] || null;
            } else
              delete this.defines.MVT_MRT_POST_DEBUG, this.defines.MVT_POST_DEBUG_TEXTURE_COUNT = 0, this.uniforms.tCount.value = 0, this.uniforms.tDebug1.value = null, this.uniforms.tDebug2.value = null, this.uniforms.tDebug3.value = null, this.uniforms.tDebug4.value = null;
            this.needsUpdate = true;
          } }, useFog: { get: function() {
            return this.defines.MVT_POST_USE_FOG || false;
          }, set: function(e3) {
            e3 !== !!this.defines.MVT_POST_USE_FOG && (e3 ? this.defines.MVT_POST_USE_FOG = true : delete this.defines.MVT_POST_USE_FOG, this.needsUpdate = true);
          } }, tEnv: { get: function() {
            return this.uniforms.tEnv.value;
          }, set: function(e3) {
            if (e3 !== this.uniforms.tEnv.value) {
              if (e3)
                if (e3.mapping === o) {
                  this.defines.ENVMAP_TYPE_CUBE_UV = true, delete this.defines.ENVMAP_TYPE_CUBE;
                  const t2 = Ph(e3);
                  t2 && (this.defines.CUBEUV_TEXEL_WIDTH = t2.texelWidth, this.defines.CUBEUV_TEXEL_HEIGHT = t2.texelHeight, this.defines.CUBEUV_MAX_MIP = t2.maxMip + ".0");
                } else
                  this.defines.ENVMAP_TYPE_CUBE = true, delete this.defines.ENVMAP_TYPE_CUBE_UV;
              else
                delete this.defines.ENVMAP_TYPE_CUBE, delete this.defines.ENVMAP_TYPE_CUBE_UV;
              this.uniforms.tEnv.value = e3, this.needsUpdate = true;
            }
          } }, colorAdjustEnabled: { get: function() {
            return this.defines.MVT_POST_ENABLE_COLOR_ADJUST;
          }, set: function(e3) {
            e3 !== this.defines.MVT_POST_ENABLE_COLOR_ADJUST && (e3 ? this.defines.MVT_POST_ENABLE_COLOR_ADJUST = true : delete this.defines.MVT_POST_ENABLE_COLOR_ADJUST, this.needsUpdate = true);
          } } }), this.setValues(e2);
        }
        dispose() {
          let e2 = ["tEnv", "tDiffuse", "tNormal", "tDepth", "tBloom", "tReflection", "tCoverageIntensity", "tDebug1", "tDebug2", "tDebug3", "tDebug4", "tDebug5", "tDebug6"];
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this.uniforms[i2] && this.uniforms[i2].value && this.uniforms[i2].value.dispose();
          }
          super.dispose();
        }
      }
      class Uh extends yl {
        constructor({ tDiffuse: e2, tDepth: t2, tNormal: i2, tMetalness: n2, tBloom: r2, tReflection: s2 }) {
          super();
          const a2 = this.material = new Oh();
          this.tBloom = r2, this.tReflection = s2, a2.uniforms.tDiffuse.value = e2, a2.uniforms.tDepth.value = t2, a2.uniforms.tNormal.value = i2, this.fsQuad = new Sl(null), this.renderTarget = null;
        }
        render(e2, t2, i2) {
          const n2 = this.material;
          n2.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(t2.matrixWorldInverse), n2.uniforms.mvt_projectionInverseMatrix.value.copy(t2.projectionMatrixInverse), n2.uniforms.mvt_projectionMatrix.value.copy(t2.projectionMatrix), n2.uniforms.mvt_viewInverseMatrix.value.copy(t2.matrixWorld), n2.uniforms.cameraNear.value = t2.near, n2.uniforms.cameraFar.value = t2.far, n2.tEnv = i2.environment, this.fsQuad.material = n2, e2.setRenderTarget(this.renderTarget), this.fsQuad.render(e2);
        }
        dispose() {
          this.material.dispose(), this.material = null, this.fsQuad.dispose(), this.fsQuad = null;
        }
        get tBloom() {
          return this.material.tBloom;
        }
        set tBloom(e2) {
          this.material.tBloom = e2;
        }
        get tReflection() {
          return this.material.tReflection;
        }
        set tReflection(e2) {
          this.material.tReflection = e2;
        }
      }
      class zh {
        constructor(e2) {
          __publicField(this, "_enabled", true), __publicField(this, "_rendering"), __publicField(this, "_renderPass"), __publicField(this, "_tDiffuse"), __publicField(this, "_tDepth"), __publicField(this, "_tNormal"), __publicField(this, "_tSpecular"), __publicField(this, "_tBloom"), __publicField(this, "_tReflection"), __publicField(this, "_useMrt", false), this._rendering = e2;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          e2 !== this._useMrt && (this._useMrt = e2, e2 || this.dispose());
        }
        set enabled(e2) {
          (e2 = !!e2) !== this._enabled && (this._enabled = e2, e2 || this.dispose());
        }
        get enabled() {
          return this._enabled;
        }
        _init() {
          const e2 = this._rendering;
          this._tDiffuse = e2.main.tDiffuse, this._tDepth = e2.main.tDepth, this._tNormal = e2.main.tNormal, this._tSpecular = e2.main.tSpecular, this._tBloom = e2.bloom.tBloom, this._tReflection = e2.ssr.tReflection, this._renderPass = new Uh({ tDiffuse: this._tDiffuse, tNormal: this._tNormal, tDepth: this._tDepth, tBloom: this._tBloom, tReflection: this._tReflection, tSpecular: this._tSpecular }), this.colorAdjustEnabled = e2.colorAdjust.enabled, this.adjustBrightnessFactor = e2.colorAdjust.brightness, this.adjustContrastFactor = e2.colorAdjust.contrast, this.adjustSaturationFactor = e2.colorAdjust.saturation;
        }
        render() {
          if (!this._enabled || !this._useMrt)
            return;
          this._enabled && !this._renderPass && this._init();
          const e2 = this._rendering;
          e2.postprocessing.enabled && e2.postprocessing.composer ? this._renderPass.renderTarget = e2.postprocessing.composer.readBuffer : this._renderPass.renderTarget = null, this._renderPass.render(e2.renderer, e2.camera, e2.scene);
        }
        dispose() {
          this._renderPass && (this._renderPass.dispose(), this._renderPass = null);
        }
        set debugTextures(e2) {
          this._renderPass && (this._renderPass.material.debugTextures = e2);
        }
        set tDiffuse(e2) {
          this._tDiffuse = e2, this._renderPass && (this._renderPass.tDiffuse = e2);
        }
        set tDepth(e2) {
          this._tDepth = e2, this._renderPass && (this._renderPass.tDepth = e2);
        }
        set tNormal(e2) {
          this._tNormal = e2, this._renderPass && (this._renderPass.tNormal = e2);
        }
        set tBloom(e2) {
          this._tBloom = e2, this._renderPass && (this._renderPass.tBloom = e2);
        }
        set tReflection(e2) {
          this._tReflection = e2, this._renderPass && (this._renderPass.tReflection = e2);
        }
        set tSpecular(e2) {
          this._tSpecular = e2, this._renderPass && (this._renderPass.tSpecular = e2);
        }
        set coverageIntensity(e2) {
          this._renderPass && (this._renderPass.material.coverageIntensity = e2);
        }
        get coverageIntensity() {
          return this._renderPass && this._renderPass.material.coverageIntensity || 0;
        }
        set tCoverageIntensity(e2) {
          this._renderPass && (this._renderPass.material.tCoverageIntensity = e2);
        }
        get tCoverageIntensity() {
          return this._renderPass && null | this._renderPass.material.tCoverageIntensity;
        }
        get debugDimension() {
          return this._renderPass && this._renderPass.material.debugDimension || { x: 0, y: 0 };
        }
        get debugOffset() {
          return this._renderPass && this._renderPass.material.debugOffset || { x: 0, y: 0 };
        }
        get tEnv() {
          return this._renderPass && this._renderPass.material.tEnv || null;
        }
        set tEnv(e2) {
          this.renderPass && (this._renderPass.material.tEnv = e2);
        }
        get useFog() {
          return this._renderPass && this._renderPass.material.useFog || false;
        }
        set useFog(e2) {
          this._renderPass && (this._renderPass.material.useFog = e2);
        }
        get fogDensity() {
          return this._renderPass && this._renderPass.material.fogDensity || 0;
        }
        set fogDensity(e2) {
          this._renderPass && (this._renderPass.material.fogDensity = e2);
        }
        get adjustBrightnessFactor() {
          return this._renderPass && this._renderPass.material.adjustBrightnessFactor || 0;
        }
        set adjustBrightnessFactor(e2) {
          this._renderPass && (this._renderPass.material.adjustBrightnessFactor = e2);
        }
        get colorAdjustEnabled() {
          return this._renderPass && this._renderPass.material.colorAdjustEnabled || false;
        }
        set colorAdjustEnabled(e2) {
          this._renderPass && (this._renderPass.material.colorAdjustEnabled = !!e2);
        }
        get adjustContrastFactor() {
          return this._renderPass && this._renderPass.material.adjustContrastFactor || 0;
        }
        set adjustContrastFactor(e2) {
          this._renderPass && (this._renderPass.material.adjustContrastFactor = e2);
        }
        get adjustSaturationFactor() {
          return this._renderPass && this._renderPass.material.adjustSaturationFactor || 0;
        }
        set adjustSaturationFactor(e2) {
          this._renderPass && (this._renderPass.material.adjustSaturationFactor = e2);
        }
        get fogSkyColorStartFactor() {
          return this._renderPass && this._renderPass.material.fogSkyColorStartFactor || 0;
        }
        set fogSkyColorStartFactor(e2) {
          this._renderPass && (this._renderPass.material.fogSkyColorStartFactor = e2);
        }
        get fogAltitudeBottom() {
          return this._renderPass && this._renderPass.material.fogAltitudeBottom || 0;
        }
        set fogAltitudeBottom(e2) {
          this._renderPass && (this._renderPass.material.fogAltitudeBottom = e2);
        }
        get fogAltitudeTop() {
          return this._renderPass && this._renderPass.material.fogAltitudeTop || 0;
        }
        set fogAltitudeTop(e2) {
          this._renderPass && (this._renderPass.material.fogAltitudeTop = e2);
        }
      }
      const Nh = { uniforms: { tDiffuse: { value: null } }, vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}", fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 tex = texture2D( tDiffuse, vUv );\n\n			gl_FragColor = LinearTosRGB( tex );\n\n		}" };
      class kh extends yl {
        constructor(e2, t2) {
          super(), this.textureID = void 0 !== t2 ? t2 : "tDiffuse", e2 instanceof Ai ? (this.uniforms = e2.uniforms, this.material = e2) : e2 && (this.uniforms = Ci.clone(e2.uniforms), this.material = new Ai({ defines: Object.assign({}, e2.defines), uniforms: this.uniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader })), this.fsQuad = new Sl(this.material);
        }
        render(e2, t2, i2) {
          this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i2.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e2.setRenderTarget(null), this.fsQuad.render(e2)) : (e2.setRenderTarget(t2), this.clear && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), this.fsQuad.render(e2));
        }
      }
      class Bh extends yl {
        constructor(e2, t2) {
          super(), this.scene = e2, this.camera = t2, this.clear = true, this.needsSwap = false, this.inverse = false;
        }
        render(e2, t2, i2) {
          const n2 = e2.getContext(), r2 = e2.state;
          let s2, a2;
          r2.buffers.color.setMask(false), r2.buffers.depth.setMask(false), r2.buffers.color.setLocked(true), r2.buffers.depth.setLocked(true), this.inverse ? (s2 = 0, a2 = 1) : (s2 = 1, a2 = 0), r2.buffers.stencil.setTest(true), r2.buffers.stencil.setOp(n2.REPLACE, n2.REPLACE, n2.REPLACE), r2.buffers.stencil.setFunc(n2.ALWAYS, s2, 4294967295), r2.buffers.stencil.setClear(a2), r2.buffers.stencil.setLocked(true), e2.setRenderTarget(i2), this.clear && e2.clear(), e2.render(this.scene, this.camera), e2.setRenderTarget(t2), this.clear && e2.clear(), e2.render(this.scene, this.camera), r2.buffers.color.setLocked(false), r2.buffers.depth.setLocked(false), r2.buffers.stencil.setLocked(false), r2.buffers.stencil.setFunc(n2.EQUAL, 1, 4294967295), r2.buffers.stencil.setOp(n2.KEEP, n2.KEEP, n2.KEEP), r2.buffers.stencil.setLocked(true);
        }
      }
      class Vh extends yl {
        constructor() {
          super(), this.needsSwap = false;
        }
        render(e2) {
          e2.state.buffers.stencil.setLocked(false), e2.state.buffers.stencil.setTest(false);
        }
      }
      class Gh {
        constructor(e2, t2) {
          if (this.renderer = e2, void 0 === t2) {
            const i2 = e2.getSize(new ie());
            this._pixelRatio = e2.getPixelRatio(), this._width = i2.width, this._height = i2.height, (t2 = new we(this._width * this._pixelRatio, this._height * this._pixelRatio)).texture.name = "EffectComposer.rt1";
          } else
            this._pixelRatio = 1, this._width = t2.width, this._height = t2.height;
          this.renderTarget1 = t2, this.renderTarget2 = t2.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], void 0 === wl && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === kh && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new kh(wl), this.clock = new po();
        }
        swapBuffers() {
          const e2 = this.readBuffer;
          this.readBuffer = this.writeBuffer, this.writeBuffer = e2;
        }
        addPass(e2) {
          this.passes.push(e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        insertPass(e2, t2) {
          this.passes.splice(t2, 0, e2), e2.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        removePass(e2) {
          const t2 = this.passes.indexOf(e2);
          -1 !== t2 && this.passes.splice(t2, 1);
        }
        isLastEnabledPass(e2) {
          for (let t2 = e2 + 1; t2 < this.passes.length; t2++)
            if (this.passes[t2].enabled)
              return false;
          return true;
        }
        render(e2) {
          void 0 === e2 && (e2 = this.clock.getDelta());
          const t2 = this.renderer.getRenderTarget();
          let i2 = false;
          for (let n2 = 0, r2 = this.passes.length; n2 < r2; n2++) {
            const t3 = this.passes[n2];
            if (false !== t3.enabled) {
              if (t3.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n2), t3.render(this.renderer, this.writeBuffer, this.readBuffer, e2, i2), t3.needsSwap) {
                if (i2) {
                  const t4 = this.renderer.getContext(), i3 = this.renderer.state.buffers.stencil;
                  i3.setFunc(t4.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e2), i3.setFunc(t4.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
              }
              void 0 !== Bh && (t3 instanceof Bh ? i2 = true : t3 instanceof Vh && (i2 = false));
            }
          }
          this.renderer.setRenderTarget(t2);
        }
        reset(e2) {
          if (void 0 === e2) {
            const t2 = this.renderer.getSize(new ie());
            this._pixelRatio = this.renderer.getPixelRatio(), this._width = t2.width, this._height = t2.height, (e2 = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
          }
          this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e2, this.renderTarget2 = e2.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
        }
        setSize(e2, t2) {
          this._width = e2, this._height = t2;
          const i2 = this._width * this._pixelRatio, n2 = this._height * this._pixelRatio;
          this.renderTarget1.setSize(i2, n2), this.renderTarget2.setSize(i2, n2);
          for (let r2 = 0; r2 < this.passes.length; r2++)
            this.passes[r2].setSize(i2, n2);
        }
        setPixelRatio(e2) {
          this._pixelRatio = e2, this.setSize(this._width, this._height);
        }
      }
      new en(-1, 1, 1, -1, 0, 1);
      const Hh = new ri();
      Hh.setAttribute("position", new Jt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), Hh.setAttribute("uv", new Jt([0, 2, 0, 0, 2, 0], 2)), Gh.prototype.dispose = function() {
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
      }, kh.prototype.dispose = function() {
        this.material.dispose(), this.fsQuad.dispose();
      };
      class jh {
        constructor(e2) {
          __publicField(this, "_enabled", false), __publicField(this, "_inited", false), __publicField(this, "_useMrt", false), __publicField(this, "_rendering"), __publicField(this, "_renderComposer"), __publicField(this, "_passes", []), this._rendering = e2;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          e2 !== this._useMrt && (this._useMrt = e2);
        }
        set enabled(e2) {
          (e2 = !!e2) !== this._enabled && (this._enabled = e2, e2 || this.dispose());
        }
        get enabled() {
          return this._enabled;
        }
        _init() {
          const e2 = this._rendering, t2 = e2.renderer, i2 = e2.resolution, n2 = new ie(i2.x, i2.y), r2 = e2.pixelRatio, s2 = this._postRenderTarget = new we(n2.x * r2, n2.y * r2, { minFilter: u, magFilter: u, type: x, format: b, encoding: e2.outputEncoding, stencilBuffer: true, samples: 4 });
          s2.texture.name = "EffectComposer.rt1";
          const a2 = this._renderComposer = new Gh(t2, s2);
          a2.setPixelRatio(r2), a2.setSize(n2.x, n2.y);
          const o2 = new kh(Nh);
          o2.material.transparent = true, a2.addPass(o2);
          for (let l2 = 0; l2 < this._passes.length; l2++) {
            const e3 = this._passes[l2];
            a2.addPass(e3);
          }
        }
        render() {
          if (!this._enabled)
            return;
          this._enabled && !this._renderComposer && this._init();
          const e2 = this._rendering;
          this.useMrt && (this._setMrtUniforms("tDiffuse", e2.main.tDiffuse), this._setMrtUniforms("tDepth", e2.main.tDepth), this._setMrtUniforms("tNormal", e2.main.tNormal), this._setMrtUniforms("tSpecular", e2.main.tSpecular), this._setMrtUniforms("tBloom", e2.bloom.tBloom), this._setMrtUniforms("tReflection", e2.ssr.tReflection)), this._renderComposer.render();
        }
        _setMrtUniforms(e2, t2) {
          for (let i2 = 0; i2 < this._passes.length; i2++) {
            const n2 = this._passes[i2];
            if (n2.material) {
              const i3 = n2.material.uniforms;
              i3[e2] && (i3[e2].value = t2);
            }
          }
        }
        dispose() {
          this._renderComposer && (this._renderComposer.dispose(), this._renderComposer = null, this._postRenderTarget = null);
        }
        addPass(e2) {
          if (0 !== this._passes.length || this._inited || (this.enabled = true, this._inited = true), e2 && !e2.renderOrder && (e2.renderOrder = 0), 0 === this._passes.length)
            return this._passes.push(e2), void (this._renderComposer && this._renderComposer.addPass(e2));
          for (let t2 = this._passes.length - 1; t2 >= 0; t2--) {
            if (e2.renderOrder >= this._passes[t2].renderOrder) {
              this._passes.splice(t2 + 1, 0, e2), this._renderComposer && this._renderComposer.insertPass(e2, t2 + 2);
              break;
            }
            0 === t2 && (this._passes.splice(t2, 0, e2), this._renderComposer && this._renderComposer.insertPass(e2, t2 + 1));
          }
        }
        removePass(e2) {
          const t2 = this._passes.indexOf(e2);
          -1 !== t2 && (this._passes.splice(t2, 1), this._renderComposer.removePass(e2)), 0 === this._passes.length && this._inited && (this.enabled = false, this._inited = false);
        }
        get composer() {
          return this._renderComposer;
        }
      }
      class Wh extends Rt {
        constructor(e2) {
          super(), __publicField(this, "_enableRtc", true), __publicField(this, "_cachedRtc", [0, 0, 0]), __publicField(this, "makeMeshPositionOffset", (e3) => {
            this._cachedRtc = [e3[0], e3[1], e3[2] || 0], this.updateTransform();
          }), __publicField(this, "makeGeometryOffsetPosition", (e3, t2) => {
            if (!this._enableRtc)
              return;
            const i2 = e3.boundingSphere && e3.boundingSphere.center;
            if (!i2)
              return this._cachedRtc = [0, 0, 0], void this.updateTransform();
            const { x: n2, y: r2, z: s2 } = i2;
            e3.isCustomInstancedBufferGeometry ? this.makePostionArrayOffset(e3.attributes.instancedPosition.array, n2, r2, s2, t2) : (this.makePostionArrayOffset(e3.attributes.position.array, n2, r2, s2, t2), e3.attributes.position.array.length), e3.computeBoundingSphere(), this._cachedRtc = [n2, r2, s2], this.updateTransform();
          }), __publicField(this, "makePostionArrayOffset", (e3, t2, i2, n2, r2) => {
            if (!e3 || e3.length < 3)
              return;
            let s2 = r2 || e3;
            for (let a2 = 0, o2 = e3.length - 2; a2 < o2; a2 += 3)
              e3[a2] = s2[a2] - t2, e3[a2 + 1] = s2[a2 + 1] - i2, e3[a2 + 2] = s2[a2 + 2] - n2;
          }), __publicField(this, "updateTransform", () => {
            const [e3, t2, i2] = this._cachedRtc;
            this.position.set(e3, t2, i2), this.updateMatrixWorld(true);
          }), Object.defineProperties(this, { enableRtc: { get: function() {
            return this._enableRtc;
          }, set: function(e3) {
            this._enableRtc = e3;
          } } });
        }
        defineGeometryProxyProperties(e2 = []) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            Object.defineProperty(this, i2, { get: function() {
              return this.geometry[i2];
            }, set: function(e3) {
              this.geometry[i2] = e3;
            } });
          }
        }
        defineMaterialProxyProperties(e2 = []) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            Object.defineProperty(this, i2, { get: function() {
              return this.material[i2];
            }, set: function(e3) {
              this.material[i2] = e3;
            } });
          }
        }
      }
      function Xh(e2) {
        var t2, i2 = Math.PI / 180, n2 = 6378137, r2 = 20037508342789244e-9, s2 = [n2 * (Math.abs(e2[0]) <= 180 ? e2[0] : e2[0] - 360 * ((t2 = e2[0]) < 0 ? -1 : t2 > 0 ? 1 : 0)) * i2, n2 * Math.log(Math.tan(0.25 * Math.PI + 0.5 * e2[1] * i2))];
        return s2[0] > r2 && (s2[0] = r2), s2[0] < -r2 && (s2[0] = -r2), s2[1] > r2 && (s2[1] = r2), s2[1] < -r2 && (s2[1] = -r2), s2;
      }
      function qh(e2) {
        var t2 = 180 / Math.PI, i2 = 6378137;
        return [e2[0] * t2 / i2, (0.5 * Math.PI - 2 * Math.atan(Math.exp(-e2[1] / i2))) * t2];
      }
      function Yh() {
      }
      function Zh(e2, t2) {
        for (let i2 in t2)
          e2[i2] = t2[i2];
      }
      function Jh(e2, t2) {
        this.lng = e2, this.lat = t2;
      }
      function Kh(e2, t2) {
        this.x = e2, this.y = t2;
      }
      Zh(Jh.prototype, { equals: function(e2) {
        return this.lat === e2.lat && this.lng === e2.lng;
      }, clone: function() {
        return new Jh(this.lat, this.lng);
      }, getLngSpan: function(e2) {
        let t2 = this.lng, i2 = Math.abs(e2 - t2);
        return i2 > 180 && (i2 = 360 - i2), i2;
      }, sub: function(e2) {
        return new Jh(this.lat - e2.lat, this.lng - e2.lng);
      }, toString: function() {
        return "Point";
      } }), Zh(Yh, { EARTHRADIUS: 637099681e-2, MCBAND: [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0], LLBAND: [75, 60, 45, 30, 15, 0], MC2LL: [[1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1], [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2], [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2], [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2], [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1], [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]], LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5], [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5], [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]], getDistanceByMC: function(e2, t2) {
        if (!e2 || !t2)
          return 0;
        let i2, n2, r2, s2;
        return (e2 = this.convertMC2LL(e2)) ? (i2 = this.toRadians(e2.lng), n2 = this.toRadians(e2.lat), (t2 = this.convertMC2LL(t2)) ? (r2 = this.toRadians(t2.lng), s2 = this.toRadians(t2.lat), this.getDistance(i2, r2, n2, s2)) : 0) : 0;
      }, getDistanceByLL: function(e2, t2) {
        if (!e2 || !t2)
          return 0;
        let i2, n2, r2, s2;
        return e2.lng = this.getLoop(e2.lng, -180, 180), e2.lat = this.getRange(e2.lat, -74, 74), t2.lng = this.getLoop(t2.lng, -180, 180), t2.lat = this.getRange(t2.lat, -74, 74), i2 = this.toRadians(e2.lng), r2 = this.toRadians(e2.lat), n2 = this.toRadians(t2.lng), s2 = this.toRadians(t2.lat), this.getDistance(i2, n2, r2, s2);
      }, convertMC2LL: function(e2) {
        if (null == e2)
          return new Jh(0, 0);
        if (e2.lng < 180 && e2.lng > -180 && e2.lat < 90 && e2.lat > -90)
          return e2;
        let t2, i2;
        t2 = new Jh(Math.abs(e2.lng), Math.abs(e2.lat));
        for (let r2 = 0; r2 < this.MCBAND.length; r2++)
          if (t2.lat >= this.MCBAND[r2]) {
            i2 = this.MC2LL[r2];
            break;
          }
        let n2 = this.convertor(e2, i2);
        return e2 = new Jh(n2.lng.toFixed(6), n2.lat.toFixed(6));
      }, convertLL2MC: function(e2) {
        if (null == e2)
          return new Jh(0, 0);
        if (e2.lng > 180 || e2.lng < -180 || e2.lat > 90 || e2.lat < -90)
          return e2;
        let t2, i2;
        if (e2.lng = this.getLoop(e2.lng, -180, 180), e2.lat = this.getRange(e2.lat, -74, 74), t2 = new Jh(e2.lng, e2.lat), window.BMAPGL_84) {
          var n2 = {}, r2 = 6378137;
          n2.lng = t2.lng * Math.PI / 180 * r2;
          var s2 = t2.lat * Math.PI / 180;
          return n2.lat = 31890685e-1 * Math.log((1 + Math.sin(s2)) / (1 - Math.sin(s2))), new Jh(Number(n2.lng), Number(n2.lat));
        }
        for (var a2 = 0; a2 < this.LLBAND.length; a2++)
          if (t2.lat >= this.LLBAND[a2]) {
            i2 = this.LL2MC[a2];
            break;
          }
        if (!i2) {
          for (a2 = 0; a2 < this.LLBAND.length; a2++)
            if (t2.lat <= -this.LLBAND[a2]) {
              i2 = this.LL2MC[a2];
              break;
            }
        }
        let o2 = this.convertor(e2, i2);
        return e2 = new Jh(Number(o2.lng), Number(o2.lat));
      }, convertor: function(e2, t2) {
        if (!e2 || !t2)
          return;
        let i2 = t2[0] + t2[1] * Math.abs(e2.lng), n2 = Math.abs(e2.lat) / t2[9], r2 = t2[2] + t2[3] * n2 + t2[4] * n2 * n2 + t2[5] * n2 * n2 * n2 + t2[6] * n2 * n2 * n2 * n2 + t2[7] * n2 * n2 * n2 * n2 * n2 + t2[8] * n2 * n2 * n2 * n2 * n2 * n2;
        return i2 *= e2.lng < 0 ? -1 : 1, r2 *= e2.lat < 0 ? -1 : 1, new Jh(i2, r2);
      }, getDistance: function(e2, t2, i2, n2) {
        return this.EARTHRADIUS * Math.acos(Math.sin(i2) * Math.sin(n2) + Math.cos(i2) * Math.cos(n2) * Math.cos(t2 - e2));
      }, toRadians: function(e2) {
        return Math.PI * e2 / 180;
      }, toDegrees: function(e2) {
        return 180 * e2 / Math.PI;
      }, getRange: function(e2, t2, i2) {
        return null != t2 && (e2 = Math.max(e2, t2)), null != i2 && (e2 = Math.min(e2, i2)), e2;
      }, getLoop: function(e2, t2, i2) {
        for (; e2 > i2; )
          e2 -= i2 - t2;
        for (; e2 < t2; )
          e2 += i2 - t2;
        return e2;
      } }), Zh(Yh.prototype, { lngLatToMercator: function(e2) {
        return Yh.convertLL2MC(e2);
      }, lngLatToPoint: function(e2) {
        let t2 = Yh.convertLL2MC(e2);
        return new Kh(t2.lng, t2.lat);
      }, mercatorToLngLat: function(e2) {
        return Yh.convertMC2LL(e2);
      }, pointToLngLat: function(e2) {
        let t2 = new Jh(e2.x, e2.y);
        return Yh.convertMC2LL(t2);
      }, pointToPixel: function(e2, t2, i2, n2, r2) {
        if (!e2)
          return;
        e2 = this.lngLatToMercator(e2, r2);
        let s2 = this.getZoomUnits(t2);
        return new Kh(Math.round((e2.lng - i2.lng) / s2 + n2.width / 2), Math.round((i2.lat - e2.lat) / s2 + n2.height / 2));
      }, pixelToPoint: function(e2, t2, i2, n2, r2) {
        if (!e2)
          return;
        let s2 = this.getZoomUnits(t2), a2 = new Jh(i2.lng + s2 * (e2.x - n2.width / 2), i2.lat - s2 * (e2.y - n2.height / 2));
        return this.mercatorToLngLat(a2, r2);
      }, getZoomUnits: function(e2) {
        return Math.pow(2, 18 - e2);
      } });
      const Qh = (e2, t2) => {
        if (e2)
          if (0 === t2)
            e2[2] || (e2[2] = 0);
          else
            for (const i2 of e2)
              Qh(i2, t2 - 1);
      };
      function $h(e2, t2) {
        if (!e2)
          return [];
        let i2 = null;
        return t2 && ec(e2, t2), i2 = e2.features ? e2.features : Array.isArray(e2) ? e2 : [e2], i2;
      }
      function ec(e2, t2) {
        if (e2) {
          if ("FeatureCollection" === e2.type || e2.features) {
            const i2 = e2.features;
            for (const e3 of i2)
              ec(e3, t2);
          } else if (Array.isArray(e2)) {
            const i2 = e2;
            for (const e3 of i2)
              ec(e3, t2);
          } else if (("Feature" === e2.type || e2.geometry) && Array.isArray(e2.geometry.coordinates)) {
            if (e2.geometry[t2])
              return;
            nc(e2);
            const i2 = tc(e2.geometry.coordinates, t2);
            e2.geometry[t2] = i2;
          }
        }
      }
      function tc(e2, t2) {
        if (Array.isArray(e2[0])) {
          const i2 = [];
          for (let n2 of e2)
            i2.push(tc(n2, t2));
          return i2;
        }
        if ("number" == typeof e2[0] || "string" == typeof e2[0])
          return ic(e2, t2);
      }
      function ic(e2, t2) {
        if (!e2)
          return [];
        let i2 = [];
        if (e2[0] > 180 || e2[0] < -180 || e2[1] > 90 || e2[1] < -90)
          i2 = [e2[0], e2[1]];
        else if ("_bmap_mercator" === t2) {
          const t3 = Yh.convertLL2MC({ lng: e2[0], lat: e2[1] });
          i2[0] = t3.lng, i2[1] = t3.lat;
        } else
          i2 = Xh(e2);
        return void 0 !== e2[2] ? i2[2] = e2[2] : i2[2] = 0, i2;
      }
      function nc(e2) {
        e2.type || (e2.type = "Feature");
        const t2 = e2.geometry.type, i2 = { Point: 0, MultiPoint: 1, LineString: 1, MultiLineString: 2, Polygon: 2, MultiPolygon: 3 };
        return Object.keys(i2).includes(t2) && Qh(e2.geometry.coordinates, i2[t2]), e2;
      }
      function rc(e2, t2) {
        if ("Point" === e2.geometry.type)
          return [e2];
        if ("MultiPoint" === e2.geometry.type || "LineString" === e2.geometry.type) {
          const i2 = [], { type: n2, geometry: r2, ...s2 } = e2;
          for (let a2 = 0; a2 < e2.geometry.coordinates.length; a2++) {
            const n3 = e2.geometry.coordinates[a2];
            if (t2) {
              const r3 = e2.geometry[t2][a2];
              i2.push({ type: "Feature", geometry: { type: "Point", coordinates: n3, [t2]: r3 }, ...s2 });
            } else
              i2.push({ type: "Feature", geometry: { type: "Point", coordinates: n3 }, ...s2 });
          }
          return i2;
        }
        return [];
      }
      function sc(e2, t2) {
        if ("LineString" === e2.geometry.type)
          return [e2];
        if ("MultiLineString" === e2.geometry.type || "Polygon" === e2.geometry.type) {
          const i2 = [], { type: n2, geometry: r2, ...s2 } = e2;
          for (let a2 = 0; a2 < e2.geometry.coordinates.length; a2++) {
            const n3 = e2.geometry.coordinates[a2];
            if (t2) {
              const r3 = e2.geometry[t2][a2];
              i2.push({ type: "Feature", geometry: { type: "LineString", coordinates: n3, [t2]: r3 }, ...s2 });
            } else
              i2.push({ type: "Feature", geometry: { type: "LineString", coordinates: n3 }, ...s2 });
          }
          return i2;
        }
        return [];
      }
      function ac(e2, t2) {
        if ("Polygon" === e2.geometry.type)
          return [e2];
        if ("MultiPolygon" === e2.geometry.type) {
          const i2 = [], { type: n2, geometry: r2, ...s2 } = e2;
          for (let a2 = 0; a2 < e2.geometry.coordinates.length; a2++) {
            const n3 = e2.geometry.coordinates[a2];
            if (t2) {
              const r3 = e2.geometry[t2][a2];
              i2.push({ type: "Feature", geometry: { type: "Polygon", coordinates: n3, [t2]: r3 }, ...s2 });
            } else
              i2.push({ type: "Feature", geometry: { type: "Polygon", coordinates: n3 }, ...s2 });
          }
          return i2;
        }
        return [];
      }
      const oc = Object.freeze(Object.defineProperty({ __proto__: null, getGeoFeatures: $h, projectCoordinates: tc, projectPointArr: ic, unprojectPointArr: function(e2, t2) {
        if (!e2)
          return [];
        let i2 = [];
        if (e2[0] < 180 && e2[0] > -180 && e2[1] < 90 && e2[1] > -90)
          i2 = [e2[0], e2[1]];
        else if ("_bmap_mercator" === t2) {
          const t3 = Yh.convertMC2LL({ lng: e2[0], lat: e2[1] });
          i2[0] = t3.lng, i2[1] = t3.lat;
        } else
          i2 = qh(e2);
        return void 0 !== e2[2] ? i2[2] = e2[2] : i2[2] = 0, i2;
      }, fixFeature: nc, multiPointToPoints: rc, multiLineStringToLineStrings: sc, multiPolygonToPolygons: ac, convertLineString2Points: function(e2) {
        let t2 = this.getGeoFeatures(e2), i2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const e3 = t2[n2], r2 = this.multiLineStringToLineStrings(e3);
          for (let t3 = 0; t3 < r2.length; t3++) {
            const e4 = r2[t3], n3 = this.multiPointToPoints(e4);
            i2.push(...n3);
          }
        }
        return i2;
      }, convertPolygon2LineString: function(e2) {
        let t2 = this.getGeoFeatures(e2), i2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const e3 = t2[n2], r2 = this.multiPolygonToPolygons(e3);
          for (let t3 = 0; t3 < r2.length; t3++) {
            const e4 = r2[t3], n3 = this.multiLineStringToLineStrings(e4);
            i2.push(...n3);
          }
        }
        return i2;
      } }, Symbol.toStringTag, { value: "Module" }));
      function lc(e2, t2 = {}) {
        this.position = e2, this.attributes = t2, void 0 !== t2.id && (this.id = t2.id), this._projection = [];
      }
      function hc(e2, t2, i2, n2, r2) {
        return function(e3, t3) {
          const i3 = 1 - e3;
          return i3 * i3 * i3 * t3;
        }(e2, t2) + function(e3, t3) {
          const i3 = 1 - e3;
          return 3 * i3 * i3 * e3 * t3;
        }(e2, i2) + function(e3, t3) {
          return 3 * (1 - e3) * e3 * e3 * t3;
        }(e2, n2) + function(e3, t3) {
          return e3 * e3 * e3 * t3;
        }(e2, r2);
      }
      lc.prototype.getProjection = function(e2) {
        return this._projection = tc(this.position, e2), this._projection;
      };
      const cc = function(e2, t2) {
        let i2 = e2[0], n2 = e2[1];
        return [(3 * i2 + t2[0]) / 4, (3 * n2 + t2[1]) / 4];
      }, uc = function(e2, t2) {
        let i2 = e2[0], n2 = e2[1], r2 = t2[0], s2 = t2[1];
        return Math.sqrt(Math.pow(i2 - r2, 2) + Math.pow(n2 - s2, 2));
      }, dc = function(e2, t2, i2 = 1) {
        return [...cc(e2, t2), uc(e2, t2) / i2];
      }, pc = function(e2, t2, i2, n2, r2) {
        let s2 = [];
        return s2.push(hc(e2, t2[0], i2[0], n2[0], r2[0]), hc(e2, t2[1], i2[1], n2[1], r2[1]), hc(e2, t2[2], i2[2], n2[2], r2[2])), s2;
      };
      function mc(e2, t2 = 20) {
        const i2 = e2[0], n2 = e2[e2.length - 1], r2 = dc(i2, n2, 2), s2 = dc(n2, i2, 2);
        let a2 = [];
        for (let o2 = 0; o2 <= t2; o2++)
          a2.push(pc(o2 / t2, i2, r2, s2, n2));
        return a2;
      }
      class fc {
        constructor(e2 = {}) {
          __publicField(this, "_projectionName"), __publicField(this, "_objects", []), __publicField(this, "_isLoading", false), __publicField(this, "_isLoaded", false), __publicField(this, "_url"), __publicField(this, "_origin"), __publicField(this, "_data", {}), __publicField(this, "_userData", []), __publicField(this, "_addCache", []), __publicField(this, "_attributeMap", /* @__PURE__ */ new Map()), __publicField(this, "_needsUpdate", true), __publicField(this, "_templateDataLength", 0), __publicField(this, "_idIndexMap", {}), __publicField(this, "_indexIdMap", {}), __publicField(this, "_isCurve", false), this.options = e2, this._id = e2.id || new Date().valueOf();
        }
        async load(e2) {
          if (this._isLoaded && this.clear(), this._isLoading)
            return this;
          if (this._isLoading = true, "string" == typeof e2) {
            let t2 = await fetch(e2), i2 = await this._getFetchData(t2);
            this._url = e2, this._origin = i2;
          } else
            "object" == typeof e2 && (this._origin = e2);
          return this._isLoading = false, this._isLoaded = true, this;
        }
        async _getFetchData(e2) {
          return e2;
        }
        setAttribute(e2, t2) {
          return t2 ? this._attributeMap.set(e2, t2) : this._attributeMap.set(e2, e2), this.needsUpdate = true, this;
        }
        setAttributes(e2) {
          let t2 = Object.keys(e2);
          for (let i2 = 0; i2 < t2.length; i2++) {
            const n2 = t2[i2];
            this._attributeMap.set(n2, e2[n2]);
          }
          return this.needsUpdate = true, this;
        }
        removeAttribute(e2) {
          return this._attributeMap.delete(e2), this.needsUpdate = true, this;
        }
        removeAllAttributes() {
          return this._attributeMap.clear(), this.needsUpdate = true, this;
        }
        add(e2) {
          if (e2 instanceof lc) {
            const t2 = e2.id;
            if (void 0 !== t2) {
              if (void 0 !== this._idIndexMap[t2])
                return this;
              const e3 = this._addCache.length;
              this._indexIdMap[e3] = t2, this._idIndexMap[t2] = e3;
            }
            this._addCache.push(e2);
          } else if (e2 instanceof Array)
            for (let t2 = 0; t2 < e2.length; t2++) {
              const i2 = e2[t2];
              this.add(i2);
            }
          return this.needsUpdate = true, this;
        }
        remove(e2) {
          let t2;
          if (e2 instanceof lc || "[object Object]" === Array.prototype.toString.call(e2) ? t2 = e2.id : "string" == typeof e2 && (t2 = e2), void 0 !== t2) {
            const e3 = this._idIndexMap[t2];
            if (void 0 === e3)
              return void console.warn("remove fail1", e3, t2);
            const i2 = this._addCache.length - 1;
            if (e3 > i2)
              return void console.warn("remove fail2", e3, t2);
            if (e3 < i2) {
              const t3 = this._indexIdMap[i2];
              this._addCache[e3] = this._addCache[i2], this._indexIdMap[e3] = t3, this._idIndexMap[t3] = e3;
            }
            delete this._idIndexMap[t2], delete this._indexIdMap[i2], this._addCache.length = this._addCache.length - 1;
          }
          return this.needsUpdate = true, this;
        }
        get(e2) {
          let t2 = {};
          if (this.data.position && this.data.position.length && void 0 !== e2 && !(e2 >= this.data.position.length)) {
            for (const i2 in this.data)
              if (Object.hasOwnProperty.call(this.data, i2)) {
                const n2 = this.data[i2];
                t2[i2] = n2[e2];
              }
            return t2;
          }
        }
        getOriginDataIndex(e2) {
          return [e2, 0];
        }
        getOriginData(e2) {
          return this._addCache[e2];
        }
        update() {
          let e2 = { position: [], index: [] }, t2 = [];
          for (const i2 of this._attributeMap.keys())
            e2[i2] = [];
          if (this._onProcessTemplateData(e2, t2), this._onProcessAddData(e2, t2), this._isCurve && e2.position.length > 0 && Array.isArray(e2.position[0]) && Array.isArray(e2.position[0][0]) && !Array.isArray(e2.position[0][0][0]))
            for (let i2 = 0; i2 < e2.position.length; i2++) {
              const t3 = e2.position[i2];
              e2.position[i2] = mc(t3);
            }
          this.data = e2, this.userData = t2, this.needsUpdate = false;
        }
        setData(e2) {
          this.clear(), this._isLoaded = true, this._origin = e2, this.needsUpdate = true;
        }
        clear() {
          this._isLoaded = false, this._url = void 0, this._origin = void 0, this._data = {}, this._userData = [], this._addCache = [], this.needsUpdate = true, this._idIndexMap = {}, this._indexIdMap = {}, this.onClear();
        }
        onClear() {
        }
        _onProcessTemplateData(e2) {
          return e2;
        }
        _onProcessAddData(e2, t2) {
          const i2 = this.projectionName, n2 = e2.index[e2.index.length - 1];
          this._templateDataLength = e2.index.length;
          for (let r2 = 0; r2 < this._addCache.length; r2++) {
            const s2 = this._addCache[r2], a2 = s2.getProjection(i2);
            e2.position.push(a2), void 0 !== n2 ? e2.index.push(n2 + r2 + 1) : e2.index.push(r2);
            let o2 = { position: a2, index: void 0 !== n2 ? n2 + r2 + 1 : r2 };
            for (const t3 of this._attributeMap.keys()) {
              let i3;
              s2.attributes && void 0 !== s2.attributes[this._attributeMap.get(t3)] && null !== s2.attributes[this._attributeMap.get(t3)] ? (e2[t3].push(), i3 = s2.attributes[this._attributeMap.get(t3)]) : this._attributeMap.get(t3) instanceof Function && (e2[t3].push(), i3 = this._attributeMap.get(t3)(s2.attributes)), e2[t3].push(i3), o2[t3] = i3;
            }
            t2.push(o2);
          }
        }
        _getDataType(e2) {
          let t2;
          return /Point/.test(e2) ? t2 = "Point" : /LineString/.test(e2) ? t2 = "LineString" : /Polygon/.test(e2) && (t2 = "Polygon"), t2;
        }
        _onDecomposeFeature(e2, t2) {
          let i2 = (e3) => [e3];
          return "Point" === e2 ? i2 = rc : "LineString" === e2 ? i2 = sc : "Polygon" === e2 && (i2 = ac), i2(t2, this.projectionName);
        }
        dispose() {
          this.clear();
        }
        get size() {
          return this.needsUpdate && this.update(), this.data && this.data.position && this.data.position.length || 0;
        }
        get data() {
          return this._data;
        }
        set data(e2) {
          this._data = e2;
        }
        get userData() {
          return this._userData;
        }
        set userData(e2) {
          this._userData = e2;
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
        get origin() {
          return this._origin;
        }
        get projectionName() {
          return this._projectionName;
        }
        set projectionName(e2) {
          this._projectionName = e2;
        }
        get objects() {
          return this._objects;
        }
        set objects(e2) {
          this._objects = e2;
        }
        get isCurve() {
          return this._isCurve;
        }
        set isCurve(e2) {
          this._isCurve = e2, this.needsUpdate = true;
        }
      }
      class gc extends fc {
        constructor(e2) {
          super(e2), this.type = "BufferDataSource";
        }
        getOriginData(e2) {
          return e2 < this._templateDataLength && this.data.payload ? this.data.payload[e2] : this._addCache[e2 - this._templateDataLength];
        }
        _onProcessTemplateData(e2, t2) {
          let i2 = this._origin;
          if (i2 && i2.position) {
            e2.position = i2.position, e2.index = i2.index;
            for (let n2 = 0; n2 < i2.payload.length; n2++) {
              const r2 = i2.payload[n2];
              for (const t3 of this._attributeMap.keys())
                e2[t3] || (e2[t3] = []), e2[t3] = e2[t3].concat(r2[this._attributeMap.get(t3)]);
              t2.push(r2);
            }
          }
          return e2;
        }
      }
      class _c extends Wh {
        constructor() {
          super(...arguments), __publicField(this, "isGeoObject", true), __publicField(this, "dataAutoUpdate", true), __publicField(this, "_parameters"), __publicField(this, "_dataSource"), __publicField(this, "_dataSourceUpdated"), __publicField(this, "_needsUpdate"), __publicField(this, "_zooms", [0, 100]), __publicField(this, "_zoomVisibleCache"), __publicField(this, "_clampToGround"), __publicField(this, "_volumeDataSource", new gc()), __publicField(this, "engine"), __publicField(this, "getGeoFeatures", (e2, t2 = false) => {
            if (!e2)
              return [];
            let i2 = null;
            return t2 || this.map.projectGeoJSON(e2), i2 = e2.features ? e2.features : Array.isArray(e2) ? e2 : [e2], i2;
          }), __publicField(this, "travelFeatureLineCoordinate", (e2, t2, i2) => {
            const n2 = e2.geometry;
            if (!n2 || !n2[t2] || !n2.type)
              return;
            const r2 = n2[t2];
            if ("LineString" === n2.type)
              i2 && i2(r2);
            else if ("MultiLineString" === n2.type || "Polygon" === n2.type)
              for (let s2 of r2)
                i2 && i2(s2);
            else if ("MultiPolygon" === n2.type)
              for (let s2 of r2)
                for (let e3 of s2)
                  i2 && i2(e3);
          }), __publicField(this, "travelLineCoordinates", (e2, t2 = "coordinates", i2, n2 = 0) => {
            if (Array.isArray(e2) && i2)
              for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
                const s3 = e2[r2], a2 = n2 + r2, o2 = s3.geometry;
                if (!o2 || !o2[t2] || !o2.type)
                  continue;
                const l2 = o2[t2];
                if ("LineString" === o2.type)
                  i2 && i2(l2, s3, a2);
                else if ("MultiLineString" === o2.type || "Polygon" === o2.type)
                  for (let e3 of l2)
                    i2 && i2(e3, s3, a2);
                else if ("MultiPolygon" === o2.type)
                  for (let e3 of l2)
                    for (let t3 of e3)
                      i2 && i2(t3, s3, a2);
              }
          }), __publicField(this, "travelPolygonCoordinates", (e2, t2 = "coordinates", i2, n2 = 0) => {
            if (Array.isArray(e2) && i2)
              for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
                const s3 = e2[r2], a2 = n2 + r2, o2 = s3.geometry;
                if (!o2 || !o2[t2] || !o2.type)
                  continue;
                const l2 = o2[t2];
                if ("Polygon" === o2.type)
                  i2 && i2(l2, s3, a2);
                else if ("MultiPolygon" === o2.type)
                  for (let e3 of l2)
                    i2 && i2(e3, s3, a2);
                else if ("LineString" === o2.type)
                  i2 && i2([l2], s3, a2);
                else if ("MultiLineString" === o2.type)
                  for (let e3 of l2)
                    i2 && i2([e3], s3, a2);
              }
          }), __publicField(this, "travelPointCoordinates", (e2, t2 = "coordinates", i2, n2 = 0) => {
            if (Array.isArray(e2) && i2)
              for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
                const s3 = e2[r2], a2 = n2 + r2, o2 = s3.geometry;
                if (!o2 || !o2[t2] || !o2.type)
                  continue;
                const l2 = o2[t2];
                "Point" === o2.type && i2 && i2(l2, s3, a2);
              }
          }), __publicField(this, "getPointsBounding", (e2, t2 = "coordinates") => {
            let i2 = 1 / 0, n2 = 1 / 0, r2 = 1 / 0, s2 = -1 / 0, a2 = -1 / 0, o2 = -1 / 0;
            return this.travelPointCoordinates(e2, t2, (e3) => {
              const [t3, l2, h2 = 0] = e3;
              t3 < i2 && (i2 = t3), t3 > s2 && (s2 = t3), l2 < n2 && (n2 = l2), l2 > a2 && (a2 = l2), h2 < r2 && (r2 = h2), h2 > o2 && (o2 = h2);
            }), isFinite(i2) || (i2 = 0), isFinite(s2) || (s2 = 0), isFinite(n2) || (n2 = 0), isFinite(a2) || (a2 = 0), isFinite(r2) || (r2 = 0), isFinite(o2) || (o2 = 0), [i2, n2, r2, s2, a2, o2];
          });
        }
        get parameters() {
          return this._parameters;
        }
        set parameters(e2) {
          this._parameters ? this._parameters = { ...this._parameters, ...e2 } : this._parameters = { ...this.getDefaultParams(), ...e2 };
        }
        get dataSource() {
          return this._dataSource;
        }
        set dataSource(e2) {
          this.setDataSource(e2);
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
        get zooms() {
          return this._zooms;
        }
        set zooms(e2) {
          this._zooms = e2;
        }
        get inZoomsRange() {
          const e2 = this.engine;
          return !!e2 && (e2.map.getZoom() >= this.zooms[0] && e2.map.getZoom() <= this.zooms[1]);
        }
        afterAddToEngine(e2) {
          this.engine = e2, this.initObject();
        }
        beforeRemoveFromEngine(e2) {
          this.dispose();
        }
        initObject() {
        }
        getDefaultParams() {
          return {};
        }
        getEntityByIndex(e2) {
          const t2 = this.dataSource;
          if (!t2)
            return;
          const i2 = { index: e2, value: t2.getOriginData(e2), itemIndex: t2.getOriginDataIndex(e2), pairs: {} }, n2 = t2.data;
          for (const r2 of Object.keys(n2))
            i2.pairs[r2] = n2[r2][e2];
          return i2;
        }
        setDataSource(e2) {
          if (!e2 && this._dataSource) {
            const e3 = this._dataSource.objects.indexOf(this);
            e3 > -1 && this._dataSource.splice(e3, 1), this._dataSource = null;
          }
          e2.objects.indexOf(this) > -1 || (this._dataSource = e2, e2.projectionName = this.engine.map.projectionCoordsName, e2.objects.push(this), this.needsUpdate = true, this.engine.requestRender());
        }
        onBeforeScenePrepareRender(e2, t2, i2, n2) {
          if (this.dataSource && (this.dataSource.needsUpdate && (this.dataSource.update(), this._dataSourceUpdated = true), this.dataAutoUpdate && (this._dataSourceUpdated || this.needsUpdate) && this._enableCollision && (e2.rendering.collision.needsUpdate = true), this.onBeforeScenePrepareRenderHook && this.onBeforeScenePrepareRenderHook(e2, t2, i2, n2), this.clampToGround)) {
            const t3 = this.getShadowVolumeOptions();
            this._volumeDataSource = this.createVolumeDataSource();
            const i3 = this._VolumeClass;
            this._backObject && this.engine.remove(this._backObject), this._backObject = e2.add(new i3({ ...this._backMaterialOptions, ...t3 })), this._frontObject && this.engine.remove(this._frontObject), this._frontObject = e2.add(new i3({ ...this._frontMaterialOptions, ...t3 })), this._renderObject && this.engine.remove(this._renderObject), this._renderObject = e2.add(new i3({ ...this._renderMaterialOptions, ...t3, ...this.filterVolumeParamter(this.parameters) })), this._frontObject.dataSource = this._volumeDataSource, this._backObject.dataSource = this._volumeDataSource, this._renderObject.dataSource = this._volumeDataSource;
          }
        }
        onBeforeSceneRender(e2, t2, i2, n2) {
          this.dataSource && (this.dataAutoUpdate && this._dataSourceUpdated || this.dataAutoUpdate && this.needsUpdate ? this.setData() : this.geometry && this.geometry.needsUpdate && this.geometry.updateGeometry && (this.geometry.updateGeometry(), this.afterGeometryUpdate && this.afterGeometryUpdate()), delete this._dataSourceUpdated, this.visible && !this.inZoomsRange ? (this._zoomVisibleCache = this.visible, this.visible = false) : !this.visible && this._zoomVisibleCache && this.inZoomsRange && (this.visible = this._zoomVisibleCache, this._zoomVisibleCache = void 0), this.onBeforeSceneRenderHook && this.onBeforeSceneRenderHook(e2, t2, i2, n2));
        }
        setData() {
        }
        collisionTest(e2) {
          return {};
        }
        createVolumeDataSource() {
          return this.dataSource;
        }
        specifiedVolumeClass() {
          this._VolumeClass = this.constructor;
        }
        filterVolumeParamter(e2) {
          const t2 = ["opacity", "color", "vertexColors", "emissive", "mapSrc", "mapScale"];
          let i2 = {};
          return Object.keys(e2).filter((e3) => t2.includes(e3)).forEach((t3) => {
            i2[t3] = e2[t3];
          }), i2;
        }
        onDispose() {
        }
        dispose() {
          if (this.geometry && this.geometry.dispose(), this.material)
            if (Array.isArray(this.material))
              for (let e2 = 0; e2 < this.material.length; e2++) {
                this.material[e2].dispose();
              }
            else
              this.material.dispose();
          this.onDispose();
        }
        bindTerrain(e2) {
          this._terrain = e2;
        }
        initMaterialOptions() {
          this._frontMaterialOptions = { side: 0, depthWrite: false, colorWrite: false, stencilWrite: true, stencilFunc: 519, stencilZFail: 34056, stencilZPass: k }, this._backMaterialOptions = { side: 1, depthWrite: false, colorWrite: false, stencilWrite: true, stencilFunc: 519, stencilZFail: 34055, stencilZPass: k }, this._renderMaterialOptions = { side: 2, stencilWrite: true, stencilRef: 0, depthTest: false, stencilFunc: 517, stencilZFail: 0, stencilFail: 0, stencilZPass: 0 };
        }
        getShadowVolumeOptions() {
          this.geometry.computeBoundingBox();
          const { min: e2, max: t2 } = this.geometry.boundingBox, i2 = this.position;
          let n2 = new ie(e2.x, e2.y).add(i2), r2 = new ie(t2.x, t2.y).add(i2);
          const s2 = new Fo(n2, r2);
          let [a2, o2] = this._terrain._intersectHeightRange(s2);
          return { opacity: 0.4, extrude: true, extrudeValue: o2 - a2, zOffset: a2, enableBottomFace: true };
        }
        get clampToGround() {
          return this._clampToGround;
        }
        set clampToGround(e2) {
          this.clampToGround !== e2 && (this._clampToGround = e2, e2 ? (this.initMaterialOptions(), this.specifiedVolumeClass(), this.material.visible = false) : (this._frontObject && this.engine.remove(this._frontObject), this._backObject && this.engine.remove(this._backObject), this._renderObject && this.engine.remove(this._renderObject), this.material.visible = true));
        }
      }
      class vc extends _c {
        constructor() {
          super(...arguments), __publicField(this, "isMesh", true);
        }
      }
      function xc(e2) {
        let t2 = 0, i2 = 0;
        for (const a2 of e2)
          t2 += a2.w * a2.h, i2 = Math.max(i2, a2.w);
        e2.sort((e3, t3) => t3.h - e3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t2 / 0.95)), i2), h: 1 / 0 }];
        let r2 = 0, s2 = 0;
        for (const a2 of e2)
          for (let e3 = n2.length - 1; e3 >= 0; e3--) {
            const t3 = n2[e3];
            if (!(a2.w > t3.w || a2.h > t3.h)) {
              if (a2.x = t3.x, a2.y = t3.y, s2 = Math.max(s2, a2.y + a2.h), r2 = Math.max(r2, a2.x + a2.w), a2.w === t3.w && a2.h === t3.h) {
                const t4 = n2.pop();
                e3 < n2.length && (n2[e3] = t4);
              } else
                a2.h === t3.h ? (t3.x += a2.w, t3.w -= a2.w) : a2.w === t3.w ? (t3.y += a2.h, t3.h -= a2.h) : (n2.push({ x: t3.x + a2.w, y: t3.y, w: t3.w - a2.w, h: a2.h }), t3.y += a2.h, t3.h -= a2.h);
              break;
            }
          }
        return { w: r2, h: s2, fill: t2 / (r2 * s2) || 0 };
      }
      class yc extends Ai {
        constructor(e2) {
          super(), __publicField(this, "isCommonShaderMaterial", true), __publicField(this, "setCommonUniforms", (e3) => {
            for (const t2 of Object.keys(e3))
              this.uniforms[t2] = e3[t2];
          }), this.setValues(e2);
        }
      }
      const bc = Ci.merge([Xi.fog, yh, { map: { value: null }, pixelRatio: { value: 1 }, lineHeight: { value: 14 }, pixelOffsetX: { value: 0 }, pixelOffsetY: { value: 0 }, positionOffsetX: { value: 0 }, positionOffsetZ: { value: 0 }, positionOffsetY: { value: 0 }, backgroundColor: { value: [1, 1, 0, 0] }, uFlat: { value: false }, opacity: { value: 1 } }]);
      class Mc extends yc {
        constructor(e2) {
          super(), this.type = "DefaultTextMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float pixelRatio;\nuniform float positionOffsetX;\nuniform float positionOffsetY;\nuniform float pixelOffsetX;\nuniform float pixelOffsetY;\nuniform float positionOffsetZ;\nuniform bool uFlat;\nuniform vec2 resolution;\n\nattribute float pIndex;\nattribute vec2 wh;\nattribute float rotateZ;\n\nvarying vec2 vUv;\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n    #include <mvt_selective_vertex>\n    // float x = position.x;\n    // float y = position.y;\n    vUv = uv;\n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    if (uFlat) {\n        // TODO 支持offset\n        float pixelSize = getPixelSize(worldPosition.xyz);\n        float hw = wh.x * 0.5 * pixelSize;\n        float hh = wh.y * 0.5 * pixelSize;\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n            \n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        vec2 rotatedPosition;\n	    rotatedPosition.x = cos( rotateZ ) * hw - sin( rotateZ ) * hh;\n	    rotatedPosition.y = sin( rotateZ ) * hw + cos( rotateZ ) * hh;\n        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + rotatedPosition.x, position.y + rotatedPosition.y, position.z, 1.0);\n\n    }\n    else {\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);\n        worldPosition.x += positionOffsetX;\n        worldPosition.y += positionOffsetY;\n        worldPosition.z += positionOffsetZ;\n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n       \n        float w = gl_Position.w;\n        gl_Position /= w;\n        float hw = wh.x / resolution.x;\n        float hh = wh.y / resolution.y;\n        gl_Position.x += pixelOffsetX * 2. / resolution.x;\n        gl_Position.y += pixelOffsetY * 2. / resolution.y;\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n        gl_Position *= w;\n    }\n    #include <logdepthbuf_vertex>\n    // gl_PointSize = size * pixelRatio;\n    // vSize = size;\n    // vOffset = offset;\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D map;\nuniform vec4 backgroundColor;\nuniform float opacity;\nuniform float lineHeight;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    // gl_FragColor = vec4(1., 0, 0, 1.);\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));\n\n    if (backgroundColor.a > 0.0) {\n        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);\n    }\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n    \n}", this.isDefaultTextMaterial = true, this.transparent = true, this.depthTest = false, this.depthWrite = false, Object.assign(this.uniforms, Ci.clone(bc)), Eh(this), Mh(this, ["lineHeight", "pixelRatio", "map", "pixelOffsetX", "pixelOffsetY", "positionOffsetX", "positionOffsetY", "positionOffsetZ", "backgroundColor", "resolution", "opacity"]), wh(this, [["flat", "uFlat"]]), this.setValues(e2);
        }
      }
      new st(), new Ae();
      class Sc extends vc {
        constructor(e2) {
          super(e2), __publicField(this, "_collides"), __publicField(this, "_fontSize"), __publicField(this, "_fontFamily"), __publicField(this, "_fillStyle"), __publicField(this, "_padding"), __publicField(this, "_margin"), __publicField(this, "_strokeStyle"), __publicField(this, "_shouldStroke"), __publicField(this, "_maxRenderDepth"), __publicField(this, "_canRenderAll"), __publicField(this, "shouldUpdateRenderingData"), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "cachedData", []), __publicField(this, "drawingData"), __publicField(this, "canvas"), __publicField(this, "ctx"), __publicField(this, "texture"), __publicField(this, "matrixAutoUpdate", true), __publicField(this, "onBeforeSceneRenderHook", (e3, t3, i3) => {
            this.updateRenderingData();
          }), __publicField(this, "updateRenderingData", () => {
            const e3 = this.engine.rendering.pixelRatio, t3 = this.canvas, i3 = this.ctx, n2 = this._fontSize, r2 = this._fontFamily, s2 = this._fillStyle, a2 = this._padding, o2 = this.cachedData || [], l2 = xc(o2);
            let h2 = l2.w, c2 = l2.h;
            t3.width = h2 * e3, t3.height = c2 * e3, i3.save(), i3.scale(e3, e3), i3.textBaseline = "top", i3.fillStyle = s2, this._shouldStroke && (i3.strokeStyle = this._strokeStyle), i3.font = n2 + "px " + r2, this.shadowColor && (i3.shadowColor = this.shadowColor, i3.shadowOffsetX = this.shadowOffsetX || 0, i3.shadowOffsetY = this.shadowOffsetY || 0, i3.shadowBlur = this.shadowBlur || 0);
            const u2 = [], d2 = [], p2 = [], m2 = [], f2 = [], g2 = [], _2 = [];
            for (let x2 = 0, y2 = o2.length; x2 < y2; ++x2) {
              const e4 = o2[x2];
              let t4 = n2;
              if (this.parameters.vertexStyles) {
                let { fontWeight: n3, fontSize: s4, fillStyle: a3, strokeStyle: o3, lineWidth: l4 } = e4;
                i3.font = n3 >= 10 && n3 % 10 == 0 ? 10 * n3 + " " + s4 + "px " + r2 : s4 + "px " + r2, t4 = s4, l4 > 0 && (i3.lineWidth = l4, i3.strokeStyle = "rgba(" + o3.join(",") + ")"), i3.fillStyle = "rgba(" + a3.join(",") + ")";
              }
              let s3 = e4.text.split("\\");
              for (let n3 = 0; n3 < s3.length; n3++)
                (this._shouldStroke || this.parameters.vertexStyles) && i3.strokeText(s3[n3], e4.x + a2[0], e4.y + a2[1] + n3 * t4), i3.fillText(s3[n3], e4.x + a2[0], e4.y + a2[1] + n3 * t4);
              const [l3, v3, y3 = 0] = e4.position;
              u2.push(l3, v3, y3, l3, v3, y3, l3, v3, y3, l3, v3, y3), p2.push(0, 1, 2, 3), f2.push(e4.w, e4.h, e4.w, e4.h, e4.w, e4.h, e4.w, e4.h);
              const b2 = 4 * x2;
              m2.push(b2, b2 + 2, b2 + 1, b2, b2 + 3, b2 + 2);
              const M2 = e4.x / h2, S2 = (e4.x + e4.w) / h2, w2 = (e4.y + e4.h) / c2, T2 = e4.y / c2;
              d2.push(M2, w2, M2, T2, S2, T2, S2, w2), g2.push(e4.index, e4.index, e4.index, e4.index), _2.push(e4.rotateZ, e4.rotateZ, e4.rotateZ, e4.rotateZ);
            }
            i3.restore();
            const v2 = this.geometry;
            v2.setAttribute("position", new Jt(u2, 3)), v2.setAttribute("pIndex", new Jt(p2, 1)), v2.setAttribute("wh", new Jt(f2, 2)), v2.setAttribute("uv", new Jt(d2, 2)), v2.setAttribute("rotateZ", new Jt(_2, 1)), v2.setIndex(m2), v2.computeBoundingSphere(), this.makeGeometryOffsetPosition(v2, u2), u2.length > 0 && (this.texture && this.texture.dispose(), this.texture = new da(this.canvas), this.material.uniforms.map.value = this.texture), this.shouldUpdateRenderingData = false, this.needsUpdate = false;
          }), this.parameters = e2, this._collides = void 0 === this.parameters.collides || this.parameters.collides, this._fontSize = void 0 !== this.parameters.fontSize ? this.parameters.fontSize : 16, this._fontFamily = void 0 !== this.parameters.fontFamily ? this.parameters.fontFamily : "Microsoft Yahei", this._fillStyle = void 0 !== this.parameters.fillStyle ? this.parameters.fillStyle : "#f00", this._padding = void 0 !== this.parameters.padding ? this.parameters.padding : [2, 2], this._maxRenderDepth = void 0 !== this.parameters.maxRenderDepth ? this.parameters.maxRenderDepth : 1, this._margin = this.parameters.margin, this.strokeStyle = this.parameters.strokeStyle, this.cachedData = [], this.shouldUpdateRenderingData = false, this.drawingData = [];
          const t2 = this.canvas = document.createElement("canvas");
          t2.width = t2.height = 1;
          const i2 = this.ctx = t2.getContext("2d");
          i2.textAlign = "start", i2.textBaseline = "top", this.defineMaterialProxyProperties(["lineHeight", "map", "pixelOffsetX", "pixelOffsetY", "positionOffsetX", "positionOffsetY", "positionOffsetZ", "backgroundColor", "resolution", "opacity", "flat"]);
        }
        initObject() {
          let { margin: e2, padding: t2, collides: i2, fillStyle: n2, strokeStyle: r2, fontSize: s2, fontFamily: a2, vertexStyles: o2, ...l2 } = this.parameters;
          this.geometry = new ri(this.parameters), this.material = new Mc(l2), this.material.setCommonUniforms(this.engine.rendering.uniforms), this.texture = new da(this.canvas), this.material.uniforms.map.value = this.texture;
        }
        setData() {
          this._enableCollision && this._collisionData ? this.cachedData = this._collisionData : this.cachedData = this.dataSource.userData.map((e2) => {
            let t2 = this.collisionTest(e2);
            return { ...e2, w: t2.width, h: t2.height };
          }), this.update();
        }
        update() {
          this.shouldUpdateRenderingData = true, this._canRenderAll = false;
        }
        collisionTest(e2) {
          const t2 = this.ctx, i2 = this.engine.rendering.pixelRatio, n2 = this._fontSize, r2 = this._fontFamily, s2 = this._padding;
          t2.save(), t2.scale(i2, i2), t2.textBaseline = "top";
          let a2 = n2;
          if (this.parameters.vertexStyles) {
            let { fontWeight: i3, fontSize: n3, lineWidth: s3 } = e2;
            t2.font = i3 >= 10 && i3 % 10 == 0 ? 10 * i3 + " " + n3 + "px " + r2 : n3 + "px " + r2, a2 = n3, s3 > 0 && (t2.lineWidth = s3);
          } else
            t2.font = n2 + "px " + r2;
          let o2 = e2.text.split("\\");
          const l2 = o2.map((e3) => t2.measureText(e3).width);
          let h2 = Math.max(...l2), c2 = a2 * o2.length;
          const u2 = h2 + 2 * s2[0], d2 = c2 + 2 * s2[1];
          return t2.restore(), { width: u2, height: d2 };
        }
        onDispose() {
          this.texture && this.texture.dispose();
        }
        set collides(e2) {
          this._collides = e2;
        }
        get collides() {
          return this._collides;
        }
        set fontSize(e2) {
          this._fontSize = e2;
        }
        get fontSize() {
          return this._fontSize;
        }
        set fontFamily(e2) {
          this._fontFamily = e2;
        }
        get fontFamily() {
          return this._fontFamily;
        }
        set fillStyle(e2) {
          this._fillStyle = e2;
        }
        get fillStyle() {
          return this._fillStyle;
        }
        set strokeStyle(e2) {
          this._shouldStroke = !!e2, this._strokeStyle = e2;
        }
        set padding(e2) {
          this._padding = e2;
        }
        get padding() {
          return this._padding;
        }
        set margin(e2) {
          "number" == typeof e2 ? this._margin = [e2, e2] : e2 instanceof Array && (this._margin = e2);
        }
        get margin() {
          return this._margin;
        }
        set maxRenderDepth(e2) {
          this._maxRenderDepth = e2;
        }
      }
      class wc {
        constructor(e2) {
          this._rendering = e2;
        }
        init() {
          const e2 = this._flatDataSource = new fc(), t2 = this._flatText = this._rendering.add(new Sc({ fillStyle: "#fff", strokeStyle: "#000", flat: true }));
          t2.renderOrder = 100, t2.maxRenderDepth = 0.999999, t2.dataSource = e2, e2.setAttribute("text", "text").setAttribute("rotateZ", "rotateZ");
          const i2 = this._fixDataSource = new fc(), n2 = this._fixText = this._rendering.add(new Sc({ fillStyle: "#000", strokeStyle: "#fff", fontFamily: "sans-serif", vertexStyles: true }));
          n2.renderOrder = 100, n2.maxRenderDepth = 0.999999, n2.dataSource = i2, i2.setAttributes({ text: "text", fontSize: "fontSize", fontWeight: "fontWeight", fillStyle: "fontRgba", strokeStyle: "haloRgba", lineWidth: "haloSize" });
          const r2 = this._labelDataSource = new fc(), s2 = this._flatText = this._rendering.add(new Sc({ fillStyle: "#000", strokeStyle: "#fff", fontFamily: "sans-serif", flat: true, vertexStyles: true }));
          s2.renderOrder = 100, s2.maxRenderDepth = 0.999999, s2.dataSource = r2, r2.setAttributes({ text: "text", fontSize: "fontSize", fontWeight: "fontWeight", fillStyle: "fontRgba", strokeStyle: "haloRgba", lineWidth: "haloSize", rotateZ: "rotateZ" }), this._rendering.collision.add(n2, { margin: [50, 50] }, "poi"), this._rendering.collision.add(s2, { margin: [50, 50] }, "poi"), this._rendering.collision.add(t2, { margin: [80, 80] }, "poi");
        }
        addLabel(e2) {
          let t2 = e2;
          if (!(e2 instanceof lc) && "[object Object]" === Array.prototype.toString.call(e2)) {
            const { position: i2, ...n2 } = e2;
            t2 = new lc(i2, n2);
          }
          "flat" === e2.type ? this._flatDataSource.add(t2) : "labelp" === e2.type ? this._labelDataSource.add(t2) : this._fixDataSource.add(t2);
        }
        addLabels(e2) {
          for (const t2 of e2)
            this.addLabel(t2);
          this._rendering.requestRender();
        }
        removeLabel(e2) {
          "flat" === e2.type ? this._flatDataSource.remove(e2) : "labelp" === e2.type ? this._labelDataSource.remove(e2) : this._fixDataSource.remove(e2);
        }
        removeLabels(e2) {
          for (const t2 of e2)
            this.removeLabel(t2);
          this._rendering.requestRender();
        }
      }
      class Tc {
        constructor(e2) {
          __publicField(this, "_needsCreate", false), __publicField(this, "_rendering"), __publicField(this, "_enabled", false), __publicField(this, "_brightness", 0), __publicField(this, "_saturation", 0), __publicField(this, "_contrast", 0), __publicField(this, "updateComposition", (e3, t2, i2) => {
            this[e3] = i2;
            const n2 = this._rendering;
            if (n2.useMrt) {
              n2.composition[t2] = i2;
            }
          }), __publicField(this, "createFog", () => {
            const e3 = this._rendering;
            if (e3.useMrt) {
              const t2 = e3.composition;
              t2.useFog = true, t2.fogDensity = this._density;
            }
          }), __publicField(this, "destory", () => {
            const e3 = this._rendering;
            if (e3.useMrt) {
              e3.composition.useFog = false;
            }
          }), this._rendering = e2;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e2) {
          e2 !== this._enabled && (this._enabled = e2, this.updateComposition("_enabled", "colorAdjustEnabled", e2), e2 ? this._needsCreate = true : this.destory());
        }
        get brightness() {
          return this._brightness;
        }
        set brightness(e2) {
          this.updateComposition("_brightness", "adjustBrightnessFactor", e2);
        }
        get contrast() {
          return this._contrast;
        }
        set contrast(e2) {
          this.updateComposition("_contrast", "adjustContrastFactor", e2);
        }
        get saturation() {
          return this._saturation;
        }
        set saturation(e2) {
          this.updateComposition("_saturation", "adjustSaturationFactor", e2);
        }
        render() {
        }
      }
      function Ec(e2, t2, i2, n2, r2) {
        Cc(e2, t2, i2 || 0, n2 || e2.length - 1, r2 || Pc);
      }
      function Cc(e2, t2, i2, n2, r2) {
        for (; n2 > i2; ) {
          if (n2 - i2 > 600) {
            var s2 = n2 - i2 + 1, a2 = t2 - i2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), h2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            Cc(e2, t2, Math.max(i2, Math.floor(t2 - a2 * l2 / s2 + h2)), Math.min(n2, Math.floor(t2 + (s2 - a2) * l2 / s2 + h2)), r2);
          }
          var c2 = e2[t2], u2 = i2, d2 = n2;
          for (Ac(e2, i2, t2), r2(e2[n2], c2) > 0 && Ac(e2, i2, n2); u2 < d2; ) {
            for (Ac(e2, u2, d2), u2++, d2--; r2(e2[u2], c2) < 0; )
              u2++;
            for (; r2(e2[d2], c2) > 0; )
              d2--;
          }
          0 === r2(e2[i2], c2) ? Ac(e2, i2, d2) : Ac(e2, ++d2, n2), d2 <= t2 && (i2 = d2 + 1), t2 <= d2 && (n2 = d2 - 1);
        }
      }
      function Ac(e2, t2, i2) {
        var n2 = e2[t2];
        e2[t2] = e2[i2], e2[i2] = n2;
      }
      function Pc(e2, t2) {
        return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
      }
      class Rc {
        constructor(e2 = 9) {
          this._maxEntries = Math.max(4, e2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(e2) {
          let t2 = this.data;
          const i2 = [];
          if (!Vc(e2, t2))
            return i2;
          const n2 = this.toBBox, r2 = [];
          for (; t2; ) {
            for (let s2 = 0; s2 < t2.children.length; s2++) {
              const a2 = t2.children[s2], o2 = t2.leaf ? n2(a2) : a2;
              Vc(e2, o2) && (t2.leaf ? i2.push(a2) : Bc(e2, o2) ? this._all(a2, i2) : r2.push(a2));
            }
            t2 = r2.pop();
          }
          return i2;
        }
        collides(e2) {
          let t2 = this.data;
          if (!Vc(e2, t2))
            return false;
          const i2 = [];
          for (; t2; ) {
            for (let n2 = 0; n2 < t2.children.length; n2++) {
              const r2 = t2.children[n2], s2 = t2.leaf ? this.toBBox(r2) : r2;
              if (Vc(e2, s2)) {
                if (t2.leaf || Bc(e2, s2))
                  return true;
                i2.push(r2);
              }
            }
            t2 = i2.pop();
          }
          return false;
        }
        load(e2) {
          if (!e2 || !e2.length)
            return this;
          if (e2.length < this._minEntries) {
            for (let t3 = 0; t3 < e2.length; t3++)
              this.insert(e2[t3]);
            return this;
          }
          let t2 = this._build(e2.slice(), 0, e2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === t2.height)
              this._splitRoot(this.data, t2);
            else {
              if (this.data.height < t2.height) {
                const e3 = this.data;
                this.data = t2, t2 = e3;
              }
              this._insert(t2, this.data.height - t2.height - 1, true);
            }
          else
            this.data = t2;
          return this;
        }
        insert(e2) {
          return e2 && this._insert(e2, this.data.height - 1), this;
        }
        clear() {
          return this.data = Gc([]), this;
        }
        remove(e2, t2) {
          if (!e2)
            return this;
          let i2 = this.data;
          const n2 = this.toBBox(e2), r2 = [], s2 = [];
          let a2, o2, l2;
          for (; i2 || r2.length; ) {
            if (i2 || (i2 = r2.pop(), o2 = r2[r2.length - 1], a2 = s2.pop(), l2 = true), i2.leaf) {
              const n3 = Lc(e2, i2.children, t2);
              if (-1 !== n3)
                return i2.children.splice(n3, 1), r2.push(i2), this._condense(r2), this;
            }
            l2 || i2.leaf || !Bc(i2, n2) ? o2 ? (a2++, i2 = o2.children[a2], l2 = false) : i2 = null : (r2.push(i2), s2.push(a2), a2 = 0, o2 = i2, i2 = i2.children[0]);
          }
          return this;
        }
        toBBox(e2) {
          return e2;
        }
        compareMinX(e2, t2) {
          return e2.minX - t2.minX;
        }
        compareMinY(e2, t2) {
          return e2.minY - t2.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(e2) {
          return this.data = e2, this;
        }
        _all(e2, t2) {
          const i2 = [];
          for (; e2; )
            e2.leaf ? t2.push(...e2.children) : i2.push(...e2.children), e2 = i2.pop();
          return t2;
        }
        _build(e2, t2, i2, n2) {
          const r2 = i2 - t2 + 1;
          let s2, a2 = this._maxEntries;
          if (r2 <= a2)
            return s2 = Gc(e2.slice(t2, i2 + 1)), Ic(s2, this.toBBox), s2;
          n2 || (n2 = Math.ceil(Math.log(r2) / Math.log(a2)), a2 = Math.ceil(r2 / Math.pow(a2, n2 - 1))), s2 = Gc([]), s2.leaf = false, s2.height = n2;
          const o2 = Math.ceil(r2 / a2), l2 = o2 * Math.ceil(Math.sqrt(a2));
          Hc(e2, t2, i2, l2, this.compareMinX);
          for (let h2 = t2; h2 <= i2; h2 += l2) {
            const t3 = Math.min(h2 + l2 - 1, i2);
            Hc(e2, h2, t3, o2, this.compareMinY);
            for (let i3 = h2; i3 <= t3; i3 += o2) {
              const r3 = Math.min(i3 + o2 - 1, t3);
              s2.children.push(this._build(e2, i3, r3, n2 - 1));
            }
          }
          return Ic(s2, this.toBBox), s2;
        }
        _chooseSubtree(e2, t2, i2, n2) {
          for (; n2.push(t2), !t2.leaf && n2.length - 1 !== i2; ) {
            let i3, n3 = 1 / 0, a2 = 1 / 0;
            for (let o2 = 0; o2 < t2.children.length; o2++) {
              const l2 = t2.children[o2], h2 = zc(l2), c2 = (r2 = e2, s2 = l2, (Math.max(s2.maxX, r2.maxX) - Math.min(s2.minX, r2.minX)) * (Math.max(s2.maxY, r2.maxY) - Math.min(s2.minY, r2.minY)) - h2);
              c2 < a2 ? (a2 = c2, n3 = h2 < n3 ? h2 : n3, i3 = l2) : c2 === a2 && h2 < n3 && (n3 = h2, i3 = l2);
            }
            t2 = i3 || t2.children[0];
          }
          var r2, s2;
          return t2;
        }
        _insert(e2, t2, i2) {
          const n2 = i2 ? e2 : this.toBBox(e2), r2 = [], s2 = this._chooseSubtree(n2, this.data, t2, r2);
          for (s2.children.push(e2), Fc(s2, n2); t2 >= 0 && r2[t2].children.length > this._maxEntries; )
            this._split(r2, t2), t2--;
          this._adjustParentBBoxes(n2, r2, t2);
        }
        _split(e2, t2) {
          const i2 = e2[t2], n2 = i2.children.length, r2 = this._minEntries;
          this._chooseSplitAxis(i2, r2, n2);
          const s2 = this._chooseSplitIndex(i2, r2, n2), a2 = Gc(i2.children.splice(s2, i2.children.length - s2));
          a2.height = i2.height, a2.leaf = i2.leaf, Ic(i2, this.toBBox), Ic(a2, this.toBBox), t2 ? e2[t2 - 1].children.push(a2) : this._splitRoot(i2, a2);
        }
        _splitRoot(e2, t2) {
          this.data = Gc([e2, t2]), this.data.height = e2.height + 1, this.data.leaf = false, Ic(this.data, this.toBBox);
        }
        _chooseSplitIndex(e2, t2, i2) {
          let n2, r2 = 1 / 0, s2 = 1 / 0;
          for (let a2 = t2; a2 <= i2 - t2; a2++) {
            const t3 = Dc(e2, 0, a2, this.toBBox), o2 = Dc(e2, a2, i2, this.toBBox), l2 = kc(t3, o2), h2 = zc(t3) + zc(o2);
            l2 < r2 ? (r2 = l2, n2 = a2, s2 = h2 < s2 ? h2 : s2) : l2 === r2 && h2 < s2 && (s2 = h2, n2 = a2);
          }
          return n2 || i2 - t2;
        }
        _chooseSplitAxis(e2, t2, i2) {
          const n2 = e2.leaf ? this.compareMinX : Oc, r2 = e2.leaf ? this.compareMinY : Uc;
          this._allDistMargin(e2, t2, i2, n2) < this._allDistMargin(e2, t2, i2, r2) && e2.children.sort(n2);
        }
        _allDistMargin(e2, t2, i2, n2) {
          e2.children.sort(n2);
          const r2 = this.toBBox, s2 = Dc(e2, 0, t2, r2), a2 = Dc(e2, i2 - t2, i2, r2);
          let o2 = Nc(s2) + Nc(a2);
          for (let l2 = t2; l2 < i2 - t2; l2++) {
            const t3 = e2.children[l2];
            Fc(s2, e2.leaf ? r2(t3) : t3), o2 += Nc(s2);
          }
          for (let l2 = i2 - t2 - 1; l2 >= t2; l2--) {
            const t3 = e2.children[l2];
            Fc(a2, e2.leaf ? r2(t3) : t3), o2 += Nc(a2);
          }
          return o2;
        }
        _adjustParentBBoxes(e2, t2, i2) {
          for (let n2 = i2; n2 >= 0; n2--)
            Fc(t2[n2], e2);
        }
        _condense(e2) {
          for (let t2, i2 = e2.length - 1; i2 >= 0; i2--)
            0 === e2[i2].children.length ? i2 > 0 ? (t2 = e2[i2 - 1].children, t2.splice(t2.indexOf(e2[i2]), 1)) : this.clear() : Ic(e2[i2], this.toBBox);
        }
      }
      function Lc(e2, t2, i2) {
        if (!i2)
          return t2.indexOf(e2);
        for (let n2 = 0; n2 < t2.length; n2++)
          if (i2(e2, t2[n2]))
            return n2;
        return -1;
      }
      function Ic(e2, t2) {
        Dc(e2, 0, e2.children.length, t2, e2);
      }
      function Dc(e2, t2, i2, n2, r2) {
        r2 || (r2 = Gc(null)), r2.minX = 1 / 0, r2.minY = 1 / 0, r2.maxX = -1 / 0, r2.maxY = -1 / 0;
        for (let s2 = t2; s2 < i2; s2++) {
          const t3 = e2.children[s2];
          Fc(r2, e2.leaf ? n2(t3) : t3);
        }
        return r2;
      }
      function Fc(e2, t2) {
        return e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), e2;
      }
      function Oc(e2, t2) {
        return e2.minX - t2.minX;
      }
      function Uc(e2, t2) {
        return e2.minY - t2.minY;
      }
      function zc(e2) {
        return (e2.maxX - e2.minX) * (e2.maxY - e2.minY);
      }
      function Nc(e2) {
        return e2.maxX - e2.minX + (e2.maxY - e2.minY);
      }
      function kc(e2, t2) {
        const i2 = Math.max(e2.minX, t2.minX), n2 = Math.max(e2.minY, t2.minY), r2 = Math.min(e2.maxX, t2.maxX), s2 = Math.min(e2.maxY, t2.maxY);
        return Math.max(0, r2 - i2) * Math.max(0, s2 - n2);
      }
      function Bc(e2, t2) {
        return e2.minX <= t2.minX && e2.minY <= t2.minY && t2.maxX <= e2.maxX && t2.maxY <= e2.maxY;
      }
      function Vc(e2, t2) {
        return t2.minX <= e2.maxX && t2.minY <= e2.maxY && t2.maxX >= e2.minX && t2.maxY >= e2.minY;
      }
      function Gc(e2) {
        return { children: e2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
      }
      function Hc(e2, t2, i2, n2, r2) {
        const s2 = [t2, i2];
        for (; s2.length; ) {
          if ((i2 = s2.pop()) - (t2 = s2.pop()) <= n2)
            continue;
          const a2 = t2 + Math.ceil((i2 - t2) / n2 / 2) * n2;
          Ec(e2, a2, t2, i2, r2), s2.push(t2, a2, a2, i2);
        }
      }
      const jc = new st();
      class Wc {
        constructor(e2) {
          __publicField(this, "_groupObjectMap", {}), __publicField(this, "_groupDataMap", {}), __publicField(this, "_objectDataMap", /* @__PURE__ */ new Map()), __publicField(this, "_needsUpdate", false), __publicField(this, "_restrictCount", 1e3), __publicField(this, "_margin", [0, 0]), __publicField(this, "_maxRenderDepth", 1), this._rendering = e2;
        }
        add(e2, t2 = {}, i2 = "_default") {
          e2 instanceof _c ? e2.dataSource ? (this._groupObjectMap[i2] || (this._groupObjectMap[i2] = [], this._groupDataMap[i2] = []), this._groupObjectMap[i2].push(e2), e2._enableCollision = true, e2._collisionOptions = t2, e2.dataSource.setAttribute("rank", "rank")) : console.error("Object must have DataSource before it added to Collision!") : console.error("Collison Test only work with GeoObject.");
        }
        remove(e2, t2 = "_default") {
          if (!(e2 instanceof _c))
            return void console.error("Collison Test only work with GeoObject.");
          let i2 = this._groupObjectMap[t2].indexOf(e2);
          i2 > -1 ? (this._groupObjectMap[t2].splice(i2, 1), delete e2._enableCollision, delete e2._collisionOptions, delete e2._collisionData, e2.dataSource.removeAttribute("rank", "rank")) : console.error("remove error: cannot find object in this group.");
        }
        sortData() {
          let e2 = Object.keys(this._groupObjectMap);
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2], n2 = this._groupObjectMap[i2];
            for (let e3 = 0; e3 < n2.length; e3++) {
              const t3 = n2[e3];
              delete t3._collisionData;
              let i3 = t3.dataSource.userData;
              for (let e4 = 0; e4 < i3.length; e4++)
                i3[e4]._objects = t3.dataSource.objects;
            }
            this._groupDataMap[i2] = [];
            for (let e3 = 0; e3 < n2.length; e3++) {
              const t3 = n2[e3];
              this._groupDataMap[i2] = this._groupDataMap[i2].concat(t3.dataSource.userData);
            }
            this._groupDataMap[i2] = this._groupDataMap[i2].sort((e3, t3) => t3.rank - e3.rank || t3.position[0] - e3.position[0] || t3.position[1] - e3.position[1]).slice(0, this.restrictCount);
          }
          this._needsUpdate = false;
        }
        collisionTest() {
          let e2 = Object.keys(this._groupDataMap);
          if (!e2.length)
            return;
          this.needsUpdate && this.sortData();
          const t2 = this._rendering.camera;
          let i2 = jc.copy(this._rendering.renderState.viewMatrixWorldInverse), n2 = t2.projectionMatrix;
          const r2 = this._rendering.resolution ? this._rendering.resolution.toArray() : [0, 0], [s2, a2] = r2;
          if (isNaN(s2) || s2 <= 0 || isNaN(a2) || a2 <= 0)
            return console.warn("resolution is invalid"), false;
          const o2 = this._objectDataMap;
          o2.clear();
          for (let l2 = 0; l2 < e2.length; l2++) {
            const t3 = e2[l2], r3 = this._groupDataMap[t3];
            if (!r3)
              continue;
            const h2 = new Rc();
            for (let e3 = 0; e3 < r3.length; e3++) {
              const t4 = r3[e3], l3 = t4._objects, c2 = l3.filter((e4) => e4._enableCollision)[0], [u2, d2, p2] = t4.position, m2 = new Se(u2, d2, p2, 1);
              m2.applyMatrix4(i2).applyMatrix4(n2), m2.divideScalar(m2.w);
              const f2 = (m2.x + 1) / 2 * s2, g2 = (1 - m2.y) / 2 * a2;
              if (m2.z > this._maxRenderDepth)
                continue;
              let { width: _2, height: v2 } = c2.collisionTest(t4);
              if (!_2 || !v2)
                continue;
              let x2 = _2, y2 = v2;
              if (c2._collisionOptions.margin) {
                let e4 = c2._collisionOptions.margin;
                "number" == typeof e4 && (e4 = [e4, e4]), _2 += e4[0], v2 += e4[1];
              } else
                _2 += this.margin[0], v2 += this.margin[1];
              const b2 = f2 - _2 / 2, M2 = g2 - v2 / 2, S2 = b2 + _2, w2 = M2 + v2;
              if (S2 < 0 || w2 < 0 || b2 > s2 || M2 > a2)
                continue;
              const T2 = { minX: b2, minY: M2, maxX: S2, maxY: w2 };
              if (h2.collides(T2))
                continue;
              h2.insert(T2);
              let E2 = { ...t4, w: x2, h: y2 };
              for (let e4 = 0; e4 < l3.length; e4++) {
                const t5 = l3[e4];
                o2.get(t5) || o2.set(t5, []);
                o2.get(t5).push(E2);
              }
            }
          }
          Array.from(o2.entries()).forEach(([e3, t3]) => {
            e3._collisionData && e3._collisionData.length === t3.length || (e3._collisionData = t3, e3.needsUpdate = true);
          });
        }
        set margin(e2) {
          "number" == typeof e2 ? this._margin = [e2, e2] : e2 instanceof Array && (this._margin = e2);
        }
        get margin() {
          return this._margin;
        }
        set maxRenderDepth(e2) {
          this._maxRenderDepth = e2;
        }
        set restrictCount(e2) {
          this._restrictCount = e2;
        }
        get restrictCount() {
          return this._restrictCount;
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      class Xc {
        constructor(e2) {
          __publicField(this, "_rendering", null), __publicField(this, "_mixer", null), __publicField(this, "_customMixers", []), this._rendering = e2;
        }
        update(e2) {
          this._mixer && this._mixer.update(e2.deltaSeconds);
          for (const t2 of this._customMixers)
            t2.update(e2.deltaSeconds);
        }
        addMixer(e2) {
          -1 === this._customMixers.indexOf(e2) && this._customMixers.push(e2);
        }
        removeMixer(e2) {
          let t2 = this._customMixers.indexOf(e2);
          -1 !== t2 && this._customMixers.splice(t2, 1);
        }
        get mixer() {
          return this._mixer || (this._mixer = new Po(this._rendering.scene)), this._mixer;
        }
      }
      class qc {
        constructor() {
          __publicField(this, "_time", 0), __publicField(this, "_viewChanged", false), __publicField(this, "_viewMatrixWorld", new st()), __publicField(this, "_viewMatrixWorldInverse", new st()), __publicField(this, "_projectionMatrix", new st()), __publicField(this, "_cameraMatrix", new st()), __publicField(this, "_cameraMatrixInverse", new st()), __publicField(this, "_cameraOffsetX", 0), __publicField(this, "_cameraOffsetY", 0);
        }
        beginFrame(e2, t2) {
          this._deltaTime = t2 - this._time, this._deltaSeconds = this._deltaTime / 1e3, this._time = t2;
          const i2 = e2.camera, n2 = i2.matrixWorld, r2 = i2.projectionMatrix;
          n2.equals(this._viewMatrixWorld) && r2.equals(this._projectionMatrix) ? this._viewChanged = false : this._viewChanged = true, this._viewMatrixWorld.copy(i2.matrixWorld), this._viewMatrixWorldInverse.copy(i2.matrixWorldInverse), this._projectionMatrix.copy(i2.projectionMatrix);
        }
        endFrame() {
        }
        updateCameraOffsetState(e2, t2, i2) {
          this._cameraMatrix.copy(e2.matrixWorld), this._cameraMatrixInverse.copy(e2.matrixWorldInverse), this._cameraOffsetX = t2, this._cameraOffsetY = i2;
        }
        get time() {
          return this._time;
        }
        get viewChanged() {
          return this._viewChanged;
        }
        get viewMatrixWorld() {
          return this._viewMatrixWorld;
        }
        get viewMatrixWorldInverse() {
          return this._viewMatrixWorldInverse;
        }
        get cameraMatrix() {
          return this._cameraMatrix;
        }
        get cameraMatrixInverse() {
          return this._cameraMatrixInverse;
        }
        get cameraOffsetX() {
          return this._cameraOffsetX;
        }
        get cameraOffsetY() {
          return this._cameraOffsetY;
        }
        get deltaTime() {
          return this._deltaTime;
        }
        get deltaSeconds() {
          return this._deltaSeconds;
        }
      }
      new ne();
      class Yc {
        constructor(e2, t2 = {}) {
          __publicField(this, "_engine"), __publicField(this, "_outputEncoding"), __publicField(this, "_enableAnimationLoop"), __publicField(this, "_animationLoopFrameTime"), __publicField(this, "_uniforms"), __publicField(this, "_main"), __publicField(this, "_shadow"), __publicField(this, "_bloom"), __publicField(this, "_ssr"), __publicField(this, "_composition"), __publicField(this, "_fog"), __publicField(this, "_label"), __publicField(this, "_colorAdjust"), __publicField(this, "_renderState"), __publicField(this, "_camera"), __publicField(this, "_canvas"), __publicField(this, "_context"), __publicField(this, "_renderer"), __publicField(this, "_scene"), __publicField(this, "_weather"), __publicField(this, "_useMrt", false), __publicField(this, "_mainRenderTarget", null), __publicField(this, "_needsPrepareRendering", true), __publicField(this, "_needsUpdateExtraProgramCacheKey", true), __publicField(this, "_tDiffuse", null), __publicField(this, "_tDepth", null), __publicField(this, "_tEmissive", null), __publicField(this, "_tNormal", null), __publicField(this, "_tSpecular", null), __publicField(this, "_isRunning", false), __publicField(this, "_needsRenderImmediately", false), __publicField(this, "_needsRenderNext", false), __publicField(this, "_beforeRenderListeners", []), __publicField(this, "_startTime", 0), __publicField(this, "_pixelRatio", window.devicePixelRatio), __publicField(this, "_resolution"), __publicField(this, "_sky", null), __publicField(this, "_debugShaderType", 0), __publicField(this, "_beforeScenePrepareRenderObjects", /* @__PURE__ */ new Set()), __publicField(this, "_beforeSceneRenderObjects", /* @__PURE__ */ new Set()), __publicField(this, "_onRenderModeChangedObjects", /* @__PURE__ */ new Set()), __publicField(this, "_wireframe", false), __publicField(this, "_wireframeMaterial", null), __publicField(this, "_autoOffsetRelativeCenter", true), __publicField(this, "handleShaderBeforeResolve", (e3, t3, i2) => {
            if (this._useMrt) {
              const e4 = this._renderer.getRenderTarget();
              e4 && e4.isWebGLMultipleRenderTargets && (t3 = this.convertMrtSupportedFragment(t3));
            }
            return "basic" === i2.shaderID && (t3 = "#define BASIC\nuniform vec3 emissive;\n" + t3), { vertexShader: e3, fragmentShader: t3 };
          }), __publicField(this, "handleShaderBeforeCompile", (e3, t3, i2) => {
            if (e3 = ((e4, t4, i3, n2) => {
              if ((t4 || i3) && (e4 = e4.replace("void main()", (t4 || "") + "void main()\n" + (i3 || ""))), n2) {
                const t5 = e4.lastIndexOf("}");
                e4 = e4.substring(0, t5), e4 += n2 + "}";
              }
              return e4;
            })(e3, "\nattribute float _tileEditableValue;\n", null, "\nif (_tileEditableValue == 1.0) {\n    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);\n}\n"), this._useMrt) {
              const n2 = this._renderer.getRenderTarget();
              if (n2 && n2.isWebGLMultipleRenderTargets) {
                i2.isRawShaderMaterial && i2.glslVersion !== V && (e3 = ["#version 300 es", "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + e3, t3 = ["#version 300 es", "#define varying in", "layout(location = 0) out highp vec4 pc_fragColor;", "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t3);
              }
            }
            return { vertexShader: e3, fragmentShader: t3 };
          }), __publicField(this, "convertMrtSupportedFragment", (e3, t3) => ((e4) => {
            let t4 = e4;
            t4 = t4.replace("void main() {", "#include <mvt_mrt_output_pars_fragment>\nvoid main() {");
            const i2 = t4.lastIndexOf("}");
            return t4 = t4.substring(0, i2), t4 += "#include <mvt_mrt_output_fragment>\n}", t4;
          })(e3)), __publicField(this, "render", () => {
            if (!this._isRunning)
              return;
            requestAnimationFrame(this.render);
            const e3 = new Date().valueOf();
            if ((this._needsRenderNext || this._enableAnimationLoop) && this._animationLoopFrameTime < 17 && (this._needsRenderImmediately = true), !(this._needsRenderImmediately || (this._needsRenderNext || this._enableAnimationLoop) && e3 - this.lastRenderTime >= this._animationLoopFrameTime))
              return;
            let t3 = this._needsRenderImmediately ? 0 : e3 - this.lastRenderTime - this._animationLoopFrameTime;
            t3 > this._animationLoopFrameTime - 16 && (t3 = this._animationLoopFrameTime - 16), this.lastRenderTime = e3 - t3, this._needsRenderImmediately = false, this._needsRenderNext = false, this.renderScene(e3);
          }), __publicField(this, "getExtraProgramCacheKey", () => {
            if (this._useMrt) {
              const e3 = this._renderer.getRenderTarget();
              if (e3 && e3.isWebGLMultipleRenderTargets)
                return "1";
            }
            return "0";
          }), __publicField(this, "scaleZAtCurrentPosition", () => {
            const e3 = this._engine.map, t3 = e3.getScaleAt(e3.getCenter());
            this.scene.scale.z = t3;
          }), this._engine = e2, this._outputEncoding = t2.outputEncoding || U, this._preserveDrawingBuffer = t2.preserveDrawingBuffer || false, this._enableAnimationLoop = t2.enableAnimationLoop || false, this._animationLoopFrameTime = t2.animationLoopFrameTime || 16, this._pixelRatio = t2.pixelRatio || window.devicePixelRatio, this._resolution = t2.resolution, this._uniforms = { time: { value: 0 }, elapsedTime: { value: 0 }, pixelRatio: { value: this._pixelRatio }, zoomUnits: { value: 1 }, resolution: { value: new ie(t2.resolution.x, t2.resolution.y) } }, Object.freeze(this._uniforms), this._main = new _l(this), this._shadow = new vl(this), this._bloom = new Rl(this), this._ssr = new Dh(this), this._composition = new zh(this), this._fog = new xl(this), this._postprocessing = new jh(this), this._label = new wc(this), this._colorAdjust = new Tc(this), this._collision = new Wc(this), this._animation = new Xc(this), this._renderState = new qc(this);
        }
        init() {
          const e2 = this._canvas = document.createElement("canvas");
          e2.style.position = "absolute", e2.style.top = "0", e2.style.left = "0";
          const t2 = this._context = e2.getContext("webgl2", { alpha: true, stencil: true, antialias: true, powerPreference: "high-performance", preserveDrawingBuffer: this._preserveDrawingBuffer }), i2 = this._resolution;
          (this._camera = new Ri(35, i2.x / i2.y, 0.1, 100)).matrixAutoUpdate = false;
          const n2 = this._scene = new Es(), r2 = this.objectsScene = new vs(), s2 = this.environmentScene = new vs();
          n2.add(r2), n2.add(s2), n2.autoUpdate = false;
          const a2 = this._renderer = new ws({ canvas: e2, context: t2, logarithmicDepthBuffer: true });
          a2.setClearColor(16777215, 0), a2.setPixelRatio(this._pixelRatio), a2.setSize(i2.x, i2.y), a2.outputEncoding = this._outputEncoding, a2.info.autoReset = false, this._renderer.extraProgramCacheKey = "0", a2.onShaderBeforeResolve = this.handleShaderBeforeResolve, a2.onShaderBeforeCompile = this.handleShaderBeforeCompile, this._uniforms.resolution.value[0] = i2.x, this._uniforms.resolution.value[1] = i2.y, this._label.init();
        }
        addBeforeRenderListener(e2) {
          -1 === this._beforeRenderListeners.indexOf(e2) && this._beforeRenderListeners.push(e2);
        }
        removeBeforeRenderListener(e2) {
          const t2 = this._beforeRenderListeners.indexOf(e2);
          t2 > -1 && this._beforeRenderListeners.splice(t2, 1);
        }
        add(e2) {
          return e2.traverse((e3) => {
            e3.afterAddToEngine && !e3.__initInEngine && (e3.__initInEngine = true, e3.afterAddToEngine(this._engine)), e3 instanceof tl ? this._sky = e3 : e3 instanceof gl && (this._weather = e3), this.addBeforePrepareRenderObject(e3), this.addBeforeRenderObject(e3), this.addOnRenderModeChangeObject(e3);
          }), e2.__isEnvironment ? this.environmentScene.add(e2) : this.objectsScene.add(e2), this._needsRenderImmediately = true, e2;
        }
        remove(e2) {
          e2.traverse((e3) => {
            e3.beforeRemoveFromEngine && (e3.__initInEngine = void 0, e3.beforeRemoveFromEngine(this._engine)), e3 instanceof tl ? this._sky = null : e3 instanceof gl && (this._weather = null), this.removeBeforeRenderObject(e3), this.removeBeforePrepareRenderObject(e3), this.removeOnRenderModeChangeObject(e3);
          }), e2.__isEnvironment ? this.environmentScene.remove(e2) : this.objectsScene.remove(e2), this._needsRenderImmediately = true;
        }
        addBeforePrepareRenderObject(e2) {
          e2.onBeforeScenePrepareRender && this._beforeScenePrepareRenderObjects.add(e2);
        }
        removeBeforePrepareRenderObject(e2) {
          this._beforeScenePrepareRenderObjects.delete(e2);
        }
        addBeforeRenderObject(e2) {
          e2.onBeforeSceneRender && this._beforeSceneRenderObjects.add(e2);
        }
        removeBeforeRenderObject(e2) {
          this._beforeSceneRenderObjects.delete(e2);
        }
        addOnRenderModeChangeObject(e2) {
          e2.onRenderModeChanged && this._onRenderModeChangedObjects.add(e2);
        }
        removeOnRenderModeChangeObject(e2) {
          e2.onRenderModeChanged && this._onRenderModeChangedObjects.delete(e2);
        }
        startRenderLoop() {
          this._isRunning = true, this._needsRenderImmediately = true, this._startTime = new Date().valueOf(), this.render();
        }
        stopRenderLoop() {
          this._isRunning = false;
        }
        updateCamera() {
          this._engine.map.updateCamera();
        }
        requestRender() {
          this._needsRenderImmediately = true;
        }
        renderScene(e2) {
          const t2 = this._engine;
          e2 || (e2 = new Date().valueOf()), this._uniforms.time.value = e2, this._uniforms.elapsedTime.value = e2 - this._startTime, this._uniforms.zoomUnits.value = this._engine.map.getZoomUnits(), this.camera._isLocked || this.updateCamera(), t2.event.executeMousemoveRaycast();
          const i2 = this._camera, n2 = this._scene, r2 = this._renderState;
          r2.beginFrame(this, e2), this._animation.update(r2);
          for (let u2 of this._beforeRenderListeners)
            u2(this._engine, r2);
          this._beforeScenePrepareRenderObjects.forEach((e3) => {
            e3.onBeforeScenePrepareRender(t2, n2, i2, r2);
          });
          const s2 = new Ae(i2.matrix.elements[12], i2.matrix.elements[13], i2.matrix.elements[14]);
          let a2 = 0, o2 = 0;
          const l2 = 1e3, h2 = Math.floor(s2.x / l2) * l2, c2 = Math.floor(s2.y / l2) * l2;
          a2 = s2.x - h2, o2 = s2.y - c2, this._autoOffsetRelativeCenter && (i2.position.set(a2, o2, s2.z), i2.updateMatrix(), i2.updateMatrixWorld(), n2.position.set(-h2, -c2, 0)), r2.updateCameraOffsetState(i2, h2, c2), n2.updateMatrix(), n2.updateMatrixWorld();
          this._renderer.info.reset(), this._collision.collisionTest(), this._beforeSceneRenderObjects.forEach((e3) => {
            e3.onBeforeSceneRender(t2, n2, i2, r2);
          }), this._renderer.extraProgramCacheKey = this._useMrt ? "1" : "0", this._main.render(), this._renderer.extraProgramCacheKey = "0", this._bloom.render(), this._ssr.render(), this._composition.render(), this._fog.render(), this._postprocessing.render(), this._autoOffsetRelativeCenter && (i2.position.set(s2.x, s2.y, s2.z), i2.updateMatrix(), i2.updateMatrixWorld(), n2.position.set(0, 0, 0), n2.updateMatrix(), n2.updateMatrixWorld()), r2.endFrame(this);
        }
        setResolution(e2) {
          this._resolution.copy(e2), this._uniforms.resolution.value.copy(e2), this._renderer.setSize(e2.x, e2.y), this._main.setSize(e2.x, e2.y), this._bloom.setSize(e2.x, e2.y), this._ssr.setSize(e2.x, e2.y), this._needsRenderNext = true;
        }
        dispose() {
          this.stopRenderLoop(), this._wireframeMaterial && this._wireframeMaterial.dispose();
          const e2 = Array.from(this.objectsScene.children), t2 = Array.from(this.environmentScene.children);
          for (const n2 of e2)
            this.remove(n2), n2.dispose && n2.dispose();
          for (const n2 of t2)
            this.remove(n2), n2.dispose && n2.dispose();
          this._renderer.dispose();
          let i2 = this._context.getExtension("WEBGL_lose_context");
          i2 && i2.loseContext();
        }
        get sky() {
          return this._sky;
        }
        get weather() {
          return this._weather;
        }
        get debugShaderType() {
          return this._debugShaderType;
        }
        set debugShaderType(e2) {
          if (this._debugShaderType = e2, !this._useMrt)
            return;
          e2 = parseInt(e2, 10);
          const t2 = this._composition;
          if (e2 && 0 !== e2)
            if (1 === e2)
              t2.debugTextures = this._main.getTextures();
            else if (2 === e2) {
              const e3 = [];
              this.objectsScene.traverse((t3) => {
                t3.isLight && t3.shadow && t3.shadow.map && e3.push(t3.shadow.map.texture);
              }), t2.debugTextures = e3;
            } else
              3 === e2 ? t2.debugTextures = this._bloom.getTextures() : 4 === e2 ? t2.debugTextures = this._ssr.getTextures() : 5 === e2 && this._sky && this._sky.getTextures && (t2.debugTextures = this._sky.getTextures());
          else
            t2.debugTextures = null;
        }
        get useMrt() {
          return this._useMrt;
        }
        set useMrt(e2) {
          this._useMrt !== e2 && (this._useMrt = e2, this._main.useMrt = e2, this._bloom.useMrt = e2, this._ssr.useMrt = e2, this._composition.useMrt = e2, this._postprocessing.useMrt = e2, this._needsUpdateExtraProgramCacheKey = true, this._onRenderModeChangedObjects.forEach((t2) => {
            t2.onRenderModeChanged && t2.onRenderModeChanged(e2);
          }));
        }
        get main() {
          return this._main;
        }
        get shadow() {
          return this._shadow;
        }
        get bloom() {
          return this._bloom;
        }
        get ssr() {
          return this._ssr;
        }
        get composition() {
          return this._composition;
        }
        get fog() {
          return this._fog;
        }
        get postprocessing() {
          return this._postprocessing;
        }
        get label() {
          return this._label;
        }
        get colorAdjust() {
          return this._colorAdjust;
        }
        get renderState() {
          return this._renderState;
        }
        get collision() {
          return this._collision;
        }
        get animation() {
          return this._animation;
        }
        get enableAnimationLoop() {
          return this._enableAnimationLoop;
        }
        set enableAnimationLoop(e2) {
          this._enableAnimationLoop = e2;
        }
        get animationLoopFrameTime() {
          return this._animationLoopFrameTime;
        }
        set animationLoopFrameTime(e2) {
          this._animationLoopFrameTime = e2;
        }
        get resolution() {
          return this._resolution;
        }
        set resolution(e2) {
          this._resolution = e2;
        }
        get pixelRatio() {
          return this._pixelRatio;
        }
        set pixelRatio(e2) {
          this._pixelRatio = e2;
        }
        get outputEncoding() {
          return this._outputEncoding;
        }
        set outputEncoding(e2) {
          this._outputEncoding = e2;
        }
        get canvas() {
          return this._canvas;
        }
        get renderer() {
          return this._renderer;
        }
        get camera() {
          return this._camera;
        }
        get scene() {
          return this._scene;
        }
        get uniforms() {
          return this._uniforms;
        }
        set wireframe(e2) {
          e2 ? (this._wireframe = true, this._wireframeMaterial || (this._wireframeMaterial = new jt({ color: 35071, wireframe: true })), this._scene.overrideMaterial = this._wireframeMaterial) : (this._wireframe = false, this._scene.overrideMaterial = null);
        }
        get wireframe() {
          return this._wireframe;
        }
        get autoOffsetRelativeCenter() {
          return this._autoOffsetRelativeCenter;
        }
        set autoOffsetRelativeCenter(e2) {
          this._autoOffsetRelativeCenter = e2;
        }
      }
      class Zc extends class {
        constructor() {
          __publicField(this, "isFlowEvent", true);
        }
        execute() {
        }
      } {
        constructor(e2, t2 = 0) {
          super(), __publicField(this, "_currentIndex", 0), __publicField(this, "_callbacks", []), t2 > e2.length - 1 && (t2 = e2.length - 1), t2 < 0 && (t2 = 0), this._currentIndex = t2, Array.isArray(e2) ? this._callbacks = e2 : console.warn("callbacks must be an array");
        }
        execute(e2) {
          const t2 = this._callbacks[this._currentIndex];
          t2 && t2(e2, this._currentIndex), this._currentIndex++, this._currentIndex > this._callbacks.length - 1 && (this._currentIndex = 0);
        }
      }
      const Jc = class {
        constructor(e2) {
          __publicField(this, "_realtimePickEnabled", false), __publicField(this, "_mousePickNeedsUpdate", false), __publicField(this, "_mouse", new ie()), __publicField(this, "_mousePosition", new ie()), __publicField(this, "_eventMaps", {}), __publicField(this, "_objectEvents", /* @__PURE__ */ new Map()), __publicField(this, "_raycaster", new Ro()), __publicField(this, "_mapPlane", new Ni(new Ae(0, 0, 1), 0)), __publicField(this, "_tempVector3", new Ae()), __publicField(this, "_intersections"), __publicField(this, "_defaultEventObject"), __publicField(this, "_mousePickParams", null), __publicField(this, "_lastMousePickIntersectParams", null), __publicField(this, "_engine", null), __publicField(this, "_pickEventNames", null), __publicField(this, "_checkShouldEnableRealtimePick", () => {
            let e3 = null;
            for (const t2 of Object.keys(this._eventMaps))
              if (this._pickEventNames[t2] && (e3 = this._eventMaps[t2], e3 && e3.size > 0))
                return void (this._realtimePickEnabled = true);
            this._realtimePickEnabled = false;
          }), __publicField(this, "_raycast", () => {
            const e3 = this._engine;
            this._raycaster.setFromCamera(this._mouse, e3.camera), this._raycaster.mouse.copy(this._mouse);
            const t2 = this._raycaster.intersectObjects(e3.rendering.objectsScene.children, true);
            this._intersections = t2;
          }), __publicField(this, "get3DTilesObject", (e3) => {
            for (; e3 && !e3.is3DTiles; )
              e3 = e3.parent;
            return e3;
          }), __publicField(this, "get3DTilesPropertiesByBatchId", (e3, t2) => {
            let i2 = e3;
            for (; !i2.batchTable; )
              i2 = i2.parent;
            if (!i2)
              return void console.warn("batch table not found");
            const n2 = i2.batchTable, r2 = {};
            for (const s2 of Object.keys(n2.header)) {
              const e4 = n2.header[s2];
              r2[s2] = e4[t2];
            }
            return r2._tileUri = i2._tileUri, r2.tile = i2, r2;
          }), __publicField(this, "triggerFirstEventObject", (e3, t2) => {
            if (!this._intersections || 0 === this._intersections.length)
              return false;
            if (!this._eventMaps[e3])
              return false;
            const i2 = this._eventMaps[e3];
            for (let n2 = 0, r2 = this._intersections.length; n2 < r2; ++n2) {
              const e4 = this._intersections[n2], r3 = e4.object;
              if (!r3.visible)
                continue;
              let s2 = this._getEventProxyObject(r3);
              if (!s2.visible)
                continue;
              const a2 = r3.geometry ? r3.geometry.getAttribute("_batchid") : void 0;
              let o2 = false, l2 = false, h2 = null;
              if (a2) {
                const e5 = this.get3DTilesObject(r3);
                e5 && (s2 = e5, o2 = true);
              } else {
                const e5 = this.get3DTilesObject(r3);
                e5 && (l2 = true, h2 = s2, s2 = e5);
              }
              if (i2.has(s2)) {
                if (t2.object = s2, e4.point && this._correctHitPosition(e4.point, t2), o2) {
                  const i3 = a2.getX(e4.face.a);
                  t2.entity = this.get3DTilesPropertiesByBatchId(r3, i3);
                  if (!this.get3DTilesObject(r3).isEntityVisible(t2.entity))
                    continue;
                } else if (l2) {
                  if (h2.isEventEntitySupported) {
                    t2.entity = this._getEventEntity(h2, e4);
                    if (!this.get3DTilesObject(r3).isEntityVisible(t2.entity))
                      continue;
                  }
                } else
                  s2.isEventEntitySupported && (t2.entity = this._getEventEntity(s2, e4));
                t2.directObject = r3;
                const n3 = i2.get(s2);
                return this._executeCallbacks(n3, t2), true;
              }
            }
            return false;
          }), __publicField(this, "_getEventEntity", (e3, t2) => {
            let i2 = -1;
            return void 0 !== t2.instanceId ? i2 = t2.instanceId : void 0 !== t2.face && null !== t2.face ? e3.getEntityIndexByFace && (i2 = e3.getEntityIndexByFace(t2.faceIndex, t2.face.a)) : void 0 !== t2.index && (i2 = t2.index), i2 < 0 ? null : e3.getEntityByIndex(i2);
          }), __publicField(this, "_getEventProxyObject", (e3) => {
            for (; e3.__eventProxyObject || e3.__eventProxyByParent; )
              e3 = e3.__eventProxyByParent ? e3.parent : e3.__eventProxyObject;
            return e3;
          }), __publicField(this, "_correctHitPosition", (e3, t2) => {
            const i2 = [e3.x, e3.y, e3.z], n2 = this._engine.map._map.normalizeEarthPointArr(i2);
            n2[2] = i2[2], t2.point = n2, t2.position = i2;
          }), __publicField(this, "_handleClick", (e3) => {
            if (this._updateMouse(e3), this._raycast(), this.triggerFirstEventObject(Jc.EVENT_NAME_CLICK, e3) && (e3.event.defaultPrevented || e3.event.domEvent && e3.event.domEvent.defaultPrevented))
              return;
            const t2 = this._eventMaps.click && this._eventMaps.click.get(this._defaultEventObject);
            t2 && this._executeCallbacks(t2, e3);
          }), __publicField(this, "_handleDblClick", (e3) => {
            if (this._updateMouse(e3), this._raycast(), this.triggerFirstEventObject(Jc.EVENT_NAME_DOUBLE_CLICK, e3) && (e3.event.defaultPrevented || e3.event.domEvent && e3.event.domEvent.defaultPrevented))
              return;
            const t2 = this._eventMaps.dblclick && this._eventMaps.dblclick.get(this._defaultEventObject);
            t2 && this._executeCallbacks(t2, e3);
          }), __publicField(this, "_handleRightClick", (e3) => {
            if (this._updateMouse(e3), this._raycast(), this.triggerFirstEventObject(Jc.EVENT_NAME_RIGHT_CLICK, e3) && (e3.event.defaultPrevented || e3.event.domEvent && e3.event.domEvent.defaultPrevented))
              return;
            const t2 = this._eventMaps.rightclick && this._eventMaps.rightclick.get(this._defaultEventObject);
            t2 && this._executeCallbacks(t2, e3);
          }), __publicField(this, "_handleRightDblClick", (e3) => {
            if (this._updateMouse(e3), this._raycast(), this.triggerFirstEventObject(Jc.EVENT_NAME_RIGHT_DOUBLE_CLICK, e3) && (e3.event.defaultPrevented || e3.event.domEvent && e3.event.domEvent.defaultPrevented))
              return;
            const t2 = this._eventMaps.rightdblclick && this._eventMaps.rightdblclick.get(this._defaultEventObject);
            t2 && this._executeCallbacks(t2, e3);
          }), __publicField(this, "_updateMouse", (e3) => {
            const t2 = this._engine.map.getResolution(), i2 = e3.pixel[0] / t2.x, n2 = e3.pixel[1] / t2.y;
            this._mouse.set(2 * i2 - 1, 1 - 2 * n2), this._mousePosition.set(e3.pixel[0], e3.pixel[1]);
          }), __publicField(this, "_triggerMouseleaveEvent", () => {
            const e3 = this._lastMousePickIntersectParams, t2 = e3.object;
            if (!t2)
              return;
            const i2 = this._objectEvents.get(t2);
            i2 && i2[Jc.EVENT_NAME_MOUSE_LEAVE] && this._executeCallbacks(i2[Jc.EVENT_NAME_MOUSE_LEAVE], { ...this._mousePickParams, object: e3.object, entity: e3.entity });
          }), __publicField(this, "_isSameObjectAndEntity", (e3, t2) => {
            const i2 = e3.object, n2 = t2.object, r2 = e3.entity, s2 = t2.entity;
            return i2 === n2 && (void 0 === r2 && void 0 === s2 || void 0 !== r2 && void 0 !== s2 && (void 0 === r2.index || r2.index === s2.index));
          }), __publicField(this, "_getMouseHoverIntersetion", () => {
            if (!this._intersections || 0 === this._intersections.length)
              return false;
            const e3 = this._mousePickParams;
            for (let t2 = 0, i2 = this._intersections.length; t2 < i2; ++t2) {
              const i3 = this._intersections[t2], n2 = i3.object;
              if (!n2.visible)
                continue;
              let r2 = this._getEventProxyObject(n2);
              if (!r2.visible)
                continue;
              const s2 = n2.geometry.getAttribute("_batchid");
              let a2 = false;
              if (s2) {
                const e4 = this.get3DTilesObject(n2);
                e4 && (r2 = e4, a2 = true);
              } else {
                const e4 = this.get3DTilesObject(n2);
                e4 && (r2 = e4);
              }
              let o2 = null;
              if (this._objectEvents.has(r2) && (o2 = this._objectEvents.get(r2)), o2 && (o2[Jc.EVENT_NAME_MOUSE_MOVE] || o2[Jc.EVENT_NAME_MOUSE_ENTER] || o2[Jc.EVENT_NAME_MOUSE_LEAVE])) {
                if (e3.object = r2, i3.point && this._correctHitPosition(i3.point, e3), a2) {
                  const t3 = s2.getX(i3.face.a);
                  e3.entity = this.get3DTilesPropertiesByBatchId(n2, t3);
                } else
                  r2.isEventEntitySupported && (e3.entity = this._getEventEntity(r2, i3));
                return o2;
              }
            }
          }), this._engine = e2, this._defaultEventObject = {}, this._raycaster.mouse = new ie(), this._pickEventNames = { [Jc.EVENT_NAME_MOUSE_MOVE]: true, [Jc.EVENT_NAME_MOUSE_ENTER]: true, [Jc.EVENT_NAME_MOUSE_LEAVE]: true };
        }
        bind(e2, t2, i2) {
          "string" == typeof e2 && (i2 = t2, t2 = e2, e2 = this._defaultEventObject), this._eventMaps[t2] || (this._eventMaps[t2] = /* @__PURE__ */ new Map());
          const n2 = this._eventMaps[t2];
          n2.has(e2) || n2.set(e2, []);
          const r2 = n2.get(e2);
          -1 === r2.indexOf(i2) && r2.push(i2), this._objectEvents.has(e2) || this._objectEvents.set(e2, {});
          const s2 = this._objectEvents.get(e2);
          s2[t2] || (s2[t2] = r2), this._checkShouldEnableRealtimePick();
        }
        unbind(e2, t2, i2) {
          "string" == typeof e2 && (i2 = t2, t2 = e2, e2 = this._defaultEventObject);
          const n2 = this._eventMaps[t2];
          let r2 = false;
          if (n2 && n2.has(e2)) {
            const t3 = n2.get(e2), s2 = t3.indexOf(i2);
            s2 > -1 && t3.splice(s2, 1), 0 === t3.length && (n2.delete(e2), r2 = true);
          }
          if (r2) {
            const i3 = this._objectEvents.get(e2);
            i3 && delete i3[t2];
          }
          this._checkShouldEnableRealtimePick();
        }
        markEventProxy(e2, t2) {
          const i2 = t2 || e2;
          if (e2.children)
            for (let n2 = 0, r2 = e2.children.length; n2 < r2; n2++)
              e2.children[n2].__eventProxyObject = i2, this.markEventProxy(e2.children[n2]);
        }
        createMultipleToggleEvent(e2, t2 = 0) {
          return new Zc(e2, t2);
        }
        _executeCallbacks(e2, t2) {
          for (const i2 of e2)
            if (i2) {
              if (t2.event && (t2.event.defaultPrevented || t2.event.domEvent && t2.event.domEvent.defaultPrevented))
                return;
              i2.isFlowEvent ? i2.execute(t2) : i2(t2);
            }
        }
        requestMousemoveRaycast(e2) {
          if (!this._realtimePickEnabled)
            return;
          this._updateMouse(e2), this._mousePickParams = e2, this._mousePickNeedsUpdate = true;
          const t2 = this._eventMaps.mousemove && this._eventMaps.mousemove.get(this._defaultEventObject);
          if (t2) {
            this._raycaster.setFromCamera(this._mouse, this._engine.rendering.camera), this._raycaster.ray.intersectPlane(this._mapPlane, this._tempVector3);
            const i2 = [this._tempVector3.x, this._tempVector3.y, this._tempVector3.z], n2 = this._engine.map._map.normalizeEarthPointArr(i2);
            this._executeCallbacks(t2, { ...e2, point: n2, position: i2 });
          }
          this._engine.requestRender();
        }
        executeMousemoveRaycast() {
          if (!this._mousePickNeedsUpdate)
            return;
          this._mousePickNeedsUpdate = false, this._raycast();
          const e2 = this._getMouseHoverIntersetion();
          if (e2) {
            if (this._executeCallbacks(e2[Jc.EVENT_NAME_MOUSE_MOVE], this._mousePickParams), this._lastMousePickIntersectParams && this._isSameObjectAndEntity(this._mousePickParams, this._lastMousePickIntersectParams))
              return void (this._lastMousePickIntersectParams = this._mousePickParams);
            this._lastMousePickIntersectParams && this._triggerMouseleaveEvent(), this._executeCallbacks(e2[Jc.EVENT_NAME_MOUSE_ENTER], this._mousePickParams), this._lastMousePickIntersectParams = this._mousePickParams;
          } else
            this._lastMousePickIntersectParams && this._triggerMouseleaveEvent(), this._lastMousePickIntersectParams = null;
        }
        dispose() {
        }
      };
      let Kc = Jc;
      __publicField(Kc, "EVENT_NAME_CLICK", "click"), __publicField(Kc, "EVENT_NAME_DOUBLE_CLICK", "dblclick"), __publicField(Kc, "EVENT_NAME_RIGHT_CLICK", "rightclick"), __publicField(Kc, "EVENT_NAME_RIGHT_DOUBLE_CLICK", "rightdblclick"), __publicField(Kc, "EVENT_NAME_MOUSE_MOVE", "mousemove"), __publicField(Kc, "EVENT_NAME_MOUSE_ENTER", "mouseenter"), __publicField(Kc, "EVENT_NAME_MOUSE_LEAVE", "mouseleave"), __publicField(Kc, "EVENT_NAME_MOUSE_DOWN", "mousedown"), __publicField(Kc, "EVENT_NAME_MOUSE_UP", "mouseup");
      class Qc {
        init() {
        }
        parsePointToArr(e2) {
          if (!e2)
            return null;
          let t2 = [];
          if (Array.isArray(e2))
            for (let i2 of e2)
              t2.push(parseFloat(i2));
          else if ("string" == typeof e2) {
            const i2 = e2.split(",");
            for (let e3 = 0; e3 < i2.length; e3++)
              t2[e3] = parseFloat(i2[e3]);
          }
          return t2;
        }
        projectPointArr(e2, t2) {
        }
        projectGeoJSON(e2) {
          if (e2) {
            if ("FeatureCollection" === e2.type || e2.features) {
              const t2 = e2.features;
              for (const e3 of t2)
                this.projectGeoJSON(e3);
            } else if (Array.isArray(e2)) {
              const t2 = e2;
              for (const e3 of t2)
                this.projectGeoJSON(e3);
            } else if (("Feature" === e2.type || e2.geometry) && Array.isArray(e2.geometry.coordinates)) {
              if (e2.geometry[this.projectionCoordsName])
                return;
              const t2 = this.projectCoordinates(e2.geometry.coordinates);
              e2.geometry[this.projectionCoordsName] = t2;
            }
          }
        }
        projectCoordinates(e2) {
          if (Array.isArray(e2[0])) {
            const t2 = [];
            for (let i2 of e2)
              t2.push(this.projectCoordinates(i2));
            return t2;
          }
          if ("number" == typeof e2[0] || "string" == typeof e2[0])
            return this.projectPointArr(e2);
        }
        dispose() {
        }
      }
      const $c = 0, eu = 1, tu = 2, iu = new ie(), nu = new Ro(), ru = new Ni(new Ae(0, 0, 1), 0);
      new Ae();
      const su = new Ae(), au = new Ae(), ou = new Ae(), lu = new Ri();
      lu.fov = 35, new ie();
      class hu {
        constructor(e2) {
          __publicField(this, "map"), __publicField(this, "currentAction"), __publicField(this, "startX"), __publicField(this, "startY"), __publicField(this, "startCenterX"), __publicField(this, "startCenterY"), __publicField(this, "startPitch"), __publicField(this, "startHeading"), __publicField(this, "startZoom"), __publicField(this, "startZoomUnits"), __publicField(this, "startAtTop"), __publicField(this, "mapWidth"), __publicField(this, "mapHeight"), __publicField(this, "startCamera", new Ri()), __publicField(this, "startCenter", new Ae()), __publicField(this, "startNdc", new ie()), __publicField(this, "startPoint", new Ae()), __publicField(this, "startScaleX", 1), __publicField(this, "startScaleY", 1), __publicField(this, "startBoundX"), __publicField(this, "startBoundY"), __publicField(this, "_enabled", false), __publicField(this, "minPitch", 0), __publicField(this, "maxPitch", 89), __publicField(this, "zoomSpeed", 5e-3), __publicField(this, "headingSpeed", 0.4), __publicField(this, "pitchSpeed", 0.3), __publicField(this, "doubleClickTimer", null), __publicField(this, "clickInterval", 200), __publicField(this, "init", () => {
            const e3 = this.map.domContainer;
            e3.addEventListener("mousedown", this.handleMouseDown), e3.addEventListener("wheel", this.handleWheel), e3.addEventListener("contextmenu", this.handleContextMenu), e3.addEventListener("mousemove", this.handleMouseMove);
          }), __publicField(this, "handleMouseMove", (e3) => {
            this.currentAction === $c && this.onEventMouseMove && this.onEventMouseMove(e3);
          }), __publicField(this, "handleMouseDown", (e3) => {
            const [t2, i2] = this.map.getContainerSize();
            this.mapWidth = t2, this.mapHeight = i2;
            const n2 = this.map.domContainer.getBoundingClientRect();
            this.startBoundX = n2.left, this.startBoundY = n2.top, this.startScaleX = n2.width / t2, this.startScaleY = n2.height / i2;
            const r2 = (e3.clientX - this.startBoundX) / this.startScaleX, s2 = (e3.clientY - this.startBoundY) / this.startScaleY;
            if (0 === e3.button ? (this.startZoomUnits = this.map.getZoomUnitsByZoom(this.map.zoom), this.setPanStartState(r2, s2), this.currentAction = eu) : 2 === e3.button ? this.currentAction = tu : this.currentAction = $c, this.currentAction === $c)
              return;
            this.startX = r2, this.startY = s2;
            const a2 = this.map;
            this.startCenterX = a2.center[0], this.startCenterY = a2.center[1], this.startPitch = a2.pitch, this.startHeading = a2.heading, this.startZoom = a2.zoom, this.startAtTop = s2 < i2 / 2, document.addEventListener("mousemove", this.handleMouseDragging), document.addEventListener("mouseup", this.handleMouseUp);
          }), __publicField(this, "handleMouseDragging", (e3) => {
            if (this.currentAction === $c)
              return;
            this.hasMoved = true;
            const t2 = this.currentPixelX = (e3.clientX - this.startBoundX) / this.startScaleX, i2 = this.currentPixelY = (e3.clientY - this.startBoundY) / this.startScaleY;
            this.currentAction === eu ? this.handlePan(t2, i2) : this.currentAction === tu && this.handleRotate(t2, i2);
          }), __publicField(this, "handleMouseUp", (e3) => {
            this.currentAction = $c, document.removeEventListener("mousemove", this.handleMouseDragging), document.removeEventListener("mouseup", this.handleMouseUp), e3 && this.onEventClick && (this.hasMoved || this.onEventClick(e3)), e3 && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(e3), this.clearDoubleClickTimer()) : this.waitSecondClick = true), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
              this.clearDoubleClickTimer();
            }, this.clickInterval), this.hasMoved = false;
          }), __publicField(this, "clearDoubleClickTimer", () => {
            this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = false, this.doubleClickTimer = null;
          }), __publicField(this, "handleContextMenu", (e3) => {
            e3.preventDefault();
          }), __publicField(this, "handleWheel", (e3) => {
            e3.preventDefault(), e3.stopPropagation();
            const [t2, i2] = this.map.getContainerSize();
            this.mapWidth = t2, this.mapHeight = i2, this.handleZoom({ deltaX: e3.deltaX, deltaY: e3.deltaY, pixelX: e3.offsetX, pixelY: e3.offsetY });
          }), __publicField(this, "handlePan", (e3, t2) => {
            const i2 = this.map;
            this.getNdc(e3, t2, iu), this.ndcToPoint(iu, this.startCamera, ou), ou.distanceTo(this.startCamera.position) > 6e3 * i2.zoomUnits ? this.handleMouseUp() : (su.subVectors(this.startCenter, ou.sub(this.startPoint)), i2.center = [su.x, su.y], i2.updateView());
          }), __publicField(this, "setPanStartState", (e3, t2) => {
            const i2 = this.map;
            this.startCamera.copy(i2.camera), this.startCamera.updateMatrixWorld(), this.startCenter.set(i2.center[0], i2.center[1], 0), this.getNdc(e3, t2, this.startNdc), this.ndcToPoint(this.startNdc, i2.camera, this.startPoint);
          }), __publicField(this, "handleRotate", (e3, t2) => {
            const i2 = this.map;
            let n2 = e3 - this.startX;
            const r2 = t2 - this.startY;
            this.startAtTop || (n2 *= -1);
            let s2 = this.startHeading + n2 * this.headingSpeed;
            s2 = this.makeHeadingSafe(s2), i2.heading = s2;
            let a2 = this.startPitch + r2 * this.pitchSpeed;
            a2 = this.makePitchSafe(a2), i2.pitch = a2, i2.updateView();
          }), __publicField(this, "handleZoom", (e3) => {
            const t2 = this.map;
            let i2 = t2.zoom, n2 = i2 + e3.deltaY * this.zoomSpeed * -1;
            if (i2 === n2)
              return;
            if (n2 = this.makeZoomSafe(n2), n2 < t2.earthViewZoomMax)
              return this.map.zoom = n2, void this.map.updateView();
            let r2 = t2.center, s2 = t2.pitch, a2 = t2.heading;
            this.getNdc(e3.pixelX, e3.pixelY, iu), su.set(r2[0], r2[1], 0), this.ndcToPoint(iu, t2.camera, au), au.distanceTo(t2.camera.position) > 6e3 * t2.zoomUnits || (t2.computeMapCameraMatrix(lu, r2, n2, s2, a2), this.ndcToPoint(iu, lu, ou), su.sub(ou.sub(au)), this.map.center[0] = su.x, this.map.center[1] = su.y, this.map.zoom = n2, this.map.updateView());
          }), __publicField(this, "makeZoomSafe", (e3) => e3 > this.map.maxZoom ? this.map.maxZoom : e3 < this.map.minZoom ? this.map.minZoom : e3), __publicField(this, "makeHeadingSafe", (e3) => ((e3 %= 360) < 0 && (e3 += 360), e3)), __publicField(this, "makePitchSafe", (e3) => e3 < this.minPitch ? this.minPitch : e3 > this.maxPitch ? this.maxPitch : e3), __publicField(this, "dispose", () => {
            const e3 = this.map.domContainer;
            e3.removeEventListener("mousedown", this.handleMouseDown), e3.removeEventListener("wheel", this.handleWheel), e3.removeEventListener("contextmenu", this.handleContextMenu), document.removeEventListener("mousemove", this.handleMouseDragging), document.removeEventListener("mouseup", this.handleMouseUp), e3.removeEventListener("mousemove", this.handleMouseMove), this.clearDoubleClickTimer();
          }), this.map = e2, this.enabled = true, this.currentAction = $c;
        }
        set enabled(e2) {
          e2 !== this._enabled && (e2 ? this.init() : this.dispose(), this._enabled = e2);
        }
        ndcToPoint(e2, t2, i2) {
          nu.setFromCamera(e2, t2), nu.ray.intersectPlane(ru, i2);
        }
        getNdc(e2, t2, i2) {
          i2.x = e2 / this.mapWidth * 2 - 1, i2.y = 1 - t2 / this.mapHeight * 2;
        }
      }
      var cu = {}, uu = {}, du = {};
      !function(e2) {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = void 0;
        var t2 = 1;
        e2.default = function() {
          return "".concat(t2++);
        };
      }(du);
      var pu = {}, mu = {}, fu = {};
      !function(e2) {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.default = void 0;
        e2.default = function(e3) {
          var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 60, i2 = null;
          return function() {
            for (var n2 = this, r2 = arguments.length, s2 = new Array(r2), a2 = 0; a2 < r2; a2++)
              s2[a2] = arguments[a2];
            clearTimeout(i2), i2 = setTimeout(function() {
              e3.apply(n2, s2);
            }, t2);
          };
        };
      }(fu);
      var gu = {};
      Object.defineProperty(gu, "__esModule", { value: true }), gu.SensorTabIndex = gu.SensorClassName = gu.SizeSensorId = void 0;
      gu.SizeSensorId = "size-sensor-id";
      gu.SensorClassName = "size-sensor-object";
      gu.SensorTabIndex = "-1", Object.defineProperty(mu, "__esModule", { value: true }), mu.createSensor = void 0;
      var _u, vu = (_u = fu) && _u.__esModule ? _u : { default: _u }, xu = gu;
      mu.createSensor = function(e2) {
        var t2 = void 0, i2 = [], n2 = (0, vu.default)(function() {
          i2.forEach(function(t3) {
            t3(e2);
          });
        }), r2 = function() {
          t2 && t2.parentNode && (t2.contentDocument && t2.contentDocument.defaultView.removeEventListener("resize", n2), t2.parentNode.removeChild(t2), t2 = void 0, i2 = []);
        };
        return { element: e2, bind: function(r3) {
          t2 || (t2 = function() {
            "static" === getComputedStyle(e2).position && (e2.style.position = "relative");
            var t3 = document.createElement("object");
            return t3.onload = function() {
              t3.contentDocument.defaultView.addEventListener("resize", n2), n2();
            }, t3.style.display = "block", t3.style.position = "absolute", t3.style.top = "0", t3.style.left = "0", t3.style.height = "100%", t3.style.width = "100%", t3.style.overflow = "hidden", t3.style.pointerEvents = "none", t3.style.zIndex = "-1", t3.style.opacity = "0", t3.setAttribute("class", xu.SensorClassName), t3.setAttribute("tabindex", xu.SensorTabIndex), t3.type = "text/html", e2.appendChild(t3), t3.data = "about:blank", t3;
          }()), -1 === i2.indexOf(r3) && i2.push(r3);
        }, destroy: r2, unbind: function(e3) {
          var n3 = i2.indexOf(e3);
          -1 !== n3 && i2.splice(n3, 1), 0 === i2.length && t2 && r2();
        } };
      };
      var yu = {};
      Object.defineProperty(yu, "__esModule", { value: true }), yu.createSensor = void 0;
      var bu = function(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }(fu);
      yu.createSensor = function(e2) {
        var t2 = void 0, i2 = [], n2 = (0, bu.default)(function() {
          i2.forEach(function(t3) {
            t3(e2);
          });
        }), r2 = function() {
          t2.disconnect(), i2 = [], t2 = void 0;
        };
        return { element: e2, bind: function(r3) {
          var s2;
          t2 || ((s2 = new ResizeObserver(n2)).observe(e2), n2(), t2 = s2), -1 === i2.indexOf(r3) && i2.push(r3);
        }, destroy: r2, unbind: function(e3) {
          var n3 = i2.indexOf(e3);
          -1 !== n3 && i2.splice(n3, 1), 0 === i2.length && t2 && r2();
        } };
      }, Object.defineProperty(pu, "__esModule", { value: true }), pu.createSensor = void 0;
      var Mu = mu, Su = "undefined" != typeof ResizeObserver ? yu.createSensor : Mu.createSensor;
      pu.createSensor = Su, Object.defineProperty(uu, "__esModule", { value: true }), uu.removeSensor = uu.getSensor = void 0;
      var wu = function(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }(du), Tu = pu, Eu = gu;
      var Cu = {};
      uu.getSensor = function(e2) {
        var t2 = e2.getAttribute(Eu.SizeSensorId);
        if (t2 && Cu[t2])
          return Cu[t2];
        var i2 = (0, wu.default)();
        e2.setAttribute(Eu.SizeSensorId, i2);
        var n2 = (0, Tu.createSensor)(e2);
        return Cu[i2] = n2, n2;
      };
      uu.removeSensor = function(e2) {
        var t2 = e2.element.getAttribute(Eu.SizeSensorId);
        e2.element.removeAttribute(Eu.SizeSensorId), e2.destroy(), t2 && Cu[t2] && delete Cu[t2];
      }, Object.defineProperty(cu, "__esModule", { value: true }), cu.ver = Ru = cu.clear = Pu = cu.bind = void 0;
      var Au = uu, Pu = cu.bind = function(e2, t2) {
        var i2 = (0, Au.getSensor)(e2);
        return i2.bind(t2), function() {
          i2.unbind(t2);
        };
      }, Ru = cu.clear = function(e2) {
        var t2 = (0, Au.getSensor)(e2);
        (0, Au.removeSensor)(t2);
      };
      cu.ver = "1.0.1";
      const Lu = new Ro(), Iu = new Ni(new Ae(0, 0, 1), 0), Du = new Ae(), Fu = new st(), Ou = new Se();
      new ie(-1, -1);
      const Uu = new ie(-1, 0.9), zu = new ie(1, 0.9), Nu = new ie(1, -1), ku = new Ae();
      class Bu extends Qc {
        constructor(e2, t2, i2 = {}) {
          super(t2, i2), __publicField(this, "isBlankMap", true), __publicField(this, "MERCATOR_LENGTH", 200375083427892e-7), __publicField(this, "projectionCoordsName", "_web_mercator"), __publicField(this, "origin", [0, 0]), __publicField(this, "center", [0, 0]), __publicField(this, "zoom", 0), __publicField(this, "pitch", 0), __publicField(this, "heading", 0), __publicField(this, "bounds", [[-this.MERCATOR_LENGTH, -this.MERCATOR_LENGTH], [this.MERCATOR_LENGTH, this.MERCATOR_LENGTH]]), __publicField(this, "near", 0.1), __publicField(this, "_far", 38e3), __publicField(this, "fov", 35), __publicField(this, "handleViewChange", () => {
            this.onViewChanged && this.onViewChanged();
          }), __publicField(this, "handleMapResize", () => {
            this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
          }), __publicField(this, "handleEventClick", (e3) => {
            const t3 = this._engine, i3 = t3.event, n2 = t3.rendering.canvas.getBoundingClientRect(), r2 = e3.clientX - n2.left, s2 = e3.clientY - n2.top, a2 = r2 / n2.width * 2 - 1, o2 = 1 - 2 * s2 / n2.height;
            Lu.setFromCamera({ x: a2, y: o2 }, t3.rendering.camera), Lu.ray.intersectPlane(Iu, Du);
            const l2 = [r2, s2], h2 = [Du.x, Du.y, Du.z], c2 = this.normalizeEarthPointArr(h2);
            2 === e3.button ? i3._handleRightClick({ pixel: l2, point: c2, position: h2, event: e3 }) : i3._handleClick({ pixel: l2, point: c2, position: h2, event: e3 });
          }), __publicField(this, "handleEventDblClick", (e3) => {
            const t3 = this._engine, i3 = t3.event, n2 = t3.rendering.canvas.getBoundingClientRect(), r2 = e3.clientX - n2.left, s2 = e3.clientY - n2.top, a2 = r2 / n2.width * 2 - 1, o2 = 1 - 2 * s2 / n2.height;
            Lu.setFromCamera({ x: a2, y: o2 }, t3.rendering.camera), Lu.ray.intersectPlane(Iu, Du);
            const l2 = [r2, s2], h2 = [Du.x, Du.y, Du.z], c2 = this.normalizeEarthPointArr(h2);
            2 === e3.button ? i3._handleRightDblClick({ pixel: l2, point: c2, position: h2, event: e3 }) : i3._handleDblClick({ pixel: l2, point: c2, position: h2, event: e3 });
          }), __publicField(this, "handleEventMouseMove", (e3) => {
            this._engine.event.requestMousemoveRaycast({ pixel: this._getPixelFromEvent(e3), event: e3 });
          }), __publicField(this, "_getPixelFromEvent", (e3) => {
            const t3 = this._engine.rendering.canvas.getBoundingClientRect();
            return [e3.clientX - t3.left, e3.clientY - t3.top];
          }), this._engine = e2, this.domContainer = t2;
        }
        afterInit() {
          this.domContainer.appendChild(this.canvas), this.camera.matrixAutoUpdate = false, this.handleMapResize(), Pu(this.domContainer, this.handleMapResize), this.initControl();
        }
        initControl() {
          this.control = new hu(this), this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove;
        }
        getContainerSize() {
          return [this.domContainer.clientWidth, this.domContainer.clientHeight];
        }
        getResolution() {
          return new ie(this.domContainer.clientWidth, this.domContainer.clientHeight);
        }
        getCenter() {
          return this.normalizeEarthPointArr(this.center);
        }
        getZoom() {
          return this.zoom;
        }
        getPitch() {
          return this.pitch;
        }
        getZoomUnitsByZoom(e2) {
          return this.MERCATOR_LENGTH / 128 / Math.pow(2, e2);
        }
        getZoomByZoomUnits(e2) {
          return Math.log2(this.MERCATOR_LENGTH / 128 / e2);
        }
        getZoomUnits() {
          return this.getZoomUnitsByZoom(this.zoom);
        }
        getHeading() {
          return this.heading;
        }
        enableControl() {
          this.control.enabled = true;
        }
        disableControl() {
          this.control.enabled = false;
        }
        setCameraMatrix() {
          this.handleViewChange();
        }
        updateCamera() {
          this.computeMapCameraMatrix(this.camera, this.center, this.zoom, this.pitch, this.heading);
        }
        computeMapCameraMatrix(e2, t2, i2, n2, r2) {
          const [s2, a2] = this.getContainerSize();
          let o2 = this.zoomUnits = this.getZoomUnitsByZoom(i2);
          if (s2 * o2 > this.bounds[1][0] - this.bounds[0][0]) {
            let e3 = (this.bounds[1][0] - this.bounds[0][0]) / s2;
            o2 = this.zoomUnits = e3, this.zoom = this.getZoomByZoomUnits(e3);
          }
          if (a2 * o2 > this.bounds[1][1] - this.bounds[0][1]) {
            let e3 = (this.bounds[1][1] - this.bounds[0][1]) / a2;
            o2 = this.zoomUnits = e3, this.zoom = this.getZoomByZoomUnits(e3);
          }
          t2[0] - s2 / 2 * o2 < this.bounds[0][0] && (t2[0] = this.bounds[0][0] + s2 / 2 * o2), t2[0] + s2 / 2 * o2 > this.bounds[1][0] && (t2[0] = this.bounds[1][0] - s2 / 2 * o2), t2[1] - a2 / 2 * o2 < this.bounds[0][1] && (t2[1] = this.bounds[0][1] + a2 / 2 * o2), t2[1] + a2 / 2 * o2 > this.bounds[1][1] && (t2[1] = this.bounds[1][1] - a2 / 2 * o2), this.center = t2;
          const l2 = a2 / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * o2;
          this.cameraDistance = l2, e2.position.set(0, 0, 0), e2.quaternion.set(0, 0, 0, 1), e2.up.set(0, 0, 1), e2.translateX(t2[0]), e2.translateY(t2[1]), t2[2] && e2.translateZ(t2[2]), e2.rotateOnAxis(new Ae(0, 0, 1), r2 * Math.PI / 180), e2.rotateOnAxis(new Ae(1, 0, 0), n2 * Math.PI / 180), e2.translateZ(l2), e2.updateMatrix(), e2.updateMatrixWorld(), e2.aspect = s2 / a2;
          let h2 = o2;
          h2 < 1 && (h2 = 1), e2.near = this.near, e2.far = this._far * h2, e2.updateProjectionMatrix();
        }
        setCenter(e2) {
          const t2 = this.normalizeMapPoint(e2);
          t2 && (this.center = t2), this.setCameraMatrix();
        }
        setProjectionCenter(e2) {
          const t2 = this.normalizeEarthPointArr(e2);
          this.setCenter(t2);
        }
        setZoom(e2) {
          isNaN(e2) || (this.zoom = e2), this.setCameraMatrix();
        }
        setHeading(e2) {
          this.heading = e2, this.setCameraMatrix();
        }
        setPitch(e2) {
          this.pitch = e2, this.setCameraMatrix();
        }
        lookAt(e2, t2 = {}) {
          let i2 = [];
          e2.isVector3 ? e2.toArray(i2) : i2 = e2;
          const n2 = this.normalizeMapPoint(i2);
          n2 && (this.center = n2), void 0 !== t2.heading && (this.heading = t2.heading), void 0 !== t2.pitch && (this.pitch = t2.pitch), void 0 !== t2.zoom && (this.zoom = t2.zoom), this.setCameraMatrix();
        }
        setBounds(e2) {
          this.bounds = [this.projectPointArr(e2[0]), this.projectPointArr(e2[1])];
        }
        getBoundsOld() {
          const e2 = [], t2 = new ie(), i2 = te.mapLinear(te.clamp(Math.abs(90 - this.pitch), 0, 50), 0, 50, 0.1, 1);
          t2.set(-1, -1 * i2), Lu.setFromCamera(t2, this.camera), Lu.ray.intersectPlane(Iu, ku);
          const n2 = ku.x, r2 = ku.y;
          t2.set(-1, 1 * i2), Lu.setFromCamera(Uu, this.camera), Lu.ray.intersectPlane(Iu, ku);
          const s2 = ku.x, a2 = ku.y;
          t2.set(1, 1 * i2), Lu.setFromCamera(zu, this.camera), Lu.ray.intersectPlane(Iu, ku);
          const o2 = ku.x, l2 = ku.y;
          t2.set(1, -1 * i2), Lu.setFromCamera(Nu, this.camera), Lu.ray.intersectPlane(Iu, ku);
          const h2 = ku.x, c2 = ku.y;
          e2[0] = Math.min(n2, s2, o2, h2), e2[1] = Math.min(r2, a2, l2, c2), e2[2] = Math.max(n2, s2, o2, h2), e2[3] = Math.max(r2, a2, l2, c2);
          const u2 = this.normalizeEarthPointArr([e2[0], e2[1]]), d2 = this.normalizeEarthPointArr([e2[2], e2[3]]);
          return new Le(new Ae(u2[0], u2[1], 0), new Ae(d2[0], d2[1], 0));
        }
        getBoundsLarger() {
          const e2 = this.camera;
          Fu.multiplyMatrices(e2.matrixWorld, e2.projectionMatrixInverse);
          let t2 = 1 / 0, i2 = 1 / 0, n2 = -1 / 0, r2 = -1 / 0;
          [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]].forEach((e3) => {
            Ou.set(e3[0], e3[1], e3[2], 1), Ou.applyMatrix4(Fu), Ou.divideScalar(Ou.w), Ou.x < t2 && (t2 = Ou.x), Ou.x > n2 && (n2 = Ou.x), Ou.y < i2 && (i2 = Ou.y), Ou.y > r2 && (r2 = Ou.y);
          });
          const s2 = this.normalizeEarthPointArr([t2, i2]), a2 = this.normalizeEarthPointArr([n2, r2]);
          return new Le(new Ae(s2[0], s2[1], 0), new Ae(a2[0], a2[1], 0));
        }
        getBounds() {
          Lu.setFromCamera(new ie(), this.camera), Lu.ray.intersectPlane(Iu, Du);
          const e2 = Du.clone(), t2 = this.camera.position.distanceTo(Du), i2 = new Ae(2 * t2, 2 * t2), n2 = new Ae(), r2 = new Ae();
          return n2.subVectors(e2, i2), r2.addVectors(e2, i2), new Le(n2, r2);
        }
        normalizeMapPoint(e2) {
          return this.normalizeProjectionPointArr(e2);
        }
        normalizeProjectionPointArr(e2) {
          let t2 = this.parsePointToArr(e2), i2 = Xh(t2);
          return i2[0] -= this.origin[0], i2[1] -= this.origin[1], void 0 !== t2[2] && (i2[2] = t2[2]), i2;
        }
        normalizeEarthPointArr(e2) {
          let t2 = this.parsePointToArr(e2);
          t2[0] += this.origin[0], t2[1] += this.origin[1];
          let i2 = qh(t2);
          return void 0 !== t2[2] && (i2[2] = t2[2]), i2;
        }
        projectPointArr(e2, t2) {
          if (!e2)
            return t2;
          let i2 = null;
          return i2 = e2[0] > 180 || e2[1] > 90 ? [e2[0], e2[1]] : Xh(e2), void 0 !== e2[2] && (i2[2] = e2[2]), i2[0] -= this.origin[0], i2[1] -= this.origin[1], i2;
        }
        updateView() {
          this.setCameraMatrix();
        }
        getCameraDistance() {
          return this.cameraDistance;
        }
        getProjectionCenter() {
          return [this.center[0], this.center[1]];
        }
        dispose() {
          Ru(this.domContainer), this.domContainer.removeChild(this.canvas), this._engine.event, this.control.dispose(), super.dispose();
        }
        get far() {
          return this._far;
        }
        set far(e2) {
          this._far = e2;
        }
      }
      __publicField(Bu, "EARTH_RADIUS", 637e4);
      const Vu = 0, Gu = 1, Hu = 2, ju = new ie(), Wu = new Ro(), Xu = new Ni(new Ae(0, 0, 1), 0);
      new Ae(), new Ae(), new Ae();
      const qu = new Ae(), Yu = new Ri();
      new Ri(), Yu.fov = 35, new ie();
      class Zu {
        constructor(e2) {
          __publicField(this, "map"), __publicField(this, "currentAction"), __publicField(this, "startX"), __publicField(this, "startY"), __publicField(this, "startCenterX"), __publicField(this, "startCenterY"), __publicField(this, "startPitch"), __publicField(this, "startHeading"), __publicField(this, "startZoom"), __publicField(this, "startZoomUnits"), __publicField(this, "startAtTop"), __publicField(this, "mapWidth"), __publicField(this, "mapHeight"), __publicField(this, "startCamera", new Ri()), __publicField(this, "startCenter", new Ae()), __publicField(this, "startNdc", new ie()), __publicField(this, "startPoint", new Ae()), __publicField(this, "startScaleX", 1), __publicField(this, "startScaleY", 1), __publicField(this, "startBoundX"), __publicField(this, "startBoundY"), __publicField(this, "_enabled", false), __publicField(this, "minPitch", 0), __publicField(this, "maxPitch", 89), __publicField(this, "zoomSpeed", 5e-3), __publicField(this, "headingSpeed", 0.4), __publicField(this, "pitchSpeed", 0.3), __publicField(this, "doubleClickTimer", null), __publicField(this, "clickInterval", 200), __publicField(this, "_rotationMode", 1), __publicField(this, "init", () => {
            const e3 = this.map.domContainer;
            e3.addEventListener("mousedown", this.handleMouseDown), e3.addEventListener("wheel", this.handleWheel), e3.addEventListener("contextmenu", this.handleContextMenu), e3.addEventListener("mousemove", this.handleMouseMove), this.initCursorAnchor();
          }), __publicField(this, "initCursorAnchor", () => {
            const e3 = this.cursorAnchor = document.createElement("div");
            e3.style.position = "absolute", e3.style.width = "40px", e3.style.height = "40px", e3.style.backgroundColor = "rgba(255, 255, 255, 0.5)", e3.style.zIndex = 100, e3.style.pointerEvents = "none", e3.style.display = "none", this.map.domContainer.appendChild(e3);
          }), __publicField(this, "showCursorAnchor", (e3, t2) => {
            1 !== this._rotationMode && (this.cursorAnchor.style.left = e3 - 20 + "px", this.cursorAnchor.style.top = t2 - 20 + "px", this.cursorAnchor.style.display = "block");
          }), __publicField(this, "hideCursorAnchor", () => {
            this.cursorAnchor.style.display = "none";
          }), __publicField(this, "handleMouseMove", (e3) => {
            this.currentAction === Vu && this.onEventMouseMove && this.onEventMouseMove(e3);
          }), __publicField(this, "handleMouseDown", (e3) => {
            const t2 = this.map, [i2, n2] = this.map.getContainerSize();
            this.mapWidth = i2, this.mapHeight = n2;
            const r2 = this.map.domContainer.getBoundingClientRect();
            this.startBoundX = r2.left, this.startBoundY = r2.top, this.startScaleX = r2.width / i2, this.startScaleY = r2.height / n2;
            const s2 = (e3.clientX - this.startBoundX) / this.startScaleX, a2 = (e3.clientY - this.startBoundY) / this.startScaleY, o2 = new ie(s2 / i2 * 2 - 1, 1 - 2 * a2 / n2);
            if (0 === e3.button) {
              const e4 = t2._getFirstIntersectionPoint(o2);
              this.startCamera.copy(t2.camera), this.startCamera.updateMatrixWorld(), Xu.constant = -e4.z, this.startPoint.copy(e4), this.currentAction = Gu;
            } else if (2 === e3.button) {
              if (1 === this._rotationMode) {
                const e4 = t2.getProjectionCenter();
                this.startPoint.set(e4[0], e4[1], e4[2]);
                const i3 = t2.decomposeRotation();
                this.startHeading = i3.heading, this.startPitch = i3.pitch;
              } else {
                const e4 = t2._getFirstIntersectionPoint(o2);
                this.startCamera.copy(t2.camera), this.startCamera.updateMatrixWorld();
                const i3 = new Ae();
                i3.subVectors(e4, this.startCamera.position), i3.normalize(), this.startPoint.copy(e4);
                const n3 = t2.decomposeRotationFromDirection(i3);
                this.startHeading = n3.heading, this.startPitch = n3.pitch;
              }
              this.startDistance = t2.camera.position.distanceTo(this.startPoint), this.currentAction = Hu, this.showCursorAnchor(s2, a2);
            } else
              this.currentAction = Vu;
            this.currentAction !== Vu && (this.startX = s2, this.startY = a2, this.startAtTop = a2 < n2 / 2, document.addEventListener("mousemove", this.handleMouseDragging), document.addEventListener("mouseup", this.handleMouseUp));
          }), __publicField(this, "handleMouseDragging", (e3) => {
            if (this.currentAction === Vu)
              return;
            this.hasMoved = true;
            const t2 = this.currentPixelX = (e3.clientX - this.startBoundX) / this.startScaleX, i2 = this.currentPixelY = (e3.clientY - this.startBoundY) / this.startScaleY;
            this.currentAction === Gu ? (this.map.domContainer.style.cursor = "grabbing", this.handlePan(t2, i2)) : this.currentAction === Hu && (this.map.domContainer.style.cursor = "grabbing", this.handleRotate(t2, i2));
          }), __publicField(this, "handleMouseUp", (e3) => {
            this.currentAction = Vu, this.map.domContainer.style.cursor = "default", this.hideCursorAnchor(), document.removeEventListener("mousemove", this.handleMouseDragging), document.removeEventListener("mouseup", this.handleMouseUp), e3 && this.onEventClick && (this.hasMoved || this.onEventClick(e3)), e3 && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(e3), this.clearDoubleClickTimer()) : this.waitSecondClick = true), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
              this.clearDoubleClickTimer();
            }, this.clickInterval), this.hasMoved = false;
          }), __publicField(this, "clearDoubleClickTimer", () => {
            this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = false, this.doubleClickTimer = null;
          }), __publicField(this, "handleContextMenu", (e3) => {
            e3.preventDefault();
          }), __publicField(this, "handleWheel", (e3) => {
            e3.preventDefault(), e3.stopPropagation();
            const [t2, i2] = this.map.getContainerSize();
            this.mapWidth = t2, this.mapHeight = i2, this.handleZoom({ deltaX: e3.deltaX, deltaY: e3.deltaY, pixelX: e3.offsetX, pixelY: e3.offsetY });
          }), __publicField(this, "handlePan", (e3, t2) => {
            const i2 = this.map;
            this.getNdc(e3, t2, ju), this.ndcToPoint(ju, this.startCamera, qu), qu.distanceTo(i2.camera.position) > 0.8 * i2.camera.far ? this.handleMouseUp() : (qu.sub(this.startPoint), qu.subVectors(this.startCamera.position, qu), i2.camera.position.copy(qu), i2.center = [qu.x, qu.y], i2.updateView());
          }), __publicField(this, "handleRotate", (e3, t2) => {
            const i2 = this.map, n2 = i2.camera;
            let r2 = e3 - this.startX;
            const s2 = t2 - this.startY;
            this.startAtTop || (r2 *= -1);
            let a2 = this.startHeading + r2 * this.headingSpeed;
            a2 = this.makeHeadingSafe(a2);
            let o2 = this.startPitch + s2 * this.pitchSpeed;
            if (o2 = this.makePitchSafe(o2), 1 === this._rotationMode)
              i2._cameraLookAt(n2, this.startPoint, { heading: a2, pitch: o2, range: this.startDistance });
            else {
              i2._cameraLookAt(Yu, this.startPoint, { heading: a2, pitch: o2, range: 0.2 }), this.getNdc(this.startX, this.startY, ju), Wu.setFromCamera(ju, Yu);
              const e4 = Wu.ray.direction.clone();
              ju.set(0, 0), Wu.setFromCamera(ju, Yu);
              const t3 = Wu.ray.direction.clone();
              e4.angleTo(t3);
              const r3 = new Ae();
              r3.copy(e4), r3.normalize(), r3.multiplyScalar(this.startDistance), n2.position.copy(qu.copy(this.startPoint).sub(r3)), n2.quaternion.copy(Yu.quaternion);
            }
            i2.pitch = o2, i2.heading = a2, i2.updateView();
          }), __publicField(this, "handleZoom", (e3) => {
            const t2 = this.map, i2 = t2.camera, n2 = te.clamp(e3.deltaY * this.zoomSpeed * -1, -0.5, 0.5);
            this.getNdc(e3.pixelX, e3.pixelY, ju);
            const r2 = t2._getFirstIntersectionPoint(ju), s2 = i2.position.distanceTo(r2);
            if (s2 > 0.8 * i2.far)
              return void this.handleMouseUp();
            let a2 = n2 * te.clamp(s2, 0.5, 1e7);
            a2 + 0.2 > s2 ? (a2 = s2 - 0.2, t2.range = 0.2) : t2.range = s2 - a2;
            const o2 = new Ae();
            o2.subVectors(r2, i2.position), o2.normalize();
            const l2 = new Ae();
            l2.copy(o2).multiplyScalar(a2).add(i2.position), i2.position.copy(l2), t2.center = [l2.x, l2.y], t2.updateView();
          }), __publicField(this, "makeHeadingSafe", (e3) => ((e3 %= 360) < 0 && (e3 += 360), e3)), __publicField(this, "makePitchSafe", (e3) => e3 < this.minPitch ? this.minPitch : e3 > this.maxPitch ? this.maxPitch : e3), __publicField(this, "dispose", () => {
            const e3 = this.map.domContainer;
            e3.removeEventListener("mousedown", this.handleMouseDown), e3.removeEventListener("wheel", this.handleWheel), e3.removeEventListener("contextmenu", this.handleContextMenu), document.removeEventListener("mousemove", this.handleMouseDragging), document.removeEventListener("mouseup", this.handleMouseUp), e3.removeEventListener("mousemove", this.handleMouseMove), this.clearDoubleClickTimer(), this.cursorAnchor.remove();
          }), this.map = e2, this.enabled = true, this.currentAction = Vu;
        }
        set enabled(e2) {
          e2 !== this._enabled && (e2 ? this.init() : this.dispose(), this._enabled = e2);
        }
        ndcToPoint(e2, t2, i2) {
          Wu.setFromCamera(e2, t2), Wu.ray.intersectPlane(Xu, i2);
        }
        getNdc(e2, t2, i2) {
          i2.x = e2 / this.mapWidth * 2 - 1, i2.y = 1 - t2 / this.mapHeight * 2;
        }
      }
      const Ju = new Ae(0, 0, -1), Ku = new Ae(0, 1, 0), Qu = new Ro();
      Qu.mouse = new ie();
      const $u = new Ni(new Ae(0, 0, 1), 0), ed = new Ae();
      new st();
      class td extends Bu {
        constructor() {
          super(...arguments), __publicField(this, "isBlankMap3D", true), __publicField(this, "_viewStateDirty", true), __publicField(this, "range", 0.2), __publicField(this, "_getFirstIntersectionPoint", (e2) => {
            const t2 = this._engine;
            Qu.setFromCamera(e2, t2.camera), Qu.mouse.copy(e2);
            const i2 = Qu.intersectObjects(t2.rendering.objectsScene.children, true);
            let n2 = null;
            for (let r2 = 0, s2 = i2.length; r2 < s2; r2++)
              if (!i2[r2].object.isPoints && !i2[r2].object.collisionDisabled) {
                n2 = i2[r2];
                break;
              }
            return null !== n2 && n2.point ? n2.point : (Qu.ray.intersectPlane($u, ed), ed);
          });
        }
        initControl() {
          this.control = new Zu(this), this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove;
        }
        updateView() {
          this.handleViewChange();
        }
        getCenter() {
          return this.normalizeEarthPointArr(this.getProjectionCenter());
        }
        getProjectionCenter() {
          const e2 = new ie(), t2 = this._getFirstIntersectionPoint(e2);
          return [t2.x, t2.y, t2.z];
        }
        getPitch() {
          return this.pitch;
        }
        getHeading() {
          return this.heading;
        }
        getCalcRange() {
          const e2 = this.getProjectionCenter();
          return this.camera.position.distanceTo(ed.set(e2[0], e2[1], e2[2]));
        }
        getZoom() {
          return this.getZoomByZoomUnits(this.getZoomUnits());
        }
        getZoomUnits() {
          const [e2, t2] = this.getContainerSize();
          return this.getCameraDistance() * Math.tan(te.degToRad(this.fov / 2)) * 2 / t2;
        }
        getCameraDistance() {
          return this.range;
        }
        setCenter(e2) {
          this.setProjectionCenter(this.normalizeProjectionPointArr(e2));
        }
        setProjectionCenter(e2) {
          const t2 = this.decomposeRotation();
          this._cameraLookAt(this.camera, e2, { ...t2, height: this.camera.position.z }), this.center = e2, this.updateView();
        }
        setZoom(e2) {
          const t2 = this.decomposeRotation(), i2 = this.getProjectionCenter(), n2 = this.getZoomUnitsByZoom(e2), [r2, s2] = this.getContainerSize(), a2 = s2 / 2 * n2 / Math.tan(te.degToRad(this.fov / 2));
          this._cameraLookAt(this.camera, i2, { ...t2, range: 0.1 * a2, height: a2 }), this.zoom = e2, this.updateView();
        }
        setPitch(e2) {
          const t2 = this.decomposeRotation(), i2 = this.getProjectionCenter(), n2 = this.camera.position.distanceTo(ed.set(i2[0], i2[1], i2[2]));
          this._cameraLookAt(this.camera, i2, { heading: t2.heading, pitch: e2, range: n2 }), this.pitch = e2, this.updateView();
        }
        setHeading(e2) {
          const t2 = this.decomposeRotation(), i2 = this.getProjectionCenter(), n2 = this.camera.position.distanceTo(ed.set(i2[0], i2[1], i2[2]));
          this._cameraLookAt(this.camera, i2, { heading: e2, pitch: t2.pitch, range: n2 }), this.heading = e2, this.updateView();
        }
        lookAt(e2, t2 = {}) {
          let i2 = [];
          e2.isVector3 ? e2.toArray(i2) : i2 = e2;
          let n2 = this.normalizeProjectionPointArr(i2);
          const { heading: r2, pitch: s2, range: a2 } = t2;
          isNaN(r2) || (this.heading = r2), isNaN(s2) || (this.pitch = s2), isNaN(a2) || (this.range = a2), this._cameraLookAt(this.camera, n2, t2);
        }
        _cameraLookAt(e2, t2, i2) {
          const { heading: n2 = this.heading, pitch: r2 = this.pitch, range: s2, height: a2 } = i2, o2 = new Ce();
          o2.setFromAxisAngle(new Ae(0, 0, 1), n2 * Math.PI / 180);
          const l2 = new Ce();
          l2.setFromAxisAngle(new Ae(1, 0, 0), r2 * Math.PI / 180);
          const h2 = new Ce();
          h2.multiplyQuaternions(o2, l2);
          const c2 = new Ae(0, 0, -1);
          c2.applyQuaternion(h2), c2.negate();
          const u2 = new Ae();
          Array.isArray(t2) ? u2.set(t2[0], t2[1], t2[2] || 0) : t2.isVector3 && u2.copy(t2);
          const d2 = new Ae();
          isNaN(s2) || (d2.copy(c2), d2.multiplyScalar(s2), u2.add(d2)), e2.position.copy(u2), e2.quaternion.copy(h2), e2.updateMatrix(), e2.updateMatrixWorld();
        }
        offsetFromHeadingPitchRange(e2 = 0, t2 = 0, i2 = 0) {
          const n2 = new Ce();
          n2.setFromAxisAngle(new Ae(0, 0, 1), e2 * Math.PI / 180);
          const r2 = new Ce();
          r2.setFromAxisAngle(new Ae(1, 0, 0), t2 * Math.PI / 180);
          const s2 = new Ce();
          s2.multiplyQuaternions(n2, r2);
          const a2 = new Ae(0, 0, -1);
          a2.applyQuaternion(s2), a2.negate();
          const o2 = new Ae();
          return o2.copy(a2).multiplyScalar(i2), o2;
        }
        decomposeRotation() {
          const e2 = this.camera.quaternion, t2 = Ju.clone(), i2 = Ku.clone();
          return t2.applyQuaternion(e2), t2.clampScalar(-1, 1), i2.applyQuaternion(e2), this.decomposeRotationFromDirection(t2, i2);
        }
        decomposeRotationFromDirection(e2, t2) {
          const i2 = 180 - te.radToDeg(Math.acos(e2.z));
          let n2 = te.radToDeg(Math.atan2(e2.y, e2.x));
          return 0 === e2.x && 0 === e2.y && (n2 = te.radToDeg(Math.atan2(t2.y, t2.x))), n2 = (n2 - 90) % 360, { heading: n2, pitch: i2 };
        }
        updateCamera() {
          const e2 = this.camera;
          e2.updateMatrix(), e2.updateMatrixWorld();
          const [t2, i2] = this.getContainerSize();
          e2.aspect = t2 / i2, e2.near = this.near;
          let n2 = this.getZoomUnits();
          n2 < 0.5 && (n2 = 0.5), e2.far = this._far * n2 * 2, e2.updateProjectionMatrix();
        }
      }
      class id extends td {
        constructor() {
          super(...arguments), __publicField(this, "projectionCoordsName", "_bmap_mercator");
        }
        normalizeMapPoint(e2) {
          return this.normalizeEarthPointArr(e2) || [0, 0];
        }
        normalizeProjectionPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          if (t2 && t2[0] < 180 && t2[1] < 90) {
            const e3 = Yh.convertLL2MC({ lng: t2[0], lat: t2[1] });
            t2[0] = e3.lng, t2[1] = e3.lat;
          }
          return t2;
        }
        normalizeEarthPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          if (t2 && (t2[0] > 180 || t2[1] > 90)) {
            const e3 = Yh.convertMC2LL({ lng: t2[0], lat: t2[1] });
            t2[0] = e3.lng, t2[1] = e3.lat;
          }
          return t2;
        }
        projectPointArr(e2) {
          let t2 = [];
          if (e2[0] > 180 || e2[1] > 90)
            t2[0] = e2[0], t2[1] = e2[1];
          else {
            const i2 = Yh.convertLL2MC({ lng: e2[0], lat: e2[1] });
            t2[0] = i2.lng, t2[1] = i2.lat;
          }
          return void 0 !== e2[2] && (t2[2] = e2[2]), t2;
        }
      }
      var nd = 0.9996, rd = 669438e-8, sd = Math.pow(rd, 2), ad = Math.pow(rd, 3), od = rd / (1 - rd), ld = Math.sqrt(1 - rd), hd = (1 - ld) / (1 + ld), cd = Math.pow(hd, 2), ud = Math.pow(hd, 3), dd = Math.pow(hd, 4), pd = Math.pow(hd, 5), md = 1 - rd / 4 - 3 * sd / 64 - 5 * ad / 256, fd = 3 * rd / 8 + 3 * sd / 32 + 45 * ad / 1024, gd = 15 * sd / 256 + 45 * ad / 1024, _d = 35 * ad / 3072, vd = 1.5 * hd - 27 / 32 * ud + 269 / 512 * pd, xd = 21 / 16 * cd - 55 / 32 * dd, yd = 151 / 96 * ud - 417 / 128 * pd, bd = 1097 / 512 * dd, Md = 6378137;
      function Sd(e2) {
        return 6 * (e2 - 1) - 180 + 3;
      }
      function wd(e2) {
        return e2 / Math.PI * 180;
      }
      function Td(e2) {
        return e2 * Math.PI / 180;
      }
      class Ed extends td {
        constructor(e2, t2, i2 = {}) {
          super(e2, t2, i2), __publicField(this, "projectionCoordsName", "_utm"), this.zone = i2.utmZone || 50;
        }
        normalizeMapPoint(e2) {
          return this.normalizeEarthPointArr(e2) || [0, 0];
        }
        normalizeProjectionPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          if (t2 && t2[0] < 180 && t2[1] < 90) {
            const e3 = function(e4, t3) {
              const i2 = e4[0], n2 = e4[1];
              if (n2 > 84 || n2 < -80)
                throw new RangeError("latitude out of range (must be between 80 deg S and 84 deg N)");
              if (i2 > 180 || i2 < -180)
                throw new RangeError("longitude out of range (must be between 180 deg W and 180 deg E)");
              var r2 = Td(n2), s2 = Math.sin(r2), a2 = Math.cos(r2), o2 = Math.tan(r2), l2 = Math.pow(o2, 2), h2 = Math.pow(o2, 4), c2 = Td(i2), u2 = Td(Sd(t3)), d2 = Md / Math.sqrt(1 - rd * s2 * s2), p2 = od * a2 * a2, m2 = a2 * (c2 - u2), f2 = Math.pow(m2, 2), g2 = Math.pow(m2, 3), _2 = Math.pow(m2, 4), v2 = Math.pow(m2, 5), x2 = Math.pow(m2, 6), y2 = Md * (md * r2 - fd * Math.sin(2 * r2) + gd * Math.sin(4 * r2) - _d * Math.sin(6 * r2)), b2 = nd * (y2 + d2 * o2 * (f2 / 2 + _2 / 24 * (5 - l2 + 9 * p2 + 4 * p2 * p2) + x2 / 720 * (61 - 58 * l2 + h2 + 600 * p2 - 330 * od)));
              return n2 < 0 && (b2 += 1e7), [nd * d2 * (m2 + g2 / 6 * (1 - l2 + p2) + v2 / 120 * (5 - 18 * l2 + h2 + 72 * p2 - 58 * od)) + 5e5, b2];
            }(t2, this.zone);
            t2[0] = e3[0], t2[1] = e3[1];
          }
          return t2;
        }
        normalizeEarthPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          if (t2) {
            const e3 = function(e4, t3, i2) {
              let n2 = e4[0], r2 = e4[1];
              if (i2) {
                if (n2 < 1e5 || 1e6 <= n2)
                  throw new RangeError("easting out of range (must be between 100 000 m and 999 999 m)");
                if (r2 < 0 || r2 > 1e7)
                  throw new RangeError("northing out of range (must be between 0 m and 10 000 000 m)");
              }
              if (t3 < 1 || t3 > 60)
                throw new RangeError("zone number out of range (must be between 1 and 60)");
              var s2 = n2 - 5e5, a2 = r2 / nd / (Md * md), o2 = a2 + vd * Math.sin(2 * a2) + xd * Math.sin(4 * a2) + yd * Math.sin(6 * a2) + bd * Math.sin(8 * a2), l2 = Math.sin(o2), h2 = Math.pow(l2, 2), c2 = Math.cos(o2), u2 = Math.tan(o2), d2 = Math.pow(u2, 2), p2 = Math.pow(u2, 4), m2 = 1 - rd * h2, f2 = Math.sqrt(m2), g2 = (1 - rd) / m2, _2 = hd * c2 * c2, v2 = _2 * _2, x2 = s2 / (Md / f2 * nd), y2 = Math.pow(x2, 2), b2 = Math.pow(x2, 3), M2 = Math.pow(x2, 4), S2 = Math.pow(x2, 5), w2 = Math.pow(x2, 6), T2 = o2 - u2 / g2 * (y2 / 2 - M2 / 24 * (5 + 3 * d2 + 10 * _2 - 4 * v2 - 9 * od)) + w2 / 720 * (61 + 90 * d2 + 298 * _2 + 45 * p2 - 252 * od - 3 * v2);
              return [wd((x2 - b2 / 6 * (1 + 2 * d2 + _2) + S2 / 120 * (5 - 2 * _2 + 28 * d2 - 3 * v2 + 8 * od + 24 * p2)) / c2) + Sd(t3), wd(T2)];
            }(t2, this.zone);
            t2[0] = e3[0], t2[1] = e3[1];
          }
          return t2;
        }
        projectPointArr(e2) {
          return this.normalizeProjectionPointArr(e2);
        }
      }
      class Cd extends Qc {
        constructor(e2, t2, i2) {
          super(t2, i2), __publicField(this, "near", 0.1), __publicField(this, "_far", 4e3), __publicField(this, "fov", 35), __publicField(this, "projectionCoordsName", "_bmap_mercator"), __publicField(this, "handleMapUpdate", () => {
            this.onViewChanged && this.onViewChanged();
          }), __publicField(this, "handleMapResize", () => {
            this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
          }), __publicField(this, "handleEventClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.pixel.x, e3.pixel.y], n2 = [e3.latlng.lng, e3.latlng.lat], r2 = [e3.point.lng, e3.point.lat];
            t3._handleClick({ pixel: i3, point: n2, position: r2, event: e3 });
          }), __publicField(this, "handleEventRightClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.pixel.x, e3.pixel.y], n2 = [e3.latlng.lng, e3.latlng.lat], r2 = [e3.point.lng, e3.point.lat];
            t3._handleRightClick({ pixel: i3, point: n2, position: r2, event: e3 });
          }), __publicField(this, "handleEventDblClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.pixel.x, e3.pixel.y], n2 = [e3.latlng.lng, e3.latlng.lat], r2 = [e3.point.lng, e3.point.lat];
            t3._handleDblClick({ pixel: i3, point: n2, position: r2, event: e3 });
          }), __publicField(this, "handleEventRightDblClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.pixel.x, e3.pixel.y], n2 = [e3.latlng.lng, e3.latlng.lat], r2 = [e3.point.lng, e3.point.lat];
            t3._handleRightDblClick({ pixel: i3, point: n2, position: r2, event: e3 });
          }), this._engine = e2, this.map = t2;
        }
        getContainerSize() {
          const e2 = this.map.getSize();
          return [e2.width, e2.height];
        }
        getResolution() {
          const e2 = this.map.getSize();
          return new ie(e2.width, e2.height);
        }
        afterInit() {
          const e2 = this.map;
          this.canvas.style.zIndex = "3", e2.getContainer().appendChild(this.canvas), e2.addEventListener("update", this.handleMapUpdate), e2.addEventListener("resize", this.handleMapResize), e2.addEventListener("click", this.handleEventClick), e2.addEventListener("rightclick", this.handleEventRightClick), e2.addEventListener("dblclick", this.handleEventDblClick), e2.addEventListener("rightdblclick", this.handleEventRightDblClick), this.handleMapResize();
        }
        getCenter() {
          const e2 = this.map.getCenter();
          return [e2.lng, e2.lat];
        }
        getZoom() {
          return this.map.getZoom();
        }
        getZoomUnits() {
          return this.map.getZoomUnits();
        }
        getZoomByZoomUnits(e2) {
          return window.BMAPGL_84 ? Math.log2(this.MERCATOR_LENGTH / 128 / e2) : 18 - Math.log2(e2);
        }
        getZoomUnitsByZoom(e2) {
          return this.map.getZoomUnits(e2);
        }
        getHeading() {
          return this.map.getHeading();
        }
        getPitch() {
          return this.map.getTilt();
        }
        setCenter(e2) {
          this.map.setCenter(this.normalizeMapPoint(e2));
        }
        setProjectionCenter(e2) {
          const t2 = this.normalizeEarthPointArr(e2);
          this.setCenter(t2);
        }
        setZoom(e2) {
          this.map.setZoom(e2);
        }
        setPitch(e2) {
          this.map.setTilt(e2);
        }
        setHeading(e2) {
          this.map.setHeading(e2);
        }
        setBounds(e2) {
          let t2 = [this.projectPointArr(e2[0]), this.projectPointArr(e2[1])];
          this.map.setBounds(new BMapGL.Point(t2[0][0], t2[0][1]), new BMapGL.Point(t2[1][0], t2[1][1]));
        }
        getBounds() {
          this.map.getBounds();
        }
        enableControl() {
          this.map.enableDragging();
        }
        disableControl() {
          this.map.disableDragging();
        }
        updateCamera() {
          this.updateMatrixWorld(), this.updateProjectionMatrix();
        }
        updateMatrixWorld() {
          const e2 = this.map, t2 = this.camera, i2 = e2.getCenterIn(), n2 = [i2.lng, i2.lat], r2 = e2.getZoomUnits(), s2 = e2.getTilt(), a2 = e2.getHeading(), [o2, l2] = this.getContainerSize(), h2 = l2 / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * r2;
          this.cameraDistance = h2, t2.position.set(0, 0, 0), t2.quaternion.set(0, 0, 0, 1), t2.up.set(0, 1, 0), t2.translateX(n2[0]), t2.translateY(n2[1]), t2.rotateOnAxis(new Ae(0, 0, 1), a2 * Math.PI / 180), t2.rotateOnAxis(new Ae(1, 0, 0), s2 * Math.PI / 180), t2.translateZ(h2), t2.updateMatrix(), t2.updateMatrixWorld();
        }
        updateProjectionMatrix() {
          const e2 = this.camera, [t2, i2] = this.getContainerSize(), n2 = this.map.getZoomUnits();
          e2.aspect = t2 / i2, e2.near = 0.1, e2.far = this._far * n2, e2.far < 1e3 && (e2.far = 1e3), e2.updateProjectionMatrix();
        }
        normalizeMapPoint(e2) {
          const t2 = this.normalizeEarthPointArr(e2) || [0, 0];
          return new BMapGL.Point(t2[0], t2[1], t2[2]);
        }
        normalizeProjectionPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          return t2 && t2[0] < 180 && t2[1] < 90 ? this.map.lnglatToMercator(t2[0], t2[1]) : t2;
        }
        normalizeEarthPointArr(e2) {
          const t2 = this.parsePointToArr(e2);
          if (t2 && (t2[0] > 180 || t2[1] > 90)) {
            const e3 = this.map.mercatorToLnglat(t2[0], t2[1]);
            return void 0 !== t2[2] && (e3[2] = t2[2]), e3;
          }
          return t2;
        }
        projectPointArr(e2) {
          let t2 = [];
          return e2[0] > 180 || e2[1] > 90 ? (t2[0] = e2[0], t2[1] = e2[1]) : t2 = this.map.lnglatToMercator(e2[0], e2[1]), void 0 !== e2[2] && (t2[2] = e2[2]), t2;
        }
        getCameraDistance() {
          return this.cameraDistance;
        }
        getProjectionCenter() {
          const e2 = this.map.getCenterIn();
          return [e2.lng, e2.lat];
        }
        dispose() {
          const e2 = this.map;
          e2.getContainer().removeChild(this.canvas), e2.removeEventListener("update", this.handleMapUpdate), e2.removeEventListener("resize", this.handleMapResize), e2.removeEventListener("click", this.handleEventClick), super.dispose();
        }
        get far() {
          return this._far;
        }
        set far(e2) {
        }
      }
      class Ad extends Qc {
        constructor(e2, t2, i2) {
          super(t2, i2), __publicField(this, "MERCATOR_LENGTH", 200375083427892e-7), __publicField(this, "projectionCoordsName", "_web_mercator"), __publicField(this, "origin", [0, 0]), __publicField(this, "center", [0, 0]), __publicField(this, "pitch", 0), __publicField(this, "heading", 0), __publicField(this, "near", 0.1), __publicField(this, "_far", 8e3), __publicField(this, "fov", 35), __publicField(this, "cameraDistance", 1e3), __publicField(this, "handleEventClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.point.x, e3.point.y], n2 = [e3.lngLat.lng, e3.lngLat.lat], r2 = this.normalizeProjectionPointArr(n2);
            t3._handleClick({ pixel: i3, point: n2, position: r2, event: e3.originalEvent });
          }), __publicField(this, "handleEventDblClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.point.x, e3.point.y], n2 = [e3.lngLat.lng, e3.lngLat.lat], r2 = this.normalizeProjectionPointArr(n2);
            t3._handleDblClick({ pixel: i3, point: n2, position: r2, event: e3.originalEvent });
          }), __publicField(this, "handleEventRightClick", (e3) => {
            const t3 = this._engine.event, i3 = [e3.point.x, e3.point.y], n2 = [e3.lngLat.lng, e3.lngLat.lat], r2 = this.normalizeProjectionPointArr(n2);
            t3._handleRightClick({ pixel: i3, point: n2, position: r2, event: e3.originalEvent });
          }), __publicField(this, "handleMapResize", () => {
            this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
          }), this._engine = e2, this.map = t2, this.domContainer = t2._container;
        }
        afterInit() {
          this.canvas.style.pointerEvents = "none", this.domContainer.appendChild(this.canvas);
          const e2 = this.map;
          e2.on("render", (e3) => {
            this.onViewChanged && this.onViewChanged();
          }), e2.on("click", this.handleEventClick), e2.on("contextmenu", this.handleEventRightClick), e2.on("dblclick", this.handleEventDblClick), e2.on("resize", () => {
            this.handleMapResize();
          }), this.handleMapResize();
        }
        getContainerSize() {
          return [this.domContainer.clientWidth, this.domContainer.clientHeight];
        }
        getResolution() {
          return new ie(this.domContainer.clientWidth, this.domContainer.clientHeight);
        }
        setCenter(e2) {
          this.map.setCenter(e2);
        }
        setZoom(e2) {
          this.map.setZoom(e2);
        }
        setHeading(e2) {
          this.map.setBearing(e2);
        }
        setPitch(e2) {
          this.map.setPitch(e2);
        }
        getCenter() {
          const e2 = this.map.getCenter();
          return [e2.lng, e2.lat];
        }
        getZoom() {
          return this.map.getZoom();
        }
        getZoomUnitsByZoom(e2) {
          return this.MERCATOR_LENGTH / 256 / Math.pow(2, e2);
        }
        getZoomByZoomUnits(e2) {
          return Math.log2(this.MERCATOR_LENGTH / 256 / e2);
        }
        getZoomUnits() {
          return this.getZoomUnitsByZoom(this.map.getZoom());
        }
        getPitch() {
          return this.map.getPitch();
        }
        getHeading() {
          return this.map.getBearing();
        }
        enableControl() {
          this.map.dragPan.enable(), this.map.dragRotate.enable();
        }
        disableControl() {
          this.map.dragPan.disable(), this.map.dragRotate.disable();
        }
        flyTo(e2) {
        }
        updateCamera() {
          this.updateMatrixWorld(), this.updateProjectionMatrix();
        }
        updateMatrixWorld() {
          this.map;
          const e2 = this.camera, t2 = this.getCenter(), i2 = this.getZoomUnits(), n2 = this.getPitch(), r2 = this.getHeading(), [s2, a2] = this.getContainerSize(), o2 = this.normalizeProjectionPointArr(t2), l2 = a2 / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * i2;
          this.cameraDistance = l2, e2.position.set(0, 0, 0), e2.quaternion.set(0, 0, 0, 1), e2.up.set(0, 1, 0), e2.translateX(o2[0]), e2.translateY(o2[1]), e2.rotateOnAxis(new Ae(0, 0, -1), r2 * Math.PI / 180), e2.rotateOnAxis(new Ae(1, 0, 0), n2 * Math.PI / 180), e2.translateZ(l2), e2.updateMatrix();
        }
        updateProjectionMatrix() {
          const e2 = this.camera, t2 = this.getZoomUnits(), [i2, n2] = this.getContainerSize();
          e2.aspect = i2 / n2, e2.fov = this.fov, e2.near = this.near * t2, e2.far = this._far * t2, e2.updateProjectionMatrix();
        }
        normalizeMapPoint(e2) {
          return this.normalizeEarthPointArr(e2);
        }
        normalizeProjectionPointArr(e2) {
          let t2 = this.parsePointToArr(e2);
          return t2 = Xh(t2), t2[0] -= this.origin[0], t2[1] -= this.origin[1], t2;
        }
        normalizeEarthPointArr(e2) {
          let t2 = this.parsePointToArr(e2);
          t2[0] += this.origin[0], t2[1] += this.origin[1];
          let i2 = qh(t2);
          return void 0 !== t2[2] && (i2[2] = t2[2]), i2;
        }
        projectPointArr(e2, t2) {
          if (!e2)
            return t2;
          let i2 = null;
          return i2 = e2[0] > 180 || e2[1] > 90 ? [e2[0], e2[1]] : Xh(e2), void 0 !== e2[2] && (i2[2] = e2[2]), i2[0] -= this.origin[0], i2[1] -= this.origin[1], i2;
        }
        dispose() {
          Ru(this.domContainer), this.domContainer.removeChild(this.canvas), this._engine.event, super.dispose();
        }
        getProjectionCenter() {
          const e2 = this.map.getCenter();
          return this.normalizeProjectionPointArr(e2);
        }
        getCameraDistance() {
          return this.cameraDistance;
        }
        get far() {
          return this._far;
        }
        set far(e2) {
        }
      }
      __publicField(Ad, "EARTH_RADIUS", 637e4);
      class Pd {
        constructor(e2, t2 = {}) {
          __publicField(this, "_engine"), __publicField(this, "_map"), __publicField(this, "_container"), __publicField(this, "_mapType"), __publicField(this, "handleViewChange", () => {
            this._engine.rendering.requestRender();
          }), __publicField(this, "handleResolutionChange", (e3) => {
            this._engine.rendering.setResolution(e3);
          }), this._engine = e2;
          const i2 = e2.container, n2 = t2.coordType;
          if (i2 instanceof HTMLElement ? "ecef" === n2 || ("bd09" === n2 ? (this._map = new id(e2, i2, t2), this._container = i2, this._mapType = "blank_bd09") : "utm" === n2 ? (this._map = new Ed(e2, i2, t2), this._container = i2, this._mapType = "blank_utm") : t2.is3DControl ? (this._map = new td(e2, i2, t2), this._container = i2, this._mapType = "blank_3dcontrol") : (this._map = new Bu(e2, i2, t2), this._container = i2, this._mapType = "blank")) : window.BMapGL && i2 instanceof BMapGL.Map ? (this._map = new Cd(e2, i2, t2), this._container = i2.container, this._mapType = "bmapgl") : i2._mapId && (this._map = new Ad(e2, i2, t2), this._container = i2._container, this._mapType = "mapbox"), !this._map)
            throw new Error("map is invalid");
        }
        init() {
          this._map.init(), this._map.onViewChanged = this.handleViewChange, this._map.onResolutionChanged = this.handleResolutionChange;
        }
        afterInit() {
          const e2 = this._engine, t2 = this._map;
          t2.canvas = e2.rendering.canvas, t2.camera = e2.rendering.camera, t2.afterInit();
        }
        setCenter(e2) {
          this._map.setCenter(e2);
        }
        setZoom(e2) {
          this._map.setZoom(e2);
        }
        setHeading(e2) {
          this._map.setHeading(e2);
        }
        setPitch(e2) {
          this._map.setPitch(e2);
        }
        setBounds(e2) {
          this._map.setBounds(e2);
        }
        lookAt(e2, t2 = {}) {
          this._map.lookAt(e2, t2);
        }
        getBoundingBox() {
          return this._map.getBounds();
        }
        getCenter() {
          return this._map.getCenter();
        }
        getZoom() {
          return this._map.getZoom();
        }
        getZoomUnits() {
          return this._map.getZoomUnits();
        }
        getZoomByZoomUnits(e2) {
          return this._map.getZoomByZoomUnits(e2);
        }
        getZoomUnitsByZoom(e2) {
          return this._map.getZoomUnitsByZoom(e2);
        }
        getHeading() {
          return this._map.getHeading();
        }
        getPitch() {
          return this._map.getPitch();
        }
        getProjectionCenter() {
          return this._map.getProjectionCenter();
        }
        getCameraDistance() {
          return this._map.getCameraDistance();
        }
        getResolution() {
          return this._map.getResolution();
        }
        projectPointArr(e2) {
          return this._map.projectPointArr(e2);
        }
        unprojectPointArr(e2) {
          return this._map.normalizeEarthPointArr(e2);
        }
        projectCoordinates(e2) {
          return this._map.projectCoordinates(e2);
        }
        enableControl() {
          this._map.enableControl();
        }
        disableControl() {
          this._map.disableControl();
        }
        updateCamera() {
          this._map.updateCamera();
        }
        getScaleAt(e2) {
          return 1 / Math.cos(Math.PI * e2[1] / 180);
        }
        zoomTo(e2) {
          let t2 = null;
          if (e2.is3DTiles)
            t2 = e2.getBounds();
          else if (e2.isMesh) {
            const i3 = e2.geometry;
            t2 = i3.boundingBox, t2 || (i3.computeBoundingBox(), t2 = i3.boundingBox), t2 = t2.clone(), t2.applyMatrix4(e2.matrixWorld);
          }
          if (!t2)
            return;
          const i2 = this.getResolution(), n2 = (t2.max.x - t2.min.x) / i2.x, r2 = (t2.max.y - t2.min.y) / i2.y, s2 = Math.max(n2, r2), a2 = this._map.getZoomByZoomUnits(s2), o2 = [(t2.max.x + t2.min.x) / 2, (t2.max.y + t2.min.y) / 2, (t2.max.z + t2.min.z) / 2];
          if (this._map.isBlankMap3D) {
            let e3 = Math.max(t2.max.x - t2.min.x, t2.max.y - t2.min.y) / Math.tan(this.fov / 2 * Math.PI / 180);
            this._map._cameraLookAt(this._map.camera, o2, { range: e3 });
          } else
            this._map.setProjectionCenter(o2), this._map.setZoom(a2);
        }
        dispose() {
          this._map.dispose();
        }
        set onResolutionChanged(e2) {
          this._map.onResolutionChanged = e2;
        }
        get projectionCoordsName() {
          return this._map.projectionCoordsName;
        }
        get map() {
          return this._map;
        }
        get mapType() {
          return this._mapType;
        }
        get container() {
          return this._container;
        }
        get fov() {
          return this._map.fov;
        }
        get near() {
          return this._map.near;
        }
        get far() {
          return this._map.far;
        }
      }
      class Rd extends Rt {
        constructor() {
          super(), __publicField(this, "_boxGeometry"), __publicField(this, "_boxMesh"), this._boxMaterial = new jt({ transparent: true, color: 16711680, opacity: 0.3 });
        }
        attach(e2) {
          this._object = e2;
          const t2 = e2.geometry;
          t2.boundingBox || t2.computeBoundingBox(), this._boxGeometry && this._boxGeometry.dispose();
          const i2 = t2.boundingBox;
          if (this._boxGeometry = new wi(i2.max.x - i2.min.x, i2.max.y - i2.min.y, i2.max.z - i2.min.z), this._boxMesh)
            this._boxMesh.geometry = this._boxGeometry;
          else {
            const e3 = this._boxMesh = new Mi(this._boxGeometry, this._boxMaterial);
            this.add(e3);
          }
        }
        detach() {
          this._object = null, this.remove(this._boxMesh), this._boxMesh = null;
        }
        onBeforeScenePrepareRender() {
          if (this._object) {
            this._object.updateMatrixWorld();
            const e2 = this._boxMesh;
            this._object.matrixWorld.decompose(e2.position, e2.rotation, e2.scale);
          }
        }
      }
      const Ld = new Ro(), Id = new Ae(), Dd = new Ae(), Fd = new Ce(), Od = { X: new Ae(1, 0, 0), Y: new Ae(0, 1, 0), Z: new Ae(0, 0, 1) }, Ud = { type: "change" }, zd = { type: "mouseDown" }, Nd = { type: "mouseUp", mode: null }, kd = { type: "objectChange" };
      class Bd extends Rt {
        constructor(e2, t2) {
          super(), __publicField(this, "_cameraScale"), __publicField(this, "_endNorm"), __publicField(this, "_gizmo"), __publicField(this, "_getPointer"), __publicField(this, "_onPointerDown"), __publicField(this, "_onPointerHover"), __publicField(this, "_onPointerMove"), __publicField(this, "_onPointerUp"), __publicField(this, "_parentPosition"), __publicField(this, "_parentQuaternion"), __publicField(this, "_parentQuaternionInv"), __publicField(this, "_parentScale"), __publicField(this, "_plane"), __publicField(this, "_positionStart"), __publicField(this, "_quaternionStart"), __publicField(this, "_scaleStart"), __publicField(this, "_startNorm"), __publicField(this, "_worldQuaternionInv"), __publicField(this, "_worldScale"), __publicField(this, "_worldScaleStart"), __publicField(this, "_offset"), __publicField(this, "isTransformControls"), void 0 === t2 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t2 = document), this.visible = false, this.domElement = t2, this.domElement.style.touchAction = "none";
          const i2 = new op();
          this._gizmo = i2, this.add(i2);
          const n2 = new lp();
          this._plane = n2, this.add(n2);
          const r2 = this;
          function s2(e3, t3) {
            let s3 = t3;
            Object.defineProperty(r2, e3, { get: function() {
              return void 0 !== s3 ? s3 : t3;
            }, set: function(t4) {
              s3 !== t4 && (s3 = t4, n2[e3] = t4, i2[e3] = t4, r2.dispatchEvent({ type: e3 + "-changed", value: t4 }), r2.dispatchEvent(Ud));
            } }), r2[e3] = t3, n2[e3] = t3, i2[e3] = t3;
          }
          s2("camera", e2), s2("object", void 0), s2("enabled", true), s2("axis", null), s2("mode", "translate"), s2("translationSnap", null), s2("rotationSnap", null), s2("scaleSnap", null), s2("space", "local"), s2("size", 0.7), s2("dragging", false), s2("showX", true), s2("showY", true), s2("showZ", true);
          const a2 = new Ae(), o2 = new Ae(), l2 = new Ce(), h2 = new Ce(), c2 = new Ae(), u2 = new Ce(), d2 = new Ae(), p2 = new Ae(), m2 = new Ae(), f2 = new Ae();
          s2("worldPosition", a2), s2("worldPositionStart", o2), s2("worldQuaternion", l2), s2("worldQuaternionStart", h2), s2("cameraPosition", c2), s2("cameraQuaternion", u2), s2("pointStart", d2), s2("pointEnd", p2), s2("rotationAxis", m2), s2("rotationAngle", 0), s2("eye", f2), this._offset = new Ae(), this._startNorm = new Ae(), this._endNorm = new Ae(), this._cameraScale = new Ae(), this._parentPosition = new Ae(), this._parentQuaternion = new Ce(), this._parentQuaternionInv = new Ce(), this._parentScale = new Ae(), this._worldScaleStart = new Ae(), this._worldQuaternionInv = new Ce(), this._worldScale = new Ae(), this._positionStart = new Ae(), this._quaternionStart = new Ce(), this._scaleStart = new Ae(), this._getPointer = Vd.bind(this), this._onPointerDown = Hd.bind(this), this._onPointerHover = Gd.bind(this), this._onPointerMove = jd.bind(this), this._onPointerUp = Wd.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
        }
        updateMatrixWorld() {
          void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
        }
        pointerHover(e2) {
          if (void 0 === this.object || true === this.dragging)
            return;
          Ld.setFromCamera(e2, this.camera);
          const t2 = Xd(this._gizmo.picker[this.mode], Ld);
          this.axis = t2 ? t2.object.name : null;
        }
        pointerDown(e2) {
          if (void 0 !== this.object && true !== this.dragging && 0 === e2.button && null !== this.axis) {
            Ld.setFromCamera(e2, this.camera);
            const t2 = Xd(this._plane, Ld, true);
            t2 && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t2.point).sub(this.worldPositionStart)), this.dragging = true, zd.mode = this.mode, this.dispatchEvent(zd);
          }
        }
        pointerMove(e2) {
          const t2 = this.axis, i2 = this.mode, n2 = this.object;
          let r2 = this.space;
          if ("scale" === i2 ? r2 = "local" : "E" !== t2 && "XYZE" !== t2 && "XYZ" !== t2 || (r2 = "world"), void 0 === n2 || null === t2 || false === this.dragging || -1 !== e2.button)
            return;
          Ld.setFromCamera(e2, this.camera);
          const s2 = Xd(this._plane, Ld, true);
          if (s2) {
            if (this.pointEnd.copy(s2.point).sub(this.worldPositionStart), "translate" === i2)
              this._offset.copy(this.pointEnd).sub(this.pointStart), "local" === r2 && "XYZ" !== t2 && this._offset.applyQuaternion(this._worldQuaternionInv), -1 === t2.indexOf("X") && (this._offset.x = 0), -1 === t2.indexOf("Y") && (this._offset.y = 0), -1 === t2.indexOf("Z") && (this._offset.z = 0), "local" === r2 && "XYZ" !== t2 ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), n2.position.copy(this._offset).add(this._positionStart), this.translationSnap && ("local" === r2 && (n2.position.applyQuaternion(Fd.copy(this._quaternionStart).invert()), -1 !== t2.search("X") && (n2.position.x = Math.round(n2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (n2.position.y = Math.round(n2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (n2.position.z = Math.round(n2.position.z / this.translationSnap) * this.translationSnap), n2.position.applyQuaternion(this._quaternionStart)), "world" === r2 && (n2.parent && n2.position.add(Id.setFromMatrixPosition(n2.parent.matrixWorld)), -1 !== t2.search("X") && (n2.position.x = Math.round(n2.position.x / this.translationSnap) * this.translationSnap), -1 !== t2.search("Y") && (n2.position.y = Math.round(n2.position.y / this.translationSnap) * this.translationSnap), -1 !== t2.search("Z") && (n2.position.z = Math.round(n2.position.z / this.translationSnap) * this.translationSnap), n2.parent && n2.position.sub(Id.setFromMatrixPosition(n2.parent.matrixWorld))));
            else if ("scale" === i2) {
              if (-1 !== t2.search("XYZ")) {
                let e3 = this.pointEnd.length() / this.pointStart.length();
                this.pointEnd.dot(this.pointStart) < 0 && (e3 *= -1), Dd.set(e3, e3, e3);
              } else
                Id.copy(this.pointStart), Dd.copy(this.pointEnd), Id.applyQuaternion(this._worldQuaternionInv), Dd.applyQuaternion(this._worldQuaternionInv), Dd.divide(Id), -1 === t2.search("X") && (Dd.x = 1), -1 === t2.search("Y") && (Dd.y = 1), -1 === t2.search("Z") && (Dd.z = 1);
              n2.scale.copy(this._scaleStart).multiply(Dd), this.scaleSnap && (-1 !== t2.search("X") && (n2.scale.x = Math.round(n2.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Y") && (n2.scale.y = Math.round(n2.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t2.search("Z") && (n2.scale.z = Math.round(n2.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
            } else if ("rotate" === i2) {
              this._offset.copy(this.pointEnd).sub(this.pointStart);
              const e3 = 20 / this.worldPosition.distanceTo(Id.setFromMatrixPosition(this.camera.matrixWorld));
              "E" === t2 ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : "XYZE" === t2 ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Id.copy(this.rotationAxis).cross(this.eye)) * e3) : "X" !== t2 && "Y" !== t2 && "Z" !== t2 || (this.rotationAxis.copy(Od[t2]), Id.copy(Od[t2]), "local" === r2 && Id.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Id.cross(this.eye).normalize()) * e3), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), "local" === r2 && "E" !== t2 && "XYZE" !== t2 ? (n2.quaternion.copy(this._quaternionStart), n2.quaternion.multiply(Fd.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), n2.quaternion.copy(Fd.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), n2.quaternion.multiply(this._quaternionStart).normalize());
            }
            this.dispatchEvent(Ud), this.dispatchEvent(kd);
          }
        }
        pointerUp(e2) {
          0 === e2.button && (this.dragging && null !== this.axis && (Nd.mode = this.mode, this.dispatchEvent(Nd)), this.dragging = false, this.axis = null);
        }
        dispose() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e2) {
            e2.geometry && e2.geometry.dispose(), e2.material && e2.material.dispose();
          });
        }
        attach(e2) {
          return this.object = e2, this.visible = true, this;
        }
        detach() {
          return this.object = void 0, this.visible = false, this.axis = null, this;
        }
        reset() {
          this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Ud), this.dispatchEvent(kd), this.pointStart.copy(this.pointEnd));
        }
        getRaycaster() {
          return Ld;
        }
        getMode() {
          return this.mode;
        }
        setMode(e2) {
          this.mode = e2;
        }
        setTranslationSnap(e2) {
          this.translationSnap = e2;
        }
        setRotationSnap(e2) {
          this.rotationSnap = e2;
        }
        setScaleSnap(e2) {
          this.scaleSnap = e2;
        }
        setSize(e2) {
          this.size = e2;
        }
        setSpace(e2) {
          this.space = e2;
        }
        update() {
          console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
        }
      }
      function Vd(e2) {
        if (this.domElement.ownerDocument.pointerLockElement)
          return { x: 0, y: 0, button: e2.button };
        {
          const t2 = this.domElement.getBoundingClientRect();
          return { x: (e2.clientX - t2.left) / t2.width * 2 - 1, y: -(e2.clientY - t2.top) / t2.height * 2 + 1, button: e2.button };
        }
      }
      function Gd(e2) {
        if (this.enabled)
          switch (e2.pointerType) {
            case "mouse":
            case "pen":
              this.pointerHover(this._getPointer(e2));
          }
      }
      function Hd(e2) {
        this.enabled && (this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(e2)), this.pointerDown(this._getPointer(e2)));
      }
      function jd(e2) {
        this.enabled && this.pointerMove(this._getPointer(e2));
      }
      function Wd(e2) {
        this.enabled && (this.domElement.releasePointerCapture(e2.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(e2)));
      }
      function Xd(e2, t2, i2) {
        const n2 = t2.intersectObject(e2, true);
        for (let r2 = 0; r2 < n2.length; r2++)
          if (n2[r2].object.visible || i2)
            return n2[r2];
        return false;
      }
      Bd.prototype.isTransformControls = true;
      const qd = new ft(), Yd = new Ae(0, 1, 0), Zd = new Ae(0, 0, 0), Jd = new st(), Kd = new Ce(), Qd = new Ce(), $d = new Ae(), ep = new st(), tp = new Ae(1, 0, 0), ip = new Ae(0, 1, 0), np = new Ae(0, 0, 1), rp = new Ae(), sp = new Ae(), ap = new Ae();
      class op extends Rt {
        constructor() {
          super(), this.type = "TransformControlsGizmo";
          const e2 = new jt({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), t2 = new qs({ depthTest: false, depthWrite: false, fog: false, toneMapped: false, transparent: true }), i2 = e2.clone();
          i2.opacity = 0.15;
          const n2 = t2.clone();
          n2.opacity = 0.5;
          const r2 = e2.clone();
          r2.color.setHex(16711680);
          const s2 = e2.clone();
          s2.color.setHex(65280);
          const a2 = e2.clone();
          a2.color.setHex(255);
          const o2 = e2.clone();
          o2.color.setHex(16711680), o2.opacity = 0.5;
          const l2 = e2.clone();
          l2.color.setHex(65280), l2.opacity = 0.5;
          const h2 = e2.clone();
          h2.color.setHex(255), h2.opacity = 0.5;
          const c2 = e2.clone();
          c2.opacity = 0.25;
          const u2 = e2.clone();
          u2.color.setHex(16776960), u2.opacity = 0.25;
          e2.clone().color.setHex(16776960);
          const d2 = e2.clone();
          d2.color.setHex(7895160);
          const p2 = new pa(0, 0.04, 0.1, 12);
          p2.translate(0, 0.05, 0);
          const m2 = new wi(0.08, 0.08, 0.08);
          m2.translate(0, 0.04, 0);
          const f2 = new ri();
          f2.setAttribute("position", new Jt([0, 0, 0, 1, 0, 0], 3));
          const g2 = new pa(75e-4, 75e-4, 0.5, 3);
          function _2(e3, t3) {
            const i3 = new _a(e3, 75e-4, 3, 64, t3 * Math.PI * 2);
            return i3.rotateY(Math.PI / 2), i3.rotateX(Math.PI / 2), i3;
          }
          g2.translate(0, 0.25, 0);
          const v2 = { X: [[new Mi(p2, r2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Mi(p2, r2), [-0.5, 0, 0], [0, 0, Math.PI / 2]], [new Mi(g2, r2), [0, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new Mi(p2, s2), [0, 0.5, 0]], [new Mi(p2, s2), [0, -0.5, 0], [Math.PI, 0, 0]], [new Mi(g2, s2)]], Z: [[new Mi(p2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Mi(p2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]], [new Mi(g2, a2), null, [Math.PI / 2, 0, 0]]], XYZ: [[new Mi(new fa(0.1, 0), c2.clone()), [0, 0, 0]]], XY: [[new Mi(new wi(0.15, 0.15, 0.01), h2.clone()), [0.15, 0.15, 0]]], YZ: [[new Mi(new wi(0.15, 0.15, 0.01), o2.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Mi(new wi(0.15, 0.15, 0.01), l2.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, x2 = { X: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0.3, 0]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XYZ: [[new Mi(new fa(0.2, 0), i2)]], XY: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0.15, 0.15, 0]]], YZ: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]] }, y2 = { START: [[new Mi(new fa(0.01, 2), n2), null, null, null, "helper"]], END: [[new Mi(new fa(0.01, 2), n2), null, null, null, "helper"]], DELTA: [[new $s(function() {
            const e3 = new ri();
            return e3.setAttribute("position", new Jt([0, 0, 0, 1, 1, 1], 3)), e3;
          }(), n2), null, null, null, "helper"]], X: [[new $s(f2, n2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new $s(f2, n2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new $s(f2, n2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, b2 = { XYZE: [[new Mi(_2(0.5, 1), d2), null, [0, Math.PI / 2, 0]]], X: [[new Mi(_2(0.5, 0.5), r2)]], Y: [[new Mi(_2(0.5, 0.5), s2), null, [0, 0, -Math.PI / 2]]], Z: [[new Mi(_2(0.5, 0.5), a2), null, [0, Math.PI / 2, 0]]], E: [[new Mi(_2(0.75, 1), u2), null, [0, Math.PI / 2, 0]]] }, M2 = { AXIS: [[new $s(f2, n2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, S2 = { XYZE: [[new Mi(new ga(0.25, 10, 8), i2)]], X: [[new Mi(new _a(0.5, 0.1, 4, 24), i2), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new Mi(new _a(0.5, 0.1, 4, 24), i2), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new Mi(new _a(0.5, 0.1, 4, 24), i2), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new Mi(new _a(0.75, 0.1, 2, 24), i2)]] }, w2 = { X: [[new Mi(m2, r2), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new Mi(g2, r2), [0, 0, 0], [0, 0, -Math.PI / 2]], [new Mi(m2, r2), [-0.5, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Mi(m2, s2), [0, 0.5, 0]], [new Mi(g2, s2)], [new Mi(m2, s2), [0, -0.5, 0], [0, 0, Math.PI]]], Z: [[new Mi(m2, a2), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new Mi(g2, a2), [0, 0, 0], [Math.PI / 2, 0, 0]], [new Mi(m2, a2), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]], XY: [[new Mi(new wi(0.15, 0.15, 0.01), h2), [0.15, 0.15, 0]]], YZ: [[new Mi(new wi(0.15, 0.15, 0.01), o2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Mi(new wi(0.15, 0.15, 0.01), l2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new Mi(new wi(0.1, 0.1, 0.1), c2.clone())]] }, T2 = { X: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0.3, 0, 0], [0, 0, -Math.PI / 2]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [-0.3, 0, 0], [0, 0, Math.PI / 2]]], Y: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0.3, 0]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, -0.3, 0], [0, 0, Math.PI]]], Z: [[new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0, 0.3], [Math.PI / 2, 0, 0]], [new Mi(new pa(0.2, 0, 0.6, 4), i2), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]], XY: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0.15, 0.15, 0]]], YZ: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]], XZ: [[new Mi(new wi(0.2, 0.2, 0.01), i2), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]], XYZ: [[new Mi(new wi(0.2, 0.2, 0.2), i2), [0, 0, 0]]] }, E2 = { X: [[new $s(f2, n2.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new $s(f2, n2.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new $s(f2, n2.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] };
          function C2(e3) {
            const t3 = new Rt();
            for (const i3 in e3)
              for (let n3 = e3[i3].length; n3--; ) {
                const r3 = e3[i3][n3][0].clone(), s3 = e3[i3][n3][1], a3 = e3[i3][n3][2], o3 = e3[i3][n3][3], l3 = e3[i3][n3][4];
                r3.name = i3, r3.tag = l3, s3 && r3.position.set(s3[0], s3[1], s3[2]), a3 && r3.rotation.set(a3[0], a3[1], a3[2]), o3 && r3.scale.set(o3[0], o3[1], o3[2]), r3.updateMatrix();
                const h3 = r3.geometry.clone();
                h3.applyMatrix4(r3.matrix), r3.geometry = h3, r3.renderOrder = 1 / 0, r3.position.set(0, 0, 0), r3.rotation.set(0, 0, 0), r3.scale.set(1, 1, 1), t3.add(r3);
              }
            return t3;
          }
          this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = C2(v2)), this.add(this.gizmo.rotate = C2(b2)), this.add(this.gizmo.scale = C2(w2)), this.add(this.picker.translate = C2(x2)), this.add(this.picker.rotate = C2(S2)), this.add(this.picker.scale = C2(T2)), this.add(this.helper.translate = C2(y2)), this.add(this.helper.rotate = C2(M2)), this.add(this.helper.scale = C2(E2)), this.picker.translate.visible = false, this.picker.rotate.visible = false, this.picker.scale.visible = false;
        }
        onBeforeScenePrepareRender() {
          const e2 = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : Qd;
          this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode;
          let t2 = [];
          t2 = t2.concat(this.picker[this.mode].children), t2 = t2.concat(this.gizmo[this.mode].children), t2 = t2.concat(this.helper[this.mode].children);
          for (let i2 = 0; i2 < t2.length; i2++) {
            const n2 = t2[i2];
            let r2;
            if (n2.visible = true, n2.rotation.set(0, 0, 0), n2.position.copy(this.worldPosition), r2 = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n2.scale.set(1, 1, 1).multiplyScalar(r2 * this.size / 4), "helper" !== n2.tag) {
              if (n2.quaternion.copy(e2), "translate" === this.mode || "scale" === this.mode) {
                const t3 = 0.99, i3 = 0.2;
                "X" === n2.name && Math.abs(Yd.copy(tp).applyQuaternion(e2).dot(this.eye)) > t3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "Y" === n2.name && Math.abs(Yd.copy(ip).applyQuaternion(e2).dot(this.eye)) > t3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "Z" === n2.name && Math.abs(Yd.copy(np).applyQuaternion(e2).dot(this.eye)) > t3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "XY" === n2.name && Math.abs(Yd.copy(np).applyQuaternion(e2).dot(this.eye)) < i3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "YZ" === n2.name && Math.abs(Yd.copy(tp).applyQuaternion(e2).dot(this.eye)) < i3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false), "XZ" === n2.name && Math.abs(Yd.copy(ip).applyQuaternion(e2).dot(this.eye)) < i3 && (n2.scale.set(1e-10, 1e-10, 1e-10), n2.visible = false);
              } else
                "rotate" === this.mode && (Kd.copy(e2), Yd.copy(this.eye).applyQuaternion(Fd.copy(e2).invert()), -1 !== n2.name.search("E") && n2.quaternion.setFromRotationMatrix(Jd.lookAt(this.eye, Zd, ip)), "X" === n2.name && (Fd.setFromAxisAngle(tp, Math.atan2(-Yd.y, Yd.z)), Fd.multiplyQuaternions(Kd, Fd), n2.quaternion.copy(Fd)), "Y" === n2.name && (Fd.setFromAxisAngle(ip, Math.atan2(Yd.x, Yd.z)), Fd.multiplyQuaternions(Kd, Fd), n2.quaternion.copy(Fd)), "Z" === n2.name && (Fd.setFromAxisAngle(np, Math.atan2(Yd.y, Yd.x)), Fd.multiplyQuaternions(Kd, Fd), n2.quaternion.copy(Fd)));
              n2.visible = n2.visible && (-1 === n2.name.indexOf("X") || this.showX), n2.visible = n2.visible && (-1 === n2.name.indexOf("Y") || this.showY), n2.visible = n2.visible && (-1 === n2.name.indexOf("Z") || this.showZ), n2.visible = n2.visible && (-1 === n2.name.indexOf("E") || this.showX && this.showY && this.showZ), n2.material._color = n2.material._color || n2.material.color.clone(), n2.material._opacity = n2.material._opacity || n2.material.opacity, n2.material.color.copy(n2.material._color), n2.material.opacity = n2.material._opacity, this.enabled && this.axis && (n2.name === this.axis || this.axis.split("").some(function(e3) {
                return n2.name === e3;
              })) && (n2.material.color.setHex(16776960), n2.material.opacity = 1);
            } else
              n2.visible = false, "AXIS" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.visible = !!this.axis, "X" === this.axis && (Fd.setFromEuler(qd.set(0, 0, 0)), n2.quaternion.copy(e2).multiply(Fd), Math.abs(Yd.copy(tp).applyQuaternion(e2).dot(this.eye)) > 0.9 && (n2.visible = false)), "Y" === this.axis && (Fd.setFromEuler(qd.set(0, 0, Math.PI / 2)), n2.quaternion.copy(e2).multiply(Fd), Math.abs(Yd.copy(ip).applyQuaternion(e2).dot(this.eye)) > 0.9 && (n2.visible = false)), "Z" === this.axis && (Fd.setFromEuler(qd.set(0, Math.PI / 2, 0)), n2.quaternion.copy(e2).multiply(Fd), Math.abs(Yd.copy(np).applyQuaternion(e2).dot(this.eye)) > 0.9 && (n2.visible = false)), "XYZE" === this.axis && (Fd.setFromEuler(qd.set(0, Math.PI / 2, 0)), Yd.copy(this.rotationAxis), n2.quaternion.setFromRotationMatrix(Jd.lookAt(Zd, Yd, ip)), n2.quaternion.multiply(Fd), n2.visible = this.dragging), "E" === this.axis && (n2.visible = false)) : "START" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.visible = this.dragging) : "END" === n2.name ? (n2.position.copy(this.worldPosition), n2.visible = this.dragging) : "DELTA" === n2.name ? (n2.position.copy(this.worldPositionStart), n2.quaternion.copy(this.worldQuaternionStart), Id.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Id.applyQuaternion(this.worldQuaternionStart.clone().invert()), n2.scale.copy(Id), n2.visible = this.dragging) : (n2.quaternion.copy(e2), this.dragging ? n2.position.copy(this.worldPositionStart) : n2.position.copy(this.worldPosition), this.axis && (n2.visible = -1 !== this.axis.search(n2.name)));
          }
        }
      }
      op.prototype.isTransformControlsGizmo = true;
      class lp extends Mi {
        constructor() {
          super(new ji(1e5, 1e5, 2, 2), new jt({ visible: false, wireframe: true, side: 2, transparent: true, opacity: 0.1, toneMapped: false })), this.type = "TransformControlsPlane";
        }
        updateMatrixWorld(e2) {
          let t2 = this.space;
          switch (this.position.copy(this.worldPosition), "scale" === this.mode && (t2 = "local"), rp.copy(tp).applyQuaternion("local" === t2 ? this.worldQuaternion : Qd), sp.copy(ip).applyQuaternion("local" === t2 ? this.worldQuaternion : Qd), ap.copy(np).applyQuaternion("local" === t2 ? this.worldQuaternion : Qd), Yd.copy(sp), this.mode) {
            case "translate":
            case "scale":
              switch (this.axis) {
                case "X":
                  Yd.copy(this.eye).cross(rp), $d.copy(rp).cross(Yd);
                  break;
                case "Y":
                  Yd.copy(this.eye).cross(sp), $d.copy(sp).cross(Yd);
                  break;
                case "Z":
                  Yd.copy(this.eye).cross(ap), $d.copy(ap).cross(Yd);
                  break;
                case "XY":
                  $d.copy(ap);
                  break;
                case "YZ":
                  $d.copy(rp);
                  break;
                case "XZ":
                  Yd.copy(ap), $d.copy(sp);
                  break;
                case "XYZ":
                case "E":
                  $d.set(0, 0, 0);
              }
              break;
            default:
              $d.set(0, 0, 0);
          }
          0 === $d.length() ? this.quaternion.copy(this.cameraQuaternion) : (ep.lookAt(Id.set(0, 0, 0), $d, Yd), this.quaternion.setFromRotationMatrix(ep)), super.updateMatrixWorld(e2);
        }
      }
      lp.prototype.isTransformControlsPlane = true;
      class hp extends Bd {
        constructor(e2) {
          super(e2.camera, e2.map.container), __publicField(this, "_enableKeyboardEvent", false), __publicField(this, "handleKeyboardEvent", (e3) => {
            switch (e3.keyCode) {
              case 81:
                this.setSpace("local" === this.space ? "world" : "local");
                break;
              case 87:
                this.setMode("translate");
                break;
              case 69:
                this.setMode("rotate");
                break;
              case 82:
                this.setMode("scale");
                break;
              case 187:
              case 107:
                this.setSize(this.size + 0.1);
                break;
              case 189:
              case 109:
                this.setSize(Math.max(this.size - 0.1, 0.1));
                break;
              case 88:
                this.showX = !this.showX;
                break;
              case 89:
                this.showY = !this.showY;
                break;
              case 90:
                this.showZ = !this.showZ;
                break;
              case 32:
                this.enabled = !this.enabled;
                break;
              case 27:
                this.reset();
            }
          }), this.engine = e2, this.addEventListener("change", (t2) => {
            e2.requestRender();
          }), this.addEventListener("objectChange", (t2) => {
            e2.requestRender();
          }), this.addEventListener("dragging-changed", (t2) => {
            t2.value ? e2.map.disableControl() : e2.map.enableControl();
          });
        }
        dispose() {
          super.dispose(), this.enableKeyboardEvent = false;
        }
        set enableKeyboardEvent(e2) {
          e2 !== this._enableKeyboardEvent && (this._enableKeyboardEvent = e2, e2 ? window.addEventListener("keydown", this.handleKeyboardEvent) : window.removeEventListener("keydown", this.handleKeyboardEvent));
        }
      }
      class cp extends H {
        constructor(e2, t2 = {}) {
          super(), __publicField(this, "_engine"), __publicField(this, "_boundingBoxHelper"), __publicField(this, "_selectedObject"), __publicField(this, "_transformControl"), this._engine = e2;
        }
        isSelected(e2) {
          return e2 === this._selectedObject;
        }
        select(e2) {
          e2.__engine_selected || (this._selectedObject && (this._selectedObject.__engine_selected = false), this._boundingBoxHelper || (this._boundingBoxHelper = new Rd(), this._engine.add(this._boundingBoxHelper)), this._boundingBoxHelper.attach(e2), this._selectedObject = e2, e2.__engine_selected = true, this._engine.requestRender());
        }
        deselect(e2) {
          this.isSelected(e2) && (this._boundingBoxHelper.detach(), this._selectedObject = null, e2.__engine_selected = false, this._engine.requestRender());
        }
        get transformControl() {
          return this._transformControl || (this._transformControl = new hp(this._engine), this._transformControl.enableKeyboardEvent = true), this._transformControl;
        }
        attachTransform(e2) {
          const t2 = this._engine, i2 = this.transformControl;
          t2.add(i2), i2.attach(e2), i2.updateMatrixWorld(), t2.requestRender();
        }
        detachTransform() {
          const e2 = this._engine, t2 = this.transformControl;
          e2.remove(t2), t2.detach();
        }
        dispose() {
        }
      }
      Wi.mvt_uniform_zoomunits_pars = "#define GLSLIFY 1\n", Wi.mvt_extra_vertex_utils = "#define GLSLIFY 1\nfloat getPixelSize(vec3 position) {\n    return 0.1 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);\n}\n", Wi.mvt_selective_pars_vertex = "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nattribute float objectIndex;\nuniform float selectedObjectIndex;\nvarying float isSelected;\n#endif", Wi.mvt_selective_vertex = "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (objectIndex == selectedObjectIndex) {\n	isSelected = 1.0;\n} else {\n	isSelected = 0.0;\n}\n#endif", Wi.mvt_selective_pars_fragment = "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nvarying float isSelected;\nuniform vec4 selectedObjectColor;\nuniform float selectedObjectColorMode;\n#endif", Wi.mvt_selective_fragment = "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (isSelected == 1.0) {\n	if (selectedObjectColorMode == 1.) {\n		gl_FragColor = selectedObjectColor;\n	} else {\n		gl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);\n	}\n	\n}\n#endif", Wi.mvt_keepsize_pars_vertex = "#define GLSLIFY 1\nuniform bool keepSize;\nuniform float pixelRatio;\nuniform vec2 resolution;\n", Wi.mvt_keepsize_vertex = "#define GLSLIFY 1\nvec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\nfloat pixelSize = getPixelSize(worldPosition.xyz);\nif (keepSize) {\n    transformed *= pixelSize;\n}\n", Wi.mvt_emissive_pars_fragment = "#define GLSLIFY 1\n#define MVT_EMISSIVE_SHADER\n\nuniform vec3 emissive;", Wi.mvt_emissive_fragment = "#define GLSLIFY 1\n#ifdef MVT_EMISSIVE_SHADER\n    vec4 out_emissive = vec4(emissive.rgb, 1.0);\n#endif", Wi.mvt_override_standard_emissivemap_pars_fragment = "#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\nuniform bool isEmissive;", Wi.mvt_override_standard_emissivemap_fragment = "#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n	totalEmissiveRadiance *= emissiveColor.rgb;\n\n    \n#endif\n\nif (isEmissive) {\n    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);\n	#if defined( TONE_MAPPING )\n	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}", Wi.mvt_override_basic_color_pars_fragment = "#define GLSLIFY 1\nuniform bool isEmissive;\nuniform vec3 emissive;\n#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif", Wi.mvt_override_basic_color_fragment = "#define GLSLIFY 1\nif (isEmissive) {\n    gl_FragColor = vec4(emissive, 1.0);\n    #if defined( TONE_MAPPING )\n	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}\n#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif", Wi.mvt_animation_pars_vertex = "#define GLSLIFY 1\nuniform bool animationPeriodOffset;\n#ifdef ENABLE_ANIMATION_ROTATE\nuniform float animationRotatePeriod;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\nuniform float animationJumpPeriod;\nuniform float animationJumpHeight;\n#endif\n", Wi.mvt_animation_vertex = "#define GLSLIFY 1\n#ifdef ENABLE_ANIMATION_ROTATE\n    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;\n    if (animationPeriodOffset) {\n        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);\n    }\n    float rotation = rotateRatio * 6.28;\n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;\n    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;\n    transformed.xy = rotatedPosition;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\n    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;\n    if (animationPeriodOffset) {\n        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);\n    }\n    if (jumpRatio <= 0.5) {\n        jumpRatio *= 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    } else {\n        jumpRatio = (1.0 - jumpRatio) * 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    }\n    #ifdef USE_SIZE3\n        transformed.z += jumpRatio * animationJumpHeight / size3.z;\n    #else\n        transformed.z += jumpRatio * animationJumpHeight / size;\n    #endif\n    \n#endif\n", Wi.mvt_mrt_output_pars_fragment = "#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    layout(location = 1) out highp vec4 pc_fragColor1;\n    layout(location = 2) out highp vec4 pc_fragColor2;\n    layout(location = 3) out highp vec4 pc_fragColor3;\n    // layout(location = 4) out highp vec4 pc_fragColor4;\n    // layout(location = 5) out highp vec4 pc_fragColor5;\n    // layout(location = 6) out highp vec4 pc_fragColor6;\n    // layout(location = 7) out highp vec4 pc_fragColor7;\n#endif\n\n#if defined(MVT_EMISSIVE_UNIFORM)\n// 发光颜色自定义\n    #if defined(MVT_EMISSIVE_COLOR)\n        uniform vec3 mvt_emissive;\n    #endif  \n    uniform float mvt_emissiveIntensity;\n#endif", Wi.mvt_mrt_output_fragment = "#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    // 自定义发光颜色，完全由着色器控制 在着色器中输出 vec4 out_emissive;\n    #if defined(MVT_EMISSIVE_SHADER)\n        pc_fragColor1 = out_emissive;\n    #elif defined(STANDARD)\n        pc_fragColor1.rgb = totalEmissiveRadiance;\n        pc_fragColor1.a = pc_fragColor.a;\n    #elif defined(BASIC)\n        pc_fragColor1.rgb = emissive;\n        pc_fragColor1.a = pc_fragColor.a;\n    // 通过传入的uniform变量颜色自发光\n    #elif defined(MVT_EMISSIVE_UNIFORM)\n        // 发光颜色自定义\n        #if defined(MVT_EMISSIVE_COLOR)\n            pc_fragColor1.rgb = mvt_emissive * mvt_emissiveIntensity;\n            pc_fragColor1.a = pc_fragColor.a;\n        #else  \n            pc_fragColor1 = pc_fragColor * mvt_emissiveIntensity;\n        #endif\n    #else\n        pc_fragColor1 = vec4(0.0, 0.0, 0.0, 0.0);\n      \n    #endif\n\n    #if defined(STANDARD)\n        #ifndef FLAT_SHADED\n            pc_fragColor2 = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);\n        #else\n            pc_fragColor2 = vec4(0.0, 0.0, 0.0, 0.0);\n        #endif\n        pc_fragColor3 = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);\n    #else\n        #if defined(MVT_FRAG_NORMAL)\n            pc_fragColor2 = vec4(packNormalToRGB(mvt_frag_normal), 1.0);\n        #else\n            pc_fragColor2 = vec4(0.0, 0.0, 0.0, 0.0);\n        #endif\n        \n        float temp_reflectionFactor = 0.0;\n        #if defined(MVT_FRAG_REFLECTION_FACTOR)\n            temp_reflectionFactor = mvt_frag_reflectionFactor;\n        #endif\n        pc_fragColor3 = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);\n    #endif\n    \n    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);\n    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);\n#endif\n", Wi.mvt_extra_meshbasic_frag_pars = "#define GLSLIFY 1\n#define BASIC\nuniform vec3 emissive;", jt.prototype.emissiveIntensity = 1, qi.basic.uniforms.emissive = { value: new ge(0) };
      class up extends Xa {
        constructor(e2) {
          super(e2), this.type = x;
        }
        parse(e2) {
          const t2 = function(e3, t3) {
            switch (e3) {
              case 1:
                console.error("THREE.RGBELoader Read Error: " + (t3 || ""));
                break;
              case 2:
                console.error("THREE.RGBELoader Write Error: " + (t3 || ""));
                break;
              case 3:
                console.error("THREE.RGBELoader Bad File Format: " + (t3 || ""));
                break;
              default:
                console.error("THREE.RGBELoader: Error: " + (t3 || ""));
            }
            return -1;
          }, i2 = function(e3, t3, i3) {
            t3 = t3 || 1024;
            let n3 = e3.pos, r3 = -1, s3 = 0, a3 = "", o2 = String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n3, n3 + 128)));
            for (; 0 > (r3 = o2.indexOf("\n")) && s3 < t3 && n3 < e3.byteLength; )
              a3 += o2, s3 += o2.length, n3 += 128, o2 += String.fromCharCode.apply(null, new Uint16Array(e3.subarray(n3, n3 + 128)));
            return -1 < r3 && (false !== i3 && (e3.pos += s3 + r3 + 1), a3 + o2.slice(0, r3));
          }, n2 = function(e3, t3, i3, n3) {
            const r3 = e3[t3 + 3], s3 = Math.pow(2, r3 - 128) / 255;
            i3[n3 + 0] = e3[t3 + 0] * s3, i3[n3 + 1] = e3[t3 + 1] * s3, i3[n3 + 2] = e3[t3 + 2] * s3, i3[n3 + 3] = 1;
          }, r2 = function(e3, t3, i3, n3) {
            const r3 = e3[t3 + 3], s3 = Math.pow(2, r3 - 128) / 255;
            i3[n3 + 0] = Uo.toHalfFloat(Math.min(e3[t3 + 0] * s3, 65504)), i3[n3 + 1] = Uo.toHalfFloat(Math.min(e3[t3 + 1] * s3, 65504)), i3[n3 + 2] = Uo.toHalfFloat(Math.min(e3[t3 + 2] * s3, 65504)), i3[n3 + 3] = Uo.toHalfFloat(1);
          }, s2 = new Uint8Array(e2);
          s2.pos = 0;
          const a2 = function(e3) {
            const n3 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r3 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s3 = /^\s*FORMAT=(\S+)\s*$/, a3 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, o2 = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
            let l2, h2;
            if (e3.pos >= e3.byteLength || !(l2 = i2(e3)))
              return t2(1, "no header found");
            if (!(h2 = l2.match(/^#\?(\S+)/)))
              return t2(3, "bad initial token");
            for (o2.valid |= 1, o2.programtype = h2[1], o2.string += l2 + "\n"; l2 = i2(e3), false !== l2; )
              if (o2.string += l2 + "\n", "#" !== l2.charAt(0)) {
                if ((h2 = l2.match(n3)) && (o2.gamma = parseFloat(h2[1])), (h2 = l2.match(r3)) && (o2.exposure = parseFloat(h2[1])), (h2 = l2.match(s3)) && (o2.valid |= 2, o2.format = h2[1]), (h2 = l2.match(a3)) && (o2.valid |= 4, o2.height = parseInt(h2[1], 10), o2.width = parseInt(h2[2], 10)), 2 & o2.valid && 4 & o2.valid)
                  break;
              } else
                o2.comments += l2 + "\n";
            return 2 & o2.valid ? 4 & o2.valid ? o2 : t2(3, "missing image size specifier") : t2(3, "missing format specifier");
          }(s2);
          if (-1 !== a2) {
            const e3 = a2.width, i3 = a2.height, o2 = function(e4, i4, n3) {
              const r3 = i4;
              if (r3 < 8 || r3 > 32767 || 2 !== e4[0] || 2 !== e4[1] || 128 & e4[2])
                return new Uint8Array(e4);
              if (r3 !== (e4[2] << 8 | e4[3]))
                return t2(3, "wrong scanline width");
              const s3 = new Uint8Array(4 * i4 * n3);
              if (!s3.length)
                return t2(4, "unable to allocate buffer space");
              let a3 = 0, o3 = 0;
              const l2 = 4 * r3, h2 = new Uint8Array(4), c2 = new Uint8Array(l2);
              let u2 = n3;
              for (; u2 > 0 && o3 < e4.byteLength; ) {
                if (o3 + 4 > e4.byteLength)
                  return t2(1);
                if (h2[0] = e4[o3++], h2[1] = e4[o3++], h2[2] = e4[o3++], h2[3] = e4[o3++], 2 != h2[0] || 2 != h2[1] || (h2[2] << 8 | h2[3]) != r3)
                  return t2(3, "bad rgbe scanline format");
                let i5, n4 = 0;
                for (; n4 < l2 && o3 < e4.byteLength; ) {
                  i5 = e4[o3++];
                  const r4 = i5 > 128;
                  if (r4 && (i5 -= 128), 0 === i5 || n4 + i5 > l2)
                    return t2(3, "bad scanline data");
                  if (r4) {
                    const t3 = e4[o3++];
                    for (let e5 = 0; e5 < i5; e5++)
                      c2[n4++] = t3;
                  } else
                    c2.set(e4.subarray(o3, o3 + i5), n4), n4 += i5, o3 += i5;
                }
                const d2 = r3;
                for (let e5 = 0; e5 < d2; e5++) {
                  let t3 = 0;
                  s3[a3] = c2[e5 + t3], t3 += r3, s3[a3 + 1] = c2[e5 + t3], t3 += r3, s3[a3 + 2] = c2[e5 + t3], t3 += r3, s3[a3 + 3] = c2[e5 + t3], a3 += 4;
                }
                u2--;
              }
              return s3;
            }(s2.subarray(s2.pos), e3, i3);
            if (-1 !== o2) {
              let t3, s3, l2;
              switch (this.type) {
                case v:
                  l2 = o2.length / 4;
                  const e4 = new Float32Array(4 * l2);
                  for (let t4 = 0; t4 < l2; t4++)
                    n2(o2, 4 * t4, e4, 4 * t4);
                  t3 = e4, s3 = v;
                  break;
                case x:
                  l2 = o2.length / 4;
                  const i4 = new Uint16Array(4 * l2);
                  for (let t4 = 0; t4 < l2; t4++)
                    r2(o2, 4 * t4, i4, 4 * t4);
                  t3 = i4, s3 = x;
                  break;
                default:
                  console.error("THREE.RGBELoader: unsupported type: ", this.type);
              }
              return { width: e3, height: i3, data: t3, header: a2.string, gamma: a2.gamma, exposure: a2.exposure, type: s3 };
            }
          }
          return null;
        }
        setDataType(e2) {
          return this.type = e2, this;
        }
        load(e2, t2, i2, n2) {
          return super.load(e2, function(e3, i3) {
            switch (e3.type) {
              case v:
              case x:
                e3.encoding = O, e3.minFilter = m, e3.magFilter = m, e3.generateMipmaps = false, e3.flipY = true;
            }
            t2 && t2(e3, i3);
          }, i2, n2);
        }
      }
      class dp extends Va {
        constructor(e2) {
          super(e2), this.hdrLoader = new up(), this.type = x;
        }
        load(e2, t2, i2, n2) {
          Array.isArray(e2) || (console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."), this.setDataType(e2), e2 = t2, t2 = i2, i2 = n2, n2 = arguments[4]);
          const r2 = new Di();
          switch (r2.type = this.type, r2.type) {
            case v:
            case x:
              r2.encoding = O, r2.minFilter = m, r2.magFilter = m, r2.generateMipmaps = false;
          }
          const s2 = this;
          let a2 = 0;
          function o2(t3, i3, n3, o3) {
            new Ha(s2.manager).setPath(s2.path).setResponseType("arraybuffer").setWithCredentials(s2.withCredentials).load(e2[t3], function(e3) {
              a2++;
              const n4 = s2.hdrLoader.parse(e3);
              if (n4) {
                if (void 0 !== n4.data) {
                  const e4 = new zs(n4.data, n4.width, n4.height);
                  e4.type = r2.type, e4.encoding = r2.encoding, e4.format = r2.format, e4.minFilter = r2.minFilter, e4.magFilter = r2.magFilter, e4.generateMipmaps = r2.generateMipmaps, r2.images[t3] = e4;
                }
                6 === a2 && (r2.needsUpdate = true, i3 && i3(r2));
              }
            }, n3, o3);
          }
          for (let l2 = 0; l2 < e2.length; l2++)
            o2(l2, t2, i2, n2);
          return r2;
        }
        setDataType(e2) {
          return this.type = e2, this.hdrLoader.setDataType(e2), this;
        }
      }
      const pp = { map: { value: null } };
      class mp extends Ai {
        constructor(e2) {
          super(), this.defines = {}, this.uniforms = Ci.clone(pp), this.side = 2, this.vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vUv = uv;\n    gl_Position = projectionMatrix * viewPos;\n    gl_Position.z = gl_Position.w;\n}\n", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nuniform sampler2D map;\nvoid main() {\n\n    gl_FragColor = texture2D(map, vUv);\n\n    #include <encodings_fragment>\n}\n", this.depthWrite = false, this.depthTest = false, this.envMap = null, Object.defineProperties(this, { map: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            this.uniforms.map.value = e3, this.needsUpdate = true;
          } } });
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class fp extends tl {
        constructor(e2 = {}) {
          super(), __publicField(this, "isCustomStaticSky", true), __publicField(this, "_textureIsCube", false), __publicField(this, "_textureIsHDR", false), __publicField(this, "_textureURL", null), __publicField(this, "_textureNames", null), __publicField(this, "_affectWorld", true), __publicField(this, "_isVerticalTexture", null), __publicField(this, "_mesh", null), __publicField(this, "_material", null), __publicField(this, "_sphereGeometry", null), __publicField(this, "_envTexture", null), __publicField(this, "_engine", null), __publicField(this, "_PMREMGenerator", null), e2.texture;
          const t2 = this._sphereGeometry = new ga(1, 32, 32);
          this.isVerticalTexture = e2.isVerticalTexture || false;
          const i2 = this._mesh = new Mi(t2, this._material);
          i2.frustumCulled = false, i2.collisionDisabled = true, i2.scale.setScalar(1e4), i2.rotateX(Math.PI / 2), this.add(i2);
        }
        afterAddToEngine(e2) {
          super.afterAddToEngine(e2), this._engine = e2, this._PMREMGenerator = new cn(e2.renderer), this._loadSkyTexture();
        }
        onBeforeScenePrepareRender(e2, t2, i2) {
          this._mesh.position.copy(i2.position), super.onBeforeScenePrepareRender(e2);
        }
        _loadSkyTexture() {
          if (!this._engine || !this._textureURL)
            return;
          let e2 = null;
          e2 = this._textureIsHDR ? this._textureIsCube ? new dp() : new up() : this._textureIsCube ? new Wa() : new qa();
          const t2 = this._engine.rendering.scene;
          let i2 = null;
          this._textureIsCube ? (e2.setPath(this._textureURL), i2 = this._textureNames ? this._textureNames : this._textureIsHDR ? ["nz.HDR", "pz.HDR", "px.HDR", "nx.HDR", "py.HDR", "ny.HDR"] : ["nz.jpg", "pz.jpg", "px.jpg", "nx.jpg", "py.jpg", "ny.jpg"]) : i2 = this._textureURL, e2.load(i2, (e3) => {
            this._textureIsCube ? (this._envTexture = this._PMREMGenerator.fromCubemap(e3).texture, this._affectWorld && (t2.environment = this._envTexture)) : (e3.encoding = 3001, this._material.map = e3, this._material.needsUpdate = true, this._isVerticalTexture ? t2.environment = null : (this._envTexture = this._PMREMGenerator.fromEquirectangular(e3).texture, this._affectWorld && (t2.environment = this._envTexture))), this._engine.requestRender();
          });
        }
        get isVerticalTexture() {
          return this._verticalTexture;
        }
        set isVerticalTexture(e2) {
          e2 !== this._isVerticalTexture && (this._material && this._material.dispose(), this._material = new mp(), this._isVerticalTexture = e2, this._mesh && (this._mesh.material = this._material));
        }
        get textureURL() {
          return this._textureURL;
        }
        set textureURL(e2) {
          this._textureURL = e2, this._loadSkyTexture();
        }
        get affectWorld() {
          return this._affectWorld;
        }
        set affectWorld(e2) {
          const t2 = this._engine.rendering.scene;
          e2 ? (this._affectWorld = true, t2.environment = this._envTexture) : (this._affectWorld = false, t2.environment === this._envTexture && (t2.environment = null));
        }
      }
      class gp extends Mi {
        constructor() {
          super(gp.Geometry, new jt({ opacity: 0, transparent: true })), this.isLensflare = true, this.type = "Lensflare", this.frustumCulled = false, this.renderOrder = 1 / 0;
          const e2 = new Ae(), t2 = new Ae(), i2 = new ua(16, 16, b), n2 = new ua(16, 16, b), r2 = gp.Geometry, s2 = new va({ uniforms: { scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n				precision highp float;\n\n				uniform vec3 screenPosition;\n				uniform vec2 scale;\n\n				attribute vec3 position;\n\n				void main() {\n\n					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n				}", fragmentShader: "\n\n				precision highp float;\n\n				void main() {\n\n					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n				}", depthTest: true, depthWrite: false, transparent: false }), a2 = new va({ uniforms: { map: { value: i2 }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n				precision highp float;\n\n				uniform vec3 screenPosition;\n				uniform vec2 scale;\n\n				attribute vec3 position;\n				attribute vec2 uv;\n\n				varying vec2 vUV;\n\n				void main() {\n\n					vUV = uv;\n\n					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n				}", fragmentShader: "\n\n				precision highp float;\n\n				uniform sampler2D map;\n\n				varying vec2 vUV;\n\n				void main() {\n\n					gl_FragColor = texture2D( map, vUV );\n\n				}", depthTest: false, depthWrite: false, transparent: false }), o2 = new Mi(r2, s2), l2 = [], h2 = _p.Shader, c2 = new va({ uniforms: { map: { value: null }, occlusionMap: { value: n2 }, color: { value: new ge(16777215) }, scale: { value: new ie() }, screenPosition: { value: new Ae() } }, vertexShader: h2.vertexShader, fragmentShader: h2.fragmentShader, blending: 2, transparent: true, depthWrite: false }), u2 = new Mi(r2, c2);
          this.addElement = function(e3) {
            l2.push(e3);
          };
          const d2 = new ie(), p2 = new ie(), m2 = new Fo(), f2 = new Se();
          this.onBeforeRender = function(h3, g2, _2) {
            h3.getCurrentViewport(f2);
            const v2 = f2.w / f2.z, x2 = f2.z / 2, y2 = f2.w / 2;
            let b2 = 16 / f2.w;
            if (d2.set(b2 * v2, b2), m2.min.set(f2.x, f2.y), m2.max.set(f2.x + (f2.z - 16), f2.y + (f2.w - 16)), t2.setFromMatrixPosition(this.matrixWorld), t2.applyMatrix4(_2.matrixWorldInverse), !(t2.z > 0) && (e2.copy(t2).applyMatrix4(_2.projectionMatrix), p2.x = f2.x + e2.x * x2 + x2 - 8, p2.y = f2.y + e2.y * y2 + y2 - 8, m2.containsPoint(p2))) {
              h3.copyFramebufferToTexture(p2, i2);
              let t3 = s2.uniforms;
              t3.scale.value = d2, t3.screenPosition.value = e2, h3.renderBufferDirect(_2, null, r2, s2, o2, null), h3.copyFramebufferToTexture(p2, n2), t3 = a2.uniforms, t3.scale.value = d2, t3.screenPosition.value = e2, h3.renderBufferDirect(_2, null, r2, a2, o2, null);
              const m3 = 2 * -e2.x, g3 = 2 * -e2.y;
              for (let i3 = 0, n3 = l2.length; i3 < n3; i3++) {
                const t4 = l2[i3], n4 = c2.uniforms;
                n4.color.value.copy(t4.color), n4.map.value = t4.texture, n4.screenPosition.value.x = e2.x + m3 * t4.distance, n4.screenPosition.value.y = e2.y + g3 * t4.distance, b2 = t4.size / f2.w;
                const s3 = f2.w / f2.z;
                n4.scale.value.set(b2 * s3, b2), c2.uniformsNeedUpdate = true, h3.renderBufferDirect(_2, null, r2, c2, u2, null);
              }
            }
          }, this.dispose = function() {
            s2.dispose(), a2.dispose(), c2.dispose(), i2.dispose(), n2.dispose();
            for (let e3 = 0, t3 = l2.length; e3 < t3; e3++)
              l2[e3].texture.dispose();
          };
        }
      }
      class _p {
        constructor(e2, t2 = 1, i2 = 0, n2 = new ge(16777215)) {
          this.texture = e2, this.size = t2, this.distance = i2, this.color = n2;
        }
      }
      _p.Shader = { uniforms: { map: { value: null }, occlusionMap: { value: null }, color: { value: null }, scale: { value: null }, screenPosition: { value: null } }, vertexShader: "\n\n		precision highp float;\n\n		uniform vec3 screenPosition;\n		uniform vec2 scale;\n\n		uniform sampler2D occlusionMap;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n\n		varying vec2 vUV;\n		varying float vVisibility;\n\n		void main() {\n\n			vUV = uv;\n\n			vec2 pos = position.xy;\n\n			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n			vVisibility =        visibility.r / 9.0;\n			vVisibility *= 1.0 - visibility.g / 9.0;\n			vVisibility *=       visibility.b / 9.0;\n\n			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n		}", fragmentShader: "\n\n		precision highp float;\n\n		uniform sampler2D map;\n		uniform vec3 color;\n\n		varying vec2 vUV;\n		varying float vVisibility;\n\n		void main() {\n\n			vec4 texture = texture2D( map, vUV );\n			texture.a *= vVisibility;\n			gl_FragColor = texture;\n			gl_FragColor.rgb *= color;\n\n		}" }, gp.Geometry = function() {
        const e2 = new ri(), t2 = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]), i2 = new Cs(t2, 5);
        return e2.setIndex([0, 1, 2, 0, 2, 3]), e2.setAttribute("position", new Ps(i2, 3, 0, false)), e2.setAttribute("uv", new Ps(i2, 2, 3, false)), e2;
      }();
      const vp = "#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}", xp = "#define GLSLIFY 1\nconst float PI = 3.14159265358;\n\n// Units are in megameters.\nconst float groundRadiusMM = 6.371;\nconst float atmosphereRadiusMM = 6.471;\n\nconst vec2 tLUTRes = vec2(256.0, 64.0)*1.;\nconst vec2 msLUTRes = vec2(32.0, 32.0)*1.;\nconst vec2 skyLUTRes = vec2(200.0, 200.0)*2.;\n\nconst vec3 groundAlbedo = vec3(0.1);\n\n// These are per megameter.\nconst vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);\nconst float rayleighAbsorptionBase = 0.0;\n\nconst float mieScatteringBase = 3.996;\nconst float mieAbsorptionBase = 4.4;\n\nconst vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);\n\n// Quality\nconst float sunTransmittanceSteps = 40.0;\nconst float mulScattSteps = 20.0;\nconst int sqrtSamples = 8;\n\nconst int numScatteringSteps = 16;\n\nuniform float altitude;\nuniform float viewHeight;\n/*\n * Animates the sun movement.\n */\nfloat getSunAltitude(float time)\n{\n    const float periodSec = 10.0;\n    return (PI)*time/periodSec - PI/24.;\n}\nvec3 getSunDir(float time)\n{\n    // float altitude = getSunAltitude(time);\n    // altitude = 2.8;\n    return normalize(vec3(cos(altitude), sin(altitude), 0.0));\n}\n\n/* Animate camera */\nvec3 getViewPos(float time){\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002 + viewHeight, 0.0);\n\n    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution\n    float alt_range = 50.0;\n\n    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;\n\n    return viewPos;\n}\n\nfloat getMiePhase(float cosTheta) {\n    const float g = 0.8;\n    const float scale = 3.0/(8.0*PI);\n\n    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);\n    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);\n\n    return scale*num/denom;\n}\n\nfloat getRayleighPhase(float cosTheta) {\n    const float k = 3.0/(16.0*PI);\n    return k*(1.0+cosTheta*cosTheta);\n}\n\nvoid getScatteringValues(vec3 pos,\n                         out vec3 rayleighScattering,\n                         out float mieScattering,\n                         out vec3 extinction) {\n    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;\n    // Note: Paper gets these switched up.\n    float rayleighDensity = exp(-altitudeKM/8.0);\n    float mieDensity = exp(-altitudeKM/1.2);\n\n    rayleighScattering = rayleighScatteringBase*rayleighDensity;\n    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;\n\n    mieScattering = mieScatteringBase*mieDensity;\n    float mieAbsorption = mieAbsorptionBase*mieDensity;\n\n    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);\n\n    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat rayIntersectSphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0f && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\n// From https://www.shadertoy.com/view/wlBXWK\nvec2 rayIntersectSphere2D(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\n * Same parameterization here.\n */\nvec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n	float sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    // return pos;\n    return texture(tex, uv).rgb;\n}\nvec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n	float sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    return texture(tex, uv).rgb;\n}\n\n/* \n * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere\n*/\n\nvec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,\n                              vec3 viewPos,\n                              vec3 rayDir,\n                              vec3 sunDir,\n                              float numSteps) {\n                              \n                              \n    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);\n    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);\n\n    float mindist, maxdist;\n\n    if (atmos_intercept.x < atmos_intercept.y){\n        // there is an atmosphere intercept!\n        // start at the closest atmosphere intercept\n        // trace the distance between the closest and farthest intercept\n        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;\n		maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;\n    } else {\n        // no atmosphere intercept means no atmosphere!\n        return vec3(0.0);\n    }\n\n    // if in the atmosphere start at the camera\n    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;\n\n    // if there's a terra intercept that's closer than the atmosphere one,\n    // use that instead!\n    if (terra_intercept > 0.0){ // confirm valid intercepts			\n        maxdist = terra_intercept;\n    }\n\n    // start marching at the min dist\n    vec3 pos = viewPos + mindist * rayDir;\n                              \n    float cosTheta = dot(rayDir, sunDir);\n\n	float miePhaseValue = getMiePhase(cosTheta);\n	float rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n    vec3 lum = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    float t = 0.0;\n    for (float i = 0.0; i < numSteps; i += 1.0) {\n        float newT = ((i + 0.3)/numSteps)*(maxdist-mindist);\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*rayDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        \n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        vec3 sampleTransmittance = exp(-dt*extinction);\n\n        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);\n        vec3 psiMS = 0.0*getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);\n\n        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);\n        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);\n        vec3 inScattering = (rayleighInScattering + mieInScattering);\n\n        // Integrated scattering within path segment.\n        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n        lum += scatteringIntegral*transmittance;\n\n        transmittance *= sampleTransmittance;\n    }\n    return lum;\n}\n", yp = { uniforms: { altitude: { value: 2.8 }, iChannel0: { value: null }, iChannelResolution0: { value: [256, 256] }, iChannel1: { value: null }, iChannelResolution1: { value: [256, 256] }, iChannel2: { value: null }, iChannelResolution2: { value: [256, 256] }, cameraDirection: { value: new Ae(0, 0.27, -1) }, viewHeight: { value: 2e-3 }, upDirection: { value: new Ae(0, 1, 0) }, tWeather: { value: null }, mixGrayFactor: { value: 0 } }, vertexShader: "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);\n    vWorldPosition = normalize(vec3(position.x, position.y, position.z));\n    // vWorldPosition = normalize(position);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.z = gl_Position.w;\n}\n", fragmentShader: xp + "\n#define GLSLIFY 1\n/*\n * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW \n * implementation of Sebastian Hillare's Unreal engine sky-atmosphere\n * ... still doesn't implement aerial perspective lut, just makes space views possible\n* TODO: replace sunflare with something new that works\n        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)\n */\n\n/*\n * Final output basically looks up the value from the skyLUT, and then adds a sun on top,\n * does some tonemapping.\n */\n#include <common>\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelResolution0;\nuniform sampler2D iChannel1;\nuniform vec2 iChannelResolution1;\nuniform sampler2D iChannel2;\nuniform vec2 iChannelResolution2;\nuniform vec2 iResolution;\nuniform vec3 cameraDirection;\nuniform vec3 upDirection;\n\nconst vec3 grayColor = vec3(0.5, 0.5, 0.5);\n\nvec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {\n\n    vec3 viewPos = getViewPos(0.);\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n    // uv *= skyLUTRes;\n    // uv /= iChannelResolution1.xy;\n\n    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;\n    return texture(iChannel1, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {\n    const float sunSolidAngle = 0.01*PI/180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta >= minSunCosTheta) return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset*50000.0)*0.5;\n    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\nvec4 toLinear(vec4 sRGB)\n{\n	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n	vec4 lower = sRGB/vec4(12.92);\n\n	return mix(higher, lower, cutoff);\n}\n\nvoid main() {\n    vec3 sunDir = getSunDir(0.);\n    vec3 viewPos = getViewPos(0.);\n\n    vec3 camDir = normalize(cameraDirection);\n    float camFOVWidth = PI/3.0;\n    // vec2 iResolution = vec2(1102, 1246);\n    float camWidthScale = 2.0*tan(camFOVWidth/2.0);\n    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;\n\n    vec3 camRight = normalize(cross(camDir, upDirection));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    // camRight = viewMatrix[0].xzy;\n    // camUp = viewMatrix[1].xzy;\n    // camDir = viewMatrix[2].xzy;\n    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;\n    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);\n    vec3 rayDir = normalize(vWorldPosition.xzy);\n    vec3 lum;\n\n    if (length(viewPos) < atmosphereRadiusMM * 1.0){\n        lum = getValFromSkyLUT(rayDir, sunDir);\n    } else {\n    \n        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere\n        lum = raymarchScattering(iChannel0, iChannelResolution0.xy,\n                                 iChannel2, iChannelResolution2.xy,\n                                 viewPos, rayDir, sunDir, float(numScatteringSteps));\n        \n        // This little bit of red helps to debug when the rendering switches to pure raymarching\n        //lum += vec3(1e-3,0.0,0.0);\n    }\n\n    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.\n    lum *= 100.0;\n    lum = jodieReinhardTonemap(lum);\n    lum = pow(lum, vec3(1.0/2.2));\n\n    // lum += sunWithBloom(rayDir, sunDir);\n     // Bloom should be added at the end, but this is subtle and works well.\n    vec3 sunLum = sunWithBloom(rayDir, sunDir);\n    // Use smoothstep to limit the effect, so it drops off to actual zero.\n    sunLum = smoothstep(0.002, 1.0, sunLum);\n    if (length(sunLum) > 0.0) {\n        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {\n            sunLum *= 0.0;\n        } else {\n            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.\n            sunLum *= getValFromTLUT(iChannel0, iChannelResolution0.xy, viewPos, sunDir);\n        }\n    }\n    lum += sunLum;\n\n    gl_FragColor = vec4(lum,1.0);\n    gl_FragColor = toLinear(gl_FragColor);\n\n    // gl_FragColor.rgb = vWorldPosition;\n    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));\n    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);\n    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));\n    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;\n    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;\n    // gl_FragColor.z += cloudDensity;\n    // Peek at the Transmittance LUT\n    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {\n        // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);\n    // }\n    // fragColor = vec4(100.*texture(iChannel0, fragCoord.xy/iResolution.xy).rgb,1.0);\n       \n    // Peek at the Sky View LUT\n    // gl_FragColor = vec4(8.*texture(iChannel1, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);\n\n    // Peek at the Multiscattering LUT\n    //fragColor = vec4(100.*texture(iChannel2, fragCoord.xy/iResolution.xy).rgb,1.0);\n//if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {\n     // gl_FragColor = vec4(100.*texture(iChannel2, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);\n// }\n    // gl_FragColor = vec4(100.*texture(iChannel0, gl_FragCoord.xy/iChannelResolution0 * 0.1).rgb,1.0);\n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n}\n" }, bp = { uniforms: { altitude: { value: 2.8 }, viewHeight: { value: 2e-4 } }, vertexShader: vp, fragmentShader: xp + "\n#define GLSLIFY 1\n// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the transmittance from that point to sun, through the atmosphere.\nvarying vec2 vUv;\nvec3 getSunTransmittance(vec3 pos, vec3 sunDir) {\n    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {\n        return vec3(0.0);\n    }\n\n    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);\n    float t = 0.0;\n\n    vec3 transmittance = vec3(1.0);\n    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {\n        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*sunDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        transmittance *= exp(-dt*extinction);\n    }\n    return transmittance;\n}\n\nvoid main()\n{\n    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;\n    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);\n}\n" }, Mp = { uniforms: { altitude: { value: 2.8 }, iChannel0: { value: null }, iChannelResolution0: { value: [256, 256] }, viewHeight: { value: 2e-4 } }, vertexShader: vp, fragmentShader: xp + "\n#define GLSLIFY 1\n// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).\nvarying vec2 vUv;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelResolution0;\nvec3 getSphericalDir(float theta, float phi) {\n     float cosPhi = cos(phi);\n     float sinPhi = sin(phi);\n     float cosTheta = cos(theta);\n     float sinTheta = sin(theta);\n     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);\n}\n\n// Calculates Equation (5) and (7) from the paper.\nvoid getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {\n    lumTotal = vec3(0.0);\n    fms = vec3(0.0);\n\n    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);\n    for (int i = 0; i < sqrtSamples; i++) {\n        for (int j = 0; j < sqrtSamples; j++) {\n            // This integral is symmetric about theta = 0 (or theta = PI), so we\n            // only need to integrate from zero to PI, not zero to 2*PI.\n            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);\n            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));\n            vec3 rayDir = getSphericalDir(theta, phi);\n\n            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);\n            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);\n            float tMax = atmoDist;\n            if (groundDist > 0.0) {\n                tMax = groundDist;\n            }\n\n            float cosTheta = dot(rayDir, sunDir);\n\n            float miePhaseValue = getMiePhase(cosTheta);\n            float rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);\n            float t = 0.0;\n            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {\n                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;\n                float dt = newT - t;\n                t = newT;\n\n                vec3 newPos = pos + t*rayDir;\n\n                vec3 rayleighScattering, extinction;\n                float mieScattering;\n                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n                vec3 sampleTransmittance = exp(-dt*extinction);\n\n                // Integrate within each segment.\n                vec3 scatteringNoPhase = rayleighScattering + mieScattering;\n                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;\n                lumFactor += transmittance*scatteringF;\n\n                // This is slightly different from the paper, but I think the paper has a mistake?\n                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).\n                vec3 sunTransmittance = getValFromTLUT(iChannel0, iChannelResolution0.xy, newPos, sunDir);\n\n                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;\n                float mieInScattering = mieScattering*miePhaseValue;\n                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;\n\n                // Integrated scattering within path segment.\n                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n                lum += scatteringIntegral*transmittance;\n                transmittance *= sampleTransmittance;\n            }\n\n            if (groundDist > 0.0) {\n                vec3 hitPos = pos + groundDist*rayDir;\n                if (dot(pos, sunDir) > 0.0) {\n                    hitPos = normalize(hitPos)*groundRadiusMM;\n                    lum += transmittance*groundAlbedo*getValFromTLUT(iChannel0, iChannelResolution0.xy, hitPos, sunDir);\n                }\n            }\n\n            fms += lumFactor*invSamples;\n            lumTotal += lum*invSamples;\n        }\n    }\n}\n\nvoid main()\n{\n    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    vec3 lum, f_ms;\n    getMulScattValues(pos, sunDir, lum, f_ms);\n\n    // Equation 10 from the paper.\n    vec3 psi = lum  / (1.0 - f_ms);\n    gl_FragColor = vec4(1. * psi, 1.0);\n    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);\n}\n" }, Sp = { uniforms: { altitude: { value: 2.8 }, iChannel0: { value: null }, iChannelResolution0: { value: [256, 256] }, iChannel1: { value: null }, iChannelResolution1: { value: [256, 256] }, viewHeight: { value: 2e-4 }, mixGrayFactor: { value: 0 } }, vertexShader: vp, fragmentShader: xp + "\n#define GLSLIFY 1\n// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),\n// but the latitude/altitude is non-linear to get more resolution near the horizon.\nvarying vec2 vUv;\nuniform sampler2D iChannel0;\nuniform vec2 iChannelResolution0;\nuniform sampler2D iChannel1;\nuniform vec2 iChannelResolution1;\nuniform float mixGrayFactor;\n\nvoid main() {\n    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;\n\n    float azimuthAngle = (u - 0.5)*2.0*PI;\n\n    // Non-linear mapping of altitude. See Section 5.3 of the paper.\n\n    float adjV;\n    if (v < 0.5) {\n		float coord = 1.0 - 2.0*v;\n		adjV = -coord*coord;\n	} else {\n		float coord = v*2.0 - 1.0;\n		adjV = coord*coord;\n	}\n\n    vec3 viewPos = getViewPos(0.);\n\n    float height = length(viewPos); vec3 up = viewPos / height;\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;\n    float altitudeAngle = adjV*0.5*PI - horizonAngle;\n\n    float cosAltitude = cos(altitudeAngle);\n    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));\n\n    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));\n    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));\n\n    vec3 lum = raymarchScattering(iChannel0, iChannelResolution0.xy,\n                                  iChannel1, iChannelResolution1.xy,\n                                  viewPos, rayDir, sunDir, float(numScatteringSteps));\n    gl_FragColor = vec4(lum, 1.0);\n\n    if (mixGrayFactor > 0.0) {\n        lum = gl_FragColor.xyz;\n        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);\n        lum = mix(lum, gray, mixGrayFactor);\n        gl_FragColor = vec4(lum, 1.0);\n    }\n}\n" };
      class wp extends Mi {
        constructor() {
          super(), __publicField(this, "_fsQuad"), __publicField(this, "_hasPaintedScatterBuffer"), __publicField(this, "_scatteringMaterial"), __publicField(this, "_scatteringRenderTarget"), __publicField(this, "_transmittanceMaterial"), __publicField(this, "_transmittanceRenderTarget"), __publicField(this, "_viewMaterial"), __publicField(this, "_viewRenderTarget"), this.geometry = new ga(1, 32, 32), this.frustumCulled = false;
          const e2 = [256, 64], t2 = [32, 32], i2 = [400, 400], n2 = this._transmittanceRenderTarget = new we(e2[0], e2[1], { type: x, depthBuffer: false });
          n2.texture.name = "SkyAtomsphere.transmittance", this._transmittanceMaterial = new Ai({ uniforms: Ci.clone(bp.uniforms), vertexShader: bp.vertexShader, fragmentShader: bp.fragmentShader });
          const r2 = this._scatteringRenderTarget = new we(t2[0], t2[1], { type: x, depthBuffer: false });
          r2.texture.name = "SkyAtomsphere.scattering", this._scatteringMaterial = new Ai({ uniforms: Ci.clone(Mp.uniforms), vertexShader: Mp.vertexShader, fragmentShader: Mp.fragmentShader }), this._scatteringMaterial.uniforms.iChannel0.value = n2.texture, this._scatteringMaterial.uniforms.iChannelResolution0.value = [e2[0], e2[1]], this._fsQuad = new Sl(null);
          const s2 = this._viewRenderTarget = new we(i2[0], i2[1], { type: x, depthBuffer: false });
          s2.texture.name = "SkyAtomsphere.view";
          const a2 = this._viewMaterial = new Ai({ uniforms: Ci.clone(Sp.uniforms), vertexShader: Sp.vertexShader, fragmentShader: Sp.fragmentShader });
          a2.uniforms.iChannel0.value = n2.texture, a2.uniforms.iChannelResolution0.value = [e2[0], e2[1]], a2.uniforms.iChannel1.value = r2.texture, a2.uniforms.iChannelResolution1.value = [t2[0], t2[1]];
          const o2 = this.material = new Ai({ uniforms: Ci.clone(yp.uniforms), vertexShader: yp.vertexShader, fragmentShader: yp.fragmentShader, side: 2 });
          o2.uniforms.iChannel0.value = n2.texture, o2.uniforms.iChannelResolution0.value = [e2[0], e2[1]], o2.uniforms.iChannel2.value = r2.texture, o2.uniforms.iChannelResolution2.value = [t2[0], t2[1]], o2.uniforms.iChannel1.value = s2.texture, o2.uniforms.iChannelResolution1.value = [i2[0], i2[1]], this._fsQuad = new Sl(null), this.scale.multiplyScalar(1e4), this.altitude = 0;
        }
        onBeforeRender(e2, t2, i2) {
        }
        updateRenderTargets(e2, t2) {
          const i2 = this._fsQuad;
          this._hasPaintedScatterBuffer || (i2.material = this._transmittanceMaterial, e2.setRenderTarget(this._transmittanceRenderTarget), e2.clear(), i2.render(e2), i2.material = this._scatteringMaterial, e2.setRenderTarget(this._scatteringRenderTarget), e2.clear(), i2.render(e2), this._hasPaintedScatterBuffer = true), i2.material = this._viewMaterial, e2.setRenderTarget(this._viewRenderTarget), e2.clear(), i2.render(e2), e2.setRenderTarget(null);
        }
        dispose() {
          this.geometry.dispose(), this._transmittanceRenderTarget.dispose(), this._scatteringRenderTarget.dispose(), this._viewRenderTarget.dispose(), this._transmittanceMaterial.dispose(), this._scatteringMaterial.dispose(), this._viewMaterial.dispose(), this.material.dispose(), this._fsQuad.dispose();
        }
        get altitude() {
          return this.material.uniforms.altitude.value;
        }
        set altitude(e2) {
          this._transmittanceMaterial.uniforms.altitude.value = e2, this._scatteringMaterial.uniforms.altitude.value = e2, this._viewMaterial.uniforms.altitude.value = e2, this.material.uniforms.altitude.value = e2;
        }
        get mixGrayFactor() {
          return this._viewMaterial.uniforms.mixGrayFactor.value;
        }
        set mixGrayFactor(e2) {
          this._viewMaterial.uniforms.mixGrayFactor.value = e2;
        }
      }
      const Tp = { weatherMap: { value: null }, noiseMap: { value: null }, blueNoiseMap: { value: null }, shapeNoiseMap: { value: null }, coverage: { value: 0.8 }, density: { value: 6 }, time: { value: 0 }, speed: { value: 1 }, sizeScale: { value: 0.5 }, skyMap: { value: null }, sunLightMap: { value: null }, skyAltitude: { value: 2.8 }, thicknessBias: { value: 0 }, thicknessScale: { value: 1 }, mixGrayFactor: { value: 0 }, sunColor: { value: [1, 0.95, 0.85] } }, Ep = "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    // vWorldPosition = normalize(position);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);\n    float skyZ = mix(0.1, 0.002, clamp(length(position.xy) * 1.0, 0.0, 1.0));\n    // float skyZ = mix(0.1, 0.002, length(position.xy));\n    vWorldPosition = (modelMatrix * vec4(position.x, position.y, skyZ, 1.0)).xyz - vec3(cameraPosition.xy, cameraPosition.z);\n    vWorldPosition = normalize(vWorldPosition);\n    \n    vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    worldPosition -= cameraPosition;\n    float disToCenter = length(worldPosition.xy);\n    float c = sqrt(pow(6300000.0, 2.0) + pow(disToCenter, 2.0));\n    worldPosition.z = clamp(6300400.0 - c, 0.0, 400.0);\n    vWorldPosition = worldPosition / 1000.0;\n    // float radiusZ = clamp(sqrt(0.5 * 0.5 - pow(length(position.xy), 2.0)), 0.0, 0.5);\n    // vWorldPosition.z = clamp(sqrt(1.0 - pow(length(vWorldPosition.xy), 2.0)), 0.0, 1.0);\n    // vWorldPosition = normalize(vec3(position.x, position.y, skyZ * 1.));\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y, skyZ), 1.0);\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition + vec3(cameraPosition.xyz), 1.0);\n    // gl_Position.z = gl_Position.w;\n}\n", Cp = "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\n\nuniform sampler2D weatherMap;\nuniform sampler2D noiseMap;\nuniform sampler2D blueNoiseMap;\nuniform sampler2D shapeNoiseMap;\nuniform sampler2D skyMap;\nuniform sampler2D sunLightMap;\nuniform float coverage;\nuniform float time;\nuniform float speed;\nuniform float sizeScale;\n// uniform float thinkness;\nuniform float thicknessBias;\nuniform float thicknessScale;\nuniform float density;\nuniform vec3 sunColor;\n\nuniform float skyAltitude;\nuniform float mixGrayFactor;\nconst float groundRadiusMM = 6.371;\n\nconst float cloud_inscatter = 0.2;\nconst float cloud_silver_intensity = 2.5;\nconst float cloud_silver_exponent = 2.0;\nconst float cloud_outscatter = 0.1;\nconst float cloud_in_vs_outscatter = 0.5;\nconst float cloud_beer = 1.0;\nconst float cloud_attuention_clampval = 0.2;\nconst float cloud_outscatter_ambient = 0.9;\nconst float cloud_ambient_minimum = 0.2;\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\nvec3 getSunDir() {\n    return normalize(vec3(cos(skyAltitude), sin(skyAltitude), 0.0));\n}\n\nvec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0004, 0.0);\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n\n    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);\n    return texture(skyMap, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec4 toLinear(vec4 sRGB)\n{\n	bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n	vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n	vec4 lower = sRGB/vec4(12.92);\n\n	return mix(higher, lower, cutoff);\n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn) {\n    return ln + (v - l0) * (hn - ln) / (h0 - l0);\n}\n\nconst float slice = 1.0 / 128.0;\nvec4 texture3DNoise(sampler2D noiseTexture, vec2 uv, float z_percent) {\n    uv = mod(uv, 1.0);\n    uv.x *= slice;\n    float num = float(int(z_percent / slice));\n    float alpha = mod(z_percent, slice) / slice;\n    vec4 val1 = texture2D(noiseTexture, vec2(uv.x + num * slice, uv.y));\n    vec4 val2 = texture2D(noiseTexture, vec2(uv.x + (num + 1.0) * slice, uv.y));\n    return mix(val1, val2, alpha);\n}\n\nfloat getCloud(vec3 pos) {\n    vec2 cloudUV = pos.xy * 0.1;\n    float uvOffset = time / 1000000.0 * speed;\n    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    float ph = clamp((pos.z - 0.4) / 0.6, 0.0, 1.0);\n    float srb = saturate(remap(ph, 0.0, 0.007, 0.0, 1.0));\n    float wh = 1.0; // weatherColor.z;\n    float srt = saturate(remap(ph, wh * 0.2, wh, 1.0, 0.0));\n    float sa = srb * srt;\n    float drb = ph * saturate(remap(ph, 0.0, 0.15, 0.0, 1.0));\n    float drt = saturate(remap(ph, 0.9, 1.0, 1.0, 0.0));\n    float da = density * drb * drt /** weatherColor.w*/ * 2.0;\n    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    // vec4 texture3DNoise = texture3DNoise(shapeNoiseMap, cloudUV, ph);\n    // float sn_sample = texture3DNoise.x;\n    float sn = saturate(remap(sn_sample * sa, 1.0 - coverage * wmc, 1.0, 0.0, 1.0)) * da;\n    return sn;\n}\n\nfloat HG(float cos_angle, float g) {\n    float g2 = g * g;\n    float val = ((1.0 - g2) / pow( 1.0 + g2 - 2.0 * g * cos_angle, 1.5)) / 4.0 * 3.1415;\n    return val; \n}\nfloat InOutScatter(float cos_angle) {\n    float first_hg = HG(cos_angle, cloud_inscatter);\n    float second_hg = cloud_silver_intensity * pow(saturate(cos_angle), cloud_silver_exponent);\n    float in_scatter_hg = max(first_hg, second_hg); \n    float out_scatter_hg = HG(cos_angle, -cloud_outscatter);\n    return mix(in_scatter_hg, out_scatter_hg, cloud_in_vs_outscatter);\n}\nfloat Attenuation(float density_to_sun, float cos_angle){\n    float prim = exp(-cloud_beer * density_to_sun);\n    float scnd = exp(-cloud_beer * cloud_attuention_clampval) * 0.7;\n    // reduce clamping while facing the sun\n    float checkval = remap(cos_angle, 0.0, 1.0, scnd, scnd * 0.5); \n    return max(checkval, prim);\n}\nfloat OutScatterAmbient(float density,float percent_height){\n    float depth = cloud_outscatter_ambient * pow(density ,remap(percent_height, 0.3, 0.9, 0.5, 1.0));\n    float vertical = pow(saturate(remap(percent_height, 0.0, 0.3, 0.8, 1.0)), 0.8);\n    float out_scatter = depth * vertical;\n    out_scatter = 1.0 - saturate(out_scatter);\n    return out_scatter; \n}\n\nvec3 CalculateLight(vec3 sunLightColor, float density, float density_to_sun, float\n    cos_angle , float percent_height, float bluenoise, float dist_along_ray ){\n    float attenuation_prob = Attenuation(density_to_sun, cos_angle);\n    float ambient_out_scatter = OutScatterAmbient(density,percent_height);\n    // be calculated once for each march but gave no/tiny perf improvements.\n    float sun_highlight = InOutScatter(cos_angle);\n    float attenuation = attenuation_prob * sun_highlight * ambient_out_scatter;\n    //Ambient min (dist_along_ray used so that far away regions (huge steps ) arent calculated (wrongly))\n    attenuation = max(density * cloud_ambient_minimum * (1.0 - pow(saturate(dist_along_ray/4000.0), 2.0)), attenuation);\n    // combat banding a bit more\n    attenuation += bluenoise * 0.003;\n    vec3 ret_color = attenuation * sunLightColor;\n    return ret_color; \n}\n\n#ifndef MVT_CLOUD_VOLUMETRIC\nvec4 computePlanarCloud() {\n    vec2 cloudUV = vWorldPosition.xy * 0.1;\n    float uvOffset = time / 1000000.0 * speed;\n    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);\n    // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)\n    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));\n \n    float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);\n    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);\n    vec3 cloudColor = vec3(remap(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));\n\n    // 太阳散射，根据厚度发生变化\n    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;\n    if (mixGrayFactor > 0.0) {\n        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);\n        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);\n    }\n    cloudColor = sunLightColor;\n    cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));\n    \n    // 天空大气颜色\n    vec3 sunDir = getSunDir();\n    vec3 rayDir = normalize(vWorldPosition.xzy);\n\n    cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);\n\n    vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);\n    atmosphereColor *= 100.0;\n    atmosphereColor = jodieReinhardTonemap(atmosphereColor);\n    atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));\n    atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;\n\n    float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);\n    atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);\n    cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);\n\n    // 和天空大气混合\n    cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));\n\n    // cloudColor = atmosphereColor; // lum;\n    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;\n    return vec4(cloudColor, cloudAlpha);\n}\n#endif\n\n#ifdef MVT_CLOUD_VOLUMETRIC\nvec4 computeVolumetricCloud() {\n    // vec2 cloudUV = vUv * 1.0;\n    // vec2 cloudUV = vWorldPosition.xy * 0.1;\n    // float uvOffset = time / 1000000.0 * speed;\n    // vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    // float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    // // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);\n    // // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)\n    // vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    // float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    // float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));\n\n    vec3 sunDir = getSunDir();\n    vec3 direction = normalize(vWorldPosition);\n    vec3 samplePos = vec3(vWorldPosition.xy, 0.4);\n    float directDensity = 0.0;\n    float sunDensity = 0.0;\n    vec3 cloudColor = vec3(0.0);\n\n    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;\n    if (mixGrayFactor > 0.0) {\n        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);\n        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);\n    }\n    float step = 0.6 / float(MVT_NUM_SAMPLE_STEPS);\n    vec2 cloudUV = samplePos.xy * 0.1;\n    for (int i = 0; i < MVT_NUM_SAMPLE_STEPS; i += 1) {\n        float blueNoise = (texture2D(blueNoiseMap, cloudUV) - 0.5).x * 0.1;\n        samplePos += direction * step * (1.0 + blueNoise);\n        float directSampleInfo = getCloud(samplePos);\n        directDensity += directSampleInfo;\n        vec3 sunPos = samplePos + sunDir * 0.05;\n        float sunSampleInfo = getCloud(sunPos);\n        sunDensity += directSampleInfo;\n        sunDensity += sunSampleInfo;\n\n        float ph = clamp((samplePos.z - 0.4) / 0.6, 0.0, 1.0);\n        cloudColor += CalculateLight(sunLightColor, (1.0 - directDensity) * 1.0, sunDensity * 0.5, dot(direction, sunDir.xzy), ph, 0.1, 10.0);\n    \n        // cloudColor += sunColor * clamp(1.0 - directSampleInfo - sunSampleInfo, 0.0, 1.0);\n        // cloudColor += CalculateLight(sunLightColor, 1.0 - directSampleInfo, sunSampleInfo, dot(direction, sunDir.xzy), ph, 0.1, float(i));\n        if (directDensity > 1.0) {\n            directDensity = 1.0;\n            break;\n        }\n    }\n    // float densityScale = 1.0 / sampleSteps * 20.0;\n    // float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);\n    // directDensity /= float(MVT_NUM_SAMPLE_STEPS);\n    sunDensity /= float(MVT_NUM_SAMPLE_STEPS);\n    // cloudColor += CalculateLight(sunLightColor, directDensity, sunDensity, dot(direction, sunDir.xzy), 0.2, 0.1, 10.0);\n    float cloudAlpha = clamp(directDensity, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);\n    // cloudColor = sunColor * dot(direction, sunDir) * exp(-0.3 * clamp(sunDensity, 0.0, 1.0));\n    // cloudColor = jodieReinhardTonemap(cloudColor);\n\n   \n    return vec4(cloudColor, cloudAlpha);\n}\n#endif\n\nvoid main() {\n    #ifdef MVT_CLOUD_VOLUMETRIC\n        gl_FragColor = computeVolumetricCloud();\n    #else\n        gl_FragColor = computePlanarCloud();\n    #endif\n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n}\n";
      class Ap extends Mi {
        constructor() {
          super(), this.geometry = new ga(2, 12, 12, 0, 2 * Math.PI, 0, Math.PI), this.frustumCulled = false;
          (this.material = new Ai({ uniforms: Ci.clone(Tp), vertexShader: Ep, fragmentShader: Cp, side: 2, transparent: true, defines: { MVT_NUM_SAMPLE_STEPS: 4 } })).uniforms.sunLightMap.value = this.createGradientMap(), this.rotateX(Math.PI / 2), this.scale.multiplyScalar(7e4);
        }
        createGradientMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 2;
          let t2 = e2.getContext("2d"), i2 = t2.createLinearGradient(0, 0, 64, 0);
          return i2.addColorStop(0, "rgb(0,0,0)"), i2.addColorStop(0.45, "rgb(0,0,0)"), i2.addColorStop(0.5, "rgb(200,30,10)"), i2.addColorStop(0.52, "rgb(220,80,20)"), i2.addColorStop(0.58, "rgb(255,255,255)"), i2.addColorStop(1, "rgb(255,255,255)"), t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap = new da(e2), this._cachedGradientMap;
        }
        dispose() {
          this._cachedGradientMap.dispose();
        }
        get speed() {
          return this.material.uniforms.speed.value;
        }
        set speed(e2) {
          this.material.uniforms.speed.value = e2;
        }
        get coverage() {
          return this.material.uniforms.coverage.value;
        }
        set coverage(e2) {
          this.material.uniforms.coverage.value = e2;
        }
        get density() {
          return this.material.uniforms.density.value;
        }
        set density(e2) {
          this.material.uniforms.density.value = e2;
        }
        get sizeScale() {
          return this.material.uniforms.sizeScale.value;
        }
        set sizeScale(e2) {
          this.material.uniforms.sizeScale.value = e2;
        }
        get skyAltitude() {
          return this.material.uniforms.skyAltitude.value;
        }
        set skyAltitude(e2) {
          this.material.uniforms.skyAltitude.value = e2;
        }
        get thicknessBias() {
          return this.material.uniforms.thicknessBias.value;
        }
        set thicknessBias(e2) {
          this.material.uniforms.thicknessBias.value = e2;
        }
        get thicknessScale() {
          return this.material.uniforms.thicknessScale.value;
        }
        set thicknessScale(e2) {
          this.material.uniforms.thicknessScale.value = e2;
        }
        get mixGrayFactor() {
          return this.material.uniforms.mixGrayFactor.value;
        }
        set mixGrayFactor(e2) {
          this.material.uniforms.mixGrayFactor.value = e2;
        }
        get sampleSteps() {
          return this.material.defines.MVT_NUM_SAMPLE_STEPS;
        }
        set sampleSteps(e2) {
          e2 !== this.material.defines.MVT_NUM_SAMPLE_STEPS && (this.material.defines.MVT_NUM_SAMPLE_STEPS = parseInt(e2, 10), this.material.needsUpdate = true);
        }
        get volumetric() {
          return void 0 !== this.material.defines.MVT_CLOUD_VOLUMETRIC;
        }
        set volumetric(e2) {
          e2 ? this.material.defines.MVT_CLOUD_VOLUMETRIC = "" : delete this.material.defines.MVT_CLOUD_VOLUMETRIC, this.material.needsUpdate = true;
        }
      }
      new Ae(), new ge(16777215);
      class Pp extends Va {
        constructor(e2) {
          super(e2), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e3) {
            return new Op(e3);
          }), this.register(function(e3) {
            return new Gp(e3);
          }), this.register(function(e3) {
            return new Hp(e3);
          }), this.register(function(e3) {
            return new zp(e3);
          }), this.register(function(e3) {
            return new Np(e3);
          }), this.register(function(e3) {
            return new kp(e3);
          }), this.register(function(e3) {
            return new Bp(e3);
          }), this.register(function(e3) {
            return new Fp(e3);
          }), this.register(function(e3) {
            return new Vp(e3);
          }), this.register(function(e3) {
            return new Up(e3);
          }), this.register(function(e3) {
            return new Ip(e3);
          }), this.register(function(e3) {
            return new jp(e3);
          });
        }
        load(e2, t2, i2, n2) {
          const r2 = this;
          let s2;
          s2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : ho.extractUrlBase(e2), this.manager.itemStart(e2);
          const a2 = function(t3) {
            n2 ? n2(t3) : console.error(t3), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
          }, o2 = new Ha(this.manager);
          o2.setPath(this.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(e2, function(i3) {
            try {
              r2.parse(i3, s2, function(i4) {
                t2(i4), r2.manager.itemEnd(e2);
              }, a2);
            } catch (rl2) {
              a2(rl2);
            }
          }, i2, a2);
        }
        setDRACOLoader(e2) {
          return this.dracoLoader = e2, this;
        }
        setDDSLoader() {
          throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
        }
        setKTX2Loader(e2) {
          return this.ktx2Loader = e2, this;
        }
        setMeshoptDecoder(e2) {
          return this.meshoptDecoder = e2, this;
        }
        register(e2) {
          return -1 === this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.push(e2), this;
        }
        unregister(e2) {
          return -1 !== this.pluginCallbacks.indexOf(e2) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e2), 1), this;
        }
        parse(e2, t2, i2, n2) {
          let r2;
          const s2 = {}, a2 = {};
          if ("string" == typeof e2)
            r2 = e2;
          else {
            if (ho.decodeText(new Uint8Array(e2, 0, 4)) === Wp) {
              try {
                s2[Lp.KHR_BINARY_GLTF] = new Yp(e2);
              } catch (h2) {
                return void (n2 && n2(h2));
              }
              r2 = s2[Lp.KHR_BINARY_GLTF].content;
            } else
              r2 = ho.decodeText(new Uint8Array(e2));
          }
          const o2 = JSON.parse(r2);
          if (void 0 === o2.asset || o2.asset.version[0] < 2)
            return void (n2 && n2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
          const l2 = new Em(o2, { path: t2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
          l2.fileLoader.setRequestHeader(this.requestHeader);
          for (let c2 = 0; c2 < this.pluginCallbacks.length; c2++) {
            const e3 = this.pluginCallbacks[c2](l2);
            a2[e3.name] = e3, s2[e3.name] = true;
          }
          if (o2.extensionsUsed)
            for (let c2 = 0; c2 < o2.extensionsUsed.length; ++c2) {
              const e3 = o2.extensionsUsed[c2], t3 = o2.extensionsRequired || [];
              switch (e3) {
                case Lp.KHR_MATERIALS_UNLIT:
                  s2[e3] = new Dp();
                  break;
                case Lp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                  s2[e3] = new Qp();
                  break;
                case Lp.KHR_DRACO_MESH_COMPRESSION:
                  s2[e3] = new Zp(o2, this.dracoLoader);
                  break;
                case Lp.KHR_TEXTURE_TRANSFORM:
                  s2[e3] = new Jp();
                  break;
                case Lp.KHR_MESH_QUANTIZATION:
                  s2[e3] = new $p();
                  break;
                default:
                  t3.indexOf(e3) >= 0 && void 0 === a2[e3] && console.warn('THREE.GLTFLoader: Unknown extension "' + e3 + '".');
              }
            }
          l2.setExtensions(s2), l2.setPlugins(a2), l2.parse(i2, n2);
        }
        parseAsync(e2, t2) {
          const i2 = this;
          return new Promise(function(n2, r2) {
            i2.parse(e2, t2, n2, r2);
          });
        }
      }
      function Rp() {
        let e2 = {};
        return { get: function(t2) {
          return e2[t2];
        }, add: function(t2, i2) {
          e2[t2] = i2;
        }, remove: function(t2) {
          delete e2[t2];
        }, removeAll: function() {
          e2 = {};
        } };
      }
      const Lp = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
      class Ip {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
        }
        _markDefs() {
          const e2 = this.parser, t2 = this.parser.json.nodes || [];
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
            const n3 = t2[i2];
            n3.extensions && n3.extensions[this.name] && void 0 !== n3.extensions[this.name].light && e2._addNodeRef(this.cache, n3.extensions[this.name].light);
          }
        }
        _loadLight(e2) {
          const t2 = this.parser, i2 = "light:" + e2;
          let n2 = t2.cache.get(i2);
          if (n2)
            return n2;
          const r2 = t2.json, s2 = ((r2.extensions && r2.extensions[this.name] || {}).lights || [])[e2];
          let a2;
          const o2 = new ge(16777215);
          void 0 !== s2.color && o2.fromArray(s2.color);
          const l2 = void 0 !== s2.range ? s2.range : 0;
          switch (s2.type) {
            case "directional":
              a2 = new lo(o2), a2.target.position.set(0, 0, -1), a2.add(a2.target);
              break;
            case "point":
              a2 = new ao(o2), a2.distance = l2;
              break;
            case "spot":
              a2 = new to(o2), a2.distance = l2, s2.spot = s2.spot || {}, s2.spot.innerConeAngle = void 0 !== s2.spot.innerConeAngle ? s2.spot.innerConeAngle : 0, s2.spot.outerConeAngle = void 0 !== s2.spot.outerConeAngle ? s2.spot.outerConeAngle : Math.PI / 4, a2.angle = s2.spot.outerConeAngle, a2.penumbra = 1 - s2.spot.innerConeAngle / s2.spot.outerConeAngle, a2.target.position.set(0, 0, -1), a2.add(a2.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + s2.type);
          }
          return a2.position.set(0, 0, 0), a2.decay = 2, void 0 !== s2.intensity && (a2.intensity = s2.intensity), a2.name = t2.createUniqueName(s2.name || "light_" + e2), n2 = Promise.resolve(a2), t2.cache.add(i2, n2), n2;
        }
        createNodeAttachment(e2) {
          const t2 = this, i2 = this.parser, n2 = i2.json.nodes[e2], r2 = (n2.extensions && n2.extensions[this.name] || {}).light;
          return void 0 === r2 ? null : this._loadLight(r2).then(function(e3) {
            return i2._getNodeRef(t2.cache, r2, e3);
          });
        }
      }
      class Dp {
        constructor() {
          this.name = Lp.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return jt;
        }
        extendParams(e2, t2, i2) {
          const n2 = [];
          e2.color = new ge(1, 1, 1), e2.opacity = 1;
          const r2 = t2.pbrMetallicRoughness;
          if (r2) {
            if (Array.isArray(r2.baseColorFactor)) {
              const t3 = r2.baseColorFactor;
              e2.color.fromArray(t3), e2.opacity = t3[3];
            }
            void 0 !== r2.baseColorTexture && n2.push(i2.assignTexture(e2, "map", r2.baseColorTexture, U));
          }
          return Promise.all(n2);
        }
      }
      class Fp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser.json.materials[e2];
          if (!i2.extensions || !i2.extensions[this.name])
            return Promise.resolve();
          const n2 = i2.extensions[this.name].emissiveStrength;
          return void 0 !== n2 && (t2.emissiveIntensity = n2), Promise.resolve();
        }
      }
      class Op {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [], s2 = n2.extensions[this.name];
          if (void 0 !== s2.clearcoatFactor && (t2.clearcoat = s2.clearcoatFactor), void 0 !== s2.clearcoatTexture && r2.push(i2.assignTexture(t2, "clearcoatMap", s2.clearcoatTexture)), void 0 !== s2.clearcoatRoughnessFactor && (t2.clearcoatRoughness = s2.clearcoatRoughnessFactor), void 0 !== s2.clearcoatRoughnessTexture && r2.push(i2.assignTexture(t2, "clearcoatRoughnessMap", s2.clearcoatRoughnessTexture)), void 0 !== s2.clearcoatNormalTexture && (r2.push(i2.assignTexture(t2, "clearcoatNormalMap", s2.clearcoatNormalTexture)), void 0 !== s2.clearcoatNormalTexture.scale)) {
            const e3 = s2.clearcoatNormalTexture.scale;
            t2.clearcoatNormalScale = new ie(e3, e3);
          }
          return Promise.all(r2);
        }
      }
      class Up {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [], s2 = n2.extensions[this.name];
          return void 0 !== s2.iridescenceFactor && (t2.iridescence = s2.iridescenceFactor), void 0 !== s2.iridescenceTexture && r2.push(i2.assignTexture(t2, "iridescenceMap", s2.iridescenceTexture)), void 0 !== s2.iridescenceIor && (t2.iridescenceIOR = s2.iridescenceIor), void 0 === t2.iridescenceThicknessRange && (t2.iridescenceThicknessRange = [100, 400]), void 0 !== s2.iridescenceThicknessMinimum && (t2.iridescenceThicknessRange[0] = s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && (t2.iridescenceThicknessRange[1] = s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceThicknessTexture && r2.push(i2.assignTexture(t2, "iridescenceThicknessMap", s2.iridescenceThicknessTexture)), Promise.all(r2);
        }
      }
      class zp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [];
          t2.sheenColor = new ge(0, 0, 0), t2.sheenRoughness = 0, t2.sheen = 1;
          const s2 = n2.extensions[this.name];
          return void 0 !== s2.sheenColorFactor && t2.sheenColor.fromArray(s2.sheenColorFactor), void 0 !== s2.sheenRoughnessFactor && (t2.sheenRoughness = s2.sheenRoughnessFactor), void 0 !== s2.sheenColorTexture && r2.push(i2.assignTexture(t2, "sheenColorMap", s2.sheenColorTexture, U)), void 0 !== s2.sheenRoughnessTexture && r2.push(i2.assignTexture(t2, "sheenRoughnessMap", s2.sheenRoughnessTexture)), Promise.all(r2);
        }
      }
      class Np {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [], s2 = n2.extensions[this.name];
          return void 0 !== s2.transmissionFactor && (t2.transmission = s2.transmissionFactor), void 0 !== s2.transmissionTexture && r2.push(i2.assignTexture(t2, "transmissionMap", s2.transmissionTexture)), Promise.all(r2);
        }
      }
      class kp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [], s2 = n2.extensions[this.name];
          t2.thickness = void 0 !== s2.thicknessFactor ? s2.thicknessFactor : 0, void 0 !== s2.thicknessTexture && r2.push(i2.assignTexture(t2, "thicknessMap", s2.thicknessTexture)), t2.attenuationDistance = s2.attenuationDistance || 0;
          const a2 = s2.attenuationColor || [1, 1, 1];
          return t2.attenuationColor = new ge(a2[0], a2[1], a2[2]), Promise.all(r2);
        }
      }
      class Bp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_IOR;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser.json.materials[e2];
          if (!i2.extensions || !i2.extensions[this.name])
            return Promise.resolve();
          const n2 = i2.extensions[this.name];
          return t2.ior = void 0 !== n2.ior ? n2.ior : 1.5, Promise.resolve();
        }
      }
      class Vp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e2) {
          const t2 = this.parser.json.materials[e2];
          return t2.extensions && t2.extensions[this.name] ? ya : null;
        }
        extendMaterialParams(e2, t2) {
          const i2 = this.parser, n2 = i2.json.materials[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return Promise.resolve();
          const r2 = [], s2 = n2.extensions[this.name];
          t2.specularIntensity = void 0 !== s2.specularFactor ? s2.specularFactor : 1, void 0 !== s2.specularTexture && r2.push(i2.assignTexture(t2, "specularIntensityMap", s2.specularTexture));
          const a2 = s2.specularColorFactor || [1, 1, 1];
          return t2.specularColor = new ge(a2[0], a2[1], a2[2]), void 0 !== s2.specularColorTexture && r2.push(i2.assignTexture(t2, "specularColorMap", s2.specularColorTexture, U)), Promise.all(r2);
        }
      }
      class Gp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.KHR_TEXTURE_BASISU;
        }
        loadTexture(e2) {
          const t2 = this.parser, i2 = t2.json, n2 = i2.textures[e2];
          if (!n2.extensions || !n2.extensions[this.name])
            return null;
          const r2 = n2.extensions[this.name], s2 = t2.options.ktx2Loader;
          if (!s2) {
            if (i2.extensionsRequired && i2.extensionsRequired.indexOf(this.name) >= 0)
              throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
          }
          return t2.loadTextureImage(e2, r2.source, s2);
        }
      }
      class Hp {
        constructor(e2) {
          this.parser = e2, this.name = Lp.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e2) {
          const t2 = this.name, i2 = this.parser, n2 = i2.json, r2 = n2.textures[e2];
          if (!r2.extensions || !r2.extensions[t2])
            return null;
          const s2 = r2.extensions[t2], a2 = n2.images[s2.source];
          let o2 = i2.textureLoader;
          if (a2.uri) {
            const e3 = i2.options.manager.getHandler(a2.uri);
            null !== e3 && (o2 = e3);
          }
          return this.detectSupport().then(function(r3) {
            if (r3)
              return i2.loadTextureImage(e2, s2.source, o2);
            if (n2.extensionsRequired && n2.extensionsRequired.indexOf(t2) >= 0)
              throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i2.loadTexture(e2);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(e2) {
            const t2 = new Image();
            t2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t2.onload = t2.onerror = function() {
              e2(1 === t2.height);
            };
          })), this.isSupported;
        }
      }
      class jp {
        constructor(e2) {
          this.name = Lp.EXT_MESHOPT_COMPRESSION, this.parser = e2;
        }
        loadBufferView(e2) {
          const t2 = this.parser.json, i2 = t2.bufferViews[e2];
          if (i2.extensions && i2.extensions[this.name]) {
            const e3 = i2.extensions[this.name], n2 = this.parser.getDependency("buffer", e3.buffer), r2 = this.parser.options.meshoptDecoder;
            if (!r2 || !r2.supported) {
              if (t2.extensionsRequired && t2.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              return null;
            }
            return Promise.all([n2, r2.ready]).then(function(t3) {
              const i3 = e3.byteOffset || 0, n3 = e3.byteLength || 0, s2 = e3.count, a2 = e3.byteStride, o2 = new ArrayBuffer(s2 * a2), l2 = new Uint8Array(t3[0], i3, n3);
              return r2.decodeGltfBuffer(new Uint8Array(o2), s2, a2, l2, e3.mode, e3.filter), o2;
            });
          }
          return null;
        }
      }
      const Wp = "glTF", Xp = 1313821514, qp = 5130562;
      class Yp {
        constructor(e2) {
          this.name = Lp.KHR_BINARY_GLTF, this.content = null, this.body = null;
          const t2 = new DataView(e2, 0, 12);
          if (this.header = { magic: ho.decodeText(new Uint8Array(e2.slice(0, 4))), version: t2.getUint32(4, true), length: t2.getUint32(8, true) }, this.header.magic !== Wp)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const i2 = this.header.length - 12, n2 = new DataView(e2, 12);
          let r2 = 0;
          for (; r2 < i2; ) {
            const t3 = n2.getUint32(r2, true);
            r2 += 4;
            const i3 = n2.getUint32(r2, true);
            if (r2 += 4, i3 === Xp) {
              const i4 = new Uint8Array(e2, 12 + r2, t3);
              this.content = ho.decodeText(i4);
            } else if (i3 === qp) {
              const i4 = 12 + r2;
              this.body = e2.slice(i4, i4 + t3);
            }
            r2 += t3;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class Zp {
        constructor(e2, t2) {
          if (!t2)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          this.name = Lp.KHR_DRACO_MESH_COMPRESSION, this.json = e2, this.dracoLoader = t2, this.dracoLoader.preload();
        }
        decodePrimitive(e2, t2) {
          const i2 = this.json, n2 = this.dracoLoader, r2 = e2.extensions[this.name].bufferView, s2 = e2.extensions[this.name].attributes, a2 = {}, o2 = {}, l2 = {};
          for (const h2 in s2) {
            const e3 = mm[h2] || h2.toLowerCase();
            a2[e3] = s2[h2];
          }
          for (const h2 in e2.attributes) {
            const t3 = mm[h2] || h2.toLowerCase();
            if (void 0 !== s2[h2]) {
              const n3 = i2.accessors[e2.attributes[h2]], r3 = cm[n3.componentType];
              l2[t3] = r3, o2[t3] = true === n3.normalized;
            }
          }
          return t2.getDependency("bufferView", r2).then(function(e3) {
            return new Promise(function(t3) {
              n2.decodeDracoFile(e3, function(e4) {
                for (const t4 in e4.attributes) {
                  const i3 = e4.attributes[t4], n3 = o2[t4];
                  void 0 !== n3 && (i3.normalized = n3);
                }
                t3(e4);
              }, a2, l2);
            });
          });
        }
      }
      class Jp {
        constructor() {
          this.name = Lp.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e2, t2) {
          return void 0 !== t2.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t2.offset && void 0 === t2.rotation && void 0 === t2.scale || (e2 = e2.clone(), void 0 !== t2.offset && e2.offset.fromArray(t2.offset), void 0 !== t2.rotation && (e2.rotation = t2.rotation), void 0 !== t2.scale && e2.repeat.fromArray(t2.scale), e2.needsUpdate = true), e2;
        }
      }
      class Kp extends xa {
        constructor(e2) {
          super(), this.isGLTFSpecularGlossinessMaterial = true;
          const t2 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), i2 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), n2 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r2 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s2 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), a2 = { specular: { value: new ge().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
          this._extraUniforms = a2, this.onBeforeCompile = function(e3) {
            for (const t3 in a2)
              e3.uniforms[t3] = a2[t3];
            e3.fragmentShader = e3.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t2).replace("#include <metalnessmap_pars_fragment>", i2).replace("#include <roughnessmap_fragment>", n2).replace("#include <metalnessmap_fragment>", r2).replace("#include <lights_physical_fragment>", s2);
          }, Object.defineProperties(this, { specular: { get: function() {
            return a2.specular.value;
          }, set: function(e3) {
            a2.specular.value = e3;
          } }, specularMap: { get: function() {
            return a2.specularMap.value;
          }, set: function(e3) {
            a2.specularMap.value = e3, e3 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
          } }, glossiness: { get: function() {
            return a2.glossiness.value;
          }, set: function(e3) {
            a2.glossiness.value = e3;
          } }, glossinessMap: { get: function() {
            return a2.glossinessMap.value;
          }, set: function(e3) {
            a2.glossinessMap.value = e3, e3 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
          } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e2);
        }
        copy(e2) {
          return super.copy(e2), this.specularMap = e2.specularMap, this.specular.copy(e2.specular), this.glossinessMap = e2.glossinessMap, this.glossiness = e2.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
        }
      }
      class Qp {
        constructor() {
          this.name = Lp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
        }
        getMaterialType() {
          return Kp;
        }
        extendParams(e2, t2, i2) {
          const n2 = t2.extensions[this.name];
          e2.color = new ge(1, 1, 1), e2.opacity = 1;
          const r2 = [];
          if (Array.isArray(n2.diffuseFactor)) {
            const t3 = n2.diffuseFactor;
            e2.color.fromArray(t3), e2.opacity = t3[3];
          }
          if (void 0 !== n2.diffuseTexture && r2.push(i2.assignTexture(e2, "map", n2.diffuseTexture, U)), e2.emissive = new ge(0, 0, 0), e2.glossiness = void 0 !== n2.glossinessFactor ? n2.glossinessFactor : 1, e2.specular = new ge(1, 1, 1), Array.isArray(n2.specularFactor) && e2.specular.fromArray(n2.specularFactor), void 0 !== n2.specularGlossinessTexture) {
            const t3 = n2.specularGlossinessTexture;
            r2.push(i2.assignTexture(e2, "glossinessMap", t3)), r2.push(i2.assignTexture(e2, "specularMap", t3, U));
          }
          return Promise.all(r2);
        }
        createMaterial(e2) {
          const t2 = new Kp(e2);
          return t2.fog = true, t2.color = e2.color, t2.map = void 0 === e2.map ? null : e2.map, t2.lightMap = null, t2.lightMapIntensity = 1, t2.aoMap = void 0 === e2.aoMap ? null : e2.aoMap, t2.aoMapIntensity = 1, t2.emissive = e2.emissive, t2.emissiveIntensity = void 0 === e2.emissiveIntensity ? 1 : e2.emissiveIntensity, t2.emissiveMap = void 0 === e2.emissiveMap ? null : e2.emissiveMap, t2.bumpMap = void 0 === e2.bumpMap ? null : e2.bumpMap, t2.bumpScale = 1, t2.normalMap = void 0 === e2.normalMap ? null : e2.normalMap, t2.normalMapType = 0, e2.normalScale && (t2.normalScale = e2.normalScale), t2.displacementMap = null, t2.displacementScale = 1, t2.displacementBias = 0, t2.specularMap = void 0 === e2.specularMap ? null : e2.specularMap, t2.specular = e2.specular, t2.glossinessMap = void 0 === e2.glossinessMap ? null : e2.glossinessMap, t2.glossiness = e2.glossiness, t2.alphaMap = null, t2.envMap = void 0 === e2.envMap ? null : e2.envMap, t2.envMapIntensity = 1, t2;
        }
      }
      class $p {
        constructor() {
          this.name = Lp.KHR_MESH_QUANTIZATION;
        }
      }
      class em extends wa {
        constructor(e2, t2, i2, n2) {
          super(e2, t2, i2, n2);
        }
        copySampleValue_(e2) {
          const t2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = e2 * n2 * 3 + n2;
          for (let s2 = 0; s2 !== n2; s2++)
            t2[s2] = i2[r2 + s2];
          return t2;
        }
      }
      em.prototype.interpolate_ = function(e2, t2, i2, n2) {
        const r2 = this.resultBuffer, s2 = this.sampleValues, a2 = this.valueSize, o2 = 2 * a2, l2 = 3 * a2, h2 = n2 - t2, c2 = (i2 - t2) / h2, u2 = c2 * c2, d2 = u2 * c2, p2 = e2 * l2, m2 = p2 - l2, f2 = -2 * d2 + 3 * u2, g2 = d2 - u2, _2 = 1 - f2, v2 = g2 - u2 + c2;
        for (let x2 = 0; x2 !== a2; x2++) {
          const e3 = s2[m2 + x2 + a2], t3 = s2[m2 + x2 + o2] * h2, i3 = s2[p2 + x2 + a2], n3 = s2[p2 + x2] * h2;
          r2[x2] = _2 * e3 + v2 * t3 + f2 * i3 + g2 * n3;
        }
        return r2;
      };
      const tm = new Ce();
      class im extends em {
        interpolate_(e2, t2, i2, n2) {
          const r2 = super.interpolate_(e2, t2, i2, n2);
          return tm.fromArray(r2).normalize().toArray(r2), r2;
        }
      }
      const nm = 0, rm = 1, sm = 2, am = 3, om = 4, lm = 5, hm = 6, cm = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, um = { 9728: u, 9729: m, 9984: d, 9985: 1007, 9986: p, 9987: f }, dm = { 33071: h, 33648: c, 10497: l }, pm = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, mm = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, fm = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, gm = { CUBICSPLINE: void 0, LINEAR: P, STEP: A }, _m = "OPAQUE", vm = "MASK", xm = "BLEND";
      function ym(e2, t2, i2) {
        for (const n2 in i2.extensions)
          void 0 === e2[n2] && (t2.userData.gltfExtensions = t2.userData.gltfExtensions || {}, t2.userData.gltfExtensions[n2] = i2.extensions[n2]);
      }
      function bm(e2, t2) {
        void 0 !== t2.extras && ("object" == typeof t2.extras ? Object.assign(e2.userData, t2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t2.extras));
      }
      function Mm(e2, t2) {
        if (e2.updateMorphTargets(), void 0 !== t2.weights)
          for (let i2 = 0, n2 = t2.weights.length; i2 < n2; i2++)
            e2.morphTargetInfluences[i2] = t2.weights[i2];
        if (t2.extras && Array.isArray(t2.extras.targetNames)) {
          const i2 = t2.extras.targetNames;
          if (e2.morphTargetInfluences.length === i2.length) {
            e2.morphTargetDictionary = {};
            for (let t3 = 0, n2 = i2.length; t3 < n2; t3++)
              e2.morphTargetDictionary[i2[t3]] = t3;
          } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
      function Sm(e2) {
        const t2 = e2.extensions && e2.extensions[Lp.KHR_DRACO_MESH_COMPRESSION];
        let i2;
        return i2 = t2 ? "draco:" + t2.bufferView + ":" + t2.indices + ":" + wm(t2.attributes) : e2.indices + ":" + wm(e2.attributes) + ":" + e2.mode, i2;
      }
      function wm(e2) {
        let t2 = "";
        const i2 = Object.keys(e2).sort();
        for (let n2 = 0, r2 = i2.length; n2 < r2; n2++)
          t2 += i2[n2] + ":" + e2[i2[n2]] + ";";
        return t2;
      }
      function Tm(e2) {
        switch (e2) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      class Em {
        constructor(e2 = {}, t2 = {}) {
          this.json = e2, this.extensions = {}, this.plugins = {}, this.options = t2, this.cache = new Rp(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
          const i2 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), n2 = navigator.userAgent.indexOf("Firefox") > -1, r2 = n2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
          "undefined" == typeof createImageBitmap || i2 || n2 && r2 < 98 ? this.textureLoader = new qa(this.options.manager) : this.textureLoader = new uo(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Ha(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
        }
        setExtensions(e2) {
          this.extensions = e2;
        }
        setPlugins(e2) {
          this.plugins = e2;
        }
        parse(e2, t2) {
          const i2 = this, n2 = this.json, r2 = this.extensions;
          this.cache.removeAll(), this._invokeAll(function(e3) {
            return e3._markDefs && e3._markDefs();
          }), Promise.all(this._invokeAll(function(e3) {
            return e3.beforeRoot && e3.beforeRoot();
          })).then(function() {
            return Promise.all([i2.getDependencies("scene"), i2.getDependencies("animation"), i2.getDependencies("camera")]);
          }).then(function(t3) {
            const s2 = { scene: t3[0][n2.scene || 0], scenes: t3[0], animations: t3[1], cameras: t3[2], asset: n2.asset, parser: i2, userData: {} };
            ym(r2, s2, n2), bm(s2, n2), Promise.all(i2._invokeAll(function(e3) {
              return e3.afterRoot && e3.afterRoot(s2);
            })).then(function() {
              e2(s2);
            });
          }).catch(t2);
        }
        _markDefs() {
          const e2 = this.json.nodes || [], t2 = this.json.skins || [], i2 = this.json.meshes || [];
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            const i3 = t2[n2].joints;
            for (let t3 = 0, n3 = i3.length; t3 < n3; t3++)
              e2[i3[t3]].isBone = true;
          }
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
            const t3 = e2[n2];
            void 0 !== t3.mesh && (this._addNodeRef(this.meshCache, t3.mesh), void 0 !== t3.skin && (i2[t3.mesh].isSkinnedMesh = true)), void 0 !== t3.camera && this._addNodeRef(this.cameraCache, t3.camera);
          }
        }
        _addNodeRef(e2, t2) {
          void 0 !== t2 && (void 0 === e2.refs[t2] && (e2.refs[t2] = e2.uses[t2] = 0), e2.refs[t2]++);
        }
        _getNodeRef(e2, t2, i2) {
          if (e2.refs[t2] <= 1)
            return i2;
          const n2 = i2.clone(), r2 = (e3, t3) => {
            const i3 = this.associations.get(e3);
            null != i3 && this.associations.set(t3, i3);
            for (const [n3, s2] of e3.children.entries())
              r2(s2, t3.children[n3]);
          };
          return r2(i2, n2), n2.name += "_instance_" + e2.uses[t2]++, n2;
        }
        _invokeOne(e2) {
          const t2 = Object.values(this.plugins);
          t2.push(this);
          for (let i2 = 0; i2 < t2.length; i2++) {
            const n2 = e2(t2[i2]);
            if (n2)
              return n2;
          }
          return null;
        }
        _invokeAll(e2) {
          const t2 = Object.values(this.plugins);
          t2.unshift(this);
          const i2 = [];
          for (let n2 = 0; n2 < t2.length; n2++) {
            const r2 = e2(t2[n2]);
            r2 && i2.push(r2);
          }
          return i2;
        }
        getDependency(e2, t2) {
          const i2 = e2 + ":" + t2;
          let n2 = this.cache.get(i2);
          if (!n2) {
            switch (e2) {
              case "scene":
                n2 = this.loadScene(t2);
                break;
              case "node":
                n2 = this.loadNode(t2);
                break;
              case "mesh":
                n2 = this._invokeOne(function(e3) {
                  return e3.loadMesh && e3.loadMesh(t2);
                });
                break;
              case "accessor":
                n2 = this.loadAccessor(t2);
                break;
              case "bufferView":
                n2 = this._invokeOne(function(e3) {
                  return e3.loadBufferView && e3.loadBufferView(t2);
                });
                break;
              case "buffer":
                n2 = this.loadBuffer(t2);
                break;
              case "material":
                n2 = this._invokeOne(function(e3) {
                  return e3.loadMaterial && e3.loadMaterial(t2);
                });
                break;
              case "texture":
                n2 = this._invokeOne(function(e3) {
                  return e3.loadTexture && e3.loadTexture(t2);
                });
                break;
              case "skin":
                n2 = this.loadSkin(t2);
                break;
              case "animation":
                n2 = this._invokeOne(function(e3) {
                  return e3.loadAnimation && e3.loadAnimation(t2);
                });
                break;
              case "camera":
                n2 = this.loadCamera(t2);
                break;
              default:
                throw new Error("Unknown type: " + e2);
            }
            this.cache.add(i2, n2);
          }
          return n2;
        }
        getDependencies(e2) {
          let t2 = this.cache.get(e2);
          if (!t2) {
            const i2 = this, n2 = this.json[e2 + ("mesh" === e2 ? "es" : "s")] || [];
            t2 = Promise.all(n2.map(function(t3, n3) {
              return i2.getDependency(e2, n3);
            })), this.cache.add(e2, t2);
          }
          return t2;
        }
        loadBuffer(e2) {
          const t2 = this.json.buffers[e2], i2 = this.fileLoader;
          if (t2.type && "arraybuffer" !== t2.type)
            throw new Error("THREE.GLTFLoader: " + t2.type + " buffer type is not supported.");
          if (void 0 === t2.uri && 0 === e2)
            return Promise.resolve(this.extensions[Lp.KHR_BINARY_GLTF].body);
          const n2 = this.options;
          return new Promise(function(e3, r2) {
            i2.load(ho.resolveURL(t2.uri, n2.path), e3, void 0, function() {
              r2(new Error('THREE.GLTFLoader: Failed to load buffer "' + t2.uri + '".'));
            });
          });
        }
        loadBufferView(e2) {
          const t2 = this.json.bufferViews[e2];
          return this.getDependency("buffer", t2.buffer).then(function(e3) {
            const i2 = t2.byteLength || 0, n2 = t2.byteOffset || 0;
            return e3.slice(n2, n2 + i2);
          });
        }
        loadAccessor(e2) {
          const t2 = this, i2 = this.json, n2 = this.json.accessors[e2];
          if (void 0 === n2.bufferView && void 0 === n2.sparse)
            return Promise.resolve(null);
          const r2 = [];
          return void 0 !== n2.bufferView ? r2.push(this.getDependency("bufferView", n2.bufferView)) : r2.push(null), void 0 !== n2.sparse && (r2.push(this.getDependency("bufferView", n2.sparse.indices.bufferView)), r2.push(this.getDependency("bufferView", n2.sparse.values.bufferView))), Promise.all(r2).then(function(e3) {
            const r3 = e3[0], s2 = pm[n2.type], a2 = cm[n2.componentType], o2 = a2.BYTES_PER_ELEMENT, l2 = o2 * s2, h2 = n2.byteOffset || 0, c2 = void 0 !== n2.bufferView ? i2.bufferViews[n2.bufferView].byteStride : void 0, u2 = true === n2.normalized;
            let d2, p2;
            if (c2 && c2 !== l2) {
              const e4 = Math.floor(h2 / c2), i3 = "InterleavedBuffer:" + n2.bufferView + ":" + n2.componentType + ":" + e4 + ":" + n2.count;
              let l3 = t2.cache.get(i3);
              l3 || (d2 = new a2(r3, e4 * c2, n2.count * c2 / o2), l3 = new Cs(d2, c2 / o2), t2.cache.add(i3, l3)), p2 = new Ps(l3, s2, h2 % c2 / o2, u2);
            } else
              d2 = null === r3 ? new a2(n2.count * s2) : new a2(r3, h2, n2.count * s2), p2 = new qt(d2, s2, u2);
            if (void 0 !== n2.sparse) {
              const t3 = pm.SCALAR, i3 = cm[n2.sparse.indices.componentType], o3 = n2.sparse.indices.byteOffset || 0, l3 = n2.sparse.values.byteOffset || 0, h3 = new i3(e3[1], o3, n2.sparse.count * t3), c3 = new a2(e3[2], l3, n2.sparse.count * s2);
              null !== r3 && (p2 = new qt(p2.array.slice(), p2.itemSize, p2.normalized));
              for (let e4 = 0, n3 = h3.length; e4 < n3; e4++) {
                const t4 = h3[e4];
                if (p2.setX(t4, c3[e4 * s2]), s2 >= 2 && p2.setY(t4, c3[e4 * s2 + 1]), s2 >= 3 && p2.setZ(t4, c3[e4 * s2 + 2]), s2 >= 4 && p2.setW(t4, c3[e4 * s2 + 3]), s2 >= 5)
                  throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
            }
            return p2;
          });
        }
        loadTexture(e2) {
          const t2 = this.json, i2 = this.options, n2 = t2.textures[e2].source, r2 = t2.images[n2];
          let s2 = this.textureLoader;
          if (r2.uri) {
            const e3 = i2.manager.getHandler(r2.uri);
            null !== e3 && (s2 = e3);
          }
          return this.loadTextureImage(e2, n2, s2);
        }
        loadTextureImage(e2, t2, i2) {
          const n2 = this, r2 = this.json, s2 = r2.textures[e2], a2 = r2.images[t2], o2 = (a2.uri || a2.bufferView) + ":" + s2.sampler;
          if (this.textureCache[o2])
            return this.textureCache[o2];
          const h2 = this.loadImageSource(t2, i2).then(function(t3) {
            t3.flipY = false, s2.name && (t3.name = s2.name);
            const i3 = (r2.samplers || {})[s2.sampler] || {};
            return t3.magFilter = um[i3.magFilter] || m, t3.minFilter = um[i3.minFilter] || f, t3.wrapS = dm[i3.wrapS] || l, t3.wrapT = dm[i3.wrapT] || l, n2.associations.set(t3, { textures: e2 }), t3;
          }).catch(function() {
            return null;
          });
          return this.textureCache[o2] = h2, h2;
        }
        loadImageSource(e2, t2) {
          const i2 = this, n2 = this.json, r2 = this.options;
          if (void 0 !== this.sourceCache[e2])
            return this.sourceCache[e2].then((e3) => e3.clone());
          const s2 = n2.images[e2], a2 = self.URL || self.webkitURL;
          let o2 = s2.uri || "", l2 = false;
          if (void 0 !== s2.bufferView)
            o2 = i2.getDependency("bufferView", s2.bufferView).then(function(e3) {
              l2 = true;
              const t3 = new Blob([e3], { type: s2.mimeType });
              return o2 = a2.createObjectURL(t3), o2;
            });
          else if (void 0 === s2.uri)
            throw new Error("THREE.GLTFLoader: Image " + e2 + " is missing URI and bufferView");
          const h2 = Promise.resolve(o2).then(function(e3) {
            return new Promise(function(i3, n3) {
              let s3 = i3;
              true === t2.isImageBitmapLoader && (s3 = function(e4) {
                const t3 = new Me(e4);
                t3.needsUpdate = true, i3(t3);
              }), t2.load(ho.resolveURL(e3, r2.path), s3, void 0, n3);
            });
          }).then(function(e3) {
            var t3;
            return true === l2 && a2.revokeObjectURL(o2), e3.userData.mimeType = s2.mimeType || ((t3 = s2.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t3.search(/^data\:image\/jpeg/) ? "image/jpeg" : t3.search(/\.webp($|\?)/i) > 0 || 0 === t3.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e3;
          }).catch(function(e3) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", o2), e3;
          });
          return this.sourceCache[e2] = h2, h2;
        }
        assignTexture(e2, t2, i2, n2) {
          const r2 = this;
          return this.getDependency("texture", i2.index).then(function(s2) {
            if (void 0 === i2.texCoord || 0 == i2.texCoord || "aoMap" === t2 && 1 == i2.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i2.texCoord + " for texture " + t2 + " not yet supported."), r2.extensions[Lp.KHR_TEXTURE_TRANSFORM]) {
              const e3 = void 0 !== i2.extensions ? i2.extensions[Lp.KHR_TEXTURE_TRANSFORM] : void 0;
              if (e3) {
                const t3 = r2.associations.get(s2);
                s2 = r2.extensions[Lp.KHR_TEXTURE_TRANSFORM].extendTexture(s2, e3), r2.associations.set(s2, t3);
              }
            }
            return void 0 !== n2 && (s2.encoding = n2), e2[t2] = s2, s2;
          });
        }
        assignFinalMaterial(e2) {
          const t2 = e2.geometry;
          let i2 = e2.material;
          const n2 = void 0 === t2.attributes.tangent, r2 = void 0 !== t2.attributes.color, s2 = void 0 === t2.attributes.normal;
          if (e2.isPoints) {
            const e3 = "PointsMaterial:" + i2.uuid;
            let t3 = this.cache.get(e3);
            t3 || (t3 = new ra(), Ht.prototype.copy.call(t3, i2), t3.color.copy(i2.color), t3.map = i2.map, t3.sizeAttenuation = false, this.cache.add(e3, t3)), i2 = t3;
          } else if (e2.isLine) {
            const e3 = "LineBasicMaterial:" + i2.uuid;
            let t3 = this.cache.get(e3);
            t3 || (t3 = new qs(), Ht.prototype.copy.call(t3, i2), t3.color.copy(i2.color), this.cache.add(e3, t3)), i2 = t3;
          }
          if (n2 || r2 || s2) {
            let e3 = "ClonedMaterial:" + i2.uuid + ":";
            i2.isGLTFSpecularGlossinessMaterial && (e3 += "specular-glossiness:"), n2 && (e3 += "derivative-tangents:"), r2 && (e3 += "vertex-colors:"), s2 && (e3 += "flat-shading:");
            let t3 = this.cache.get(e3);
            t3 || (t3 = i2.clone(), r2 && (t3.vertexColors = true), s2 && (t3.flatShading = true), n2 && (t3.normalScale && (t3.normalScale.y *= -1), t3.clearcoatNormalScale && (t3.clearcoatNormalScale.y *= -1)), this.cache.add(e3, t3), this.associations.set(t3, this.associations.get(i2))), i2 = t3;
          }
          i2.aoMap && void 0 === t2.attributes.uv2 && void 0 !== t2.attributes.uv && t2.setAttribute("uv2", t2.attributes.uv), e2.material = i2;
        }
        getMaterialType() {
          return xa;
        }
        loadMaterial(e2) {
          const t2 = this, i2 = this.json, n2 = this.extensions, r2 = i2.materials[e2];
          let s2;
          const a2 = {}, o2 = r2.extensions || {}, l2 = [];
          if (o2[Lp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const e3 = n2[Lp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            s2 = e3.getMaterialType(), l2.push(e3.extendParams(a2, r2, t2));
          } else if (o2[Lp.KHR_MATERIALS_UNLIT]) {
            const e3 = n2[Lp.KHR_MATERIALS_UNLIT];
            s2 = e3.getMaterialType(), l2.push(e3.extendParams(a2, r2, t2));
          } else {
            const i3 = r2.pbrMetallicRoughness || {};
            if (a2.color = new ge(1, 1, 1), a2.opacity = 1, Array.isArray(i3.baseColorFactor)) {
              const e3 = i3.baseColorFactor;
              a2.color.fromArray(e3), a2.opacity = e3[3];
            }
            void 0 !== i3.baseColorTexture && l2.push(t2.assignTexture(a2, "map", i3.baseColorTexture, U)), a2.metalness = void 0 !== i3.metallicFactor ? i3.metallicFactor : 1, a2.roughness = void 0 !== i3.roughnessFactor ? i3.roughnessFactor : 1, void 0 !== i3.metallicRoughnessTexture && (l2.push(t2.assignTexture(a2, "metalnessMap", i3.metallicRoughnessTexture)), l2.push(t2.assignTexture(a2, "roughnessMap", i3.metallicRoughnessTexture))), s2 = this._invokeOne(function(t3) {
              return t3.getMaterialType && t3.getMaterialType(e2);
            }), l2.push(Promise.all(this._invokeAll(function(t3) {
              return t3.extendMaterialParams && t3.extendMaterialParams(e2, a2);
            })));
          }
          true === r2.doubleSided && (a2.side = 2);
          const h2 = r2.alphaMode || _m;
          if (h2 === xm ? (a2.transparent = true, a2.depthWrite = false) : (a2.transparent = false, h2 === vm && (a2.alphaTest = void 0 !== r2.alphaCutoff ? r2.alphaCutoff : 0.5)), void 0 !== r2.normalTexture && s2 !== jt && (l2.push(t2.assignTexture(a2, "normalMap", r2.normalTexture)), a2.normalScale = new ie(1, 1), void 0 !== r2.normalTexture.scale)) {
            const e3 = r2.normalTexture.scale;
            a2.normalScale.set(e3, e3);
          }
          return void 0 !== r2.occlusionTexture && s2 !== jt && (l2.push(t2.assignTexture(a2, "aoMap", r2.occlusionTexture)), void 0 !== r2.occlusionTexture.strength && (a2.aoMapIntensity = r2.occlusionTexture.strength)), void 0 !== r2.emissiveFactor && s2 !== jt && (a2.emissive = new ge().fromArray(r2.emissiveFactor)), void 0 !== r2.emissiveTexture && s2 !== jt && l2.push(t2.assignTexture(a2, "emissiveMap", r2.emissiveTexture, U)), Promise.all(l2).then(function() {
            let i3;
            return i3 = s2 === Kp ? n2[Lp.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a2) : new s2(a2), r2.name && (i3.name = r2.name), bm(i3, r2), t2.associations.set(i3, { materials: e2 }), r2.extensions && ym(n2, i3, r2), i3;
          });
        }
        createUniqueName(e2) {
          const t2 = Eo.sanitizeNodeName(e2 || "");
          let i2 = t2;
          for (let n2 = 1; this.nodeNamesUsed[i2]; ++n2)
            i2 = t2 + "_" + n2;
          return this.nodeNamesUsed[i2] = true, i2;
        }
        loadGeometries(e2) {
          const t2 = this, i2 = this.extensions, n2 = this.primitiveCache;
          function r2(e3) {
            return i2[Lp.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e3, t2).then(function(i3) {
              return Am(i3, e3, t2);
            });
          }
          const s2 = [];
          for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
            const i3 = e2[a2], o3 = Sm(i3), l2 = n2[o3];
            if (l2)
              s2.push(l2.promise);
            else {
              let e3;
              e3 = i3.extensions && i3.extensions[Lp.KHR_DRACO_MESH_COMPRESSION] ? r2(i3) : Am(new ri(), i3, t2), n2[o3] = { primitive: i3, promise: e3 }, s2.push(e3);
            }
          }
          return Promise.all(s2);
        }
        loadMesh(e2) {
          const t2 = this, i2 = this.json, n2 = this.extensions, r2 = i2.meshes[e2], s2 = r2.primitives, a2 = [];
          for (let l2 = 0, h2 = s2.length; l2 < h2; l2++) {
            const e3 = void 0 === s2[l2].material ? (void 0 === (o2 = this.cache).DefaultMaterial && (o2.DefaultMaterial = new xa({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: 0 })), o2.DefaultMaterial) : this.getDependency("material", s2[l2].material);
            a2.push(e3);
          }
          var o2;
          return a2.push(t2.loadGeometries(s2)), Promise.all(a2).then(function(i3) {
            const a3 = i3.slice(0, i3.length - 1), o3 = i3[i3.length - 1], l2 = [];
            for (let c2 = 0, u2 = o3.length; c2 < u2; c2++) {
              const i4 = o3[c2], h3 = s2[c2];
              let u3;
              const d2 = a3[c2];
              if (h3.mode === om || h3.mode === lm || h3.mode === hm || void 0 === h3.mode)
                u3 = true === r2.isSkinnedMesh ? new Os(i4, d2) : new Mi(i4, d2), true !== u3.isSkinnedMesh || u3.geometry.attributes.skinWeight.normalized || u3.normalizeSkinWeights(), h3.mode === lm ? u3.geometry = Pm(u3.geometry, 1) : h3.mode === hm && (u3.geometry = Pm(u3.geometry, 2));
              else if (h3.mode === rm)
                u3 = new ia(i4, d2);
              else if (h3.mode === am)
                u3 = new $s(i4, d2);
              else if (h3.mode === sm)
                u3 = new na(i4, d2);
              else {
                if (h3.mode !== nm)
                  throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h3.mode);
                u3 = new ha(i4, d2);
              }
              Object.keys(u3.geometry.morphAttributes).length > 0 && Mm(u3, r2), u3.name = t2.createUniqueName(r2.name || "mesh_" + e2), bm(u3, r2), h3.extensions && ym(n2, u3, h3), t2.assignFinalMaterial(u3), l2.push(u3);
            }
            for (let n3 = 0, r3 = l2.length; n3 < r3; n3++)
              t2.associations.set(l2[n3], { meshes: e2, primitives: n3 });
            if (1 === l2.length)
              return l2[0];
            const h2 = new vs();
            t2.associations.set(h2, { meshes: e2 });
            for (let e3 = 0, t3 = l2.length; e3 < t3; e3++)
              h2.add(l2[e3]);
            return h2;
          });
        }
        loadCamera(e2) {
          let t2;
          const i2 = this.json.cameras[e2], n2 = i2[i2.type];
          if (n2)
            return "perspective" === i2.type ? t2 = new Ri(te.radToDeg(n2.yfov), n2.aspectRatio || 1, n2.znear || 1, n2.zfar || 2e6) : "orthographic" === i2.type && (t2 = new en(-n2.xmag, n2.xmag, n2.ymag, -n2.ymag, n2.znear, n2.zfar)), i2.name && (t2.name = this.createUniqueName(i2.name)), bm(t2, i2), Promise.resolve(t2);
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }
        loadSkin(e2) {
          const t2 = this.json.skins[e2], i2 = { joints: t2.joints };
          return void 0 === t2.inverseBindMatrices ? Promise.resolve(i2) : this.getDependency("accessor", t2.inverseBindMatrices).then(function(e3) {
            return i2.inverseBindMatrices = e3, i2;
          });
        }
        loadAnimation(e2) {
          const t2 = this.json.animations[e2], i2 = [], n2 = [], r2 = [], s2 = [], a2 = [];
          for (let o2 = 0, l2 = t2.channels.length; o2 < l2; o2++) {
            const e3 = t2.channels[o2], l3 = t2.samplers[e3.sampler], h2 = e3.target, c2 = void 0 !== h2.node ? h2.node : h2.id, u2 = void 0 !== t2.parameters ? t2.parameters[l3.input] : l3.input, d2 = void 0 !== t2.parameters ? t2.parameters[l3.output] : l3.output;
            i2.push(this.getDependency("node", c2)), n2.push(this.getDependency("accessor", u2)), r2.push(this.getDependency("accessor", d2)), s2.push(l3), a2.push(h2);
          }
          return Promise.all([Promise.all(i2), Promise.all(n2), Promise.all(r2), Promise.all(s2), Promise.all(a2)]).then(function(i3) {
            const n3 = i3[0], r3 = i3[1], s3 = i3[2], a3 = i3[3], o2 = i3[4], l2 = [];
            for (let e3 = 0, t3 = n3.length; e3 < t3; e3++) {
              const t4 = n3[e3], i4 = r3[e3], h3 = s3[e3], c2 = a3[e3], u2 = o2[e3];
              if (void 0 === t4)
                continue;
              let d2;
              switch (t4.updateMatrix(), t4.matrixAutoUpdate = true, fm[u2.path]) {
                case fm.weights:
                  d2 = La;
                  break;
                case fm.rotation:
                  d2 = Da;
                  break;
                default:
                  d2 = Oa;
              }
              const p2 = t4.name ? t4.name : t4.uuid, m2 = void 0 !== c2.interpolation ? gm[c2.interpolation] : P, f2 = [];
              fm[u2.path] === fm.weights ? t4.traverse(function(e4) {
                e4.morphTargetInfluences && f2.push(e4.name ? e4.name : e4.uuid);
              }) : f2.push(p2);
              let g2 = h3.array;
              if (h3.normalized) {
                const e4 = Tm(g2.constructor), t5 = new Float32Array(g2.length);
                for (let i5 = 0, n4 = g2.length; i5 < n4; i5++)
                  t5[i5] = g2[i5] * e4;
                g2 = t5;
              }
              for (let e4 = 0, n4 = f2.length; e4 < n4; e4++) {
                const t5 = new d2(f2[e4] + "." + fm[u2.path], i4.array, g2, m2);
                "CUBICSPLINE" === c2.interpolation && (t5.createInterpolant = function(e5) {
                  return new (this instanceof Da ? im : em)(this.times, this.values, this.getValueSize() / 3, e5);
                }, t5.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l2.push(t5);
              }
            }
            const h2 = t2.name ? t2.name : "animation_" + e2;
            return new Ua(h2, void 0, l2);
          });
        }
        createNodeMesh(e2) {
          const t2 = this.json, i2 = this, n2 = t2.nodes[e2];
          return void 0 === n2.mesh ? null : i2.getDependency("mesh", n2.mesh).then(function(e3) {
            const t3 = i2._getNodeRef(i2.meshCache, n2.mesh, e3);
            return void 0 !== n2.weights && t3.traverse(function(e4) {
              if (e4.isMesh)
                for (let t4 = 0, i3 = n2.weights.length; t4 < i3; t4++)
                  e4.morphTargetInfluences[t4] = n2.weights[t4];
            }), t3;
          });
        }
        loadNode(e2) {
          const t2 = this.json, i2 = this.extensions, n2 = this, r2 = t2.nodes[e2], s2 = r2.name ? n2.createUniqueName(r2.name) : "";
          return function() {
            const t3 = [], i3 = n2._invokeOne(function(t4) {
              return t4.createNodeMesh && t4.createNodeMesh(e2);
            });
            return i3 && t3.push(i3), void 0 !== r2.camera && t3.push(n2.getDependency("camera", r2.camera).then(function(e3) {
              return n2._getNodeRef(n2.cameraCache, r2.camera, e3);
            })), n2._invokeAll(function(t4) {
              return t4.createNodeAttachment && t4.createNodeAttachment(e2);
            }).forEach(function(e3) {
              t3.push(e3);
            }), Promise.all(t3);
          }().then(function(t3) {
            let a2;
            if (a2 = true === r2.isBone ? new Us() : t3.length > 1 ? new vs() : 1 === t3.length ? t3[0] : new Rt(), a2 !== t3[0])
              for (let e3 = 0, i3 = t3.length; e3 < i3; e3++)
                a2.add(t3[e3]);
            if (r2.name && (a2.userData.name = r2.name, a2.name = s2), bm(a2, r2), r2.extensions && ym(i2, a2, r2), void 0 !== r2.matrix) {
              const e3 = new st();
              e3.fromArray(r2.matrix), a2.applyMatrix4(e3);
            } else
              void 0 !== r2.translation && a2.position.fromArray(r2.translation), void 0 !== r2.rotation && a2.quaternion.fromArray(r2.rotation), void 0 !== r2.scale && a2.scale.fromArray(r2.scale);
            return n2.associations.has(a2) || n2.associations.set(a2, {}), n2.associations.get(a2).nodes = e2, a2;
          });
        }
        loadScene(e2) {
          const t2 = this.json, i2 = this.extensions, n2 = this.json.scenes[e2], r2 = this, s2 = new vs();
          n2.name && (s2.name = r2.createUniqueName(n2.name)), bm(s2, n2), n2.extensions && ym(i2, s2, n2);
          const a2 = n2.nodes || [], o2 = [];
          for (let l2 = 0, h2 = a2.length; l2 < h2; l2++)
            o2.push(Cm(a2[l2], s2, t2, r2));
          return Promise.all(o2).then(function() {
            return r2.associations = ((e3) => {
              const t3 = /* @__PURE__ */ new Map();
              for (const [i3, n3] of r2.associations)
                (i3 instanceof Ht || i3 instanceof Me) && t3.set(i3, n3);
              return e3.traverse((e4) => {
                const i3 = r2.associations.get(e4);
                null != i3 && t3.set(e4, i3);
              }), t3;
            })(s2), s2;
          });
        }
      }
      function Cm(e2, t2, i2, n2) {
        const r2 = i2.nodes[e2];
        return n2.getDependency("node", e2).then(function(e3) {
          if (void 0 === r2.skin)
            return e3;
          let t3;
          return n2.getDependency("skin", r2.skin).then(function(e4) {
            t3 = e4;
            const i3 = [];
            for (let r3 = 0, s2 = t3.joints.length; r3 < s2; r3++)
              i3.push(n2.getDependency("node", t3.joints[r3]));
            return Promise.all(i3);
          }).then(function(i3) {
            return e3.traverse(function(e4) {
              if (!e4.isMesh)
                return;
              const n3 = [], r3 = [];
              for (let s2 = 0, a2 = i3.length; s2 < a2; s2++) {
                const e5 = i3[s2];
                if (e5) {
                  n3.push(e5);
                  const i4 = new st();
                  void 0 !== t3.inverseBindMatrices && i4.fromArray(t3.inverseBindMatrices.array, 16 * s2), r3.push(i4);
                } else
                  console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t3.joints[s2]);
              }
              e4.bind(new Bs(n3, r3), e4.matrixWorld);
            }), e3;
          });
        }).then(function(e3) {
          t2.add(e3);
          const s2 = [];
          if (r2.children) {
            const t3 = r2.children;
            for (let r3 = 0, a2 = t3.length; r3 < a2; r3++) {
              const a3 = t3[r3];
              s2.push(Cm(a3, e3, i2, n2));
            }
          }
          return Promise.all(s2);
        });
      }
      function Am(e2, t2, i2) {
        const n2 = t2.attributes, r2 = [];
        function s2(t3, n3) {
          return i2.getDependency("accessor", t3).then(function(t4) {
            e2.setAttribute(n3, t4);
          });
        }
        for (const a2 in n2) {
          const t3 = mm[a2] || a2.toLowerCase();
          t3 in e2.attributes || r2.push(s2(n2[a2], t3));
        }
        if (void 0 !== t2.indices && !e2.index) {
          const n3 = i2.getDependency("accessor", t2.indices).then(function(t3) {
            e2.setIndex(t3);
          });
          r2.push(n3);
        }
        return bm(e2, t2), function(e3, t3, i3) {
          const n3 = t3.attributes, r3 = new Le();
          if (void 0 === n3.POSITION)
            return;
          {
            const e4 = i3.json.accessors[n3.POSITION], t4 = e4.min, s4 = e4.max;
            if (void 0 === t4 || void 0 === s4)
              return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            if (r3.set(new Ae(t4[0], t4[1], t4[2]), new Ae(s4[0], s4[1], s4[2])), e4.normalized) {
              const t5 = Tm(cm[e4.componentType]);
              r3.min.multiplyScalar(t5), r3.max.multiplyScalar(t5);
            }
          }
          const s3 = t3.targets;
          if (void 0 !== s3) {
            const e4 = new Ae(), t4 = new Ae();
            for (let n4 = 0, r4 = s3.length; n4 < r4; n4++) {
              const r5 = s3[n4];
              if (void 0 !== r5.POSITION) {
                const n5 = i3.json.accessors[r5.POSITION], s4 = n5.min, a3 = n5.max;
                if (void 0 !== s4 && void 0 !== a3) {
                  if (t4.setX(Math.max(Math.abs(s4[0]), Math.abs(a3[0]))), t4.setY(Math.max(Math.abs(s4[1]), Math.abs(a3[1]))), t4.setZ(Math.max(Math.abs(s4[2]), Math.abs(a3[2]))), n5.normalized) {
                    const e5 = Tm(cm[n5.componentType]);
                    t4.multiplyScalar(e5);
                  }
                  e4.max(t4);
                } else
                  console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
              }
            }
            r3.expandByVector(e4);
          }
          e3.boundingBox = r3;
          const a2 = new Je();
          r3.getCenter(a2.center), a2.radius = r3.min.distanceTo(r3.max) / 2, e3.boundingSphere = a2;
        }(e2, t2, i2), Promise.all(r2).then(function() {
          return void 0 !== t2.targets ? function(e3, t3, i3) {
            let n3 = false, r3 = false, s3 = false;
            for (let h2 = 0, c2 = t3.length; h2 < c2; h2++) {
              const e4 = t3[h2];
              if (void 0 !== e4.POSITION && (n3 = true), void 0 !== e4.NORMAL && (r3 = true), void 0 !== e4.COLOR_0 && (s3 = true), n3 && r3 && s3)
                break;
            }
            if (!n3 && !r3 && !s3)
              return Promise.resolve(e3);
            const a2 = [], o2 = [], l2 = [];
            for (let h2 = 0, c2 = t3.length; h2 < c2; h2++) {
              const c3 = t3[h2];
              if (n3) {
                const t4 = void 0 !== c3.POSITION ? i3.getDependency("accessor", c3.POSITION) : e3.attributes.position;
                a2.push(t4);
              }
              if (r3) {
                const t4 = void 0 !== c3.NORMAL ? i3.getDependency("accessor", c3.NORMAL) : e3.attributes.normal;
                o2.push(t4);
              }
              if (s3) {
                const t4 = void 0 !== c3.COLOR_0 ? i3.getDependency("accessor", c3.COLOR_0) : e3.attributes.color;
                l2.push(t4);
              }
            }
            return Promise.all([Promise.all(a2), Promise.all(o2), Promise.all(l2)]).then(function(t4) {
              const i4 = t4[0], a3 = t4[1], o3 = t4[2];
              return n3 && (e3.morphAttributes.position = i4), r3 && (e3.morphAttributes.normal = a3), s3 && (e3.morphAttributes.color = o3), e3.morphTargetsRelative = true, e3;
            });
          }(e2, t2.targets, i2) : e2;
        });
      }
      function Pm(e2, t2) {
        let i2 = e2.getIndex();
        if (null === i2) {
          const t3 = [], n3 = e2.getAttribute("position");
          if (void 0 === n3)
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e2;
          for (let e3 = 0; e3 < n3.count; e3++)
            t3.push(e3);
          e2.setIndex(t3), i2 = e2.getIndex();
        }
        const n2 = i2.count - 2, r2 = [];
        if (2 === t2)
          for (let a2 = 1; a2 <= n2; a2++)
            r2.push(i2.getX(0)), r2.push(i2.getX(a2)), r2.push(i2.getX(a2 + 1));
        else
          for (let a2 = 0; a2 < n2; a2++)
            a2 % 2 == 0 ? (r2.push(i2.getX(a2)), r2.push(i2.getX(a2 + 1)), r2.push(i2.getX(a2 + 2))) : (r2.push(i2.getX(a2 + 2)), r2.push(i2.getX(a2 + 1)), r2.push(i2.getX(a2)));
        r2.length / 3 !== n2 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s2 = e2.clone();
        return s2.setIndex(r2), s2;
      }
      new Ni(new Ae(0, 0, 1), 0);
      class Rm extends tl {
        constructor() {
          super(), __publicField(this, "isUltraDynamicSky", true), __publicField(this, "_rtFlipCount", 0), __publicField(this, "_skyNeedsUpdate", true), __publicField(this, "_staticEnvMapNeedsUpdate", true), __publicField(this, "_realtimeCapture", true), __publicField(this, "_envMapType", 2), __publicField(this, "_PMREMGenerator", null), __publicField(this, "_cloud", null), __publicField(this, "_envRenderTarget1", null), __publicField(this, "_envRenderTarget2", null), __publicField(this, "_skyAtomsphere", null), __publicField(this, "name", "UltraDynamicSky"), __publicField(this, "dynamicCloud", false), __publicField(this, "updateRealtimeEnvironment", () => {
            const e2 = this.engine;
            if (!this._envRenderTarget1) {
              this.disposeEnvRenderTarget(1), this._PMREMGenerator = new cn(e2.renderer);
              const t2 = this._envRenderTarget1 = new we(1, 1, { type: x, format: b, encoding: U, depthBuffer: false });
              t2.texture.mapping = o, t2.texture.name = "PMREM.cubeUv1", t2.scissorTest = true;
              const i2 = this._envRenderTarget2 = new we(1, 1, { type: x, format: b, encoding: U, depthBuffer: false });
              i2.texture.mapping = o, i2.texture.name = "PMREM.cubeUv2", i2.scissorTest = true, this._PMREMGenerator.prepareForRenderTarget(this._envRenderTarget1, this._envRenderTarget2, 128);
            }
            e2.rendering.objectsScene.visible = false, this._rtFlipCount % 2 == 0 ? (this._PMREMGenerator.fromSceneToRenderTarget(e2.scene, this._envRenderTarget1, this._envRenderTarget2, 0, 0.1, 1e4), e2.rendering.scene.environment = this._envRenderTarget1.texture) : (this._PMREMGenerator.fromSceneToRenderTarget(e2.scene, this._envRenderTarget2, this._envRenderTarget1, 0, 0.1, 1e4), e2.rendering.scene.environment = this._envRenderTarget2.texture), e2.rendering.objectsScene.visible = true;
          }), __publicField(this, "disposeEnvRenderTarget", (e2) => {
            this._envRenderTarget1 && (this._envRenderTarget1.dispose(), this._envRenderTarget1 = null), this._envRenderTarget2 && (this._envRenderTarget2.dispose(), this._envRenderTarget2 = null);
          });
        }
        afterAddToEngine(e2) {
          super.afterAddToEngine(e2), this.engine = e2, this.initEnv();
        }
        initEnv() {
          const e2 = this.engine, t2 = this._skyAtomsphere = new wp();
          t2.collisionDisabled = true, t2.__isEnvironment = true, t2.renderOrder = -100, e2.add(t2);
          const i2 = this._cloud = new Ap(), n2 = new qa(), r2 = n2.load($o("assets/textures/cloud/weather_1.png"), (e3) => {
            r2.wrapS = r2.wrapT = l, i2.material.uniforms.weatherMap.value = r2;
          }), s2 = n2.load($o("assets/textures/cloud/shape_1.png"), (e3) => {
            s2.wrapS = s2.wrapT = l, i2.material.uniforms.noiseMap.value = s2;
          }), a2 = n2.load($o("assets/textures/cloud/blue_noise.png"), (e3) => {
            a2.wrapS = a2.wrapT = l, i2.material.uniforms.blueNoiseMap.value = a2;
          }), o2 = n2.load($o("assets/textures/cloud/3d_noise_128.png"), (e3) => {
            o2.wrapS = o2.wrapT = l, i2.material.uniforms.shapeNoiseMap.value = o2;
          });
          i2.material.uniforms.skyMap.value = t2.material.uniforms.iChannel1.value, i2.__isEnvironment = true, i2.renderOrder = -99, e2.add(i2);
        }
        onBeforeScenePrepareRender() {
          super.onBeforeScenePrepareRender();
          const e2 = this.engine, t2 = this._skyAtomsphere, i2 = this._cloud;
          this._skyNeedsUpdate && (t2.updateRenderTargets(e2.rendering.renderer, e2.rendering.camera), i2.material.uniforms.skyAltitude.value = t2.altitude), this.dynamicCloud && (i2.material.uniforms.time.value = e2.rendering.uniforms.elapsedTime.value), (this._skyNeedsUpdate || this.dynamicCloud) && (t2.position.set(0, 0, 0), t2.updateMatrixWorld(), i2.position.set(0, 0, 0), i2.updateMatrixWorld(), this.updateRealtimeEnvironment()), t2.position.copy(e2.rendering.camera.position), t2.position.z -= 0, i2.position.copy(e2.rendering.camera.position), this._skyNeedsUpdate = false;
        }
        updateLight() {
          if (super.updateLight(), this._lensflare) {
            const e2 = this._sunDirection.z, t2 = this._sunDirection.x;
            let i2 = 10 * this.engine.map.getCameraDistance();
            if (e2 > 0.01 && this.sunLight.intensity > 0.1 && i2 < 1e6) {
              this._lensflare.visible = true;
              const [n2, r2] = this.engine.map.getProjectionCenter();
              this._lensflare.position.set(n2 + t2 * i2, r2, e2 * i2);
            } else
              this._lensflare.visible = false;
          }
        }
        onTimeChanged(e2) {
          this._skyAtomsphere.altitude = (e2 / 86400 - 0.25) * Math.PI * 2, this._skyNeedsUpdate = true;
        }
        getTextures() {
          return 2 === this._envMapType ? [this._envRenderTarget1.texture, this._envRenderTarget2.texture] : [];
        }
        get cloudIntensity() {
          return this._cloud.coverage;
        }
        set cloudIntensity(e2) {
          this._cloud.coverage = e2, this._skyNeedsUpdate = true;
        }
        get mixGrayFactor() {
          return this._skyAtomsphere.mixGrayFactor;
        }
        set mixGrayFactor(e2) {
          this._skyAtomsphere.mixGrayFactor = e2, this._cloud.mixGrayFactor = e2, this._skyNeedsUpdate = true;
        }
        get realtimeCapture() {
          return this._realtimeCapture;
        }
        set realtimeCapture(e2) {
          e2 !== this._realtimeCapture && (console.warn("has not been supported"), this._skyNeedsUpdate = true, this._realtimeCapture = e2);
        }
        get clipUnderground() {
          return false;
        }
        set clipUnderground(e2) {
          console.warn("has not been supported");
        }
        beforeRemoveFromEngine(e2) {
          this.disposeEnvRenderTarget(this._realtimeCapture);
        }
        dispose() {
          super.dispose();
        }
      }
      class Lm {
        constructor() {
          this.name = "", this.minZoom = 0, this.maxZoom = 20, this.bounds = [], this.center = [];
        }
        fetchTile(e2, t2, i2) {
          return null;
        }
        getMetaData() {
        }
      }
      class Im extends Lm {
        constructor(e2 = "https://a.tile.openstreetmap.org/") {
          super(), this.address = e2, this.format = "png";
        }
        fetchTile(e2, t2, i2) {
          return new Promise((n2, r2) => {
            const s2 = document.createElement("img");
            s2.onload = function() {
              n2(s2);
            }, s2.onerror = function() {
              r2();
            }, s2.crossOrigin = "Anonymous", s2.src = this.address + e2 + "/" + t2 + "/" + i2 + "." + this.format;
          });
        }
      }
      class Dm extends ri {
        constructor(e2 = 1, t2 = 1, i2 = 1, n2 = 1, r2 = false, s2 = 10) {
          super();
          const a2 = [], o2 = [], l2 = [], h2 = [];
          Dm.buildPlane(e2, t2, i2, n2, a2, o2, l2, h2), r2 && Dm.buildSkirt(e2, t2, i2, n2, s2, a2, o2, l2, h2), this.setIndex(a2), this.setAttribute("position", new Jt(o2, 3)), this.setAttribute("normal", new Jt(l2, 3)), this.setAttribute("uv", new Jt(h2, 2));
        }
        static buildPlane(e2 = 1, t2 = 1, i2 = 1, n2 = 1, r2, s2, a2, o2) {
          const l2 = e2 / 2, h2 = t2 / 2, c2 = i2 + 1, u2 = n2 + 1, d2 = e2 / i2, p2 = t2 / n2;
          for (let m2 = 0; m2 < u2; m2++) {
            const e3 = m2 * p2 - h2;
            for (let t3 = 0; t3 < c2; t3++) {
              const r3 = t3 * d2 - l2;
              s2.push(r3, 0, e3), a2.push(0, 1, 0), o2.push(t3 / i2, 1 - m2 / n2);
            }
          }
          for (let m2 = 0; m2 < n2; m2++)
            for (let e3 = 0; e3 < i2; e3++) {
              const t3 = e3 + c2 * m2, i3 = e3 + c2 * (m2 + 1), n3 = e3 + 1 + c2 * (m2 + 1), s3 = e3 + 1 + c2 * m2;
              r2.push(t3, i3, s3, i3, n3, s3);
            }
        }
        static buildSkirt(e2 = 1, t2 = 1, i2 = 1, n2 = 1, r2, s2, a2, o2, l2) {
          const h2 = e2 / 2, c2 = t2 / 2, u2 = i2 + 1, d2 = n2 + 1, p2 = e2 / i2, m2 = t2 / n2;
          let f2 = a2.length / 3;
          for (let _2 = 0; _2 < u2; _2++) {
            const e3 = _2 * p2 - h2, t3 = -c2;
            a2.push(e3, -r2, t3), o2.push(0, 1, 0), l2.push(_2 / i2, 1);
          }
          for (let _2 = 0; _2 < i2; _2++) {
            const e3 = _2, t3 = _2 + 1, i3 = _2 + f2, n3 = _2 + f2 + 1;
            s2.push(t3, i3, e3, t3, n3, i3);
          }
          f2 = a2.length / 3;
          for (let _2 = 0; _2 < u2; _2++) {
            const e3 = _2 * p2 - h2, t3 = n2 * m2 - c2;
            a2.push(e3, -r2, t3), o2.push(0, 1, 0), l2.push(_2 / i2, 0);
          }
          let g2 = u2 * d2 - i2 - 1;
          for (let _2 = 0; _2 < i2; _2++) {
            const e3 = g2 + _2, t3 = g2 + _2 + 1, i3 = _2 + f2, n3 = _2 + f2 + 1;
            s2.push(e3, i3, t3, i3, n3, t3);
          }
          f2 = a2.length / 3;
          for (let _2 = 0; _2 < d2; _2++) {
            const e3 = _2 * m2 - c2, t3 = -h2;
            a2.push(t3, -r2, e3), o2.push(0, 1, 0), l2.push(0, 1 - _2 / n2);
          }
          for (let _2 = 0; _2 < n2; _2++) {
            const e3 = _2 * d2, t3 = (_2 + 1) * d2, i3 = _2 + f2, n3 = _2 + f2 + 1;
            s2.push(e3, i3, t3, i3, n3, t3);
          }
          f2 = a2.length / 3;
          for (let _2 = 0; _2 < d2; _2++) {
            const e3 = _2 * m2 - c2, t3 = i2 * p2 - h2;
            a2.push(t3, -r2, e3), o2.push(0, 1, 0), l2.push(1, 1 - _2 / n2);
          }
          for (let _2 = 0; _2 < n2; _2++) {
            const e3 = _2 * d2 + n2, t3 = (_2 + 1) * d2 + n2, i3 = _2 + f2, r3 = _2 + f2 + 1;
            s2.push(t3, i3, e3, t3, r3, i3);
          }
        }
      }
      class Fm {
        static createOffscreenCanvas(e2, t2) {
          if (OffscreenCanvas)
            return new OffscreenCanvas(e2, t2);
          {
            let i2 = document.createElement("canvas");
            return i2.width = e2, i2.height = t2, i2;
          }
        }
      }
      class Om extends Mi {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0, a2 = null, o2 = null) {
          super(a2, o2), this.mapView = null, this.parentNode = null, this.nodesLoaded = 0, this.subdivided = false, this.childrenCache = null, this.cacheChild = false, this.isMesh = true, this.mapView = t2, this.parentNode = e2, this.location = i2, this.level = n2, this.x = r2, this.y = s2, t2.overrideMaterial && (this.material = t2.overrideMaterial, this.textureLoaded = true), this.initialize();
        }
        initialize() {
          this.mapView.onNodeCreated && this.mapView.onNodeCreated(this);
        }
        createChildNodes() {
        }
        subdivide() {
          const e2 = Math.min(this.mapView.provider.maxZoom, this.mapView.heightProvider.maxZoom);
          this.children.length > 0 || this.level + 1 > e2 || null !== this.parentNode && this.parentNode.nodesLoaded < Om.childrens || (this.subdivided = true, this.cacheChild && null !== this.childrenCache ? (this.isMesh = false, this.children = this.childrenCache) : this.createChildNodes(), this.mapView.onNodeSubdivided && this.mapView.onNodeSubdivided());
        }
        simplify() {
          this.cacheChild && this.children.length > 0 && (this.childrenCache = this.children), this.subdivided = false, this.isMesh = true, this.children = [];
        }
        loadTexture() {
          this.mapView.provider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Me(e2);
            t2.generateMipmaps = false, t2.format = b, t2.magFilter = m, t2.minFilter = m, t2.needsUpdate = true, this.material.map = t2, this.nodeReady();
          }).catch(() => {
            const e2 = Fm.createOffscreenCanvas(1, 1), t2 = e2.getContext("2d");
            t2.fillStyle = "#FF0000", t2.fillRect(0, 0, 1, 1);
            const i2 = new Me(e2);
            i2.generateMipmaps = false, i2.needsUpdate = true, this.material.map = i2, this.nodeReady();
          });
        }
        nodeReady() {
          if (null !== this.parentNode) {
            if (this.parentNode.nodesLoaded++, this.parentNode.nodesLoaded >= Om.childrens) {
              true === this.parentNode.subdivided && (this.parentNode.isMesh = false);
              for (let e2 = 0; e2 < this.parentNode.children.length; e2++)
                this.parentNode.children[e2].visible = true;
            }
          } else
            this.visible = true;
          this.mapView.onNodeReady && this.mapView.onNodeReady();
        }
        getNeighborsDirection(e2) {
          return null;
        }
        getNeighbors() {
          return [];
        }
      }
      Om.baseGeometry = null, Om.baseScale = null, Om.childrens = 4, Om.root = -1, Om.topLeft = 0, Om.topRight = 1, Om.bottomLeft = 2, Om.bottomRight = 3;
      class Um {
        static get(e2, t2) {
          navigator.geolocation.getCurrentPosition(function(t3) {
            e2(t3.coords, t3.timestamp);
          }, t2);
        }
        static datumsToSpherical(e2, t2) {
          const i2 = t2 * Um.EARTH_ORIGIN / 180;
          let n2 = Math.log(Math.tan((90 + e2) * Math.PI / 360)) / (Math.PI / 180);
          return n2 = n2 * Um.EARTH_ORIGIN / 180, new ie(i2, n2);
        }
        static sphericalToDatums(e2, t2) {
          const i2 = e2 / Um.EARTH_ORIGIN * 180;
          let n2 = t2 / Um.EARTH_ORIGIN * 180;
          return n2 = 180 / Math.PI * (2 * Math.atan(Math.exp(n2 * Math.PI / 180)) - Math.PI / 2), { latitude: n2, longitude: i2 };
        }
        static quadtreeToDatums(e2, t2, i2) {
          const n2 = Math.pow(2, e2), r2 = t2 / n2 * 360 - 180;
          return { latitude: Math.atan(Math.sinh(Math.PI * (1 - 2 * i2 / n2))) / Math.PI * 180, longitude: r2 };
        }
      }
      Um.EARTH_RADIUS = 6378137, Um.EARTH_PERIMETER = 2 * Math.PI * Um.EARTH_RADIUS, Um.EARTH_ORIGIN = Um.EARTH_PERIMETER / 2;
      class zm extends Om {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0) {
          super(e2, t2, i2, n2, r2, s2, zm.geometry, new jt({ wireframe: false })), this.matrixAutoUpdate = false, this.isMesh = true, this.visible = false;
        }
        initialize() {
          super.initialize(), this.loadTexture();
        }
        createChildNodes() {
          const e2 = this.level + 1, t2 = 2 * this.x, i2 = 2 * this.y, n2 = Object.getPrototypeOf(this).constructor;
          let r2 = new n2(this, this.mapView, Om.topLeft, e2, t2, i2);
          r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.topRight, e2, t2 + 1, i2), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.bottomLeft, e2, t2, i2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.bottomRight, e2, t2 + 1, i2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true);
        }
        raycast(e2, t2) {
          return true === this.isMesh && super.raycast(e2, t2);
        }
      }
      zm.geometry = new Dm(1, 1, 1, 1, false), zm.baseGeometry = zm.geometry, zm.baseScale = new Ae(Um.EARTH_PERIMETER, 1, Um.EARTH_PERIMETER);
      class Nm extends ri {
        constructor(e2 = 1, t2 = 1, i2 = 1, n2 = 1, r2 = false, s2 = 10, a2 = null, o2 = true) {
          super();
          const l2 = [], h2 = [], c2 = [], u2 = [];
          Dm.buildPlane(e2, t2, i2, n2, l2, h2, c2, u2);
          const d2 = a2.data;
          for (let p2 = 0, m2 = 0; p2 < d2.length && m2 < h2.length; p2 += 4, m2 += 3) {
            const e3 = d2[p2], t3 = d2[p2 + 1], i3 = d2[p2 + 2];
            if (0 === e3 && 0 === t3 && 0 === i3)
              h2[m2 + 1] = 0;
            else {
              const n3 = 0.1 * (65536 * e3 + 256 * t3 + i3) - 1e4;
              h2[m2 + 1] = n3;
            }
          }
          r2 && Dm.buildSkirt(e2, t2, i2, n2, s2, l2, h2, c2, u2), this.setIndex(l2), this.setAttribute("position", new Jt(h2, 3)), this.setAttribute("normal", new Jt(c2, 3)), this.setAttribute("uv", new Jt(u2, 2)), o2 && this.computeNormals(i2, n2);
        }
        computeNormals(e2, t2) {
          const i2 = this.getAttribute("position");
          if (void 0 !== i2) {
            let n2 = this.getAttribute("normal");
            const r2 = t2 * e2;
            for (let e3 = 0; e3 < r2; e3++)
              n2.setXYZ(e3, 0, 0, 0);
            const s2 = new Ae(), a2 = new Ae(), o2 = new Ae(), l2 = new Ae(), h2 = new Ae(), c2 = new Ae(), u2 = new Ae(), d2 = new Ae(), p2 = t2 * e2 * 6;
            for (let e3 = 0; e3 < p2; e3 += 3) {
              const t3 = this.index.getX(e3 + 0), r3 = this.index.getX(e3 + 1), p3 = this.index.getX(e3 + 2);
              s2.fromBufferAttribute(i2, t3), a2.fromBufferAttribute(i2, r3), o2.fromBufferAttribute(i2, p3), u2.subVectors(o2, a2), d2.subVectors(s2, a2), u2.cross(d2), l2.fromBufferAttribute(n2, t3), h2.fromBufferAttribute(n2, r3), c2.fromBufferAttribute(n2, p3), l2.add(u2), h2.add(u2), c2.add(u2), n2.setXYZ(t3, l2.x, l2.y, l2.z), n2.setXYZ(r3, h2.x, h2.y, h2.z), n2.setXYZ(p3, c2.x, c2.y, c2.z);
            }
            this.normalizeNormals(), n2.needsUpdate = true;
          }
        }
      }
      class km extends Om {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0, a2 = km.geometry, o2 = new xa({ wireframe: false, color: 16777215 })) {
          super(e2, t2, i2, n2, r2, s2, a2, o2), this.heightLoaded = false, this.geometrySize = 16, this.geometryNormals = false, o2.alphaTest = 0.1, this.isMesh = true, this.visible = false, this.matrixAutoUpdate = false;
        }
        initialize() {
          super.initialize(), this.textureLoaded ? setTimeout(() => {
            this.textureLoaded = true;
          }, 0) : this.loadTexture(), this.loadHeightGeometry();
        }
        loadTexture() {
          this.mapView.provider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Me(e2);
            t2.generateMipmaps = false, t2.format = b, t2.magFilter = m, t2.minFilter = m, t2.needsUpdate = true, this.material.map = t2;
          }).catch(() => {
            console.log("texture error");
          }).finally(() => {
            this.textureLoaded = true, this.nodeReady();
          });
        }
        nodeReady() {
          this.heightLoaded && this.textureLoaded && (this.visible = true, super.nodeReady());
        }
        createChildNodes() {
          const e2 = this.level + 1, t2 = Object.getPrototypeOf(this).constructor, i2 = 2 * this.x, n2 = 2 * this.y;
          let r2 = new t2(this, this.mapView, Om.topLeft, e2, i2, n2);
          r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.topRight, e2, i2 + 1, n2), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.bottomLeft, e2, i2, n2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.bottomRight, e2, i2 + 1, n2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true);
        }
        loadHeightGeometry() {
          if (null === this.mapView.heightProvider)
            throw new Error("GeoThree: MapView.heightProvider provider is null.");
          return this.mapView.heightProvider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = Fm.createOffscreenCanvas(this.geometrySize + 1, this.geometrySize + 1), i2 = t2.getContext("2d");
            i2.imageSmoothingEnabled = false, i2.drawImage(e2, 0, 0, km.tileSize, km.tileSize, 0, 0, t2.width, t2.height);
            const n2 = i2.getImageData(0, 0, t2.width, t2.height), r2 = new Nm(1, 1, this.geometrySize, this.geometrySize, true, 10, n2, true);
            this.geometry = r2;
          }).catch(() => {
          }).finally(() => {
            this.heightLoaded = true, this.nodeReady();
          });
        }
        raycast(e2, t2) {
          return true === this.isMesh && super.raycast(e2, t2);
        }
      }
      km.tileSize = 256, km.geometry = new Dm(1, 1, 1, 1), km.baseGeometry = zm.geometry, km.baseScale = new Ae(Um.EARTH_PERIMETER, 1, Um.EARTH_PERIMETER);
      class Bm extends ri {
        constructor(e2, t2, i2, n2, r2, s2, a2) {
          super();
          const o2 = s2 + a2;
          let l2 = 0;
          const h2 = [], c2 = new Ae(), u2 = new Ae(), d2 = [], p2 = [], m2 = [], f2 = [];
          for (let g2 = 0; g2 <= i2; g2++) {
            const o3 = [], d3 = g2 / i2;
            for (let i3 = 0; i3 <= t2; i3++) {
              const h3 = i3 / t2;
              c2.x = -e2 * Math.cos(n2 + h3 * r2) * Math.sin(s2 + d3 * a2), c2.y = e2 * Math.cos(s2 + d3 * a2), c2.z = e2 * Math.sin(n2 + h3 * r2) * Math.sin(s2 + d3 * a2), p2.push(c2.x, c2.y, c2.z), u2.set(c2.x, c2.y, c2.z).normalize(), m2.push(u2.x, u2.y, u2.z), f2.push(h3, 1 - d3), o3.push(l2++);
            }
            h2.push(o3);
          }
          for (let g2 = 0; g2 < i2; g2++)
            for (let e3 = 0; e3 < t2; e3++) {
              const t3 = h2[g2][e3 + 1], n3 = h2[g2][e3], r3 = h2[g2 + 1][e3], a3 = h2[g2 + 1][e3 + 1];
              (0 !== g2 || s2 > 0) && d2.push(t3, n3, a3), (g2 !== i2 - 1 || o2 < Math.PI) && d2.push(n3, r3, a3);
            }
          this.setIndex(d2), this.setAttribute("position", new Jt(p2, 3)), this.setAttribute("normal", new Jt(m2, 3)), this.setAttribute("uv", new Jt(f2, 2));
        }
      }
      class Vm extends Om {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0) {
          super(e2, t2, i2, n2, r2, s2, Vm.createGeometry(n2, r2, s2), new jt({ wireframe: false })), this.applyScaleNode(), this.matrixAutoUpdate = false, this.isMesh = true, this.visible = false;
        }
        initialize() {
          super.initialize(), this.loadTexture();
        }
        static createGeometry(e2, t2, i2) {
          const n2 = Math.pow(2, e2), r2 = Math.floor(Vm.segments * (40 / (e2 + 1)) / 40), s2 = 1 / n2 * 2 * Math.PI, a2 = t2 * s2, o2 = 1 / n2 * Math.PI;
          return new Bm(1, r2, r2, a2, s2, i2 * o2, o2);
        }
        applyScaleNode() {
          this.geometry.computeBoundingBox();
          const e2 = this.geometry.boundingBox.clone().getCenter(new Ae()), t2 = new st();
          t2.compose(new Ae(-e2.x, -e2.y, -e2.z), new Ce(), new Ae(Um.EARTH_RADIUS, Um.EARTH_RADIUS, Um.EARTH_RADIUS)), this.geometry.applyMatrix4(t2), this.position.copy(e2), this.updateMatrix(), this.updateMatrixWorld();
        }
        updateMatrix() {
          this.matrix.setPosition(this.position), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e2 = false) {
          (this.matrixWorldNeedsUpdate || e2) && (this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = false);
        }
        createChildNodes() {
          const e2 = this.level + 1, t2 = 2 * this.x, i2 = 2 * this.y, n2 = Object.getPrototypeOf(this).constructor;
          let r2 = new n2(this, this.mapView, Om.topLeft, e2, t2, i2);
          this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.topRight, e2, t2 + 1, i2), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.bottomLeft, e2, t2, i2 + 1), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new n2(this, this.mapView, Om.bottomRight, e2, t2 + 1, i2 + 1), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true);
        }
        raycast(e2, t2) {
          return true === this.isMesh && super.raycast(e2, t2);
        }
      }
      Vm.baseGeometry = new Bm(Um.EARTH_RADIUS, 64, 64, 0, 2 * Math.PI, 0, Math.PI), Vm.baseScale = new Ae(1, 1, 1), Vm.segments = 80;
      class Gm extends km {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0) {
          const a2 = Gm.prepareMaterial(new ba({ map: Gm.emptyTexture, color: 16777215 }));
          super(e2, t2, i2, n2, r2, s2, Gm.geometry, a2), this.frustumCulled = false;
        }
        static prepareMaterial(e2) {
          return e2.userData = { heightMap: { value: Gm.emptyTexture } }, e2.onBeforeCompile = (t2) => {
            for (const i2 in e2.userData)
              t2.uniforms[i2] = e2.userData[i2];
            t2.vertexShader = "\n			uniform sampler2D heightMap;\n			" + t2.vertexShader, t2.vertexShader = t2.vertexShader.replace("#include <fog_vertex>", "\n			#include <fog_vertex>\n	\n			// Calculate height of the title\n			vec4 _theight = texture2D(heightMap, vUv);\n			float _height = ((_theight.r * 255.0 * 65536.0 + _theight.g * 255.0 * 256.0 + _theight.b * 255.0) * 0.1) - 10000.0;\n			vec3 _transformed = position + _height * normal;\n	\n			// Vertex position based on height\n			gl_Position = projectionMatrix * modelViewMatrix * vec4(_transformed, 1.0);\n			");
          }, e2;
        }
        loadTexture() {
          this.mapView.provider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Me(e2);
            t2.generateMipmaps = false, t2.format = b, t2.magFilter = m, t2.minFilter = m, t2.needsUpdate = true, this.material.map = t2, this.textureLoaded = true, this.nodeReady();
          }).catch((e2) => {
            console.error("GeoThree: Failed to load color node data.", e2);
          }).finally(() => {
            this.textureLoaded = true, this.nodeReady();
          }), this.loadHeightGeometry();
        }
        loadHeightGeometry() {
          if (null === this.mapView.heightProvider)
            throw new Error("GeoThree: MapView.heightProvider provider is null.");
          return this.mapView.heightProvider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Me(e2);
            t2.generateMipmaps = false, t2.format = b, t2.magFilter = u, t2.minFilter = u, t2.needsUpdate = true, this.material.userData.heightMap.value = t2;
          }).catch((e2) => {
            console.error("GeoThree: Failed to load height node data.", e2);
          }).finally(() => {
            this.heightLoaded = true, this.nodeReady();
          });
        }
        raycast(e2, t2) {
          if (true === this.isMesh) {
            this.geometry = zm.geometry;
            const i2 = super.raycast(e2, t2);
            return this.geometry = Gm.geometry, i2;
          }
          return false;
        }
      }
      Gm.emptyTexture = new Me(), Gm.geometrySize = 256, Gm.geometry = new Dm(1, 1, Gm.geometrySize, Gm.geometrySize, true), Gm.baseGeometry = zm.geometry, Gm.baseScale = new Ae(Um.EARTH_PERIMETER, 1, Um.EARTH_PERIMETER);
      const Hm = new Ae(), jm = new Ae();
      const Wm = new st(), Xm = new Ae(), qm = new Vi(), Ym = new Ae();
      class Zm extends class {
        constructor() {
          this.subdivideDistance = 50, this.simplifyDistance = 300;
        }
        updateLOD(e2, t2, i2, n2) {
          t2.getWorldPosition(Hm), e2.children[0].traverse((t3) => {
            t3.getWorldPosition(jm);
            let i3 = Hm.distanceTo(jm);
            i3 /= Math.pow(2, e2.provider.maxZoom - t3.level), i3 < this.subdivideDistance ? t3.subdivide() : i3 > this.simplifyDistance && t3.parentNode && t3.parentNode.simplify();
          });
        }
      } {
        constructor() {
          super(...arguments), this.subdivideDistance = 120, this.simplifyDistance = 400, this.testCenter = true, this.pointOnly = false, this.lodOffset = 0;
        }
        updateLOD(e2, t2, i2, n2) {
          Wm.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), qm.setFromProjectionMatrix(Wm), t2.getWorldPosition(Xm), e2.children[0].traverse((t3) => {
            t3.getWorldPosition(Ym);
            let i3 = Xm.distanceTo(Ym);
            i3 /= Math.pow(2, e2.provider.maxZoom - t3.level + this.lodOffset);
            const n3 = this.pointOnly ? qm.containsPoint(Ym) : qm.intersectsObject(t3);
            i3 < this.subdivideDistance && n3 ? t3.subdivide() : i3 > this.simplifyDistance && t3.parentNode && t3.parentNode.simplify();
          });
        }
      }
      function Jm(e2, t2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, s2) {
          function a2(e3) {
            try {
              l2(n2.next(e3));
            } catch (rl2) {
              s2(rl2);
            }
          }
          function o2(e3) {
            try {
              l2(n2.throw(e3));
            } catch (rl2) {
              s2(rl2);
            }
          }
          function l2(e3) {
            var t3;
            e3.done ? r2(e3.value) : (t3 = e3.value, t3 instanceof i2 ? t3 : new i2(function(e4) {
              e4(t3);
            })).then(a2, o2);
          }
          l2((n2 = n2.apply(e2, t2 || [])).next());
        });
      }
      class Km {
        constructor(e2 = 257) {
          this.gridSize = e2;
          const t2 = e2 - 1;
          if (t2 & t2 - 1)
            throw new Error(`Expected grid size to be 2^n+1, got ${e2}.`);
          this.numTriangles = t2 * t2 * 2 - 2, this.numParentTriangles = this.numTriangles - t2 * t2, this.indices = new Uint32Array(this.gridSize * this.gridSize), this.coords = new Uint16Array(4 * this.numTriangles);
          for (let i2 = 0; i2 < this.numTriangles; i2++) {
            let e3 = i2 + 2, n2 = 0, r2 = 0, s2 = 0, a2 = 0, o2 = 0, l2 = 0;
            for (1 & e3 ? s2 = a2 = o2 = t2 : n2 = r2 = l2 = t2; (e3 >>= 1) > 1; ) {
              const t3 = n2 + s2 >> 1, i3 = r2 + a2 >> 1;
              1 & e3 ? (s2 = n2, a2 = r2, n2 = o2, r2 = l2) : (n2 = s2, r2 = a2, s2 = o2, a2 = l2), o2 = t3, l2 = i3;
            }
            const h2 = 4 * i2;
            this.coords[h2 + 0] = n2, this.coords[h2 + 1] = r2, this.coords[h2 + 2] = s2, this.coords[h2 + 3] = a2;
          }
        }
        createTile(e2) {
          return new Qm(e2, this);
        }
      }
      class Qm {
        constructor(e2, t2) {
          const i2 = t2.gridSize;
          if (e2.length !== i2 * i2)
            throw new Error(`Expected terrain data of length ${i2 * i2} (${i2} x ${i2}), got ${e2.length}.`);
          this.terrain = e2, this.martini = t2, this.errors = new Float32Array(e2.length), this.update();
        }
        update() {
          const { numTriangles: e2, numParentTriangles: t2, coords: i2, gridSize: n2 } = this.martini, { terrain: r2, errors: s2 } = this;
          for (let a2 = e2 - 1; a2 >= 0; a2--) {
            const e3 = 4 * a2, o2 = i2[e3 + 0], l2 = i2[e3 + 1], h2 = i2[e3 + 2], c2 = i2[e3 + 3], u2 = o2 + h2 >> 1, d2 = l2 + c2 >> 1, p2 = u2 + d2 - l2, m2 = d2 + o2 - u2, f2 = (r2[l2 * n2 + o2] + r2[c2 * n2 + h2]) / 2, g2 = d2 * n2 + u2, _2 = Math.abs(f2 - r2[g2]);
            if (s2[g2] = Math.max(s2[g2], _2), a2 < t2) {
              const e4 = (l2 + m2 >> 1) * n2 + (o2 + p2 >> 1), t3 = (c2 + m2 >> 1) * n2 + (h2 + p2 >> 1);
              s2[g2] = Math.max(s2[g2], s2[e4], s2[t3]);
            }
          }
        }
        getMesh(e2 = 0, t2 = false) {
          const { gridSize: i2, indices: n2 } = this.martini, { errors: r2 } = this;
          let s2 = 0, a2 = 0;
          const o2 = i2 - 1;
          let l2, h2, c2 = 0;
          const u2 = [], d2 = [], p2 = [], m2 = [];
          function f2(g3, _3, v3, x3, y3, b3) {
            const M2 = g3 + v3 >> 1, S2 = _3 + x3 >> 1;
            Math.abs(g3 - y3) + Math.abs(_3 - b3) > 1 && r2[S2 * i2 + M2] > e2 ? (f2(y3, b3, g3, _3, M2, S2), f2(v3, x3, y3, b3, M2, S2)) : (l2 = _3 * i2 + g3, h2 = x3 * i2 + v3, c2 = b3 * i2 + y3, 0 === n2[l2] && (t2 && (0 === g3 ? u2.push(s2) : g3 === o2 && d2.push(s2), 0 === _3 ? p2.push(s2) : _3 === o2 && m2.push(s2)), n2[l2] = ++s2), 0 === n2[h2] && (t2 && (0 === v3 ? u2.push(s2) : v3 === o2 && d2.push(s2), 0 === x3 ? p2.push(s2) : x3 === o2 && m2.push(s2)), n2[h2] = ++s2), 0 === n2[c2] && (t2 && (0 === y3 ? u2.push(s2) : y3 === o2 && d2.push(s2), 0 === b3 ? p2.push(s2) : b3 === o2 && m2.push(s2)), n2[c2] = ++s2), a2++);
          }
          n2.fill(0), f2(0, 0, o2, o2, o2, 0), f2(o2, o2, 0, 0, 0, o2);
          let g2 = 2 * s2, _2 = 3 * a2;
          t2 && (g2 += 2 * (u2.length + d2.length + p2.length + m2.length), _2 += 3 * (2 * (u2.length - 1) + 2 * (d2.length - 1) + 2 * (p2.length - 1) + 2 * (m2.length - 1)));
          const v2 = new Uint16Array(g2), x2 = new Uint32Array(_2);
          let y2 = 0;
          function b2(t3, s3, a3, o3, l3, h3) {
            const c3 = t3 + a3 >> 1, u3 = s3 + o3 >> 1;
            if (Math.abs(t3 - l3) + Math.abs(s3 - h3) > 1 && r2[u3 * i2 + c3] > e2)
              b2(l3, h3, t3, s3, c3, u3), b2(a3, o3, l3, h3, c3, u3);
            else {
              const e3 = n2[s3 * i2 + t3] - 1, r3 = n2[o3 * i2 + a3] - 1, c4 = n2[h3 * i2 + l3] - 1;
              v2[2 * e3] = t3, v2[2 * e3 + 1] = s3, v2[2 * r3] = a3, v2[2 * r3 + 1] = o3, v2[2 * c4] = l3, v2[2 * c4 + 1] = h3, x2[y2++] = e3, x2[y2++] = r3, x2[y2++] = c4;
            }
          }
          if (b2(0, 0, o2, o2, o2, 0), b2(o2, o2, 0, 0, 0, o2), t2) {
            let e3 = function(e4) {
              const i3 = e4.length;
              for (let n3 = 0; n3 < i3 - 1; n3++) {
                const i4 = e4[n3], r3 = e4[n3 + 1], s3 = t3 / 2, a3 = (t3 + 2) / 2;
                v2[t3++] = v2[2 * i4], v2[t3++] = v2[2 * i4 + 1], x2[y2++] = i4, x2[y2++] = s3, x2[y2++] = r3, x2[y2++] = s3, x2[y2++] = a3, x2[y2++] = r3;
              }
              v2[t3++] = v2[2 * e4[i3 - 1]], v2[t3++] = v2[2 * e4[i3 - 1] + 1];
            };
            u2.sort((e4, t4) => v2[2 * e4 + 1] - v2[2 * t4 + 1]), d2.sort((e4, t4) => v2[2 * t4 + 1] - v2[2 * e4 + 1]), p2.sort((e4, t4) => v2[2 * t4] - v2[2 * e4]), m2.sort((e4, t4) => v2[2 * e4] - v2[2 * t4]);
            let t3 = 2 * s2;
            e3(u2), e3(d2), e3(p2), e3(m2);
          }
          return { vertices: v2, triangles: x2, numVerticesWithoutSkirts: s2 };
        }
      }
      class $m extends km {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0, { elevationDecoder: a2 = null, meshMaxError: o2 = 10, exageration: l2 = 1 } = {}) {
          super(e2, t2, i2, n2, r2, s2, $m.geometry, $m.prepareMaterial(new ba({ map: $m.emptyTexture, color: 16777215, side: 2 }), n2, l2)), this.elevationDecoder = { rScaler: 256, gScaler: 1, bScaler: 1 / 256, offset: -32768 }, this.exageration = 1, this.meshMaxError = 10, a2 && (this.elevationDecoder = a2), this.meshMaxError = o2, this.exageration = l2, this.frustumCulled = false;
        }
        static prepareMaterial(e2, t2, i2 = 1) {
          return e2.userData = { heightMap: { value: $m.emptyTexture }, drawNormals: { value: 0 }, drawBlack: { value: 0 }, zoomlevel: { value: t2 }, computeNormals: { value: 1 }, drawTexture: { value: 1 } }, e2.onBeforeCompile = (t3) => {
            for (let i3 in e2.userData)
              t3.uniforms[i3] = e2.userData[i3];
            t3.vertexShader = "\n				uniform bool computeNormals;\n				uniform float zoomlevel;\n				uniform sampler2D heightMap;\n				" + t3.vertexShader, t3.fragmentShader = "\n				uniform bool drawNormals;\n				uniform bool drawTexture;\n				uniform bool drawBlack;\n				" + t3.fragmentShader, t3.fragmentShader = t3.fragmentShader.replace("#include <dithering_fragment>", "\n				if(drawBlack) {\n					gl_FragColor = vec4( 0.0,0.0,0.0, 1.0 );\n				} else if(drawNormals) {\n					gl_FragColor = vec4( ( 0.5 * vNormal + 0.5 ), 1.0 );\n				} else if (!drawTexture) {\n					gl_FragColor = vec4( 0.0,0.0,0.0, 0.0 );\n				}"), t3.vertexShader = t3.vertexShader.replace("#include <fog_vertex>", "\n				#include <fog_vertex>\n\n				// queried pixels:\n				// +-----------+\n				// |   |   |   |\n				// | a | b | c |\n				// |   |   |   |\n				// +-----------+\n				// |   |   |   |\n				// | d | e | f |\n				// |   |   |   |\n				// +-----------+\n				// |   |   |   |\n				// | g | h | i |\n				// |   |   |   |\n				// +-----------+\n\n				if (computeNormals) {\n					float e = getElevation(vUv, 0.0);\n					ivec2 size = textureSize(heightMap, 0);\n					float offset = 1.0 / float(size.x);\n					float a = getElevation(vUv + vec2(-offset, -offset), 0.0);\n					float b = getElevation(vUv + vec2(0, -offset), 0.0);\n					float c = getElevation(vUv + vec2(offset, -offset), 0.0);\n					float d = getElevation(vUv + vec2(-offset, 0), 0.0);\n					float f = getElevation(vUv + vec2(offset, 0), 0.0);\n					float g = getElevation(vUv + vec2(-offset, offset), 0.0);\n					float h = getElevation(vUv + vec2(0, offset), 0.0);\n					float i = getElevation(vUv + vec2(offset,offset), 0.0);\n\n\n					float normalLength = 500.0 / zoomlevel;\n\n					vec3 v0 = vec3(0.0, 0.0, 0.0);\n					vec3 v1 = vec3(0.0, normalLength, 0.0);\n					vec3 v2 = vec3(normalLength, 0.0, 0.0);\n					v0.z = (e + d + g + h) / 4.0;\n					v1.z = (e+ b + a + d) / 4.0;\n					v2.z = (e+ h + i + f) / 4.0;\n					vNormal = (normalize(cross(v2 - v0, v1 - v0))).rbg;\n				}\n				");
          }, e2;
        }
        static getTerrain(e2, t2, i2) {
          const { rScaler: n2, bScaler: r2, gScaler: s2, offset: a2 } = i2, o2 = t2 + 1, l2 = new Float32Array(o2 * o2);
          for (let h2 = 0, c2 = 0; c2 < t2; c2++)
            for (let i3 = 0; i3 < t2; i3++, h2++) {
              const t3 = 4 * h2, i4 = e2[t3 + 0], o3 = e2[t3 + 1], u2 = e2[t3 + 2];
              l2[h2 + c2] = i4 * n2 + o3 * s2 + u2 * r2 + a2;
            }
          for (let h2 = o2 * (o2 - 1), c2 = 0; c2 < o2 - 1; c2++, h2++)
            l2[h2] = l2[h2 - o2];
          for (let h2 = o2 - 1, c2 = 0; c2 < o2; c2++, h2 += o2)
            l2[h2] = l2[h2 - 1];
          return l2;
        }
        static getMeshAttributes(e2, t2, i2, n2, r2) {
          const s2 = i2 + 1, a2 = e2.length / 2, o2 = new Float32Array(3 * a2), l2 = new Float32Array(2 * a2), [h2, c2, u2, d2] = n2 || [0, 0, i2, i2], p2 = (u2 - h2) / i2, m2 = (d2 - c2) / i2;
          for (let f2 = 0; f2 < a2; f2++) {
            const n3 = e2[2 * f2], a3 = e2[2 * f2 + 1], c3 = a3 * s2 + n3;
            o2[3 * f2 + 0] = n3 * p2 + h2, o2[3 * f2 + 1] = -t2[c3] * r2, o2[3 * f2 + 2] = -a3 * m2 + d2, l2[2 * f2 + 0] = n3 / i2, l2[2 * f2 + 1] = a3 / i2;
          }
          return { position: { value: o2, size: 3 }, uv: { value: l2, size: 2 } };
        }
        onHeightImage(e2) {
          return Jm(this, void 0, void 0, function* () {
            const t2 = e2.width, i2 = t2 + 1;
            var n2 = Fm.createOffscreenCanvas(t2, t2), r2 = n2.getContext("2d");
            r2.imageSmoothingEnabled = false, r2.drawImage(e2, 0, 0, t2, t2, 0, 0, n2.width, n2.height);
            var s2 = r2.getImageData(0, 0, n2.width, n2.height).data;
            const a2 = $m.getTerrain(s2, t2, this.elevationDecoder), o2 = new Km(i2).createTile(a2), { vertices: l2, triangles: h2 } = o2.getMesh("function" == typeof this.meshMaxError ? this.meshMaxError(this.level) : this.meshMaxError), c2 = $m.getMeshAttributes(l2, a2, t2, [-0.5, -0.5, 0.5, 0.5], this.exageration);
            this.geometry = new ri(), this.geometry.setIndex(new Zt(h2, 1)), this.geometry.setAttribute("position", new Jt(c2.position.value, c2.position.size)), this.geometry.setAttribute("uv", new Jt(c2.uv.value, c2.uv.size)), this.geometry.rotateX(Math.PI);
            var d2 = new Me(e2);
            d2.generateMipmaps = false, d2.format = b, d2.magFilter = u, d2.minFilter = u, d2.needsUpdate = true, this.material.userData.heightMap.value = d2;
          });
        }
        loadHeightGeometry() {
          if (null === this.mapView.heightProvider)
            throw new Error("GeoThree: MapView.heightProvider provider is null.");
          return this.mapView.heightProvider.fetchTile(this.level, this.x, this.y).then((e2) => Jm(this, void 0, void 0, function* () {
            this.onHeightImage(e2);
          })).finally(() => {
            this.heightLoaded = true, this.nodeReady();
          });
        }
      }
      $m.geometrySize = 16, $m.emptyTexture = new Me(), $m.geometry = new Dm(1, 1, 1, 1), $m.tileSize = 256;
      class ef extends Om {
        constructor(e2 = null, t2 = null, i2 = Om.root, n2 = 0, r2 = 0, s2 = 0, a2 = ef.geometry, o2 = new xa({ wireframe: false, color: 16777215 })) {
          super(e2, t2, i2, n2, r2, s2, a2, o2), this.heightLoaded = false, this.textureLoaded = false, this.geometrySize = 16, this.geometryNormals = false, this.isMesh = true, this.visible = false, this.matrixAutoUpdate = false;
        }
        initialize() {
          super.initialize(), this.loadTexture(), this.loadHeightGeometry();
        }
        loadTexture() {
          this.mapView.provider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Me(e2);
            t2.generateMipmaps = false, t2.format = b, t2.magFilter = m, t2.minFilter = m, t2.needsUpdate = true, this.material.map = t2;
          }).finally(() => {
            this.textureLoaded = true, this.nodeReady();
          });
        }
        nodeReady() {
          this.heightLoaded && this.textureLoaded && (this.visible = true, super.nodeReady());
        }
        createChildNodes() {
          const e2 = this.level + 1, t2 = Object.getPrototypeOf(this).constructor, i2 = 2 * this.x, n2 = 2 * this.y;
          let r2 = new t2(this, this.mapView, Om.topLeft, e2, i2, n2);
          r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.topRight, e2, i2 + 1, n2), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, -0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.bottomLeft, e2, i2, n2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(-0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true), r2 = new t2(this, this.mapView, Om.bottomRight, e2, i2 + 1, n2 + 1), r2.scale.set(0.5, 1, 0.5), r2.position.set(0.25, 0, 0.25), this.add(r2), r2.updateMatrix(), r2.updateMatrixWorld(true);
        }
        loadHeightGeometry() {
          if (null === this.mapView.heightProvider)
            throw new Error("GeoThree: MapView.heightProvider provider is null.");
          return this.mapView.heightProvider.fetchTile(this.level, this.x, this.y).then((e2) => {
            const t2 = new Nm(1, 1, this.geometrySize, this.geometrySize, true, 10, imageData, true);
            this.geometry = t2;
          }).catch(() => {
            console.error("GeoThree: Failed to load height node data.", this);
          }).finally(() => {
            this.heightLoaded = true, this.nodeReady();
          });
        }
        raycast(e2, t2) {
          return true === this.isMesh && super.raycast(e2, t2);
        }
      }
      ef.tileSize = 256, ef.geometry = new Dm(1, 1, 1, 1), ef.baseGeometry = zm.geometry, ef.baseScale = new Ae(Um.EARTH_PERIMETER, 1, Um.EARTH_PERIMETER);
      class tf extends Mi {
        constructor(e2 = tf.PLANAR, t2 = new Im(), i2 = null, n2 = null) {
          super(void 0, new jt({ transparent: true, opacity: 0 })), this.lod = null, this.onNodeReady = null, this.provider = null, this.heightProvider = null, this.root = null, this.overrideMaterial = n2, this.lod = new Zm(), this.provider = t2, this.heightProvider = i2, this.setRoot(e2);
        }
        update(e2, t2, i2) {
          this.lod.updateLOD(this, e2, t2, i2);
        }
        setRoot(e2) {
          if ("number" == typeof e2) {
            if (!tf.mapModes.has(e2))
              throw new Error("Map mode " + e2 + " does is not registered.");
            e2 = new (tf.mapModes.get(e2))(null, this);
          }
          null !== this.root && (this.remove(this.root), this.root = null), this.root = e2, null !== this.root && (this.geometry = this.root.constructor.baseGeometry, this.scale.copy(this.root.constructor.baseScale), this.root.mapView = this, this.add(this.root));
        }
        setProvider(e2) {
          e2 !== this.provider && (this.provider = e2, this.clear());
        }
        setHeightProvider(e2) {
          e2 !== this.heightProvider && (this.heightProvider = e2, this.clear());
        }
        clear() {
          return this.traverse(function(e2) {
            e2.childrenCache && (e2.childrenCache = null), e2.initialize && e2.initialize();
          }), this;
        }
        getMetaData() {
          this.provider.getMetaData();
        }
        raycast(e2, t2) {
          return false;
        }
      }
      tf.PLANAR = 200, tf.SPHERICAL = 201, tf.HEIGHT = 202, tf.HEIGHT_SHADER = 203, tf.MARTINI = 204, tf.TERRAIN = 205, tf.mapModes = /* @__PURE__ */ new Map([[tf.PLANAR, zm], [tf.SPHERICAL, Vm], [tf.HEIGHT, km], [tf.HEIGHT_SHADER, Gm], [tf.MARTINI, $m], [tf.TERRAIN, ef]]);
      class nf {
        static get(e2, t2, i2) {
          const n2 = new XMLHttpRequest();
          return n2.overrideMimeType("text/plain"), n2.open("GET", e2, true), void 0 !== t2 && (n2.onload = function() {
            t2(n2.response);
          }), void 0 !== i2 && (n2.onerror = i2), n2.send(null), n2;
        }
        static getRaw(e2, t2, i2) {
          var n2 = new XMLHttpRequest();
          return n2.responseType = "arraybuffer", n2.open("GET", e2, true), void 0 !== t2 && (n2.onload = function() {
            t2(n2.response);
          }), void 0 !== i2 && (n2.onerror = i2), n2.send(null), n2;
        }
        static request(e2, t2, i2, n2, r2, s2, a2) {
          const o2 = new XMLHttpRequest();
          if (o2.overrideMimeType("text/plain"), o2.open(t2, e2, true), null != i2)
            for (const l2 in i2)
              o2.setRequestHeader(l2, i2[l2]);
          return void 0 !== r2 && (o2.onload = function(e3) {
            r2(function(e4) {
              try {
                return JSON.parse(e4);
              } catch (rl2) {
                return e4;
              }
            }(o2.response), o2);
          }), void 0 !== s2 && (o2.onerror = s2), void 0 !== a2 && (o2.onprogress = a2), void 0 !== n2 ? o2.send(n2) : o2.send(null), o2;
        }
      }
      class rf extends Lm {
        constructor(e2 = "", t2 = rf.AERIAL) {
          super(), this.maxZoom = 19, this.format = "jpeg", this.mapSize = 512, this.subdomain = "t1", this.apiKey = e2, this.type = t2;
        }
        getMetaData() {
          const e2 = "http://dev.virtualearth.net/REST/V1/Imagery/Metadata/RoadOnDemand?output=json&include=ImageryProviders&key=" + this.apiKey;
          nf.get(e2, function(e3) {
            JSON.parse(e3);
          });
        }
        static quadKey(e2, t2, i2) {
          let n2 = "";
          for (let r2 = e2; r2 > 0; r2--) {
            const e3 = 1 << r2 - 1;
            let s2 = 0;
            0 != (t2 & e3) && s2++, 0 != (i2 & e3) && (s2 += 2), n2 += s2;
          }
          return n2;
        }
        fetchTile(e2, t2, i2) {
          return new Promise((n2, r2) => {
            const s2 = document.createElement("img");
            if (s2.onload = function() {
              n2(s2);
            }, s2.onerror = function() {
              r2();
            }, s2.crossOrigin = "Anonymous", this.getUrl) {
              const n3 = this.getUrl(e2, t2, i2);
              if (false !== n3)
                return void (s2.src = n3);
            }
            s2.src = "http://ecn." + this.subdomain + ".tiles.virtualearth.net/tiles/" + this.type + rf.quadKey(e2, t2, i2) + ".jpeg?g=1173";
          });
        }
      }
      rf.AERIAL = "a", rf.ROAD = "r", rf.AERIAL_LABELS = "h", rf.OBLIQUE = "o", rf.OBLIQUE_LABELS = "b";
      (class extends Lm {
        constructor(e2, t2, i2, n2, r2, s2) {
          super(), this.appId = void 0 !== e2 ? e2 : "", this.appCode = void 0 !== t2 ? t2 : "", this.style = void 0 !== i2 ? i2 : "base", this.scheme = void 0 !== n2 ? n2 : "normal.day", this.format = void 0 !== r2 ? r2 : "png", this.size = void 0 !== s2 ? s2 : 512, this.version = "newest", this.server = 1;
        }
        nextServer() {
          this.server = this.server % 4 == 0 ? 1 : this.server + 1;
        }
        getMetaData() {
        }
        fetchTile(e2, t2, i2) {
          return this.nextServer(), new Promise((n2, r2) => {
            const s2 = document.createElement("img");
            s2.onload = function() {
              n2(s2);
            }, s2.onerror = function() {
              r2();
            }, s2.crossOrigin = "Anonymous", s2.src = "https://" + this.server + "." + this.style + ".maps.api.here.com/maptile/2.1/maptile/" + this.version + "/" + this.scheme + "/" + e2 + "/" + t2 + "/" + i2 + "/" + this.size + "/" + this.format + "?app_id=" + this.appId + "&app_code=" + this.appCode;
          });
        }
      }).PATH = "/maptile/2.1/";
      class sf extends Lm {
        constructor(e2 = "", t2 = "", i2 = sf.STYLE, n2 = "png", r2 = false, s2 = "v4") {
          super(), this.apiToken = e2, this.format = n2, this.useHDPI = r2, this.mode = i2, this.mapId = t2, this.style = t2, this.version = s2;
        }
        getMetaData() {
          const e2 = sf.ADDRESS + this.version + "/" + this.mapId + ".json?access_token=" + this.apiToken;
          nf.get(e2, (e3) => {
            const t2 = JSON.parse(e3);
            this.name = t2.name, this.minZoom = t2.minZoom, this.maxZoom = t2.maxZoom, this.bounds = t2.bounds, this.center = t2.center;
          });
        }
        fetchTile(e2, t2, i2) {
          return new Promise((n2, r2) => {
            const s2 = document.createElement("img");
            if (s2.onload = function() {
              n2(s2);
            }, s2.onerror = function() {
              r2();
            }, s2.crossOrigin = "Anonymous", this.getUrl) {
              const n3 = this.getUrl(e2, t2, i2);
              if (false !== n3)
                return void (s2.src = n3);
            }
            this.mode === sf.STYLE ? s2.src = sf.ADDRESS + "styles/v1/" + this.style + "/tiles/" + e2 + "/" + t2 + "/" + i2 + (this.useHDPI ? "@2x?access_token=" : "?access_token=") + this.apiToken : s2.src = sf.ADDRESS + "v4/" + this.mapId + "/" + e2 + "/" + t2 + "/" + i2 + (this.useHDPI ? "@2x." : ".") + this.format + "?access_token=" + this.apiToken;
          });
        }
      }
      sf.ADDRESS = "https://api.mapbox.com/", sf.STYLE = 100, sf.MAP_ID = 101;
      const af = {};
      function of(e2) {
        if ("string" != typeof e2)
          throw new TypeError("Path must be a string. Received " + JSON.stringify(e2));
      }
      function lf(e2, t2) {
        for (var i2, n2 = "", r2 = 0, s2 = -1, a2 = 0, o2 = 0; o2 <= e2.length; ++o2) {
          if (o2 < e2.length)
            i2 = e2.charCodeAt(o2);
          else {
            if (47 === i2)
              break;
            i2 = 47;
          }
          if (47 === i2) {
            if (s2 === o2 - 1 || 1 === a2)
              ;
            else if (s2 !== o2 - 1 && 2 === a2) {
              if (n2.length < 2 || 2 !== r2 || 46 !== n2.charCodeAt(n2.length - 1) || 46 !== n2.charCodeAt(n2.length - 2)) {
                if (n2.length > 2) {
                  var l2 = n2.lastIndexOf("/");
                  if (l2 !== n2.length - 1) {
                    -1 === l2 ? (n2 = "", r2 = 0) : r2 = (n2 = n2.slice(0, l2)).length - 1 - n2.lastIndexOf("/"), s2 = o2, a2 = 0;
                    continue;
                  }
                } else if (2 === n2.length || 1 === n2.length) {
                  n2 = "", r2 = 0, s2 = o2, a2 = 0;
                  continue;
                }
              }
              t2 && (n2.length > 0 ? n2 += "/.." : n2 = "..", r2 = 2);
            } else
              n2.length > 0 ? n2 += "/" + e2.slice(s2 + 1, o2) : n2 = e2.slice(s2 + 1, o2), r2 = o2 - s2 - 1;
            s2 = o2, a2 = 0;
          } else
            46 === i2 && -1 !== a2 ? ++a2 : a2 = -1;
        }
        return n2;
      }
      var hf = { resolve: function() {
        for (var e2, t2 = "", i2 = false, n2 = arguments.length - 1; n2 >= -1 && !i2; n2--) {
          var r2;
          n2 >= 0 ? r2 = arguments[n2] : (void 0 === e2 && (e2 = process.cwd()), r2 = e2), of(r2), 0 !== r2.length && (t2 = r2 + "/" + t2, i2 = 47 === r2.charCodeAt(0));
        }
        return t2 = lf(t2, !i2), i2 ? t2.length > 0 ? "/" + t2 : "/" : t2.length > 0 ? t2 : ".";
      }, normalize: function(e2) {
        if (of(e2), 0 === e2.length)
          return ".";
        var t2 = 47 === e2.charCodeAt(0), i2 = 47 === e2.charCodeAt(e2.length - 1);
        return 0 !== (e2 = lf(e2, !t2)).length || t2 || (e2 = "."), e2.length > 0 && i2 && (e2 += "/"), t2 ? "/" + e2 : e2;
      }, isAbsolute: function(e2) {
        return of(e2), e2.length > 0 && 47 === e2.charCodeAt(0);
      }, join: function() {
        if (0 === arguments.length)
          return ".";
        for (var e2, t2 = 0; t2 < arguments.length; ++t2) {
          var i2 = arguments[t2];
          of(i2), i2.length > 0 && (void 0 === e2 ? e2 = i2 : e2 += "/" + i2);
        }
        return void 0 === e2 ? "." : hf.normalize(e2);
      }, relative: function(e2, t2) {
        if (of(e2), of(t2), e2 === t2)
          return "";
        if ((e2 = hf.resolve(e2)) === (t2 = hf.resolve(t2)))
          return "";
        for (var i2 = 1; i2 < e2.length && 47 === e2.charCodeAt(i2); ++i2)
          ;
        for (var n2 = e2.length, r2 = n2 - i2, s2 = 1; s2 < t2.length && 47 === t2.charCodeAt(s2); ++s2)
          ;
        for (var a2 = t2.length - s2, o2 = r2 < a2 ? r2 : a2, l2 = -1, h2 = 0; h2 <= o2; ++h2) {
          if (h2 === o2) {
            if (a2 > o2) {
              if (47 === t2.charCodeAt(s2 + h2))
                return t2.slice(s2 + h2 + 1);
              if (0 === h2)
                return t2.slice(s2 + h2);
            } else
              r2 > o2 && (47 === e2.charCodeAt(i2 + h2) ? l2 = h2 : 0 === h2 && (l2 = 0));
            break;
          }
          var c2 = e2.charCodeAt(i2 + h2);
          if (c2 !== t2.charCodeAt(s2 + h2))
            break;
          47 === c2 && (l2 = h2);
        }
        var u2 = "";
        for (h2 = i2 + l2 + 1; h2 <= n2; ++h2)
          h2 !== n2 && 47 !== e2.charCodeAt(h2) || (0 === u2.length ? u2 += ".." : u2 += "/..");
        return u2.length > 0 ? u2 + t2.slice(s2 + l2) : (s2 += l2, 47 === t2.charCodeAt(s2) && ++s2, t2.slice(s2));
      }, _makeLong: function(e2) {
        return e2;
      }, dirname: function(e2) {
        if (of(e2), 0 === e2.length)
          return ".";
        for (var t2 = e2.charCodeAt(0), i2 = 47 === t2, n2 = -1, r2 = true, s2 = e2.length - 1; s2 >= 1; --s2)
          if (47 === (t2 = e2.charCodeAt(s2))) {
            if (!r2) {
              n2 = s2;
              break;
            }
          } else
            r2 = false;
        return -1 === n2 ? i2 ? "/" : "." : i2 && 1 === n2 ? "//" : e2.slice(0, n2);
      }, basename: function(e2, t2) {
        if (void 0 !== t2 && "string" != typeof t2)
          throw new TypeError('"ext" argument must be a string');
        of(e2);
        var i2, n2 = 0, r2 = -1, s2 = true;
        if (void 0 !== t2 && t2.length > 0 && t2.length <= e2.length) {
          if (t2.length === e2.length && t2 === e2)
            return "";
          var a2 = t2.length - 1, o2 = -1;
          for (i2 = e2.length - 1; i2 >= 0; --i2) {
            var l2 = e2.charCodeAt(i2);
            if (47 === l2) {
              if (!s2) {
                n2 = i2 + 1;
                break;
              }
            } else
              -1 === o2 && (s2 = false, o2 = i2 + 1), a2 >= 0 && (l2 === t2.charCodeAt(a2) ? -1 == --a2 && (r2 = i2) : (a2 = -1, r2 = o2));
          }
          return n2 === r2 ? r2 = o2 : -1 === r2 && (r2 = e2.length), e2.slice(n2, r2);
        }
        for (i2 = e2.length - 1; i2 >= 0; --i2)
          if (47 === e2.charCodeAt(i2)) {
            if (!s2) {
              n2 = i2 + 1;
              break;
            }
          } else
            -1 === r2 && (s2 = false, r2 = i2 + 1);
        return -1 === r2 ? "" : e2.slice(n2, r2);
      }, extname: function(e2) {
        of(e2);
        for (var t2 = -1, i2 = 0, n2 = -1, r2 = true, s2 = 0, a2 = e2.length - 1; a2 >= 0; --a2) {
          var o2 = e2.charCodeAt(a2);
          if (47 !== o2)
            -1 === n2 && (r2 = false, n2 = a2 + 1), 46 === o2 ? -1 === t2 ? t2 = a2 : 1 !== s2 && (s2 = 1) : -1 !== t2 && (s2 = -1);
          else if (!r2) {
            i2 = a2 + 1;
            break;
          }
        }
        return -1 === t2 || -1 === n2 || 0 === s2 || 1 === s2 && t2 === n2 - 1 && t2 === i2 + 1 ? "" : e2.slice(t2, n2);
      }, format: function(e2) {
        if (null === e2 || "object" != typeof e2)
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e2);
        return function(e3, t2) {
          var i2 = t2.dir || t2.root, n2 = t2.base || (t2.name || "") + (t2.ext || "");
          return i2 ? i2 === t2.root ? i2 + n2 : i2 + e3 + n2 : n2;
        }("/", e2);
      }, parse: function(e2) {
        of(e2);
        var t2 = { root: "", dir: "", base: "", ext: "", name: "" };
        if (0 === e2.length)
          return t2;
        var i2, n2 = e2.charCodeAt(0), r2 = 47 === n2;
        r2 ? (t2.root = "/", i2 = 1) : i2 = 0;
        for (var s2 = -1, a2 = 0, o2 = -1, l2 = true, h2 = e2.length - 1, c2 = 0; h2 >= i2; --h2)
          if (47 !== (n2 = e2.charCodeAt(h2)))
            -1 === o2 && (l2 = false, o2 = h2 + 1), 46 === n2 ? -1 === s2 ? s2 = h2 : 1 !== c2 && (c2 = 1) : -1 !== s2 && (c2 = -1);
          else if (!l2) {
            a2 = h2 + 1;
            break;
          }
        return -1 === s2 || -1 === o2 || 0 === c2 || 1 === c2 && s2 === o2 - 1 && s2 === a2 + 1 ? -1 !== o2 && (t2.base = t2.name = 0 === a2 && r2 ? e2.slice(1, o2) : e2.slice(a2, o2)) : (0 === a2 && r2 ? (t2.name = e2.slice(1, s2), t2.base = e2.slice(1, o2)) : (t2.name = e2.slice(a2, s2), t2.base = e2.slice(a2, o2)), t2.ext = e2.slice(s2, o2)), a2 > 0 ? t2.dir = e2.slice(0, a2 - 1) : r2 && (t2.dir = "/"), t2;
      }, sep: "/", delimiter: ":", win32: null, posix: null };
      hf.posix = hf;
      var cf = hf;
      function uf(e2) {
        let t2;
        try {
          t2 = new URL(e2, "http://fakehost.com/");
        } catch (r2) {
          return null;
        }
        const i2 = t2.pathname.split("/").pop(), n2 = i2.lastIndexOf(".");
        if (-1 === n2 || n2 === i2.length - 1)
          return null;
        return i2.substring(n2 + 1);
      }
      class df {
        constructor() {
          this.maxSize = 800, this.minSize = 600, this.unloadPercent = 0.05, this.itemSet = /* @__PURE__ */ new Map(), this.itemList = [], this.usedSet = /* @__PURE__ */ new Set(), this.callbacks = /* @__PURE__ */ new Map(), this.unloadPriorityCallback = null;
          const e2 = this.itemSet;
          this.defaultPriorityCallback = (t2) => e2.get(t2);
        }
        isFull() {
          return this.itemSet.size >= this.maxSize;
        }
        add(e2, t2) {
          const i2 = this.itemSet;
          if (i2.has(e2))
            return false;
          if (this.isFull())
            return false;
          const n2 = this.usedSet, r2 = this.itemList, s2 = this.callbacks;
          return r2.push(e2), n2.add(e2), i2.set(e2, Date.now()), s2.set(e2, t2), true;
        }
        remove(e2) {
          const t2 = this.usedSet, i2 = this.itemSet, n2 = this.itemList, r2 = this.callbacks;
          if (i2.has(e2)) {
            r2.get(e2)(e2);
            const s2 = n2.indexOf(e2);
            return n2.splice(s2, 1), t2.delete(e2), i2.delete(e2), r2.delete(e2), true;
          }
          return false;
        }
        markUsed(e2) {
          const t2 = this.itemSet, i2 = this.usedSet;
          t2.has(e2) && !i2.has(e2) && (t2.set(e2, Date.now()), i2.add(e2));
        }
        markAllUnused() {
          this.usedSet.clear();
        }
        unloadUnusedContent() {
          const e2 = this.unloadPercent, t2 = this.minSize, i2 = this.itemList, n2 = this.itemSet, r2 = this.usedSet, s2 = this.callbacks, a2 = i2.length - r2.size, o2 = i2.length - t2, l2 = this.unloadPriorityCallback || this.defaultPriorityCallback;
          if (o2 > 0 && a2 > 0) {
            i2.sort((e3, t3) => {
              const i3 = r2.has(e3), n3 = r2.has(t3);
              return i3 && n3 ? 0 : i3 || n3 ? i3 ? 1 : -1 : l2(t3) - l2(e3);
            });
            const h2 = Math.min(o2, a2), c2 = Math.max(t2 * e2, h2 * e2);
            let u2 = Math.min(c2, a2);
            u2 = Math.ceil(u2);
            const d2 = i2.splice(0, u2);
            for (let e3 = 0, t3 = d2.length; e3 < t3; e3++) {
              const t4 = d2[e3];
              s2.get(t4)(t4), n2.delete(t4), s2.delete(t4);
            }
          }
        }
        scheduleUnload(e2 = true) {
          var t2;
          this.scheduled || (this.scheduled = true, t2 = () => {
            this.scheduled = false, this.unloadUnusedContent(), e2 && this.markAllUnused();
          }, Promise.resolve().then(t2));
        }
      }
      class pf {
        constructor() {
          this.maxJobs = 6, this.items = [], this.callbacks = /* @__PURE__ */ new Map(), this.currJobs = 0, this.scheduled = false, this.autoUpdate = true, this.priorityCallback = () => {
            throw new Error("PriorityQueue: PriorityCallback function not defined.");
          }, this.schedulingCallback = (e2) => {
            requestAnimationFrame(e2);
          }, this._runjobs = () => {
            this.tryRunJobs(), this.scheduled = false;
          };
        }
        sort() {
          const e2 = this.priorityCallback;
          this.items.sort(e2);
        }
        add(e2, t2) {
          return new Promise((i2, n2) => {
            const r2 = this.items, s2 = this.callbacks;
            r2.push(e2), s2.set(e2, (...e3) => t2(...e3).then(i2).catch(n2)), this.autoUpdate && this.scheduleJobRun();
          });
        }
        remove(e2) {
          const t2 = this.items, i2 = this.callbacks, n2 = t2.indexOf(e2);
          -1 !== n2 && (t2.splice(n2, 1), i2.delete(e2));
        }
        tryRunJobs() {
          this.sort();
          const e2 = this.items, t2 = this.callbacks, i2 = this.maxJobs;
          let n2 = this.currJobs;
          for (; i2 > n2 && e2.length > 0; ) {
            n2++;
            const i3 = e2.pop(), r2 = t2.get(i3);
            t2.delete(i3), r2(i3).then(() => {
              this.currJobs--, this.autoUpdate && this.scheduleJobRun();
            }).catch(() => {
              this.currJobs--, this.autoUpdate && this.scheduleJobRun();
            });
          }
          this.currJobs = n2;
        }
        scheduleJobRun() {
          this.scheduled || (this.schedulingCallback(this._runjobs), this.scheduled = true);
        }
      }
      function mf(e2) {
        return 3 === e2 || 4 === e2;
      }
      function ff(e2, t2) {
        return e2.__lastFrameVisited === t2 && e2.__used;
      }
      function gf(e2, t2) {
        e2.__lastFrameVisited !== t2 && (e2.__lastFrameVisited = t2, e2.__used = false, e2.__inFrustum = false, e2.__isLeaf = false, e2.__visible = false, e2.__active = false, e2.__error = 1 / 0, e2.__distanceFromCamera = 1 / 0, e2.__childrenWereVisible = false, e2.__allChildrenLoaded = false);
      }
      function _f(e2, t2, i2) {
        if (gf(e2, t2), e2.__used = true, i2.markUsed(e2), e2.__contentEmpty) {
          const n2 = e2.children;
          for (let e3 = 0, r2 = n2.length; e3 < r2; e3++)
            _f(n2[e3], t2, i2);
        }
      }
      function vf(e2, t2, i2) {
        if (e2.__contentEmpty && (!e2.__externalTileSet || mf(e2.__loadingState))) {
          const n2 = e2.children;
          for (let e3 = 0, r2 = n2.length; e3 < r2; e3++) {
            const r3 = n2[e3];
            r3.__depthFromRenderedParent = t2, vf(r3, t2, i2);
          }
        } else
          i2.requestTileContents(e2);
      }
      function xf(e2, t2 = null, i2 = null, n2 = null, r2 = 0) {
        if (t2 && t2(e2, n2, r2))
          return void (i2 && i2(e2, n2, r2));
        const s2 = e2.children;
        for (let a2 = 0, o2 = s2.length; a2 < o2; a2++)
          xf(s2[a2], t2, i2, e2, r2 + 1);
        i2 && i2(e2, n2, r2);
      }
      function yf(e2, t2) {
        const i2 = t2.stats, n2 = t2.frameCount, r2 = t2.errorTarget, s2 = t2.maxDepth, a2 = t2.loadSiblings, o2 = t2.lruCache, l2 = t2.stopAtEmptyTiles;
        gf(e2, n2);
        if (false === t2.tileInView(e2))
          return false;
        if (e2.__used = true, o2.markUsed(e2), e2.__inFrustum = true, i2.inFrustum++, (l2 || !e2.__contentEmpty) && !e2.__externalTileSet) {
          t2.calculateError(e2);
          if (e2.__error <= r2)
            return true;
          if (t2.maxDepth > 0 && e2.__depth + 1 >= s2)
            return true;
        }
        let h2 = false;
        const c2 = e2.children;
        for (let u2 = 0, d2 = c2.length; u2 < d2; u2++) {
          const e3 = yf(c2[u2], t2);
          h2 = h2 || e3;
        }
        if (h2 && a2)
          for (let u2 = 0, d2 = c2.length; u2 < d2; u2++) {
            _f(c2[u2], n2, o2);
          }
        return true;
      }
      function bf(e2, t2) {
        const i2 = t2.stats, n2 = t2.frameCount;
        if (!ff(e2, n2))
          return;
        i2.used++;
        const r2 = e2.children;
        let s2 = false;
        for (let a2 = 0, o2 = r2.length; a2 < o2; a2++) {
          const e3 = r2[a2];
          s2 = s2 || ff(e3, n2);
        }
        if (s2) {
          let i3 = false, s3 = true;
          for (let e3 = 0, a2 = r2.length; e3 < a2; e3++) {
            const a3 = r2[e3];
            if (bf(a3, t2), i3 = i3 || a3.__wasSetVisible || a3.__childrenWereVisible, ff(a3, n2)) {
              const e4 = a3.__allChildrenLoaded || !a3.__contentEmpty && mf(a3.__loadingState) || a3.__externalTileSet && 4 === a3.__loadingState;
              s3 = s3 && e4;
            }
          }
          e2.__childrenWereVisible = i3, e2.__allChildrenLoaded = s3;
        } else
          e2.__isLeaf = true;
      }
      function Mf(e2, t2) {
        const i2 = t2.stats, n2 = t2.frameCount;
        if (!ff(e2, n2))
          return;
        const r2 = e2.parent, s2 = r2 ? r2.__depthFromRenderedParent : -1;
        e2.__depthFromRenderedParent = s2;
        const a2 = t2.lruCache;
        if (e2.__isLeaf)
          return e2.__depthFromRenderedParent++, void (3 === e2.__loadingState ? (e2.__inFrustum && (e2.__visible = true, i2.visible++), e2.__active = true, i2.active++) : a2.isFull() || e2.__contentEmpty && !e2.__externalTileSet || t2.requestTileContents(e2));
        const o2 = (t2.errorTarget + 1) * t2.errorThreshold, l2 = e2.__error <= o2, h2 = l2 || "ADD" === e2.refine, c2 = !e2.__contentEmpty, u2 = c2 || e2.__externalTileSet, d2 = mf(e2.__loadingState) && u2, p2 = e2.__childrenWereVisible, m2 = e2.children;
        let f2 = e2.__allChildrenLoaded;
        if (h2 && c2 && e2.__depthFromRenderedParent++, h2 && !d2 && !a2.isFull() && u2 && t2.requestTileContents(e2), (l2 && !f2 && !p2 && d2 || "ADD" === e2.refine && d2) && (e2.__inFrustum && (e2.__visible = true, i2.visible++), e2.__active = true, i2.active++), "ADD" !== e2.refine && l2 && !f2 && d2)
          for (let g2 = 0, _2 = m2.length; g2 < _2; g2++) {
            const i3 = m2[g2];
            ff(i3, n2) && !a2.isFull() && (i3.__depthFromRenderedParent = e2.__depthFromRenderedParent + 1, vf(i3, i3.__depthFromRenderedParent, t2));
          }
        else
          for (let g2 = 0, _2 = m2.length; g2 < _2; g2++) {
            const e3 = m2[g2];
            ff(e3, n2) && Mf(e3, t2);
          }
      }
      function Sf(e2, t2) {
        const i2 = ff(e2, t2.frameCount);
        if (i2 || e2.__usedLastFrame) {
          let n2 = false, r2 = false;
          i2 && (n2 = e2.__active, r2 = t2.displayActiveTiles && e2.__active || e2.__visible), e2.__contentEmpty || 3 !== e2.__loadingState || (e2.__wasSetActive !== n2 && t2.setTileActive(e2, n2), e2.__wasSetVisible !== r2 && t2.setTileVisible(e2, r2)), e2.__wasSetActive = n2, e2.__wasSetVisible = r2, e2.__usedLastFrame = i2;
          const s2 = e2.children;
          for (let e3 = 0, i3 = s2.length; e3 < i3; e3++) {
            Sf(s2[e3], t2);
          }
        }
      }
      const wf = (e2, t2) => e2.__depth !== t2.__depth ? e2.__depth > t2.__depth ? -1 : 1 : e2.__inFrustum !== t2.__inFrustum ? e2.__inFrustum ? 1 : -1 : e2.__used !== t2.__used ? e2.__used ? 1 : -1 : e2.__error !== t2.__error ? e2.__error > t2.__error ? 1 : -1 : e2.__distanceFromCamera !== t2.__distanceFromCamera ? e2.__distanceFromCamera > t2.__distanceFromCamera ? -1 : 1 : 0, Tf = (e2) => 1 / (e2.__depthFromRenderedParent + 1);
      function Ef(e2) {
        return new TextDecoder().decode(e2);
      }
      class Cf {
        constructor(e2, t2, i2, n2) {
          this.buffer = e2, this.binOffset = t2 + i2, this.binLength = n2;
          let r2 = null;
          if (0 !== i2) {
            const n3 = new Uint8Array(e2, t2, i2);
            r2 = JSON.parse(Ef(n3));
          } else
            r2 = {};
          this.header = r2;
        }
        getKeys() {
          return Object.keys(this.header);
        }
        getData(e2, t2, i2 = null, n2 = null) {
          const r2 = this.header;
          if (!(e2 in r2))
            return null;
          const s2 = r2[e2];
          if (s2 instanceof Object) {
            if (Array.isArray(s2))
              return s2;
            {
              const { buffer: r3, binOffset: a2, binLength: o2 } = this, l2 = s2.byteOffset || 0, h2 = s2.type || n2, c2 = s2.componentType || i2;
              if ("type" in s2 && n2 && s2.type !== n2)
                throw new Error("FeatureTable: Specified type does not match expected type.");
              let u2, d2;
              switch (h2) {
                case "SCALAR":
                  u2 = 1;
                  break;
                case "VEC2":
                  u2 = 2;
                  break;
                case "VEC3":
                  u2 = 3;
                  break;
                case "VEC4":
                  u2 = 4;
                  break;
                default:
                  throw new Error(`FeatureTable : Feature type not provided for "${e2}".`);
              }
              const p2 = a2 + l2, m2 = t2 * u2;
              switch (c2) {
                case "BYTE":
                  d2 = new Int8Array(r3, p2, m2);
                  break;
                case "UNSIGNED_BYTE":
                  d2 = new Uint8Array(r3, p2, m2);
                  break;
                case "SHORT":
                  d2 = new Int16Array(r3, p2, m2);
                  break;
                case "UNSIGNED_SHORT":
                  d2 = new Uint16Array(r3, p2, m2);
                  break;
                case "INT":
                  d2 = new Int32Array(r3, p2, m2);
                  break;
                case "UNSIGNED_INT":
                  d2 = new Uint32Array(r3, p2, m2);
                  break;
                case "FLOAT":
                  d2 = new Float32Array(r3, p2, m2);
                  break;
                case "DOUBLE":
                  d2 = new Float64Array(r3, p2, m2);
                  break;
                default:
                  throw new Error(`FeatureTable : Feature component type not provided for "${e2}".`);
              }
              if (p2 + m2 * d2.BYTES_PER_ELEMENT > a2 + o2)
                throw new Error("FeatureTable: Feature data read outside binary body length.");
              return d2;
            }
          }
          return s2;
        }
      }
      class Af extends Cf {
        constructor(e2, t2, i2, n2, r2) {
          super(e2, i2, n2, r2), this.batchSize = t2;
        }
        getData(e2, t2 = null, i2 = null) {
          return super.getData(e2, this.batchSize, t2, i2);
        }
      }
      class Pf {
        constructor() {
          this.fetchOptions = {}, this.workingPath = "";
        }
        load(e2) {
          return fetch(e2, this.fetchOptions).then((t2) => {
            if (!t2.ok)
              throw new Error(`Failed to load file "${e2}" with status ${t2.status} : ${t2.statusText}`);
            return t2.arrayBuffer();
          }).then((t2) => ("" === this.workingPath && (this.workingPath = this.workingPathForURL(e2)), this.parse(t2)));
        }
        resolveExternalURL(e2) {
          return /^[^\\/]/.test(e2) ? this.workingPath + "/" + e2 : e2;
        }
        workingPathForURL(e2) {
          const t2 = e2.split(/[\\/]/g);
          t2.pop();
          return t2.join("/") + "/";
        }
        parse(e2) {
          throw new Error("LoaderBase: Parse not implemented.");
        }
      }
      class Rf extends Pf {
        parse(e2) {
          const t2 = new DataView(e2), i2 = String.fromCharCode(t2.getUint8(0)) + String.fromCharCode(t2.getUint8(1)) + String.fromCharCode(t2.getUint8(2)) + String.fromCharCode(t2.getUint8(3));
          console.assert("b3dm" === i2);
          const n2 = t2.getUint32(4, true);
          console.assert(1 === n2);
          const r2 = t2.getUint32(8, true);
          console.assert(r2 === e2.byteLength);
          const s2 = t2.getUint32(12, true), a2 = t2.getUint32(16, true), o2 = t2.getUint32(20, true), l2 = t2.getUint32(24, true), h2 = e2.slice(28, 28 + s2 + a2), c2 = new Cf(h2, 0, s2, a2), u2 = 28 + s2 + a2, d2 = e2.slice(u2, u2 + o2 + l2), p2 = new Af(d2, c2.getData("BATCH_LENGTH"), 0, o2, l2), m2 = u2 + o2 + l2;
          return { version: n2, featureTable: c2, batchTable: p2, glbBytes: new Uint8Array(e2, m2, r2 - m2) };
        }
      }
      class Lf extends Rf {
        constructor(e2 = Ba) {
          super(), this.manager = e2;
        }
        parse(e2) {
          const t2 = super.parse(e2), i2 = t2.glbBytes.slice().buffer;
          return new Promise((e3, n2) => {
            const r2 = this.manager, s2 = this.fetchOptions, a2 = r2.getHandler("path.gltf") || new Pp(r2);
            "include" === s2.credentials && "cors" === s2.mode && a2.setCrossOrigin("use-credentials"), "credentials" in s2 && a2.setWithCredentials("include" === s2.credentials), s2.headers && a2.setRequestHeader(s2.headers);
            let o2 = this.workingPath;
            !/[\\/]$/.test(o2) && o2.length && (o2 += "/"), a2.parse(i2, o2, (i3) => {
              const { batchTable: n3, featureTable: r3 } = t2, { scene: s3 } = i3, a3 = r3.getData("RTC_CENTER");
              a3 && (s3.position.x += a3[0], s3.position.y += a3[1], s3.position.z += a3[2]), i3.batchTable = n3, i3.featureTable = r3, s3.batchTable = n3, s3.featureTable = r3, e3(i3);
            }, n2);
          });
        }
      }
      class If extends Pf {
        parse(e2) {
          const t2 = new DataView(e2), i2 = String.fromCharCode(t2.getUint8(0)) + String.fromCharCode(t2.getUint8(1)) + String.fromCharCode(t2.getUint8(2)) + String.fromCharCode(t2.getUint8(3));
          console.assert("pnts" === i2);
          const n2 = t2.getUint32(4, true);
          console.assert(1 === n2);
          const r2 = t2.getUint32(8, true);
          console.assert(r2 === e2.byteLength);
          const s2 = t2.getUint32(12, true), a2 = t2.getUint32(16, true), o2 = t2.getUint32(20, true), l2 = t2.getUint32(24, true), h2 = e2.slice(28, 28 + s2 + a2), c2 = new Cf(h2, 0, s2, a2), u2 = 28 + s2 + a2, d2 = e2.slice(u2, u2 + o2 + l2), p2 = new Af(d2, c2.getData("BATCH_LENGTH") || c2.getData("POINTS_LENGTH"), 0, o2, l2);
          return Promise.resolve({ version: n2, featureTable: c2, batchTable: p2 });
        }
      }
      class Df extends If {
        constructor(e2 = Ba) {
          super(), this.manager = e2;
        }
        parse(e2) {
          return super.parse(e2).then((e3) => {
            const { featureTable: t2 } = e3, i2 = t2.getData("POINTS_LENGTH"), n2 = t2.getData("POSITION", i2, "FLOAT", "VEC3"), r2 = t2.getData("RGB", i2, "UNSIGNED_BYTE", "VEC3");
            ["RTC_CENTER", "QUANTIZED_VOLUME_OFFSET", "QUANTIZED_VOLUME_SCALE", "CONSTANT_RGBA", "BATCH_LENGTH", "POSITION_QUANTIZED", "RGBA", "RGB565", "NORMAL", "NORMAL_OCT16P"].forEach((e4) => {
              e4 in t2.header && console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e4}" detected.`);
            });
            const s2 = new ri();
            s2.setAttribute("position", new qt(n2, 3, false));
            const a2 = new ra();
            a2.size = 2, a2.sizeAttenuation = false, null !== r2 && (s2.setAttribute("color", new qt(r2, 3, true)), a2.vertexColors = true);
            const o2 = new ha(s2, a2);
            e3.scene = o2, e3.scene.featureTable = t2;
            const l2 = t2.getData("RTC_CENTER");
            return l2 && (e3.scene.position.x += l2[0], e3.scene.position.y += l2[1], e3.scene.position.z += l2[2]), e3;
          });
        }
      }
      class Ff extends Pf {
        parse(e2) {
          const t2 = new DataView(e2), i2 = String.fromCharCode(t2.getUint8(0)) + String.fromCharCode(t2.getUint8(1)) + String.fromCharCode(t2.getUint8(2)) + String.fromCharCode(t2.getUint8(3));
          console.assert("i3dm" === i2);
          const n2 = t2.getUint32(4, true);
          console.assert(1 === n2);
          const r2 = t2.getUint32(8, true);
          console.assert(r2 === e2.byteLength);
          const s2 = t2.getUint32(12, true), a2 = t2.getUint32(16, true), o2 = t2.getUint32(20, true), l2 = t2.getUint32(24, true), h2 = t2.getUint32(28, true), c2 = e2.slice(32, 32 + s2 + a2), u2 = new Cf(c2, 0, s2, a2), d2 = 32 + s2 + a2, p2 = e2.slice(d2, d2 + o2 + l2), m2 = new Af(p2, u2.getData("INSTANCES_LENGTH"), 0, o2, l2), f2 = d2 + o2 + l2, g2 = new Uint8Array(e2, f2, r2 - f2);
          let _2 = null, v2 = null;
          if (h2)
            _2 = g2, v2 = Promise.resolve();
          else {
            const e3 = this.resolveExternalURL(Ef(g2));
            v2 = fetch(e3, this.fetchOptions).then((t3) => {
              if (!t3.ok)
                throw new Error(`I3DMLoaderBase : Failed to load file "${e3}" with status ${t3.status} : ${t3.statusText}`);
              return t3.arrayBuffer();
            }).then((e4) => {
              _2 = new Uint8Array(e4);
            });
          }
          return v2.then(() => ({ version: n2, featureTable: u2, batchTable: m2, glbBytes: _2 }));
        }
      }
      const Of = new Ae(), Uf = new Ae(), zf = new Ae(), Nf = new Ae(), kf = new Ce(), Bf = new Ae(), Vf = new st();
      class Gf extends Ff {
        constructor(e2 = Ba) {
          super(), this.manager = e2;
        }
        resolveExternalURL(e2) {
          return this.manager.resolveURL(super.resolveExternalURL(e2));
        }
        parse(e2) {
          return super.parse(e2).then((e3) => {
            const { featureTable: t2, batchTable: i2 } = e3, n2 = e3.glbBytes.slice().buffer;
            return new Promise((e4, r2) => {
              const s2 = this.fetchOptions, a2 = this.manager, o2 = a2.getHandler("path.gltf") || new Pp(a2);
              "include" === s2.credentials && "cors" === s2.mode && o2.setCrossOrigin("use-credentials"), "credentials" in s2 && o2.setWithCredentials("include" === s2.credentials), s2.headers && o2.setRequestHeader(s2.headers);
              let l2 = this.workingPath;
              /[\\/]$/.test(l2) || (l2 += "/"), o2.parse(n2, l2, (n3) => {
                const r3 = t2.getData("INSTANCES_LENGTH"), s3 = t2.getData("POSITION", r3, "FLOAT", "VEC3"), a3 = t2.getData("NORMAL_UP", r3, "FLOAT", "VEC3"), o3 = t2.getData("NORMAL_RIGHT", r3, "FLOAT", "VEC3"), l3 = t2.getData("SCALE_NON_UNIFORM", r3, "FLOAT", "VEC3"), h2 = t2.getData("SCALE", r3, "FLOAT", "SCALAR");
                ["RTC_CENTER", "QUANTIZED_VOLUME_OFFSET", "QUANTIZED_VOLUME_SCALE", "EAST_NORTH_UP", "POSITION_QUANTIZED", "NORMAL_UP_OCT32P", "NORMAL_RIGHT_OCT32P"].forEach((e5) => {
                  e5 in t2.header && console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e5}" detected.`);
                });
                const c2 = /* @__PURE__ */ new Map(), u2 = [];
                n3.scene.traverse((e5) => {
                  if (e5.isMesh) {
                    const { geometry: t3, material: i3 } = e5, n4 = new Xs(t3, i3, r3);
                    n4.position.copy(e5.position), n4.rotation.copy(e5.rotation), n4.scale.copy(e5.scale), u2.push(n4), c2.set(e5, n4);
                  }
                });
                const d2 = new Ae();
                for (let e5 = 0; e5 < r3; e5++)
                  d2.x += s3[3 * e5 + 0] / r3, d2.y += s3[3 * e5 + 1] / r3, d2.z += s3[3 * e5 + 2] / r3;
                c2.forEach((e5, t3) => {
                  const i3 = t3.parent;
                  i3 && (i3.remove(t3), i3.add(e5), e5.updateMatrixWorld(), e5.position.copy(d2).applyMatrix4(e5.matrixWorld));
                });
                for (let e5 = 0; e5 < r3; e5++) {
                  Nf.set(s3[3 * e5 + 0] - d2.x, s3[3 * e5 + 1] - d2.y, s3[3 * e5 + 2] - d2.z), a3 ? (Uf.set(a3[3 * e5 + 0], a3[3 * e5 + 1], a3[3 * e5 + 2]), zf.set(o3[3 * e5 + 0], o3[3 * e5 + 1], o3[3 * e5 + 2]), Of.crossVectors(zf, Uf).normalize(), Vf.makeBasis(zf, Uf, Of), kf.setFromRotationMatrix(Vf)) : kf.set(0, 0, 0, 1), h2 ? Bf.setScalar(h2[e5]) : l3 ? Bf.set(l3[3 * e5 + 0], l3[3 * e5 + 1], l3[3 * e5 + 2]) : Bf.set(1, 1, 1), Vf.compose(Nf, kf, Bf);
                  for (let t3 = 0, i3 = u2.length; t3 < i3; t3++) {
                    u2[t3].setMatrixAt(e5, Vf);
                  }
                }
                n3.batchTable = i2, n3.featureTable = t2, n3.scene.batchTable = i2, n3.scene.featureTable = t2, e4(n3);
              }, r2);
            });
          });
        }
      }
      class Hf extends Pf {
        parse(e2) {
          const t2 = new DataView(e2), i2 = String.fromCharCode(t2.getUint8(0)) + String.fromCharCode(t2.getUint8(1)) + String.fromCharCode(t2.getUint8(2)) + String.fromCharCode(t2.getUint8(3));
          console.assert("cmpt" === i2, 'CMPTLoader: The magic bytes equal "cmpt".');
          const n2 = t2.getUint32(4, true);
          console.assert(1 === n2, 'CMPTLoader: The version listed in the header is "1".');
          const r2 = t2.getUint32(8, true);
          console.assert(r2 === e2.byteLength, "CMPTLoader: The contents buffer length listed in the header matches the file.");
          const s2 = t2.getUint32(12, true), a2 = [];
          let o2 = 16;
          for (let l2 = 0; l2 < s2; l2++) {
            const t3 = new DataView(e2, o2, 12), i3 = String.fromCharCode(t3.getUint8(0)) + String.fromCharCode(t3.getUint8(1)) + String.fromCharCode(t3.getUint8(2)) + String.fromCharCode(t3.getUint8(3)), n3 = t3.getUint32(4, true), r3 = t3.getUint32(8, true), s3 = new Uint8Array(e2, o2, r3);
            a2.push({ type: i3, buffer: s3, version: n3 }), o2 += r3;
          }
          return { version: n2, tiles: a2 };
        }
      }
      class jf extends Hf {
        constructor(e2 = Ba) {
          super(), this.manager = e2;
        }
        parse(e2) {
          const t2 = super.parse(e2), i2 = this.manager, n2 = [];
          for (const r2 in t2.tiles) {
            const { type: e3, buffer: s2 } = t2.tiles[r2];
            switch (e3) {
              case "b3dm": {
                const e4 = s2.slice(), t3 = new Lf(i2);
                t3.workingPath = this.workingPath, t3.fetchOptions = this.fetchOptions;
                const r3 = t3.parse(e4.buffer);
                n2.push(r3);
                break;
              }
              case "pnts": {
                const e4 = s2.slice(), t3 = new Df(i2);
                t3.workingPath = this.workingPath, t3.fetchOptions = this.fetchOptions;
                const r3 = t3.parse(e4.buffer);
                n2.push(r3);
                break;
              }
              case "i3dm": {
                const e4 = s2.slice(), t3 = new Gf(i2);
                t3.workingPath = this.workingPath, t3.fetchOptions = this.fetchOptions;
                const r3 = t3.parse(e4.buffer);
                n2.push(r3);
                break;
              }
            }
          }
          return Promise.all(n2).then((e3) => {
            const t3 = new vs();
            return e3.forEach((e4) => {
              t3.add(e4.scene);
            }), { tiles: e3, scene: t3 };
          });
        }
      }
      class Wf extends Pf {
        constructor(e2 = Ba) {
          super(), this.manager = e2;
        }
        parse(e2) {
          return new Promise((t2, i2) => {
            const n2 = this.manager, r2 = this.fetchOptions;
            let s2 = n2.getHandler("path.gltf") || n2.getHandler("path.glb");
            s2 || (s2 = new Pp(n2), "include" === r2.credentials && "cors" === r2.mode && s2.setCrossOrigin("use-credentials"), "credentials" in r2 && s2.setWithCredentials("include" === r2.credentials), r2.headers && s2.setRequestHeader(r2.headers));
            let a2 = s2.resourcePath || s2.path || this.workingPath;
            !/[\\/]$/.test(a2) && a2.length && (a2 += "/"), s2.parse(e2, a2, (e3) => {
              t2(e3);
            }, i2);
          });
        }
      }
      const Xf = new st();
      class qf extends vs {
        constructor(e2) {
          super(), this.name = "TilesRenderer.TilesGroup", this.tilesRenderer = e2;
        }
        raycast(e2, t2) {
          this.tilesRenderer.optimizeRaycast && this.tilesRenderer.raycast(e2, t2);
        }
        updateMatrixWorld(e2) {
          if (this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldNeedsUpdate || e2) {
            null === this.parent ? Xf.copy(this.matrix) : Xf.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false;
            const e3 = Xf.elements, t2 = this.matrixWorld.elements;
            let i2 = false;
            for (let n2 = 0; n2 < 16; n2++) {
              const r2 = e3[n2], s2 = t2[n2];
              if (Math.abs(r2 - s2) > Number.EPSILON) {
                i2 = true;
                break;
              }
            }
            if (i2) {
              this.matrixWorld.copy(Xf);
              const e4 = this.children;
              for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
                e4[t3].updateMatrixWorld();
            }
          }
        }
      }
      const Yf = new Je(), Zf = new st(), Jf = new Ae(), Kf = new Ae(), Qf = new rt(), $f = [];
      function eg(e2, t2) {
        return e2.distance - t2.distance;
      }
      function tg(e2, t2, i2) {
        e2.traverse((e3) => {
          Object.getPrototypeOf(e3).raycast.call(e3, t2, i2);
        });
      }
      function ig(e2, t2, i2, n2) {
        if (i2.has(e2)) {
          if (tg(e2.cached.scene, n2, $f), $f.length > 0) {
            $f.length > 1 && $f.sort(eg);
            const e3 = $f[0];
            return $f.length = 0, e3;
          }
          return null;
        }
        const r2 = [], s2 = e2.children;
        for (let l2 = 0, h2 = s2.length; l2 < h2; l2++) {
          const e3 = s2[l2], i3 = e3.cached, a3 = t2.matrixWorld;
          Zf.copy(a3);
          const o3 = i3.sphere;
          if (o3 && (Yf.copy(o3), Yf.applyMatrix4(Zf), !n2.ray.intersectsSphere(Yf)))
            continue;
          const h3 = i3.box, c2 = i3.boxTransform;
          if (h3) {
            if (Zf.multiply(c2).invert(), Qf.copy(n2.ray), Qf.applyMatrix4(Zf), !Qf.intersectBox(h3, Jf))
              continue;
            {
              let t3;
              Kf.setFromMatrixScale(Zf), t3 = Kf.x, Math.abs(Math.max(Kf.x - Kf.y, Kf.x - Kf.z)) > 1e-6 && console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting.");
              let i4 = { distance: 1 / 0, tile: null };
              r2.push(i4), i4.distance = Jf.distanceToSquared(Qf.origin) * t3 * t3, i4.tile = e3;
            }
          }
        }
        r2.sort(eg);
        let a2 = 1 / 0, o2 = null;
        for (let l2 = 0, h2 = r2.length; l2 < h2; l2++) {
          const e3 = r2[l2];
          if (e3.distance > a2)
            break;
          {
            const r3 = e3.tile, s3 = r3.cached.scene;
            let l3 = null;
            if (i2.has(r3) ? (tg(s3, n2, $f), $f.length > 0 && ($f.length > 1 && $f.sort(eg), l3 = $f[0])) : l3 = ig(r3, t2, i2, n2), l3) {
              const e4 = l3.distance * l3.distance;
              e4 < a2 && (a2 = e4, o2 = l3), $f.length = 0;
            }
          }
        }
        return o2;
      }
      function ng(e2, t2, i2, n2, r2) {
        const s2 = e2.cached, a2 = t2.matrixWorld;
        Zf.copy(a2);
        const o2 = s2.sphere;
        if (o2 && (Yf.copy(o2), Yf.applyMatrix4(Zf), !n2.ray.intersectsSphere(Yf)))
          return;
        const l2 = s2.box, h2 = s2.boxTransform;
        if (l2 && (Zf.multiply(h2).invert(), Qf.copy(n2.ray).applyMatrix4(Zf), !Qf.intersectsBox(l2)))
          return;
        const c2 = s2.scene;
        if (i2.has(e2))
          return void tg(c2, n2, r2);
        const u2 = e2.children;
        for (let d2 = 0, p2 = u2.length; d2 < p2; d2++)
          ng(u2[d2], t2, i2, n2, r2);
      }
      const rg = Symbol("INITIAL_FRUSTUM_CULLED"), sg = new st(), ag = new st(), og = new Ae(), lg = new Ae(), hg = new Ae(), cg = new Ae(), ug = new Ae(1, 0, 0), dg = new Ae(0, 1, 0);
      function pg(e2, t2) {
        e2.traverse((e3) => {
          e3.frustumCulled = e3[rg] && t2;
        });
      }
      class mg extends class {
        get rootTileSet() {
          const e2 = this.tileSets[this.rootURL];
          return !e2 || e2 instanceof Promise ? null : e2;
        }
        get root() {
          const e2 = this.rootTileSet;
          return e2 ? e2.root : null;
        }
        constructor(e2) {
          this.tileSets = {}, this.rootURL = e2, this.fetchOptions = {}, this.preprocessURL = null;
          const t2 = new df();
          t2.unloadPriorityCallback = Tf;
          const i2 = new pf();
          i2.maxJobs = 4, i2.priorityCallback = wf;
          const n2 = new pf();
          n2.maxJobs = 1, n2.priorityCallback = wf, this.lruCache = t2, this.downloadQueue = i2, this.parseQueue = n2, this.stats = { parsing: 0, downloading: 0, failed: 0, inFrustum: 0, used: 0, active: 0, visible: 0 }, this.frameCount = 0, this.errorTarget = 6, this.errorThreshold = 1 / 0, this.loadSiblings = true, this.displayActiveTiles = false, this.maxDepth = 1 / 0, this.stopAtEmptyTiles = true;
        }
        traverse(e2, t2) {
          const i2 = this.tileSets[this.rootURL];
          i2 && i2.root && xf(i2.root, e2, t2);
        }
        update() {
          const e2 = this.stats, t2 = this.lruCache, i2 = this.tileSets, n2 = i2[this.rootURL];
          if (!(this.rootURL in i2))
            return void this.loadRootTileSet(this.rootURL);
          if (!n2 || !n2.root)
            return;
          const r2 = n2.root;
          e2.inFrustum = 0, e2.used = 0, e2.active = 0, e2.visible = 0, this.frameCount++, yf(r2, this), bf(r2, this), Mf(r2, this), Sf(r2, this), t2.scheduleUnload();
        }
        parseTile(e2, t2, i2) {
          return null;
        }
        disposeTile(e2) {
        }
        preprocessNode(e2, t2, i2) {
          e2.content && (!("uri" in e2.content) && "url" in e2.content && (e2.content.uri = e2.content.url, delete e2.content.url), e2.content.uri && (e2.content.uri = function(...e3) {
            const t3 = /^[a-zA-Z]+:\/\//;
            let i3 = -1;
            for (let n2 = 0, r2 = e3.length; n2 < r2; n2++)
              t3.test(e3[n2]) && (i3 = n2);
            if (-1 === i3)
              return cf.join(...e3).replace(/\\/g, "/");
            {
              const n2 = i3 <= 0 ? e3 : e3.slice(i3), r2 = n2[0].match(t3)[0];
              return n2[0] = n2[0].substring(r2.length), (r2 + cf.join(...n2)).replace(/\\/g, "/");
            }
          }(i2, e2.content.uri)), e2.content.boundingVolume && !("box" in e2.content.boundingVolume || "sphere" in e2.content.boundingVolume || "region" in e2.content.boundingVolume) && delete e2.content.boundingVolume), e2.parent = t2, e2.children = e2.children || [];
          if (e2.content && e2.content.uri) {
            const t3 = uf(e2.content.uri), i3 = Boolean(t3 && "json" === t3.toLowerCase());
            e2.__externalTileSet = i3, e2.__contentEmpty = i3;
          } else
            e2.__externalTileSet = false, e2.__contentEmpty = true;
          e2.__distanceFromCamera = 1 / 0, e2.__error = 1 / 0, e2.__inFrustum = false, e2.__isLeaf = false, e2.__usedLastFrame = false, e2.__used = false, e2.__wasSetVisible = false, e2.__visible = false, e2.__childrenWereVisible = false, e2.__allChildrenLoaded = false, e2.__wasSetActive = false, e2.__active = false, e2.__loadingState = 0, e2.__loadIndex = 0, e2.__loadAbort = null, e2.__depthFromRenderedParent = -1, null === t2 ? (e2.__depth = 0, e2.refine = e2.refine || "REPLACE") : (e2.__depth = t2.__depth + 1, e2.refine = e2.refine || t2.refine);
        }
        setTileActive(e2, t2) {
        }
        setTileVisible(e2, t2) {
        }
        calculateError(e2) {
          return 0;
        }
        tileInView(e2) {
          return true;
        }
        fetchTileSet(e2, t2, i2 = null) {
          return fetch(e2, t2).then((t3) => {
            if (t3.ok)
              return t3.json();
            throw new Error(`TilesRenderer: Failed to load tileset "${e2}" with status ${t3.status} : ${t3.statusText}`);
          }).then((t3) => {
            const n2 = t3.asset.version;
            console.assert("1.0" === n2 || "0.0" === n2, 'asset.version is expected to be a string of "1.0" or "0.0"');
            const r2 = cf.dirname(e2);
            return xf(t3.root, (e3, t4) => this.preprocessNode(e3, t4, r2), null, i2, i2 ? i2.__depth : 0), t3;
          });
        }
        loadRootTileSet(e2) {
          const t2 = this.tileSets;
          if (e2 in t2)
            return t2[e2] instanceof Error ? Promise.reject(t2[e2]) : Promise.resolve(t2[e2]);
          {
            const i2 = this.fetchTileSet(this.preprocessURL ? this.preprocessURL(e2) : e2, this.fetchOptions).then((i3) => {
              t2[e2] = i3;
            });
            return i2.catch((i3) => {
              console.error(i3), t2[e2] = i3;
            }), t2[e2] = i2, i2;
          }
        }
        requestTileContents(e2) {
          if (0 !== e2.__loadingState)
            return;
          const t2 = this.stats, i2 = this.lruCache, n2 = this.downloadQueue, r2 = this.parseQueue, s2 = e2.__externalTileSet;
          i2.add(e2, (e3) => {
            1 === e3.__loadingState ? (e3.__loadAbort.abort(), e3.__loadAbort = null) : s2 ? e3.children.length = 0 : this.disposeTile(e3), 1 === e3.__loadingState ? t2.downloading-- : 2 === e3.__loadingState && t2.parsing--, e3.__loadingState = 0, e3.__loadIndex++, r2.remove(e3), n2.remove(e3);
          }), e2.__loadIndex++;
          const a2 = e2.__loadIndex, o2 = new AbortController(), l2 = o2.signal;
          t2.downloading++, e2.__loadAbort = o2, e2.__loadingState = 1;
          const h2 = (s3) => {
            e2.__loadIndex === a2 && ("AbortError" !== s3.name ? (r2.remove(e2), n2.remove(e2), 2 === e2.__loadingState ? t2.parsing-- : 1 === e2.__loadingState && t2.downloading--, t2.failed++, console.error(`TilesRenderer : Failed to load tile at url "${e2.content.uri}".`), console.error(s3), e2.__loadingState = 4) : i2.remove(e2));
          };
          s2 ? n2.add(e2, (e3) => {
            if (e3.__loadIndex !== a2)
              return Promise.resolve();
            const t3 = this.preprocessURL ? this.preprocessURL(e3.content.uri) : e3.content.uri;
            return this.fetchTileSet(t3, Object.assign({ signal: l2 }, this.fetchOptions), e3);
          }).then((i3) => {
            e2.__loadIndex === a2 && (t2.downloading--, e2.__loadAbort = null, e2.__loadingState = 3, e2.children.push(i3.root));
          }).catch(h2) : n2.add(e2, (e3) => {
            if (e3.__loadIndex !== a2)
              return Promise.resolve();
            const t3 = this.preprocessURL ? this.preprocessURL(e3.content.uri) : e3.content.uri;
            return fetch(t3, Object.assign({ signal: l2 }, this.fetchOptions));
          }).then((t3) => {
            if (e2.__loadIndex === a2) {
              if (t3.ok)
                return t3.arrayBuffer();
              throw new Error(`Failed to load model with error code ${t3.status}`);
            }
          }).then((i3) => {
            if (e2.__loadIndex === a2)
              return t2.downloading--, t2.parsing++, e2.__loadAbort = null, e2.__loadingState = 2, r2.add(e2, (e3) => {
                if (e3.__loadIndex !== a2)
                  return Promise.resolve();
                const t3 = uf(e3.content.uri);
                return this.parseTile(i3, e3, t3);
              });
          }).then(() => {
            e2.__loadIndex === a2 && (t2.parsing--, e2.__loadingState = 3, e2.__wasSetVisible && this.setTileVisible(e2, true), e2.__wasSetActive && this.setTileActive(e2, true));
          }).catch(h2);
        }
        dispose() {
          const e2 = this.lruCache;
          this.traverse((t2) => {
            e2.remove(t2);
          });
        }
      } {
        get autoDisableRendererCulling() {
          return this._autoDisableRendererCulling;
        }
        set autoDisableRendererCulling(e2) {
          this._autoDisableRendererCulling !== e2 && (super._autoDisableRendererCulling = e2, this.forEachLoadedModel((t2) => {
            pg(t2, !e2);
          }));
        }
        constructor(...e2) {
          super(...e2), this.group = new qf(this), this.cameras = [], this.cameraMap = /* @__PURE__ */ new Map(), this.cameraInfo = [], this.activeTiles = /* @__PURE__ */ new Set(), this.visibleTiles = /* @__PURE__ */ new Set(), this._autoDisableRendererCulling = true, this.optimizeRaycast = true, this.onLoadTileSet = null, this.onLoadModel = null, this.onDisposeModel = null, this.onTileVisibilityChange = null;
          const t2 = new ka();
          t2.setURLModifier((e3) => this.preprocessURL ? this.preprocessURL(e3) : e3), this.manager = t2;
          const i2 = this;
          this._overridenRaycast = function(e3, t3) {
            i2.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, e3, t3);
          };
        }
        getBounds(e2) {
          if (!this.root)
            return false;
          const t2 = this.root.cached, i2 = t2.box, n2 = t2.boxTransform;
          return !!i2 && (e2.copy(i2), e2.applyMatrix4(n2), true);
        }
        getOrientedBounds(e2, t2) {
          if (!this.root)
            return false;
          const i2 = this.root.cached, n2 = i2.box, r2 = i2.boxTransform;
          return !!n2 && (e2.copy(n2), t2.copy(r2), true);
        }
        getBoundingSphere(e2) {
          if (!this.root)
            return false;
          const t2 = this.root.cached.sphere;
          return !!t2 && (e2.copy(t2), true);
        }
        forEachLoadedModel(e2) {
          this.traverse((t2) => {
            const i2 = t2.cached.scene;
            i2 && e2(i2, t2);
          });
        }
        raycast(e2, t2) {
          if (this.root)
            if (e2.firstHitOnly) {
              const i2 = ig(this.root, this.group, this.activeTiles, e2);
              i2 && t2.push(i2);
            } else
              ng(this.root, this.group, this.activeTiles, e2, t2);
        }
        hasCamera(e2) {
          return this.cameraMap.has(e2);
        }
        setCamera(e2) {
          const t2 = this.cameras, i2 = this.cameraMap;
          return !i2.has(e2) && (i2.set(e2, new ie()), t2.push(e2), true);
        }
        setResolution(e2, t2, i2) {
          const n2 = this.cameraMap;
          return !!n2.has(e2) && (t2 instanceof ie ? n2.get(e2).copy(t2) : n2.get(e2).set(t2, i2), true);
        }
        setResolutionFromRenderer(e2, t2) {
          const i2 = this.cameraMap;
          if (!i2.has(e2))
            return false;
          const n2 = i2.get(e2);
          return t2.getSize(n2), n2.multiplyScalar(t2.getPixelRatio()), true;
        }
        deleteCamera(e2) {
          const t2 = this.cameras, i2 = this.cameraMap;
          if (i2.has(e2)) {
            const n2 = t2.indexOf(e2);
            return t2.splice(n2, 1), i2.delete(e2), true;
          }
          return false;
        }
        fetchTileSet(e2, ...t2) {
          const i2 = super.fetchTileSet(e2, ...t2);
          return i2.then((t3) => {
            this.onLoadTileSet && Promise.resolve().then(() => {
              this.onLoadTileSet(t3, e2);
            });
          }), i2;
        }
        update() {
          const e2 = this.group, t2 = this.cameras, i2 = this.cameraMap, n2 = this.cameraInfo;
          if (0 === t2.length)
            return void console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.");
          for (; n2.length > t2.length; )
            n2.pop();
          for (; n2.length < t2.length; )
            n2.push({ frustum: new Vi(), isOrthographic: false, sseDenominator: -1, position: new Ae(), invScale: -1, pixelSize: 0 });
          let r2;
          ag.copy(e2.matrixWorld).invert(), og.setFromMatrixScale(ag), r2 = og.x, Math.abs(Math.max(og.x - og.y, og.x - og.z)) > 1e-6 && console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");
          for (let s2 = 0, a2 = n2.length; s2 < a2; s2++) {
            const a3 = t2[s2], o2 = n2[s2], l2 = o2.frustum, h2 = o2.position, c2 = i2.get(a3);
            0 !== c2.width && 0 !== c2.height || console.warn("TilesRenderer: resolution for camera error calculation is not set.");
            const u2 = a3.projectionMatrix.elements;
            if (o2.isOrthographic = 1 === u2[15], o2.isOrthographic) {
              const e3 = 2 / u2[0], t3 = 2 / u2[5];
              o2.pixelSize = Math.max(t3 / c2.height, e3 / c2.width);
            } else
              o2.sseDenominator = 2 / u2[5] / c2.height;
            o2.invScale = r2, sg.copy(e2.matrixWorld), sg.premultiply(a3.matrixWorldInverse), sg.premultiply(a3.projectionMatrix), l2.setFromProjectionMatrix(sg), h2.set(0, 0, 0), h2.applyMatrix4(a3.matrixWorld), h2.applyMatrix4(ag);
          }
          super.update();
        }
        preprocessNode(e2, t2, i2) {
          super.preprocessNode(e2, t2, i2);
          const n2 = new st();
          if (e2.transform) {
            const t3 = e2.transform;
            for (let e3 = 0; e3 < 16; e3++)
              n2.elements[e3] = t3[e3];
          } else
            n2.identity();
          t2 && n2.premultiply(t2.cached.transform);
          const r2 = new st().copy(n2).invert();
          let s2 = null, a2 = null, o2 = null;
          if ("box" in e2.boundingVolume) {
            const t3 = e2.boundingVolume.box;
            s2 = new Le(), a2 = new st(), o2 = new st(), lg.set(t3[3], t3[4], t3[5]), hg.set(t3[6], t3[7], t3[8]), cg.set(t3[9], t3[10], t3[11]);
            const i3 = lg.length(), r3 = hg.length(), l3 = cg.length();
            lg.normalize(), hg.normalize(), cg.normalize(), 0 === i3 && lg.crossVectors(hg, cg), 0 === r3 && hg.crossVectors(lg, cg), 0 === l3 && cg.crossVectors(lg, hg), a2.set(lg.x, hg.x, cg.x, t3[0], lg.y, hg.y, cg.y, t3[1], lg.z, hg.z, cg.z, t3[2], 0, 0, 0, 1), a2.premultiply(n2), o2.copy(a2).invert(), s2.min.set(-i3, -r3, -l3), s2.max.set(i3, r3, l3);
          }
          let l2 = null;
          if ("sphere" in e2.boundingVolume) {
            const t3 = e2.boundingVolume.sphere;
            l2 = new Je(), l2.center.set(t3[0], t3[1], t3[2]), l2.radius = t3[3], l2.applyMatrix4(n2);
          } else if ("box" in e2.boundingVolume) {
            const t3 = e2.boundingVolume.box;
            l2 = new Je(), s2.getBoundingSphere(l2), l2.center.set(t3[0], t3[1], t3[2]), l2.applyMatrix4(n2);
          }
          "region" in e2.boundingVolume && console.warn("ThreeTilesRenderer: region bounding volume not supported."), e2.cached = { loadIndex: 0, transform: n2, transformInverse: r2, active: false, inFrustum: [], box: s2, boxTransform: a2, boxTransformInverse: o2, sphere: l2, region: null, scene: null, geometry: null, material: null };
        }
        parseTile(e2, t2, i2) {
          t2._loadIndex = t2._loadIndex || 0, t2._loadIndex++;
          const n2 = t2.content.uri.split(/[\\\/]/g);
          n2.pop();
          const r2 = n2.join("/"), s2 = this.fetchOptions, a2 = this.manager, o2 = t2._loadIndex;
          let l2 = null;
          switch (i2) {
            case "b3dm": {
              const t4 = new Lf(a2);
              t4.workingPath = r2, t4.fetchOptions = s2, l2 = t4.parse(e2).then((e3) => e3.scene);
              break;
            }
            case "pnts": {
              const t4 = new Df(a2);
              t4.workingPath = r2, t4.fetchOptions = s2, l2 = t4.parse(e2).then((e3) => e3.scene);
              break;
            }
            case "i3dm": {
              const t4 = new Gf(a2);
              t4.workingPath = r2, t4.fetchOptions = s2, l2 = t4.parse(e2).then((e3) => e3.scene);
              break;
            }
            case "cmpt": {
              const t4 = new jf(a2);
              t4.workingPath = r2, t4.fetchOptions = s2, l2 = t4.parse(e2).then((e3) => e3.scene);
              break;
            }
            case "gltf":
            case "glb":
              const t3 = new Wf(a2);
              t3.workingPath = r2, t3.fetchOptions = s2, l2 = t3.parse(e2).then((e3) => e3.scene);
              break;
            default:
              console.warn(`TilesRenderer: Content type "${i2}" not supported.`), l2 = Promise.resolve(null);
          }
          return l2.then((e3) => {
            if (t2._loadIndex !== o2)
              return;
            const n3 = this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis || "y", r3 = t2.cached, s3 = r3.transform;
            switch (n3.toLowerCase()) {
              case "x":
                sg.makeRotationAxis(dg, -Math.PI / 2);
                break;
              case "y":
                sg.makeRotationAxis(ug, Math.PI / 2);
                break;
              case "z":
                sg.identity();
            }
            e3.updateMatrix(), "pnts" !== i2 && e3.matrix.multiply(sg), e3.matrix.premultiply(s3), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale), e3.traverse((e4) => {
              e4[rg] = e4.frustumCulled;
            }), pg(e3, !this.autoDisableRendererCulling), r3.scene = e3, e3.traverse((e4) => {
              e4.raycast = this._overridenRaycast;
            });
            const a3 = [], l3 = [], h2 = [];
            e3.traverse((e4) => {
              if (e4.geometry && l3.push(e4.geometry), e4.material) {
                const t3 = e4.material;
                a3.push(e4.material);
                for (const e5 in t3) {
                  const i3 = t3[e5];
                  i3 && i3.isTexture && h2.push(i3);
                }
              }
            }), r3.materials = a3, r3.geometry = l3, r3.textures = h2, this.onLoadModel && this.onLoadModel(e3, t2);
          });
        }
        disposeTile(e2) {
          const t2 = e2.cached;
          if (t2.scene) {
            const i2 = t2.materials, n2 = t2.geometry, r2 = t2.textures;
            for (let e3 = 0, t3 = n2.length; e3 < t3; e3++)
              n2[e3].dispose();
            for (let e3 = 0, t3 = i2.length; e3 < t3; e3++)
              i2[e3].dispose();
            for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
              r2[e3].dispose();
            }
            this.onDisposeModel && this.onDisposeModel(t2.scene, e2), t2.scene = null, t2.materials = null, t2.textures = null, t2.geometry = null;
          }
          e2._loadIndex++;
        }
        setTileVisible(e2, t2) {
          const i2 = e2.cached.scene, n2 = this.visibleTiles, r2 = this.group;
          t2 ? (r2.add(i2), n2.add(e2), i2.updateMatrixWorld(true)) : (r2.remove(i2), n2.delete(e2)), this.onTileVisibilityChange && this.onTileVisibilityChange(i2, e2, t2);
        }
        setTileActive(e2, t2) {
          const i2 = this.activeTiles;
          t2 ? i2.add(e2) : i2.delete(e2);
        }
        calculateError(e2) {
          const t2 = e2.cached, i2 = t2.inFrustum, n2 = this.cameras, r2 = this.cameraInfo, s2 = e2.boundingVolume;
          if ("box" in s2 || "sphere" in s2) {
            const s3 = t2.sphere, a2 = t2.box, o2 = t2.boxTransformInverse, l2 = t2.transformInverse, h2 = a2 && o2;
            let c2 = -1 / 0, u2 = 1 / 0;
            for (let t3 = 0, d2 = n2.length; t3 < d2; t3++) {
              if (!i2[t3])
                continue;
              const n3 = r2[t3], d3 = n3.invScale;
              let p2;
              if (n3.isOrthographic) {
                const t4 = n3.pixelSize;
                p2 = e2.geometricError / (t4 * d3);
              } else {
                let t4;
                og.copy(n3.position), h2 ? (og.applyMatrix4(o2), t4 = a2.distanceToPoint(og)) : (og.applyMatrix4(l2), t4 = Math.max(s3.distanceToPoint(og), 0));
                const i3 = t4 * d3, r3 = n3.sseDenominator;
                p2 = e2.geometricError / (i3 * r3), u2 = Math.min(u2, i3);
              }
              c2 = Math.max(c2, p2);
            }
            e2.__distanceFromCamera = u2, e2.__error = c2;
          } else
            "region" in s2 && console.warn("ThreeTilesRenderer : Region bounds not supported.");
        }
        tileInView(e2) {
          const t2 = e2.cached, i2 = t2.sphere, n2 = t2.inFrustum;
          if (i2) {
            const e3 = this.cameraInfo;
            let t3 = false;
            for (let r2 = 0, s2 = e3.length; r2 < s2; r2++) {
              e3[r2].frustum.intersectsSphere(i2) ? (t3 = true, n2[r2] = true) : n2[r2] = false;
            }
            return t3;
          }
          return true;
        }
      }
      const fg = new Ae(), gg = ["x", "y", "z"];
      class _g extends ia {
        constructor(e2, t2 = 16776960, i2 = 40) {
          const n2 = new ri(), r2 = [];
          for (let s2 = 0; s2 < 3; s2++) {
            const e3 = gg[s2], t3 = gg[(s2 + 1) % 3];
            fg.set(0, 0, 0);
            for (let n3 = 0; n3 < i2; n3++) {
              let s3;
              s3 = 2 * Math.PI * n3 / (i2 - 1), fg[e3] = Math.sin(s3), fg[t3] = Math.cos(s3), r2.push(fg.x, fg.y, fg.z), s3 = 2 * Math.PI * (n3 + 1) / (i2 - 1), fg[e3] = Math.sin(s3), fg[t3] = Math.cos(s3), r2.push(fg.x, fg.y, fg.z);
            }
          }
          n2.setAttribute("position", new qt(new Float32Array(r2), 3)), n2.computeBoundingSphere(), super(n2, new qs({ color: t2, toneMapped: false })), this.sphere = e2, this.type = "SphereHelper";
        }
        updateMatrixWorld(e2) {
          const t2 = this.sphere;
          this.position.copy(t2.center), this.scale.setScalar(t2.radius), super.updateMatrixWorld(e2);
        }
      }
      const vg = Symbol("ORIGINAL_MATERIAL"), xg = Symbol("HAS_RANDOM_COLOR"), yg = Symbol("HAS_RANDOM_NODE_COLOR");
      function bg() {
      }
      class Mg extends mg {
        constructor(...e2) {
          super(...e2);
          const t2 = this.group, i2 = new vs();
          i2.name = "DebugTilesRenderer.boxGroup", t2.add(i2);
          const n2 = new vs();
          n2.name = "DebugTilesRenderer.sphereGroup", t2.add(n2), this.displayBoxBounds = false, this.displaySphereBounds = false, this.colorMode = 0, this.customColorCallback = null, this.boxGroup = i2, this.sphereGroup = n2, this.maxDebugDepth = -1, this.maxDebugDistance = -1, this.maxDebugError = -1, this.getDebugColor = (e3, t3) => {
            t3.setRGB(e3, e3, e3);
          }, this.extremeDebugDepth = -1, this.extremeDebugError = -1;
        }
        initExtremes() {
          let e2 = -1;
          this.traverse((t3) => {
            e2 = Math.max(e2, t3.__depth);
          });
          let t2 = -1;
          this.traverse((e3) => {
            t2 = Math.max(t2, e3.geometricError);
          }), this.extremeDebugDepth = e2, this.extremeDebugError = t2;
        }
        fetchTileSet(...e2) {
          const t2 = super.fetchTileSet(...e2);
          return t2.then(() => {
            Promise.resolve().then(() => {
              this.initExtremes();
            });
          }).catch(() => {
          }), t2;
        }
        getTileInformationFromActiveObject(e2) {
          let t2 = null;
          return this.activeTiles.forEach((i2) => {
            if (t2)
              return true;
            const n2 = i2.cached.scene;
            n2 && n2.traverse((n3) => {
              n3 === e2 && (t2 = i2);
            });
          }), t2 ? { distanceToCamera: t2.__distanceFromCamera, geometricError: t2.geometricError, screenSpaceError: t2.__error, depth: t2.__depth, isLeaf: t2.__isLeaf } : null;
        }
        update() {
          if (super.update(), !this.root)
            return;
          this.boxGroup.visible = this.displayBoxBounds, this.sphereGroup.visible = this.displaySphereBounds;
          let e2 = -1;
          e2 = -1 === this.maxDebugDepth ? this.extremeDebugDepth : this.maxDebugDepth;
          let t2 = -1;
          t2 = -1 === this.maxDebugError ? this.extremeDebugError : this.maxDebugError;
          let i2 = -1;
          i2 = -1 === this.maxDebugDistance ? this.root.cached.sphere.radius : this.maxDebugDistance;
          const n2 = this.errorTarget, r2 = this.colorMode;
          this.visibleTiles.forEach((s2) => {
            const a2 = s2.cached.scene;
            let o2, l2, h2;
            7 === r2 && (o2 = Math.random(), l2 = 0.5 + 0.5 * Math.random(), h2 = 0.375 + 0.25 * Math.random()), a2.traverse((a3) => {
              8 === r2 && (o2 = Math.random(), l2 = 0.5 + 0.5 * Math.random(), h2 = 0.375 + 0.25 * Math.random());
              const c2 = a3.material;
              if (c2) {
                const u2 = a3[vg];
                if (0 === r2 && c2 !== u2)
                  a3.material.dispose(), a3.material = a3[vg];
                else if (0 !== r2 && c2 === u2)
                  if (a3.isPoints) {
                    const e3 = new ra();
                    e3.size = u2.size, e3.sizeAttenuation = u2.sizeAttenuation, a3.material = e3;
                  } else
                    a3.material = new xa(), a3.material.flatShading = true;
                switch (7 !== r2 && delete a3.material[xg], 8 !== r2 && delete a3.material[yg], r2) {
                  case 4: {
                    const t3 = s2.__depth / e2;
                    this.getDebugColor(t3, a3.material.color);
                    break;
                  }
                  case 5: {
                    const t3 = s2.__depthFromRenderedParent / e2;
                    this.getDebugColor(t3, a3.material.color);
                    break;
                  }
                  case 1: {
                    const e3 = s2.__error / n2;
                    e3 > 1 ? a3.material.color.setRGB(1, 0, 0) : this.getDebugColor(e3, a3.material.color);
                    break;
                  }
                  case 2: {
                    const e3 = Math.min(s2.geometricError / t2, 1);
                    this.getDebugColor(e3, a3.material.color);
                    break;
                  }
                  case 3: {
                    const e3 = Math.min(s2.__distanceFromCamera / i2, 1);
                    this.getDebugColor(e3, a3.material.color);
                    break;
                  }
                  case 6:
                    s2.children && 0 !== s2.children.length ? this.getDebugColor(0, a3.material.color) : this.getDebugColor(1, a3.material.color);
                    break;
                  case 8:
                    a3.material[yg] || (a3.material.color.setHSL(o2, l2, h2), a3.material[yg] = true);
                    break;
                  case 7:
                    a3.material[xg] || (a3.material.color.setHSL(o2, l2, h2), a3.material[xg] = true);
                    break;
                  case 9:
                    this.customColorCallback ? this.customColorCallback(s2, a3) : console.warn("DebugTilesRenderer: customColorCallback not defined");
                }
              }
            });
          });
        }
        setTileVisible(e2, t2) {
          super.setTileVisible(e2, t2);
          const i2 = e2.cached, n2 = this.sphereGroup, r2 = this.boxGroup, s2 = i2.boxHelperGroup, a2 = i2.sphereHelper;
          t2 ? (s2 && (r2.add(s2), s2.updateMatrixWorld(true)), a2 && (n2.add(a2), a2.updateMatrixWorld(true))) : (s2 && r2.remove(s2), a2 && n2.remove(a2));
        }
        parseTile(e2, t2, i2) {
          return super.parseTile(e2, t2, i2).then(() => {
            const e3 = t2.cached, i3 = e3.scene;
            if (i3) {
              if (e3.box && e3.boxTransform) {
                const i4 = e3.box, n2 = e3.boxTransform, r2 = new vs();
                r2.name = "DebugTilesRenderer.boxHelperGroup", r2.matrix.copy(n2), r2.matrixAutoUpdate = false;
                const s2 = new Oo(i4, function(e4) {
                  if (!af[e4]) {
                    const t3 = Math.random(), i5 = 0.5 + 0.5 * Math.random(), n3 = 0.375 + 0.25 * Math.random();
                    af[e4] = new ge().setHSL(t3, i5, n3);
                  }
                  return af[e4];
                }(t2.__depth));
                s2.raycast = bg, r2.add(s2), e3.boxHelperGroup = r2, this.visibleTiles.has(t2) && this.displayBoxBounds && (this.boxGroup.add(r2), r2.updateMatrixWorld(true));
              }
              if (e3.sphere) {
                const i4 = e3.sphere, n2 = new _g(i4);
                n2.raycast = bg, e3.sphereHelper = n2, this.visibleTiles.has(t2) && this.displaySphereBounds && (this.sphereGroup.add(n2), n2.updateMatrixWorld(true));
              }
              i3.traverse((e4) => {
                const t3 = e4.material;
                t3 && (e4[vg] = t3);
              });
            }
          });
        }
        disposeTile(e2) {
          super.disposeTile(e2);
          const t2 = e2.cached;
          t2.boxHelperGroup && (t2.boxHelperGroup.children[0].geometry.dispose(), delete t2.boxHelperGroup), t2.sphereHelper && (t2.sphereHelper.geometry.dispose(), delete t2.sphereHelper);
        }
      }
      class Sg {
        constructor(e2) {
          __publicField(this, "_tileMaxLevel", 19), __publicField(this, "_subscribedMaxLodLevel", 1), __publicField(this, "_elementHandlers", []), __publicField(this, "_objectParent", null), __publicField(this, "subscribedDataTypeMap", {}), __publicField(this, "_active", false), __publicField(this, "_configVersion", 0), __publicField(this, "shouldIgnoreTile", (e3) => e3.__lodLevel > this._subscribedMaxLodLevel), __publicField(this, "parseElements", (e3) => {
            const t2 = e3.cached.scene, i2 = t2.batchTable && t2.batchTable.header;
            if (!i2)
              return;
            if (!i2.id || !i2.dataType)
              return;
            const n2 = i2.id, r2 = i2.dataType, s2 = {}, a2 = /* @__PURE__ */ new Map();
            let o2 = null, l2 = null, h2 = null;
            for (let c2 = 0, u2 = r2.length; c2 < u2; c2++) {
              if (!this.subscribedDataTypeMap[r2[c2]])
                continue;
              o2 = r2[c2], l2 = this.subscribedDataTypeMap[o2], h2 = n2[c2];
              const e4 = { id: h2, dataType: o2, position: [], uv: [], normal: [], index: [] };
              s2[c2] = e4;
              const t3 = a2.get(l2);
              t3 ? t3.push(e4) : a2.set(l2, [e4]);
            }
            for (const c2 of t2.children)
              this.findElementInMesh(c2, s2, a2);
            for (const c2 of a2.keys()) {
              const t3 = a2.get(c2);
              c2.addTileElementObjects(e3, t3);
            }
          }), __publicField(this, "getInterleavedBufferValue2", (e3, t2) => {
            const i2 = e3.data.array, n2 = e3.data.stride * t2 + e3.offset;
            return [i2[n2], i2[n2 + 1]];
          }), __publicField(this, "getInterleavedBufferValue3", (e3, t2) => {
            const i2 = e3.data.array, n2 = e3.data.stride * t2 + e3.offset;
            return [i2[n2], i2[n2 + 1], i2[n2 + 2]];
          }), __publicField(this, "findElementInMesh", (e3, t2, i2) => {
            if (!e3 || !e3.geometry)
              return;
            const n2 = e3.geometry.getAttribute("_batchid");
            if (!n2)
              return;
            const r2 = e3.geometry.getAttribute("normal");
            if (!r2)
              return;
            const s2 = e3.geometry.getAttribute("position"), a2 = e3.geometry.getAttribute("uv"), o2 = n2.data.count, l2 = {};
            let h2 = null;
            for (let u2 = 0; u2 < o2; u2++) {
              if (h2 = n2.getX(u2), !t2[h2])
                continue;
              let e4 = t2[h2], i3 = this.getInterleavedBufferValue3(s2, u2), o3 = this.getInterleavedBufferValue3(r2, u2), c3 = this.getInterleavedBufferValue2(a2, u2);
              e4.position.push(i3[0], i3[1], i3[2]), e4.normal.push(o3[0], o3[1], o3[2]), e4.uv.push(c3[0], c3[1]), l2[u2] = { batchId: h2, index: e4.position.length / 3 - 1 };
            }
            const c2 = e3.geometry.index.array;
            for (let u2 = 0, d2 = c2.length - 2; u2 < d2; u2 += 3) {
              let e4 = c2[u2];
              if (void 0 === l2[e4])
                continue;
              let i3 = c2[u2 + 1], n3 = c2[u2 + 2], r3 = l2[e4], s3 = r3.batchId, a3 = r3.index, o3 = l2[i3] && l2[i3].index, h3 = l2[n3] && l2[n3].index;
              if (void 0 === o3 || void 0 === h3) {
                console.warn("one face includes more than one object");
                continue;
              }
              t2[s3].index.push(a3, o3, h3);
            }
            for (const u2 of Object.keys(t2)) {
              const e4 = t2[u2], i3 = new ri();
              i3.setAttribute("position", new qt(new Float32Array(e4.position), 3)), i3.setAttribute("normal", new qt(new Float32Array(e4.normal), 3)), i3.setAttribute("uv", new qt(new Float32Array(e4.uv), 2)), i3.setIndex(e4.index), e4.geometry = i3;
            }
          }), __publicField(this, "onTileLoad", (e3, t2) => {
            this.parseTileInfo(e3), this.shouldIgnoreTile(e3);
          }), __publicField(this, "onTileDispose", (e3, t2) => {
            if (!this.shouldIgnoreTile(e3))
              for (const i2 of this._elementHandlers)
                i2.disposeTileElementObjects(e3);
          }), __publicField(this, "onTileShow", (e3) => {
            this._active && !this.shouldIgnoreTile(e3) && this.refreshTile(e3);
          }), __publicField(this, "onTileHide", (e3) => {
            if (this._active && !this.shouldIgnoreTile(e3))
              for (const t2 of this._elementHandlers)
                t2.hideTileElementObjects(e3);
          }), __publicField(this, "parseTileInfo", (e3) => {
            const t2 = e3.content.uri, i2 = t2.substring(t2.lastIndexOf("/") + 1).split(".")[0], n2 = i2.split("-");
            e3.__id = i2, e3.__level = parseInt(n2[0], 10), e3.__lodLevel = this._tileMaxLevel - e3.__level;
          }), __publicField(this, "refreshTile", (e3) => {
            if (e3.__elementsConfigVersion !== this._configVersion) {
              for (const t2 of this._elementHandlers)
                t2.disposeTileElementObjects(e3);
              this.parseElements(e3), e3.__elementsConfigVersion = this._configVersion;
            }
            for (const t2 of this._elementHandlers)
              t2.showTileElementObjects(e3);
          }), __publicField(this, "refreshTiles", () => {
            this.tilesRenderer.forEachLoadedModel((e3, t2) => {
              t2.__visible && !this.shouldIgnoreTile(t2) && this.refreshTile(t2);
            }), this.engine.requestRender();
          }), this._objectParent = e2;
        }
        registerElement(e2) {
          e2.parent = this._objectParent, e2.engine = this.engine;
          for (const t2 of e2.subscribedDataTypeIds)
            this.subscribedDataTypeMap[t2] = e2;
          return this._elementHandlers.push(e2), this._configVersion++, this._active = true, this.refreshTiles(), e2;
        }
        unregisterElement(e2) {
          for (let i2 of Object.keys(this.subscribedDataTypeMap))
            this.subscribedDataTypeMap[i2] === e2 && delete this.subscribedDataTypeMap[i2];
          let t2 = this._elementHandlers.indexOf(e2);
          t2 > -1 && (e2.dispose(), this._elementHandlers.splice(t2, 1)), this._configVersion++, this._active = this._elementHandlers.length > 0, this.refreshTiles();
        }
        tick(e2) {
          if (this._active)
            for (const t2 of this._elementHandlers)
              t2.tick(e2);
        }
        get subscribedMaxLodLevel() {
          return this._subscribedMaxLodLevel;
        }
        set subscribedMaxLodLevel(e2) {
          this._subscribedMaxLodLevel = e2;
        }
      }
      class wg extends Rt {
        constructor(e2) {
          if (super(), __publicField(this, "isEventEntitySupported", true), __publicField(this, "_expandStepSize", 100), __publicField(this, "_meshes", []), __publicField(this, "_attributes", []), __publicField(this, "_idIndexMap", {}), __publicField(this, "_indexIdMap", {}), __publicField(this, "_instanceMatrixArray", new Float32Array(1600)), __publicField(this, "_instanceMatrixArraySize", 100), __publicField(this, "_currentCount", 0), __publicField(this, "_rtc", null), __publicField(this, "updateRenderingMesh", () => {
            const e3 = this._meshes, t2 = e3.length, i2 = this.children;
            for (let n2 = 0; n2 < t2; ++n2) {
              const t3 = e3[n2], r2 = new Xs(t3.geometry, t3.material);
              r2.__eventProxyByParent = true, r2.castShadow = t3.castShadow, r2.receiveShadow = t3.receiveShadow, r2.parent = this, i2[n2] = r2;
            }
            if (i2.length > t2) {
              for (let e4 = i2.length - 1; e4 >= t2; --e4)
                this.remove(this.children[e4]);
            }
          }), __publicField(this, "expandInstanceArray", (e3) => {
            const t2 = this._instanceMatrixArraySize + this._expandStepSize * Math.ceil(e3 / this._expandStepSize), i2 = new Float32Array(16 * t2);
            i2.set(this._instanceMatrixArray), this._instanceMatrixArray = i2, this._instanceMatrixArraySize = t2;
          }), __publicField(this, "copyArrayData", (e3, t2, i2, n2, r2) => {
            for (let s2 = 0; s2 < r2; s2++)
              e3[t2 + s2] = i2[n2 + s2];
          }), e2)
            this.meshes = e2;
          else {
            const e3 = new Mi(new wi(1, 1, 1), new jt({ color: 16777215 }));
            this._meshes = [e3];
          }
          this.updateRenderingMesh();
        }
        getEntityByIndex(e2) {
          const t2 = this._indexIdMap[e2];
          if (void 0 === t2)
            return null;
          const i2 = { id: t2 };
          return i2.matrix = this._instanceMatrixArray.slice(16 * e2, 16 * (e2 + 1)), i2;
        }
        has(e2) {
          return void 0 !== this._idIndexMap[e2];
        }
        clear() {
          this._idIndexMap = {}, this._indexIdMap = {}, this._instanceMatrixArray = new Float32Array(1600), this._instanceMatrixArraySize = 100, this._currentCount = 0, this._rtc = null;
        }
        setBufferData(e2) {
          this.clear(), this.addInstances(e2);
        }
        addInstances(e2) {
          if (!e2)
            return;
          const t2 = e2.id, i2 = t2.length;
          if (0 !== i2)
            if (this._currentCount + i2 > this._instanceMatrixArraySize && this.expandInstanceArray(i2), e2.instanceMatrix)
              this._instanceMatrixArray.set(e2.instanceMatrix, 16 * this._currentCount), this._currentCount += i2;
            else {
              const n2 = e2.translation, r2 = e2.scale, s2 = e2.rotation, a2 = this._instanceMatrixArray;
              let o2 = new st(), l2 = new Ae(), h2 = new Ae(), c2 = new ft(), u2 = new Ce(), d2 = null, p2 = null, m2 = this._rtc;
              m2 || (n2 ? (m2 = [n2[0], n2[1], n2[2]], this._rtc = m2, this.position.set(m2[0], m2[1], m2[2])) : m2 = [0, 0, 0]);
              for (let e3 = 0; e3 < i2; e3++) {
                let i3 = 3 * e3;
                r2 ? h2.set(r2[i3], r2[i3 + 1], r2[i3 + 2]) : h2.set(1, 1, 1), n2 ? l2.set(n2[i3] - m2[0], n2[i3 + 1] - m2[1], n2[i3 + 2] - m2[2]) : l2.set(0, 0, 0), s2 ? c2.set(s2[i3], s2[i3 + 1], s2[i3 + 2], "XYZ") : c2.set(0, 0, 0, "XYZ"), u2.setFromEuler(c2), o2.compose(l2, u2, h2), i3 = 16 * (this._currentCount + e3);
                const f2 = o2.elements;
                for (let e4 = 0; e4 < 16; e4++)
                  a2[i3 + e4] = f2[e4];
                d2 = t2[e3], p2 = this._currentCount + e3, this._idIndexMap[d2] = p2, this._indexIdMap[p2] = d2;
              }
              this._currentCount += i2;
            }
        }
        removeInstance(e2) {
          this.removeInstances({ id: [e2] });
        }
        removeInstances(e2) {
          const t2 = e2.id, i2 = t2.length;
          if (0 !== i2)
            for (let n2 = 0; n2 < i2; ++n2) {
              const e3 = t2[n2], i3 = this._idIndexMap[e3];
              if (void 0 === i3) {
                console.warn(`remove an item ${e3} not exist`);
                continue;
              }
              const r2 = this._currentCount - 1;
              if (!(i3 > r2)) {
                if (i3 < r2) {
                  this.copyArrayData(this._instanceMatrixArray, 16 * i3, this._instanceMatrixArray, 16 * r2, 16);
                  const t3 = this._indexIdMap[r2];
                  this._indexIdMap[i3] = t3, this._idIndexMap[t3] = i3, delete this._idIndexMap[e3];
                }
                this._currentCount--;
              }
            }
        }
        update() {
          const e2 = this.children;
          for (const t2 of e2)
            t2.instanceMatrix = new Vs(this._instanceMatrixArray, 16), t2.count = this._currentCount;
        }
        set meshes(e2) {
          e2 && (Array.isArray(e2) ? this._meshes = e2 : e2.isMesh ? this._meshes = [e2] : e2.isGroup && (this._meshes = e2.children), this.updateRenderingMesh(), this.update());
        }
        set needsUpdate(e2) {
          e2 && this.update();
        }
        get meshes() {
          return this._meshes;
        }
      }
      class Tg extends Rt {
        constructor(e2) {
          super(), __publicField(this, "_lodMeshes", []), __publicField(this, "_lodChildren", {}), this._lodMeshes = e2 || [];
        }
        addInstances(e2, t2 = 0) {
          let i2 = this._lodChildren[t2];
          if (!i2) {
            let e3 = this._lodMeshes[t2];
            e3 || (e3 = this._lodMeshes[this._lodMeshes.length - 1]), i2 = new wg(e3), this._lodChildren[t2] = i2, this.add(i2);
          }
          i2 && i2.addInstances(e2);
        }
        removeInstances(e2, t2 = 0) {
          const i2 = this._lodChildren[t2];
          i2 && i2.removeInstances(e2);
        }
        setMeshesAt(e2, t2 = 0) {
          this._lodMeshes[t2] = e2;
          const i2 = this._lodChildren;
          i2[t2] && (i2[t2].meshes = e2);
        }
        setLODMeshes(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this.setMeshesAt(i2, t2);
          }
        }
        set needsUpdate(e2) {
          if (e2) {
            const e3 = this.children;
            for (const t2 of e3)
              t2 && (t2.needsUpdate = true);
          }
        }
      }
      const Eg = { pars: "", main_before: "", main_after: "", project_after: "", worldpos_after: "" }, Cg = { pars: "", main_before: "", color_after: "", custom_map: "" };
      class Ag extends Ai {
        constructor(e2) {
          super(), __publicField(this, "getShaderSource", (e3, t3, i3, n3) => {
            const r3 = Object.assign({}, t3, i3);
            for (const s2 of Object.keys(r3)) {
              const t4 = r3[s2];
              e3 = e3.replace("#chunk <" + n3 + "_" + s2 + ">", t4);
            }
            return e3;
          }), __publicField(this, "setCommonUniforms", (e3) => {
            for (const t3 of Object.keys(e3))
              this.uniforms[t3] = e3[t3];
          }), this.lights = true, this.fog = true, this.type = "ExtendMeshStandardMaterial", this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.defineMaterialNormalProperties = Mh, this.defineMaterialAliasProperties = wh, Mh(this, ["roughness", "metalness", "map", "lightMap", "aoMap", "emissive", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "roughnessMap", "metalnessMap", "alphaMap", "envMap"]), wh(this, [["color", "diffuse"]]), this.uniforms = Ci.clone(Ci.merge([qi.standard.uniforms, e2.uniforms])), this.color = new ge(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ge(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ie(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false;
          const { vertexShaderChunks: t2, fragmentShaderChunks: i2, uniforms: n2, ...r2 } = e2;
          this.setValues(r2), this.vertexShaderChunks = t2, this.fragmentShaderChunks = i2;
        }
        set vertexShaderChunks(e2) {
          this.vertexShader = this.getShaderSource("#define GLSLIFY 1\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#chunk <vertex_pars>\n\nvoid main() {\n\n    #chunk <vertex_main_before>\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#chunk <vertex_project_after>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#chunk <vertex_worldpos_after>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n#ifdef USE_TRANSMISSION\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif\n    #chunk <vertex_main_after>\n}", Eg, e2, "vertex"), this.needsUpdate = true;
        }
        set fragmentShaderChunks(e2) {
          this.fragmentShader = this.getShaderSource("#define GLSLIFY 1\n#define STANDARD\n\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\n	uniform float ior;\n#endif\n\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#chunk <fragment_pars>\n\nvoid main() {\n\n	#ifdef USE_MAP\n    	vec2 uv = vec2(vUv);\n	#endif\n    #chunk <fragment_main_before>\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#ifdef USE_MAP\n\n		#ifdef USE_CUSTOM_MAP\n			 #chunk <fragment_custom_map>\n		#else\n			vec4 sampledDiffuseColor = texture2D( map, uv );\n		#endif\n\n        #ifdef DECODE_VIDEO_TEXTURE\n\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n\n            sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\n        #endif\n\n        diffuseColor *= sampledDiffuseColor;\n\n    #endif\n	#include <color_fragment>\n    #chunk <fragment_color_after>\n	#ifdef USE_ALPHAMAP\n\n        diffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n    #endif\n	#include <alphatest_fragment>\n	float roughnessFactor = roughness;\n\n    #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, uv );\n\n        // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n        roughnessFactor *= texelRoughness.g;\n\n    #endif\n	float metalnessFactor = metalness;\n\n    #ifdef USE_METALNESSMAP\n\n        vec4 texelMetalness = texture2D( metalnessMap, uv );\n\n        // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n        metalnessFactor *= texelMetalness.b;\n\n    #endif\n	#include <normal_fragment_begin>\n	#ifdef OBJECTSPACE_NORMALMAP\n\n	normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n	#ifdef FLIP_SIDED\n\n		normal = - normal;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * faceDirection;\n\n	#endif\n\n	normal = normalize( normalMatrix * normal );\n\n    #elif defined( TANGENTSPACE_NORMALMAP )\n\n        vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n        mapN.xy *= normalScale;\n\n        #ifdef USE_TANGENT\n\n            normal = normalize( vTBN * mapN );\n\n        #else\n\n            normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\n        #endif\n\n    #elif defined( USE_BUMPMAP )\n\n        normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n\n    #endif\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#ifdef USE_EMISSIVEMAP\n\n        vec4 emissiveColor = texture2D( emissiveMap, uv );\n\n        totalEmissiveRadiance *= emissiveColor.rgb;\n\n    #endif\n\n	// accumulation\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n	#include <transmission_fragment>\n\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n	#ifdef USE_SHEEN\n\n		// Sheen energy compensation approximation calculation can be found at the end of\n		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n	#endif\n\n	#ifdef USE_CLEARCOAT\n\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n	#endif\n\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}", Cg, e2, "fragment"), this.needsUpdate = true;
        }
        dispose() {
          let e2 = ["map", "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "roughnessMap", "metalnessMap", "alphaMap", "envMap", "specularIntensityMap", "specularColorMap", "sheenColorMap", "sheenRoughnessMap"];
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this[i2] && this[i2].dispose();
          }
          super.dispose();
        }
      }
      const Pg = { pars: "\n        uniform float elapsedTime;\n        uniform vec3 windDirection;\n        uniform float windStrength;\n    ", main_after: "\n        \n    ", project_after: "\n    vec4 modelPosition = vec4( transformed, 1.0 );\n    #ifdef USE_INSTANCING\n        modelPosition = instanceMatrix * modelPosition;\n    #endif\n    modelPosition = modelMatrix * modelPosition;\n\n    float dirDot = abs(dot(windDirection, normal));\n    float period = 1500.0 * dirDot + 500.0;\n    period = sin(mod(elapsedTime, period) / period * PI * 2.0);\n    period = (period + 1.0) / 2.0;\n    vec3 worldPositionOffset = windDirection * windStrength * period * dirDot;\n    modelPosition.xyz += worldPositionOffset;\n\n    mvPosition = viewMatrix * modelPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    ", worldpos_after: "\n    #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n        worldPosition.xyz += worldPositionOffset;\n    #endif\n    " }, Rg = { pars: "\n    ", main_before: "\n    ", color_after: "\n    " };
      class Lg extends Ag {
        constructor(e2 = {}) {
          super({ uniforms: { windDirection: { value: [1, 0, 0] }, windStrength: { value: 0.5 } } }), this.vertexShaderChunks = Pg, this.fragmentShaderChunks = Rg, this.setValues(e2);
        }
        get windDirection() {
          return this.uniforms.windDirection.value;
        }
        set windDirection(e2) {
          this.uniforms.windDirection.value = e2;
        }
        get windStrength() {
          return this.uniforms.windStrength.value;
        }
        set windStrength(e2) {
          this.uniforms.windStrength.value = e2;
        }
        static fromMaterial(e2, t2) {
          const i2 = new Lg(t2);
          return i2.map = e2.map, i2.alphaTest = e2.alphaTest, i2.metalness = e2.metalness, i2.roughness = e2.roughness, i2.side = e2.side, i2.vertexColors = e2.vertexColors, i2;
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      const Ig = (e2) => {
        if (e2.isMesh)
          e2.geometry.applyMatrix4(e2.matrixWorld);
        else if (e2.children.length > 0)
          for (const t2 of e2.children)
            Ig(t2);
        e2.position.set(0, 0, 0), e2.scale.set(1, 1, 1), e2.quaternion.set(0, 0, 0, 1);
      }, Dg = (e2, t2) => {
        if (e2.isMesh)
          t2.push(e2);
        else if (e2.children.length > 0)
          for (const i2 of e2.children)
            Dg(i2, t2);
      }, Fg = (e2, t2, i2) => {
        t2 && ((e3) => {
          const t3 = new Le();
          t3.setFromObject(e3);
          const i3 = Math.max(t3.max.x - t3.min.x, t3.max.y - t3.min.y, t3.max.z - t3.min.z);
          e3.scale.multiplyScalar(1 / i3);
        })(e2), i2 && (e2.rotation.x = Math.PI / 2), e2.updateMatrixWorld(), Ig(e2), e2.updateMatrixWorld();
        const n2 = [];
        return Dg(e2, n2), n2;
      }, Og = (e2, t2, i2) => {
        const n2 = [];
        for (const r2 of e2) {
          const e3 = r2.name;
          if (!e3.startsWith("lod"))
            continue;
          const s2 = parseInt(e3.substring(3), 10);
          if (isNaN(s2))
            continue;
          const a2 = Fg(r2, t2, i2);
          n2[s2] = a2;
        }
        return n2;
      }, Ug = Object.freeze(Object.defineProperty({ __proto__: null, parseLODModel: Og, parseScene: Fg }, Symbol.toStringTag, { value: "Module" })), zg = new Pp();
      class Ng {
        constructor() {
          __publicField(this, "_lastUpdateTime", 0), __publicField(this, "_updateDelayTimerHander", null), __publicField(this, "_configVersion", 0), __publicField(this, "_treeEnabled", true), __publicField(this, "_labelEnabled", false), __publicField(this, "_idEnabled", false), __publicField(this, "_dataTypeEnabled", false), __publicField(this, "markNeedsUpdate", () => {
            this._updateDelayTimerHander || (this._updateDelayTimerHander = setTimeout(() => {
              this._tree.needsUpdate = true, this.engine.requestRender(), this._updateDelayTimerHander = null;
            }, 100));
          }), __publicField(this, "parseInstancedData", (e3, t2) => {
            const i2 = e3.geometry, n2 = t2.__id, r2 = i2.attributes.position, s2 = r2.count;
            if (0 === s2)
              return;
            const a2 = [];
            t2.__lodLevel;
            const o2 = i2.attributes.scale, l2 = i2.attributes.rotation, h2 = new Float32Array(3 * s2), c2 = new Float32Array(3 * s2), u2 = new Float32Array(3 * s2), d2 = t2.cached.scene.matrix, p2 = new Ae();
            for (let f2 = 0; f2 < s2; f2++)
              p2.set(r2.getX(f2), r2.getY(f2), r2.getZ(f2)), p2.applyMatrix4(d2), h2[3 * f2] = p2.x, h2[3 * f2 + 1] = p2.y, h2[3 * f2 + 2] = p2.z, c2[3 * f2] = o2.getX(f2), c2[3 * f2 + 1] = o2.getY(f2), c2[3 * f2 + 2] = o2.getZ(f2), u2[3 * f2] = l2.getX(f2), u2[3 * f2 + 1] = l2.getY(f2), u2[3 * f2 + 2] = l2.getZ(f2), a2.push(n2 + "-" + f2);
            const m2 = { translation: h2, scale: c2, rotation: u2, id: a2 };
            t2.__instanceData = m2;
          }), __publicField(this, "parseLabelData", (e3, t2) => {
            const i2 = e3.geometry, n2 = t2.__id, r2 = i2.attributes.position, s2 = r2.count;
            if (0 === s2)
              return;
            const a2 = i2.attributes.rotation, o2 = t2.cached.scene, l2 = o2.matrix, h2 = o2.batchTable.header.text, c2 = [], u2 = new Ae();
            for (let d2 = 0; d2 < s2; d2++)
              u2.set(r2.getX(d2), r2.getY(d2), r2.getZ(d2)), u2.applyMatrix4(l2), c2.push({ id: n2 + "-" + d2, type: "flat", position: [u2.x, u2.y, u2.z], text: h2[d2], rotateZ: a2.getZ(d2) });
            t2.__labelData = c2;
          }), __publicField(this, "remapBatchValueToNumber", (e3) => e3 ? isFinite(e3) ? e3 = Math.round(e3 % 100) : "string" == typeof e3 ? (e3 = e3.charCodeAt(3) || 0) % 100 : 0 : 0), __publicField(this, "parseBatchTableAttribute", (e3, t2, i2) => {
            const n2 = e3.cached.scene, r2 = n2.children, s2 = n2.batchTable && n2.batchTable.header;
            if (!s2)
              return;
            const a2 = s2[t2];
            if (a2)
              for (const o2 of r2) {
                if ("_tree" === o2.originalMaterialName || "_label" === o2.originalMaterialName)
                  continue;
                const e4 = o2.geometry, t3 = e4.getAttribute("_batchid");
                if (!t3)
                  continue;
                const n3 = t3.data.count;
                let r3 = -1, s3 = 0;
                const l2 = [];
                for (let i3 = 0; i3 < n3; i3++)
                  r3 = t3.getX(i3), s3 = this.remapBatchValueToNumber(a2[r3]), l2.push(s3);
                e4.attributes[i2] = new qt(new Float32Array(l2), 1);
              }
          }), __publicField(this, "onTileLoad", (e3, t2) => {
          }), __publicField(this, "onTileDispose", (e3, t2) => {
          }), __publicField(this, "onTileShow", (e3) => {
            this.refreshTile(e3);
          }), __publicField(this, "onTileHide", (e3) => {
            const t2 = e3.__instanceData;
            e3.__hasAddInstancedData && t2 && (this._tree.removeInstances(t2, e3.__lodLevel), e3.__hasAddInstancedData = false, this.markNeedsUpdate());
            const i2 = e3.__labelData;
            e3.__hasAddLabelData && i2 && (this.engine.rendering.label.removeLabels(i2), e3.__hasAddLabelData = false);
          }), __publicField(this, "refreshTile", (e3) => {
            const t2 = e3.cached.scene.children;
            if (e3.__instanceConfigVersion !== this._configVersion) {
              for (const i3 of t2)
                "_tree" === i3.originalMaterialName ? (i3.visible = false, this._treeEnabled && !e3.__instanceTreeParsed && (this.parseInstancedData(i3, e3), e3.__instanceTreeParsed = true)) : "_label" === i3.originalMaterialName && (i3.visible = false, this._labelEnabled && !e3.__instanceLabelParsed && (this.parseLabelData(i3, e3), e3.__instanceLabelParsed = true));
              this._idEnabled && !e3.__instanceIdParsed && (this.parseBatchTableAttribute(e3, "id", "_id"), e3.__instanceIdParsed = true), this._dataTypeEnabled && !e3.__instanceDataTypeParsed && (this.parseBatchTableAttribute(e3, "dataType", "_dataType"), e3.__instanceDataTypeParsed = true), e3.__instanceConfigVersion = this._configVersion;
            }
            const i2 = e3.__instanceData;
            i2 && (this._treeEnabled && !e3.__hasAddInstancedData && (this._tree.addInstances(i2, e3.__lodLevel), this.markNeedsUpdate(), e3.__hasAddInstancedData = true), !this._treeEnabled && e3.__hasAddInstancedData && (this._tree.removeInstances(i2, e3.__lodLevel), this.markNeedsUpdate(), e3.__hasAddInstancedData = false));
            const n2 = e3.__labelData;
            n2 && (this._labelEnabled && !e3.__hasAddLabelData && (this.engine.rendering.label.addLabels(n2, e3.__lodLevel), e3.__hasAddLabelData = true), !this._labelEnabled && e3.__hasAddLabelData && (this.engine.rendering.label.removeLabels(n2, e3.__lodLevel), e3.__hasAddLabelData = false));
          }), __publicField(this, "refreshTiles", () => {
            this.tilesRenderer.forEachLoadedModel((e3, t2) => {
              t2.__visible && this.refreshTile(t2);
            }), this.engine.requestRender();
          }), __publicField(this, "updateTreeModelPath", (e3) => {
            zg.load(e3, (e4) => {
              const t2 = Og(e4.scenes, true, true);
              for (const i2 of t2)
                for (const e5 of i2) {
                  if ("__foliage_leaf" === e5.material.name) {
                    const t3 = Lg.fromMaterial(e5.material);
                    t3.setCommonUniforms(this.engine.rendering.uniforms), e5.material = t3;
                  }
                  e5.castShadow = true, e5.receiveShadow = true;
                }
              this._tree.setLODMeshes(t2);
            });
          }), this.group = new vs();
          const e2 = this._tree = new Tg();
          this.updateTreeModelPath($o("assets/models/tree/tree18.glb")), this.group.add(e2);
        }
        set treeModelPath(e2) {
          this.updateTreeModelPath(e2);
        }
        set treeEnabled(e2) {
          this._treeEnabled = e2, this._configVersion++, this.refreshTiles();
        }
        get treeEnabled() {
          return this._treeEnabled;
        }
        set labelEnabled(e2) {
          this._labelEnabled = e2, this._configVersion++, this.refreshTiles();
        }
        get labelEnabled() {
          return this._labelEnabled;
        }
        set idEnabled(e2) {
          this._idEnabled = e2, this._configVersion++, this.refreshTiles();
        }
        get idEnabled() {
          return this._idEnabled;
        }
        set dataTypeEnabled(e2) {
          this._dataTypeEnabled = e2, this._configVersion++, this.refreshTiles();
        }
        get dataTypeEnabled() {
          return this._dataTypeEnabled;
        }
      }
      class kg {
        constructor() {
          __publicField(this, "_configVersion", 0), __publicField(this, "_deletedIds", /* @__PURE__ */ new Set()), __publicField(this, "_needsRefreshAll", false), __publicField(this, "updateEditableAttribute", (e2) => {
            const t2 = e2.cached.scene, i2 = t2.children, n2 = t2.batchTable && t2.batchTable.header;
            if (!n2)
              return;
            const r2 = n2.id;
            if (!r2)
              return;
            const s2 = this._deletedIds;
            for (const a2 of i2) {
              const e3 = a2.geometry, t3 = e3.getAttribute("_batchid");
              if (!t3)
                continue;
              const i3 = t3.data.count;
              let o2 = -1, l2 = 0;
              const h2 = [];
              for (let a3 = 0; a3 < i3; a3++)
                o2 = t3.getX(a3), l2 = r2[o2] + "", s2.has(l2) || this.shouldBeHidden(n2, o2) ? h2.push(1) : h2.push(0);
              e3.attributes._tileEditableValue = new qt(new Float32Array(h2), 1);
            }
          }), __publicField(this, "shouldBeHidden", (e2, t2) => false), __publicField(this, "onTileLoad", (e2, t2) => {
            e2.__editableConfigVersion = 0;
          }), __publicField(this, "onTileDispose", (e2, t2) => {
          }), __publicField(this, "onTileShow", (e2) => {
            this.refreshTile(e2);
          }), __publicField(this, "onTileHide", (e2) => {
          }), __publicField(this, "refreshTile", (e2) => {
            e2.cached.scene.children, e2.__editableConfigVersion !== this._configVersion && (this.updateEditableAttribute(e2), e2.__editableConfigVersion = this._configVersion);
          }), __publicField(this, "refreshTiles", () => {
            this._needsRefreshAll && this.tilesRenderer.forEachLoadedModel((e2, t2) => {
              t2.__visible && this.refreshTile(t2);
            });
          });
        }
        addDeletedId(e2) {
          e2 += "", this._deletedIds.add(e2), this._configVersion++, this._needsRefreshAll = true, this.engine.requestRender();
        }
        addDeletedIds(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2] + "";
            this._deletedIds.add(i2);
          }
          this._configVersion++, this._needsRefreshAll = true, this.engine.requestRender();
        }
        removeDeletedId(e2) {
          e2 += "", this._deletedIds.delete(e2), this._configVersion++, this._needsRefreshAll = true, this.engine.requestRender();
        }
        removeDeletedIds(e2) {
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2] + "";
            this._deletedIds.delete(i2);
          }
          this._configVersion++, this._needsRefreshAll = true, this.engine.requestRender();
        }
        hasDeletedId(e2) {
          return this._deletedIds.has(e2);
        }
        requestUpdate() {
          this._configVersion++, this._needsRefreshAll = true, this.engine.requestRender();
        }
      }
      class Bg {
        constructor(e2) {
          __publicField(this, "_parent", null), __publicField(this, "_material", null), __publicField(this, "subscribedDataTypeIds", []), __publicField(this, "_positionScaleFactor", 1.3), __publicField(this, "_tileObjectMap", /* @__PURE__ */ new Map()), __publicField(this, "_idObjectMap", /* @__PURE__ */ new Map()), __publicField(this, "_objectDataMap", /* @__PURE__ */ new Map()), __publicField(this, "_visibleIdMap", /* @__PURE__ */ new Map()), __publicField(this, "_scaleSize", 0.05), __publicField(this, "_tickInterval", 500), __publicField(this, "_lastTickTime", 0), this._parent = e2;
        }
        set parent(e2) {
          this._parent = e2;
        }
        createMeshFromGeometry(e2) {
          return this._material || (this._material = new jt({ color: 16777130 }), this._material.emissive = new ge(16777130)), new Mi(e2, this._material);
        }
        addTileElementObjects(e2, t2) {
          const i2 = e2.cached.scene, n2 = [];
          for (const r2 of t2) {
            const t3 = this.createMeshFromGeometry(r2.geometry, r2);
            t3.userData.id = r2.id;
            const s2 = r2.geometry.getAttribute("position").array, a2 = r2.geometry.getAttribute("normal").array;
            for (let e3 = 0, i3 = s2.length - 2; e3 < i3; e3 += 3)
              s2[e3] = s2[e3] + this._scaleSize * a2[e3], s2[e3 + 1] = s2[e3 + 1] + this._scaleSize * a2[e3 + 1], s2[e3 + 2] = s2[e3 + 2] + this._scaleSize * a2[e3 + 2];
            t3.position.copy(i2.position), t3.rotation.copy(i2.rotation), t3.scale.copy(i2.scale), t3.__tile = e2, n2.push(t3), this._objectDataMap.set(t3, r2);
          }
          this._tileObjectMap.set(e2, n2);
        }
        onEntityShow(e2, t2) {
        }
        showTileElementObjects(e2) {
          const t2 = this._tileObjectMap.get(e2);
          if (t2)
            for (const i2 of t2) {
              const e3 = i2.userData.id;
              this._visibleIdMap.set(e3, i2), this.onEntityShow(e3, i2), this._parent.add(i2);
            }
        }
        hideTileElementObjects(e2) {
          const t2 = this._tileObjectMap.get(e2);
          if (t2)
            for (const i2 of t2) {
              const e3 = i2.userData.id;
              this._visibleIdMap.get(e3) === i2 && this._visibleIdMap.delete(e3), this._parent.remove(i2);
            }
        }
        disposeTileElementObjects(e2) {
          const t2 = this._tileObjectMap.get(e2);
          if (t2) {
            for (const e3 of t2)
              e3.parent && e3.parent.remove(e3), this._objectDataMap.delete(e3), e3.geometry.dispose();
            this._tileObjectMap.delete(e2);
          }
        }
        doTick(e2) {
          for (const t2 of this._visibleIdMap.keys()) {
            const i2 = this._visibleIdMap.get(t2);
            this.tickObject(i2, e2);
          }
        }
        tickObject(e2, t2) {
        }
        tick(e2) {
          this._tickInterval <= 0 || e2 - this._lastTickTime > this._tickInterval && (this._lastTickTime = e2, this.doTick(e2));
        }
        dispose() {
          this._material && this._material.dispose(), this._tileObjectMap.forEach((e2, t2) => {
            for (const i2 of e2)
              this._parent.remove(i2);
          });
        }
      }
      class Vg extends Rt {
        constructor(e2) {
          super(), this.geometry = e2;
          const t2 = this.material = new jt({ color: 16777130 });
          t2.emissive = new ge(16777130);
          const i2 = this.mesh = new Mi(e2, t2);
          this.add(i2);
        }
        set color(e2) {
          e2.isColor || (e2 = new ge(e2)), this.material.color = e2, this.material.emissive = e2;
        }
        get color() {
          return this.material.color;
        }
      }
      const Gg = new qa(), Hg = Gg.load($o("assets/textures/element/traffic_light_mask.jpg"));
      Hg.flipY = false, Hg.magFilter = Hg.minFilter = u;
      const jg = Gg.load($o("assets/textures/element/traffic_light_number_mask.jpg"));
      jg.flipY = false, jg.magFilter = jg.minFilter = u;
      const Wg = Ci.merge([Xi.fog, xh, { spriteCount: { value: 16 }, slotCount: { value: 3 }, slotSpriteOffset0: { value: 0 }, slotSpriteOffset1: { value: 0 }, slotSpriteOffset2: { value: 0 }, slotSpriteOffset3: { value: 0 }, slotState0: { value: 0 }, slotState1: { value: 0 }, slotState2: { value: 0 }, slotState3: { value: 0 }, maskMap: { value: null }, numberMaskMap: { value: null }, number: 0, redColor: { value: [1, 0.1, 0.1] }, greenColor: { value: [0.1, 1, 0.1] }, yellowColor: { value: [1, 0.6, 0.1] } }]);
      class Xg extends yc {
        constructor(e2 = {}) {
          super(), this.type = "TrafficLightMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() { \n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#include <logdepthbuf_pars_fragment>\nuniform sampler2D maskMap;\nuniform sampler2D numberMaskMap;\nuniform float spriteCount;\n\n// 最多4个槽位，\nuniform float slotCount;\n// 每个槽位图标的偏移位置， -1代表当前槽位是倒数读秒数\nuniform float slotSpriteOffset0;\nuniform float slotSpriteOffset1;\nuniform float slotSpriteOffset2;\nuniform float slotSpriteOffset3;\n\n// 每个slot的状态，0，1，2，3 分别代表关、红、黄、绿，后续考虑合并到一个变量中\nuniform float slotState0;\nuniform float slotState1;\nuniform float slotState2;\nuniform float slotState3;\n\nuniform float number;\nvarying vec2 vUv;\n\nuniform vec3 redColor;\nuniform vec3 greenColor;\nuniform vec3 yellowColor;\n\n//#include <mvt_mrt_output_pars_fragment>\n\nvoid main() {\n\n    // 当前像素落在哪个槽位\n    float slotIndex = floor(vUv.y * slotCount);\n    float currentSlotState = 0.0;\n    float spriteIndex = 0.0;\n    if (slotIndex == 0.0) {\n        currentSlotState = slotState0;\n        spriteIndex = slotSpriteOffset0;\n    }\n    else if (slotIndex == 1.0) {\n        currentSlotState = slotState1;\n        spriteIndex = slotSpriteOffset1;\n    }\n    else if (slotIndex == 2.0) {\n        currentSlotState = slotState2;\n        spriteIndex = slotSpriteOffset2;\n    }\n    else if (slotIndex == 3.0) {\n        currentSlotState = slotState3;\n        spriteIndex = slotSpriteOffset3;\n    }\n    if (currentSlotState == 0.0) {\n        discard;\n    }\n    vec3 outColor;\n    if (currentSlotState == 1.0) {\n        outColor = redColor;\n    }\n    else if (currentSlotState == 2.0) {\n        outColor = yellowColor;\n    }\n    else if (currentSlotState == 3.0) {\n        outColor = greenColor;\n    }\n    //float slotRatio = 1.0 / spriteCount;\n    // 将高亮区域的v缩放到0-1\n    float v = (vUv.y - float(slotIndex) / slotCount) * slotCount;\n    // v = v * 0.98 + 0.01;\n\n    float u = 0.0;\n    float spriteUnit = 1.0 / spriteCount;\n\n    // 数字\n    if (spriteIndex == -1.0) {\n        // gl_FragColor = vec4(1.0, 0, 0, 1.0);\n        float i1 = floor((number + 0.001) / 10.0);\n        float i2 = floor(mod(number, 10.0));\n        if (vUv.x < 0.5) {\n            u = mix(i1 * 0.1, i1 * 0.1 + 0.1, vUv.x * 2.0);\n        }\n        else {\n            u = mix(i2 * 0.1, i2 * 0.1 + 0.1, (vUv.x - 0.5) * 2.0);\n        }\n        float r = texture2D(numberMaskMap, vec2(u, v)).r;\n        if (r < 0.05) {\n            discard;\n        }\n    }\n    else {\n        u = mix(spriteIndex * spriteUnit, (spriteIndex + 1.0) * spriteUnit, vUv.x);\n        float r = texture2D(maskMap, vec2(u, v)).r;\n        if (r < 0.05) {\n            discard;\n        }\n    }\n    \n    // gl_FragColor = vec4(texture2D(maskMap, vec2(u, v)).xyz, 1.0);\n    gl_FragColor = vec4(outColor, 1.0);\n    #include <logdepthbuf_fragment> \n	//#include <mvt_mrt_output_fragment>\n}", this.isTrafficLightMaterial = true, this.transparent = true, Object.assign(this.uniforms, Ci.clone(Wg)), Mh(this, ["slotState0", "slotState1", "slotState2", "slotState3", "number", "redColor", "greenColor", "yellowColor"]), Ah(this), Object.defineProperties(this, { slotConfig: { get: function() {
            return this._slotConfig;
          }, set: function(e3) {
            this._slotConfig = e3, this.uniforms.slotCount.value = e3.length, this.uniforms.slotSpriteOffset0.value = e3[0], this.uniforms.slotSpriteOffset1.value = e3[1] || 0, this.uniforms.slotSpriteOffset2.value = e3[2] || 0, this.uniforms.slotSpriteOffset3.value = e3[3] || 0;
          } } }), this.uniforms.maskMap.value = Hg, this.uniforms.numberMaskMap.value = jg, this.emissiveEnabled = true, this.emissiveIntensity = 0.8, this.setValues(e2);
        }
        dispose() {
          this.uniforms.maskMap && this.uniforms.maskMap.value && this.uniforms.maskMap.value.dispose(), this.uniforms.numberMaskMap && this.uniforms.numberMaskMap.value && this.uniforms.numberMaskMap.value.dispose(), super.dispose();
        }
      }
      class qg extends Rt {
        constructor(e2) {
          super(), __publicField(this, "isMesh", true), __publicField(this, "_slots", []), __publicField(this, "_slotCount", 3), __publicField(this, "_numberSlot", -1), __publicField(this, "_timeTable", null), __publicField(this, "_channelCount", 3), this.geometry = e2, this.material = new Xg(), this.number = 0;
        }
        set slots(e2) {
          this._slots = e2, this._slotCount = e2.length;
          let t2 = -1, i2 = 0;
          for (let n2 = 0, r2 = e2.length; n2 < r2; n2++)
            -1 === e2[n2] ? t2 = n2 : i2++;
          this._numberSlot = t2, this._channelCount = i2, this.material.slotConfig = e2;
        }
        get slots() {
          return this._slots;
        }
        get slotCount() {
          return this._slotCount;
        }
        get numberSlot() {
          return this._numberSlot;
        }
        get number() {
          return this._number;
        }
        set number(e2) {
          this._number = e2, this.material.number = e2;
        }
        set timeTable(e2) {
          this._number = 0, this._lightState = 0, this._timeTable = e2;
        }
        get timeTable() {
          return this.timeTable;
        }
        set lightState(e2) {
          this._lightState = e2;
        }
        get lightState() {
          return this._lightState;
        }
        updateState(e2) {
          if (this._timeTable) {
            const t2 = this._timeTable, i2 = (e2 / 1e3 - t2.startTime) % t2.period;
            for (let e3 = t2.states.length - 1, n2 = e3; n2 >= 0; --n2)
              if (t2.states[n2][0] <= i2) {
                this._lightState = t2.states[n2][1], this._number = (n2 === e3 ? t2.period : t2.states[n2 + 1][0]) - i2 + 1;
                break;
              }
            this._active = true, this.updateMaterial();
          } else
            void 0 !== this._lightState && null !== this._lightState ? (this._active = true, this.updateMaterial()) : this._active && (this.updateMaterial(), this._active = false);
        }
        updateMaterial() {
          const e2 = this.material;
          3 === this._channelCount ? (e2.slotState0 = 1 === this._lightState ? 1 : 0, e2.slotState1 = 2 === this._lightState ? 2 : 0, e2.slotState2 = 3 === this._lightState ? 3 : 0, -1 !== this._numberSlot && (e2.number = this._number, e2.slotState3 = this._lightState)) : 2 === this._channelCount ? (e2.slotState0 = 1 === this._lightState ? 1 : 0, e2.slotState1 = 3 === this._lightState ? 3 : 0, -1 !== this._numberSlot && (e2.number = this._number, e2.slotState2 = this._lightState)) : 1 === this._channelCount ? (e2.slotState0 = this._lightState, -1 !== this._numberSlot && (e2.number = this._number, e2.slotState1 = this._lightState)) : 0 === this._channelCount ? -1 !== this._numberSlot && (e2.number = this._number, e2.slotState0 = this._lightState) : console.warn("invalid channel count:", this._channelCount);
        }
      }
      const Yg = new qg();
      const Zg = {}, Jg = { up: { south: "east", north: "west", west: "south", east: "north" }, down: { south: "west", north: "east", west: "north", east: "south" }, south: { up: "west", down: "east", west: "down", east: "up" }, north: { up: "east", down: "west", west: "up", east: "down" }, west: { up: "north", down: "south", north: "down", south: "up" }, east: { up: "south", down: "north", north: "up", south: "down" } };
      let Kg = { north: [-1, 0, 0], east: [0, 1, 0], up: [0, 0, 1], south: [1, 0, 0], west: [0, -1, 0], down: [0, 0, -1] }, Qg = {}, $g = { east: new Ae(), north: new Ae(), up: new Ae(), west: new Ae(), south: new Ae(), down: new Ae() }, e_ = new Ae(), t_ = new Ae(), i_ = new Ae();
      const n_ = (e2) => void 0 !== e2, r_ = new Ae(), s_ = new Ae(1 / 40680631590769, 1 / 40680631590769, 1 / 40408299984661445e-3), a_ = new Ae(), o_ = new Ae(), l_ = function(e2, t2, i2 = 0, n2) {
        const r2 = new Ae(40680631590769, 40680631590769, 40408299984661445e-3), s2 = Math.cos(t2);
        a_.x = s2 * Math.cos(e2), a_.y = s2 * Math.sin(e2), a_.z = Math.sin(t2), a_.normalize(), o_.multiplyVectors(r2, a_);
        const a2 = Math.sqrt(a_.dot(o_));
        return o_.divideScalar(a2), a_.multiplyScalar(i2), n_(n2) || (n2 = new Ae()), n2.addVectors(o_, a_);
      };
      Zg.lnglatToEcef = (e2, t2, i2 = 0, n2) => l_(e2 * Math.PI / 180, t2 * Math.PI / 180, i2, n2), Zg.radianToEcef = l_, Zg.localFrameToFixedFrameGenerator = function(e2, t2) {
        if (!Jg.hasOwnProperty(e2) || !Jg[e2].hasOwnProperty(t2))
          throw new Error("firstAxis and secondAxis must be east, north, up, west, south or down.");
        let i2, n2 = Jg[e2][t2], r2 = e2 + t2;
        return n_(Qg[r2]) ? i2 = Qg[r2] : (i2 = function(i3, r3) {
          if (!n_(i3))
            throw new Error("origin is required.");
          if (n_(r3) || (r3 = new st()), i3.equals(r_))
            e_.fromArray(Kg[e2]), t_.fromArray(Kg[t2]), i_.fromArray(Kg[n2]);
          else if (Math.abs(i3.x) < 1e-14 && Math.abs(i3.y) < 1e-14) {
            let r4 = 0 == (s2 = +(s2 = i3.z)) ? s2 : s2 > 0 ? 1 : -1;
            e_.fromArray(Kg[e2]), "east" !== e2 && "west" !== e2 && e_.multiplyScalar(r4), t_.fromArray(Kg[t2]), "east" !== t2 && "west" !== t2 && t_.multiplyScalar(r4), i_.fromArray(Kg[n2]), "east" !== n2 && "west" !== n2 && i_.multiplyScalar(r4);
          } else {
            ((e3, t3) => {
              t3.multiplyVectors(e3, s_).normalize();
            })(i3, $g.up);
            let r4 = $g.up, s3 = $g.east;
            s3.x = -i3.y, s3.y = i3.x, s3.z = 0, $g.east.copy(s3).normalize(), $g.north.crossVectors(r4, s3), $g.down.copy($g.up).multiplyScalar(-1), $g.west.copy($g.east).multiplyScalar(-1), $g.south.copy($g.north).multiplyScalar(-1), e_ = $g[e2], t_ = $g[t2], i_ = $g[n2];
          }
          var s2;
          const a2 = r3.elements;
          return a2[0] = e_.x, a2[1] = e_.y, a2[2] = e_.z, a2[3] = 0, a2[4] = t_.x, a2[5] = t_.y, a2[6] = t_.z, a2[7] = 0, a2[8] = i_.x, a2[9] = i_.y, a2[10] = i_.z, a2[11] = 0, a2[12] = i3.x, a2[13] = i3.y, a2[14] = i3.z, a2[15] = 1, r3;
        }, Qg[r2] = i2), i2;
      }, Zg.eastNorthUpToFixedFrame = Zg.localFrameToFixedFrameGenerator("east", "north"), Zg.northEastDownToFixedFrame = Zg.localFrameToFixedFrameGenerator("north", "east"), Zg.northUpEastToFixedFrame = Zg.localFrameToFixedFrameGenerator("north", "up"), Zg.northWestUpToFixedFrame = Zg.localFrameToFixedFrameGenerator("north", "west"), mg.prototype.setTileVisible = function(e2, t2) {
        const i2 = e2.cached.scene, n2 = this.visibleTiles, r2 = this.group;
        t2 ? (r2.add(i2), n2.add(e2), i2.updateMatrixWorld(true)) : (r2.remove(i2), n2.delete(e2)), this.onTileVisibleChanged && this.onTileVisibleChanged(e2, t2);
      };
      class h_ {
        constructor() {
          __publicField(this, "_materrialMap", /* @__PURE__ */ new Map()), __publicField(this, "_inited", false);
        }
        init() {
          this._inited || (this.onInit(), this._inited = true);
        }
        onInit() {
        }
        getMaterialByKey(e2) {
          return this._materrialMap.get(e2);
        }
        dispose() {
          this.beforeDispose();
          for (const e2 of Object.keys(this._materrialMap)) {
            this._materrialMap[e2].dispose();
          }
        }
        beforeDispose() {
        }
      }
      const c_ = new qa().load($o("assets/textures/water/waternormal.jpg"));
      c_.wrapS = c_.wrapT = l;
      const u_ = Ci.merge([Xi.fog, { normalMap: { value: null }, alpha: { value: 1 }, time: { value: 0 }, size: { value: 10 }, distortionScale: { value: 2 }, textureMatrix: { value: new st() }, sunColor: { value: new ge(16777215) }, sunDirection: { value: new Ae(0.70707, 0.70707, 0) }, eye: { value: new Ae() }, waterColor: { value: new ge(8956603) }, reflectionColor: { value: new ge(8956603) }, envMap: { value: null }, mvt_normalMatrix: { value: new ne() } }]);
      class d_ extends yc {
        constructor(e2 = {}) {
          super(), __publicField(this, "_timeScaleFactor", 1e-4), this.type = "WaterMaterial", this.vertexShader = "#define GLSLIFY 1\nuniform mat4 textureMatrix;\nuniform float time;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    mirrorCoord = modelMatrix * vec4(position, 1.0);\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n}", this.fragmentShader = "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n// uniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalMap;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\n#ifdef USE_ENVMAP\n    uniform sampler2D envMap;\n#else\n    uniform vec3 reflectionColor;\n#endif\nuniform mat3 mvt_normalMatrix;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nvec4 getNoise(vec2 uv) {\n    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);\n    vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);\n    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\n    vec4 noise = texture2D(normalMap, uv0) +\n        texture2D(normalMap, uv1) +\n        texture2D(normalMap, uv2) +\n        texture2D(normalMap, uv3);\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {\n    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));\n    float direction = max(0.0, dot(eyeDirection, reflection));\n    specularColor += pow(direction, shiny) * sunColor * spec;\n    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;\n}\n\n#define ENVMAP_TYPE_CUBE_UV\n\n#include <common>\n#include <packing>\n\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\n#include <cube_uv_reflection_fragment>\n\n#define MVT_FRAG_REFLECTION_FACTOR\n#define MVT_FRAG_NORMAL\n\nvoid main() {\n\n	#include <logdepthbuf_fragment>\n    vec4 noise = getNoise(worldPosition.xy * size);\n    vec3 surfaceNormal = normalize(noise.xyz * vec3(1.5, 1.5, 1.0));\n\n    vec3 diffuseLight = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n\n    vec3 worldToEye = cameraPosition - worldPosition.xyz;\n    vec3 eyeDirection = normalize(worldToEye);\n    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);\n\n    float distance = length(worldToEye);\n\n    vec2 distortion = surfaceNormal.xy * (0.001 + 1.0 / distance) * distortionScale;\n    // vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion));\n    vec3 reflectDir = reflect(vec3(-worldToEye.x, -worldToEye.y, -worldToEye.z), vec3(0.0, 0.0, 1.0));\n    reflectDir.xy += distortion;\n\n    #ifdef USE_ENVMAP\n        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;\n    #else\n        vec3 reflectionSample = reflectionColor;\n    #endif\n\n    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);\n    float rf0 = 0.3;\n    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);\n    vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;\n    vec3 albedo = mix((sunColor * diffuseLight * 0.3 + scatter) * getShadowMask(), (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);\n    vec3 outgoingLight = albedo;\n    gl_FragColor = vec4(outgoingLight, alpha);\n    float mvt_frag_reflectionFactor = 1.0;\n    // vec3 mvt_frag_normal = vec3(0., 0., 1.0) * mvt_normalMatrix;\n    vec3 mvt_frag_normal = normalize(noise.xyz * vec3(0.2, 0.2, 1.0)) * mvt_normalMatrix;\n    // gl_FragColor = worldPosition;\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n}", this.isWaterMaterial = true, Object.assign(this.uniforms, Ci.clone(u_)), this.defines = { CUBEUV_TEXEL_WIDTH: 3255208333333333e-19, CUBEUV_TEXEL_HEIGHT: 244140625e-12, CUBEUV_MAX_MIP: "10.0" }, Mh(this, ["sunColor", "waterColor", "reflectionColor", "size", "alpha", "distortionScale"]), Object.defineProperties(this, {}), this.uniforms.normalMap.value = c_, this.setValues(e2);
        }
        onBeforeSceneRender(e2, t2, i2) {
          if (this.uniforms.eye.value.copy(i2.position), this.uniforms.time.value = e2.rendering.uniforms.elapsedTime.value * this._timeScaleFactor, this.uniforms.envMap.value !== t2.environment) {
            this.uniforms.envMap.value = t2.environment;
            const e3 = Ph(t2.environment);
            e3 && (this.defines.CUBEUV_TEXEL_WIDTH = e3.texelWidth, this.defines.CUBEUV_TEXEL_HEIGHT = e3.texelHeight, this.defines.CUBEUV_MAX_MIP = e3.maxMip + ".0"), t2.environment ? this.defines.USE_ENVMAP = true : delete this.defines.USE_ENVMAP;
          }
          this.uniforms.mvt_normalMatrix.value.getNormalMatrix(i2.matrixWorld);
          const n2 = e2.rendering.sky;
          n2 && this.uniforms.sunDirection.value.copy(n2.sunDirection);
        }
        get timeScaleFactor() {
          return this._timeScaleFactor;
        }
        set timeScaleFactor(e2) {
          this._timeScaleFactor = e2;
        }
        dispose() {
          let e2 = ["envMap", "normalMap"];
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this.uniforms[i2] && this.uniforms[i2].value && this.uniforms[i2].value.dispose();
          }
          super.dispose();
        }
      }
      const p_ = new qa(), m_ = new ge(16777215);
      class f_ extends Ai {
        constructor(e2) {
          super(), this.fragmentShader = "#define GLSLIFY 1\n#include <common>\nvarying vec3 vIdColor;\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    gl_FragColor = vec4(vIdColor.xyz, 1.0);\n\n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n#ifdef MVT_TYPE_DATATYPE\nattribute float _dataType;\n#else \nattribute float _id;\n#endif\n\nvarying vec3 vIdColor;\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #ifdef MVT_TYPE_DATATYPE\n         float value = _dataType * 0.2536789535;\n         vIdColor = vec3(mod(value, 0.1) * 9.0, mod(value, 0.01) * 90.0, mod(value, 0.001) * 900.0);\n        // vIdColor = vec3(mod(_dataType * 0.2, 0.7), mod(1.0 - mod(_dataType * 0.835, 1.0), 0.4) + 0.4, mod(_dataType * 0.57245, 0.2) + 0.2);\n    #else \n        float value = (_id + 9.3234242) * 0.2536789535;\n         vIdColor = vec3(mod(value, 0.1) * 10.0, mod(value, 0.01) * 100.0, mod(value, 0.001) * 1000.0);\n        // vIdColor = vec3(mod(_id * 0.2, 0.7), mod(1.0 - mod(_id * 0.835, 1.0), 0.7), mod(_id * 0.57245, 0.5));\n    #endif\n    \n    #include <logdepthbuf_vertex>\n}", this.defines = { MVT_TYPE_ID: true }, this.type = 1, this.setValues(e2);
        }
        set type(e2) {
          1 === e2 ? (this.defines.MVT_TYPE_ID = true, delete this.defines.MVT_TYPE_DATATYPE) : 2 === e2 && (this.defines.MVT_TYPE_DATATYPE = true, delete this.defines.MVT_TYPE_ID), this.needsUpdate = true;
        }
        get type() {
          return this.defines.MVT_TYPE_DATATYPE ? 2 : 1;
        }
      }
      const g_ = class extends fc {
        constructor(e2) {
          super(e2), __publicField(this, "_geoDataType"), __publicField(this, "_geoFeatures", []), __publicField(this, "_geoIndexMap", []), this.type = "GeoJSONDataSource";
        }
        getOriginDataIndex(e2) {
          return e2 < this._templateDataLength ? this._geoIndexMap[e2] : [e2 - this._templateDataLength + this._geoFeatures.length, 0];
        }
        getOriginData(e2) {
          if (e2 < this._templateDataLength) {
            const t2 = this._geoIndexMap[e2];
            return this._geoFeatures[t2[0]];
          }
          return this._addCache[e2 - this._templateDataLength];
        }
        async _getFetchData(e2) {
          return await e2.json();
        }
        onClear() {
          this._geoDataType = void 0, this._geoFeatures = [];
        }
        _onProcessTemplateData(e2, t2) {
          return this._prepareFeatures(), this._parseFeatures(e2, t2), e2;
        }
        _parseFeatures(e2, t2) {
          let i2 = 0;
          for (let n2 = 0; n2 < this._geoFeatures.length; n2++) {
            const r2 = this._geoFeatures[n2], s2 = this._onDecomposeFeature(this._geoDataType, r2);
            for (let a2 = 0; a2 < s2.length; a2++) {
              const r3 = s2[a2];
              e2.position.push(r3.geometry[this.projectionName]), a2 > 0 && i2++, e2.index.push(n2 + i2), this._geoIndexMap[n2 + i2] = [n2, a2];
              let o2 = { position: r3.geometry[this.projectionName], index: n2 + i2 };
              for (const t3 of this._attributeMap.keys()) {
                let i3;
                r3.properties && void 0 !== r3.properties[this._attributeMap.get(t3)] && null !== r3.properties[this._attributeMap.get(t3)] ? i3 = r3.properties[this._attributeMap.get(t3)] : this._attributeMap.get(t3) instanceof Function && (i3 = this._attributeMap.get(t3)(r3.properties)), e2[t3].push(i3), o2[t3] = i3;
              }
              t2.push(o2);
            }
          }
        }
        _prepareFeatures() {
          var e2, t2;
          this._geoFeatures = $h(this._origin, this.projectionName), this._geoDataType = super._getDataType(null == (t2 = null == (e2 = this._geoFeatures[0]) ? void 0 : e2.geometry) ? void 0 : t2.type);
        }
        get geoDataType() {
          return this._geoDataType;
        }
      };
      let __ = g_;
      __publicField(__, "fromGeoJSON", async function(e2) {
        let t2 = new g_();
        return await t2.load(e2), t2;
      }), __publicField(__, "fromUrl", async function(e2) {
        let t2 = new g_();
        return await t2.load(e2), t2;
      }), __publicField(__, "fromGeoJSONObject", function(e2) {
        let t2 = new g_();
        return t2.setData(e2), t2;
      }), __publicField(__, "fromObject", function(e2) {
        let t2 = new g_();
        return t2.setData(e2), t2;
      });
      var v_ = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, x_ = [], y_ = [], b_ = "undefined" != typeof Uint8Array ? Uint8Array : Array, M_ = false;
      function S_() {
        M_ = true;
        for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, i2 = e2.length; t2 < i2; ++t2)
          x_[t2] = e2[t2], y_[e2.charCodeAt(t2)] = t2;
        y_["-".charCodeAt(0)] = 62, y_["_".charCodeAt(0)] = 63;
      }
      function w_(e2, t2, i2) {
        for (var n2, r2, s2 = [], a2 = t2; a2 < i2; a2 += 3)
          n2 = (e2[a2] << 16) + (e2[a2 + 1] << 8) + e2[a2 + 2], s2.push(x_[(r2 = n2) >> 18 & 63] + x_[r2 >> 12 & 63] + x_[r2 >> 6 & 63] + x_[63 & r2]);
        return s2.join("");
      }
      function T_(e2) {
        var t2;
        M_ || S_();
        for (var i2 = e2.length, n2 = i2 % 3, r2 = "", s2 = [], a2 = 16383, o2 = 0, l2 = i2 - n2; o2 < l2; o2 += a2)
          s2.push(w_(e2, o2, o2 + a2 > l2 ? l2 : o2 + a2));
        return 1 === n2 ? (t2 = e2[i2 - 1], r2 += x_[t2 >> 2], r2 += x_[t2 << 4 & 63], r2 += "==") : 2 === n2 && (t2 = (e2[i2 - 2] << 8) + e2[i2 - 1], r2 += x_[t2 >> 10], r2 += x_[t2 >> 4 & 63], r2 += x_[t2 << 2 & 63], r2 += "="), s2.push(r2), s2.join("");
      }
      function E_(e2, t2, i2, n2, r2) {
        var s2, a2, o2 = 8 * r2 - n2 - 1, l2 = (1 << o2) - 1, h2 = l2 >> 1, c2 = -7, u2 = i2 ? r2 - 1 : 0, d2 = i2 ? -1 : 1, p2 = e2[t2 + u2];
        for (u2 += d2, s2 = p2 & (1 << -c2) - 1, p2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + e2[t2 + u2], u2 += d2, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + e2[t2 + u2], u2 += d2, c2 -= 8)
          ;
        if (0 === s2)
          s2 = 1 - h2;
        else {
          if (s2 === l2)
            return a2 ? NaN : 1 / 0 * (p2 ? -1 : 1);
          a2 += Math.pow(2, n2), s2 -= h2;
        }
        return (p2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
      }
      function C_(e2, t2, i2, n2, r2, s2) {
        var a2, o2, l2, h2 = 8 * s2 - r2 - 1, c2 = (1 << h2) - 1, u2 = c2 >> 1, d2 = 23 === r2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n2 ? 0 : s2 - 1, m2 = n2 ? 1 : -1, f2 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
        for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (o2 = isNaN(t2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (t2 += a2 + u2 >= 1 ? d2 / l2 : d2 * Math.pow(2, 1 - u2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + u2 >= c2 ? (o2 = 0, a2 = c2) : a2 + u2 >= 1 ? (o2 = (t2 * l2 - 1) * Math.pow(2, r2), a2 += u2) : (o2 = t2 * Math.pow(2, u2 - 1) * Math.pow(2, r2), a2 = 0)); r2 >= 8; e2[i2 + p2] = 255 & o2, p2 += m2, o2 /= 256, r2 -= 8)
          ;
        for (a2 = a2 << r2 | o2, h2 += r2; h2 > 0; e2[i2 + p2] = 255 & a2, p2 += m2, a2 /= 256, h2 -= 8)
          ;
        e2[i2 + p2 - m2] |= 128 * f2;
      }
      var A_ = {}.toString, P_ = Array.isArray || function(e2) {
        return "[object Array]" == A_.call(e2);
      };
      function R_() {
        return I_.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function L_(e2, t2) {
        if (R_() < t2)
          throw new RangeError("Invalid typed array length");
        return I_.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t2)).__proto__ = I_.prototype : (null === e2 && (e2 = new I_(t2)), e2.length = t2), e2;
      }
      function I_(e2, t2, i2) {
        if (!(I_.TYPED_ARRAY_SUPPORT || this instanceof I_))
          return new I_(e2, t2, i2);
        if ("number" == typeof e2) {
          if ("string" == typeof t2)
            throw new Error("If encoding is specified then the first argument must be a string");
          return O_(this, e2);
        }
        return D_(this, e2, t2, i2);
      }
      function D_(e2, t2, i2, n2) {
        if ("number" == typeof t2)
          throw new TypeError('"value" argument must not be a number');
        return "undefined" != typeof ArrayBuffer && t2 instanceof ArrayBuffer ? function(e3, t3, i3, n3) {
          if (t3.byteLength, i3 < 0 || t3.byteLength < i3)
            throw new RangeError("'offset' is out of bounds");
          if (t3.byteLength < i3 + (n3 || 0))
            throw new RangeError("'length' is out of bounds");
          t3 = void 0 === i3 && void 0 === n3 ? new Uint8Array(t3) : void 0 === n3 ? new Uint8Array(t3, i3) : new Uint8Array(t3, i3, n3);
          I_.TYPED_ARRAY_SUPPORT ? (e3 = t3).__proto__ = I_.prototype : e3 = U_(e3, t3);
          return e3;
        }(e2, t2, i2, n2) : "string" == typeof t2 ? function(e3, t3, i3) {
          "string" == typeof i3 && "" !== i3 || (i3 = "utf8");
          if (!I_.isEncoding(i3))
            throw new TypeError('"encoding" must be a valid string encoding');
          var n3 = 0 | k_(t3, i3), r2 = (e3 = L_(e3, n3)).write(t3, i3);
          r2 !== n3 && (e3 = e3.slice(0, r2));
          return e3;
        }(e2, t2, i2) : function(e3, t3) {
          if (N_(t3)) {
            var i3 = 0 | z_(t3.length);
            return 0 === (e3 = L_(e3, i3)).length || t3.copy(e3, 0, 0, i3), e3;
          }
          if (t3) {
            if ("undefined" != typeof ArrayBuffer && t3.buffer instanceof ArrayBuffer || "length" in t3)
              return "number" != typeof t3.length || (n3 = t3.length) != n3 ? L_(e3, 0) : U_(e3, t3);
            if ("Buffer" === t3.type && P_(t3.data))
              return U_(e3, t3.data);
          }
          var n3;
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(e2, t2);
      }
      function F_(e2) {
        if ("number" != typeof e2)
          throw new TypeError('"size" argument must be a number');
        if (e2 < 0)
          throw new RangeError('"size" argument must not be negative');
      }
      function O_(e2, t2) {
        if (F_(t2), e2 = L_(e2, t2 < 0 ? 0 : 0 | z_(t2)), !I_.TYPED_ARRAY_SUPPORT)
          for (var i2 = 0; i2 < t2; ++i2)
            e2[i2] = 0;
        return e2;
      }
      function U_(e2, t2) {
        var i2 = t2.length < 0 ? 0 : 0 | z_(t2.length);
        e2 = L_(e2, i2);
        for (var n2 = 0; n2 < i2; n2 += 1)
          e2[n2] = 255 & t2[n2];
        return e2;
      }
      function z_(e2) {
        if (e2 >= R_())
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + R_().toString(16) + " bytes");
        return 0 | e2;
      }
      function N_(e2) {
        return !(null == e2 || !e2._isBuffer);
      }
      function k_(e2, t2) {
        if (N_(e2))
          return e2.length;
        if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
          return e2.byteLength;
        "string" != typeof e2 && (e2 = "" + e2);
        var i2 = e2.length;
        if (0 === i2)
          return 0;
        for (var n2 = false; ; )
          switch (t2) {
            case "ascii":
            case "latin1":
            case "binary":
              return i2;
            case "utf8":
            case "utf-8":
            case void 0:
              return dv(e2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * i2;
            case "hex":
              return i2 >>> 1;
            case "base64":
              return pv(e2).length;
            default:
              if (n2)
                return dv(e2).length;
              t2 = ("" + t2).toLowerCase(), n2 = true;
          }
      }
      function B_(e2, t2, i2) {
        var n2 = false;
        if ((void 0 === t2 || t2 < 0) && (t2 = 0), t2 > this.length)
          return "";
        if ((void 0 === i2 || i2 > this.length) && (i2 = this.length), i2 <= 0)
          return "";
        if ((i2 >>>= 0) <= (t2 >>>= 0))
          return "";
        for (e2 || (e2 = "utf8"); ; )
          switch (e2) {
            case "hex":
              return tv(this, t2, i2);
            case "utf8":
            case "utf-8":
              return K_(this, t2, i2);
            case "ascii":
              return $_(this, t2, i2);
            case "latin1":
            case "binary":
              return ev(this, t2, i2);
            case "base64":
              return J_(this, t2, i2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return iv(this, t2, i2);
            default:
              if (n2)
                throw new TypeError("Unknown encoding: " + e2);
              e2 = (e2 + "").toLowerCase(), n2 = true;
          }
      }
      function V_(e2, t2, i2) {
        var n2 = e2[t2];
        e2[t2] = e2[i2], e2[i2] = n2;
      }
      function G_(e2, t2, i2, n2, r2) {
        if (0 === e2.length)
          return -1;
        if ("string" == typeof i2 ? (n2 = i2, i2 = 0) : i2 > 2147483647 ? i2 = 2147483647 : i2 < -2147483648 && (i2 = -2147483648), i2 = +i2, isNaN(i2) && (i2 = r2 ? 0 : e2.length - 1), i2 < 0 && (i2 = e2.length + i2), i2 >= e2.length) {
          if (r2)
            return -1;
          i2 = e2.length - 1;
        } else if (i2 < 0) {
          if (!r2)
            return -1;
          i2 = 0;
        }
        if ("string" == typeof t2 && (t2 = I_.from(t2, n2)), N_(t2))
          return 0 === t2.length ? -1 : H_(e2, t2, i2, n2, r2);
        if ("number" == typeof t2)
          return t2 &= 255, I_.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r2 ? Uint8Array.prototype.indexOf.call(e2, t2, i2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, i2) : H_(e2, [t2], i2, n2, r2);
        throw new TypeError("val must be string, number or Buffer");
      }
      function H_(e2, t2, i2, n2, r2) {
        var s2, a2 = 1, o2 = e2.length, l2 = t2.length;
        if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
          if (e2.length < 2 || t2.length < 2)
            return -1;
          a2 = 2, o2 /= 2, l2 /= 2, i2 /= 2;
        }
        function h2(e3, t3) {
          return 1 === a2 ? e3[t3] : e3.readUInt16BE(t3 * a2);
        }
        if (r2) {
          var c2 = -1;
          for (s2 = i2; s2 < o2; s2++)
            if (h2(e2, s2) === h2(t2, -1 === c2 ? 0 : s2 - c2)) {
              if (-1 === c2 && (c2 = s2), s2 - c2 + 1 === l2)
                return c2 * a2;
            } else
              -1 !== c2 && (s2 -= s2 - c2), c2 = -1;
        } else
          for (i2 + l2 > o2 && (i2 = o2 - l2), s2 = i2; s2 >= 0; s2--) {
            for (var u2 = true, d2 = 0; d2 < l2; d2++)
              if (h2(e2, s2 + d2) !== h2(t2, d2)) {
                u2 = false;
                break;
              }
            if (u2)
              return s2;
          }
        return -1;
      }
      function j_(e2, t2, i2, n2) {
        i2 = Number(i2) || 0;
        var r2 = e2.length - i2;
        n2 ? (n2 = Number(n2)) > r2 && (n2 = r2) : n2 = r2;
        var s2 = t2.length;
        if (s2 % 2 != 0)
          throw new TypeError("Invalid hex string");
        n2 > s2 / 2 && (n2 = s2 / 2);
        for (var a2 = 0; a2 < n2; ++a2) {
          var o2 = parseInt(t2.substr(2 * a2, 2), 16);
          if (isNaN(o2))
            return a2;
          e2[i2 + a2] = o2;
        }
        return a2;
      }
      function W_(e2, t2, i2, n2) {
        return mv(dv(t2, e2.length - i2), e2, i2, n2);
      }
      function X_(e2, t2, i2, n2) {
        return mv(function(e3) {
          for (var t3 = [], i3 = 0; i3 < e3.length; ++i3)
            t3.push(255 & e3.charCodeAt(i3));
          return t3;
        }(t2), e2, i2, n2);
      }
      function q_(e2, t2, i2, n2) {
        return X_(e2, t2, i2, n2);
      }
      function Y_(e2, t2, i2, n2) {
        return mv(pv(t2), e2, i2, n2);
      }
      function Z_(e2, t2, i2, n2) {
        return mv(function(e3, t3) {
          for (var i3, n3, r2, s2 = [], a2 = 0; a2 < e3.length && !((t3 -= 2) < 0); ++a2)
            n3 = (i3 = e3.charCodeAt(a2)) >> 8, r2 = i3 % 256, s2.push(r2), s2.push(n3);
          return s2;
        }(t2, e2.length - i2), e2, i2, n2);
      }
      function J_(e2, t2, i2) {
        return 0 === t2 && i2 === e2.length ? T_(e2) : T_(e2.slice(t2, i2));
      }
      function K_(e2, t2, i2) {
        i2 = Math.min(e2.length, i2);
        for (var n2 = [], r2 = t2; r2 < i2; ) {
          var s2, a2, o2, l2, h2 = e2[r2], c2 = null, u2 = h2 > 239 ? 4 : h2 > 223 ? 3 : h2 > 191 ? 2 : 1;
          if (r2 + u2 <= i2)
            switch (u2) {
              case 1:
                h2 < 128 && (c2 = h2);
                break;
              case 2:
                128 == (192 & (s2 = e2[r2 + 1])) && (l2 = (31 & h2) << 6 | 63 & s2) > 127 && (c2 = l2);
                break;
              case 3:
                s2 = e2[r2 + 1], a2 = e2[r2 + 2], 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & h2) << 12 | (63 & s2) << 6 | 63 & a2) > 2047 && (l2 < 55296 || l2 > 57343) && (c2 = l2);
                break;
              case 4:
                s2 = e2[r2 + 1], a2 = e2[r2 + 2], o2 = e2[r2 + 3], 128 == (192 & s2) && 128 == (192 & a2) && 128 == (192 & o2) && (l2 = (15 & h2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) > 65535 && l2 < 1114112 && (c2 = l2);
            }
          null === c2 ? (c2 = 65533, u2 = 1) : c2 > 65535 && (c2 -= 65536, n2.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), n2.push(c2), r2 += u2;
        }
        return function(e3) {
          var t3 = e3.length;
          if (t3 <= Q_)
            return String.fromCharCode.apply(String, e3);
          var i3 = "", n3 = 0;
          for (; n3 < t3; )
            i3 += String.fromCharCode.apply(String, e3.slice(n3, n3 += Q_));
          return i3;
        }(n2);
      }
      I_.TYPED_ARRAY_SUPPORT = void 0 === v_.TYPED_ARRAY_SUPPORT || v_.TYPED_ARRAY_SUPPORT, R_(), I_.poolSize = 8192, I_._augment = function(e2) {
        return e2.__proto__ = I_.prototype, e2;
      }, I_.from = function(e2, t2, i2) {
        return D_(null, e2, t2, i2);
      }, I_.TYPED_ARRAY_SUPPORT && (I_.prototype.__proto__ = Uint8Array.prototype, I_.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && I_[Symbol.species]), I_.alloc = function(e2, t2, i2) {
        return function(e3, t3, i3, n2) {
          return F_(t3), t3 <= 0 ? L_(e3, t3) : void 0 !== i3 ? "string" == typeof n2 ? L_(e3, t3).fill(i3, n2) : L_(e3, t3).fill(i3) : L_(e3, t3);
        }(null, e2, t2, i2);
      }, I_.allocUnsafe = function(e2) {
        return O_(null, e2);
      }, I_.allocUnsafeSlow = function(e2) {
        return O_(null, e2);
      }, I_.isBuffer = fv, I_.compare = function(e2, t2) {
        if (!N_(e2) || !N_(t2))
          throw new TypeError("Arguments must be Buffers");
        if (e2 === t2)
          return 0;
        for (var i2 = e2.length, n2 = t2.length, r2 = 0, s2 = Math.min(i2, n2); r2 < s2; ++r2)
          if (e2[r2] !== t2[r2]) {
            i2 = e2[r2], n2 = t2[r2];
            break;
          }
        return i2 < n2 ? -1 : n2 < i2 ? 1 : 0;
      }, I_.isEncoding = function(e2) {
        switch (String(e2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, I_.concat = function(e2, t2) {
        if (!P_(e2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === e2.length)
          return I_.alloc(0);
        var i2;
        if (void 0 === t2)
          for (t2 = 0, i2 = 0; i2 < e2.length; ++i2)
            t2 += e2[i2].length;
        var n2 = I_.allocUnsafe(t2), r2 = 0;
        for (i2 = 0; i2 < e2.length; ++i2) {
          var s2 = e2[i2];
          if (!N_(s2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          s2.copy(n2, r2), r2 += s2.length;
        }
        return n2;
      }, I_.byteLength = k_, I_.prototype._isBuffer = true, I_.prototype.swap16 = function() {
        var e2 = this.length;
        if (e2 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t2 = 0; t2 < e2; t2 += 2)
          V_(this, t2, t2 + 1);
        return this;
      }, I_.prototype.swap32 = function() {
        var e2 = this.length;
        if (e2 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t2 = 0; t2 < e2; t2 += 4)
          V_(this, t2, t2 + 3), V_(this, t2 + 1, t2 + 2);
        return this;
      }, I_.prototype.swap64 = function() {
        var e2 = this.length;
        if (e2 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t2 = 0; t2 < e2; t2 += 8)
          V_(this, t2, t2 + 7), V_(this, t2 + 1, t2 + 6), V_(this, t2 + 2, t2 + 5), V_(this, t2 + 3, t2 + 4);
        return this;
      }, I_.prototype.toString = function() {
        var e2 = 0 | this.length;
        return 0 === e2 ? "" : 0 === arguments.length ? K_(this, 0, e2) : B_.apply(this, arguments);
      }, I_.prototype.equals = function(e2) {
        if (!N_(e2))
          throw new TypeError("Argument must be a Buffer");
        return this === e2 || 0 === I_.compare(this, e2);
      }, I_.prototype.inspect = function() {
        var e2 = "";
        return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
      }, I_.prototype.compare = function(e2, t2, i2, n2, r2) {
        if (!N_(e2))
          throw new TypeError("Argument must be a Buffer");
        if (void 0 === t2 && (t2 = 0), void 0 === i2 && (i2 = e2 ? e2.length : 0), void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = this.length), t2 < 0 || i2 > e2.length || n2 < 0 || r2 > this.length)
          throw new RangeError("out of range index");
        if (n2 >= r2 && t2 >= i2)
          return 0;
        if (n2 >= r2)
          return -1;
        if (t2 >= i2)
          return 1;
        if (this === e2)
          return 0;
        for (var s2 = (r2 >>>= 0) - (n2 >>>= 0), a2 = (i2 >>>= 0) - (t2 >>>= 0), o2 = Math.min(s2, a2), l2 = this.slice(n2, r2), h2 = e2.slice(t2, i2), c2 = 0; c2 < o2; ++c2)
          if (l2[c2] !== h2[c2]) {
            s2 = l2[c2], a2 = h2[c2];
            break;
          }
        return s2 < a2 ? -1 : a2 < s2 ? 1 : 0;
      }, I_.prototype.includes = function(e2, t2, i2) {
        return -1 !== this.indexOf(e2, t2, i2);
      }, I_.prototype.indexOf = function(e2, t2, i2) {
        return G_(this, e2, t2, i2, true);
      }, I_.prototype.lastIndexOf = function(e2, t2, i2) {
        return G_(this, e2, t2, i2, false);
      }, I_.prototype.write = function(e2, t2, i2, n2) {
        if (void 0 === t2)
          n2 = "utf8", i2 = this.length, t2 = 0;
        else if (void 0 === i2 && "string" == typeof t2)
          n2 = t2, i2 = this.length, t2 = 0;
        else {
          if (!isFinite(t2))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          t2 |= 0, isFinite(i2) ? (i2 |= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = i2, i2 = void 0);
        }
        var r2 = this.length - t2;
        if ((void 0 === i2 || i2 > r2) && (i2 = r2), e2.length > 0 && (i2 < 0 || t2 < 0) || t2 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n2 || (n2 = "utf8");
        for (var s2 = false; ; )
          switch (n2) {
            case "hex":
              return j_(this, e2, t2, i2);
            case "utf8":
            case "utf-8":
              return W_(this, e2, t2, i2);
            case "ascii":
              return X_(this, e2, t2, i2);
            case "latin1":
            case "binary":
              return q_(this, e2, t2, i2);
            case "base64":
              return Y_(this, e2, t2, i2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return Z_(this, e2, t2, i2);
            default:
              if (s2)
                throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), s2 = true;
          }
      }, I_.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var Q_ = 4096;
      function $_(e2, t2, i2) {
        var n2 = "";
        i2 = Math.min(e2.length, i2);
        for (var r2 = t2; r2 < i2; ++r2)
          n2 += String.fromCharCode(127 & e2[r2]);
        return n2;
      }
      function ev(e2, t2, i2) {
        var n2 = "";
        i2 = Math.min(e2.length, i2);
        for (var r2 = t2; r2 < i2; ++r2)
          n2 += String.fromCharCode(e2[r2]);
        return n2;
      }
      function tv(e2, t2, i2) {
        var n2 = e2.length;
        (!t2 || t2 < 0) && (t2 = 0), (!i2 || i2 < 0 || i2 > n2) && (i2 = n2);
        for (var r2 = "", s2 = t2; s2 < i2; ++s2)
          r2 += uv(e2[s2]);
        return r2;
      }
      function iv(e2, t2, i2) {
        for (var n2 = e2.slice(t2, i2), r2 = "", s2 = 0; s2 < n2.length; s2 += 2)
          r2 += String.fromCharCode(n2[s2] + 256 * n2[s2 + 1]);
        return r2;
      }
      function nv(e2, t2, i2) {
        if (e2 % 1 != 0 || e2 < 0)
          throw new RangeError("offset is not uint");
        if (e2 + t2 > i2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function rv(e2, t2, i2, n2, r2, s2) {
        if (!N_(e2))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t2 > r2 || t2 < s2)
          throw new RangeError('"value" argument is out of bounds');
        if (i2 + n2 > e2.length)
          throw new RangeError("Index out of range");
      }
      function sv(e2, t2, i2, n2) {
        t2 < 0 && (t2 = 65535 + t2 + 1);
        for (var r2 = 0, s2 = Math.min(e2.length - i2, 2); r2 < s2; ++r2)
          e2[i2 + r2] = (t2 & 255 << 8 * (n2 ? r2 : 1 - r2)) >>> 8 * (n2 ? r2 : 1 - r2);
      }
      function av(e2, t2, i2, n2) {
        t2 < 0 && (t2 = 4294967295 + t2 + 1);
        for (var r2 = 0, s2 = Math.min(e2.length - i2, 4); r2 < s2; ++r2)
          e2[i2 + r2] = t2 >>> 8 * (n2 ? r2 : 3 - r2) & 255;
      }
      function ov(e2, t2, i2, n2, r2, s2) {
        if (i2 + n2 > e2.length)
          throw new RangeError("Index out of range");
        if (i2 < 0)
          throw new RangeError("Index out of range");
      }
      function lv(e2, t2, i2, n2, r2) {
        return r2 || ov(e2, 0, i2, 4), C_(e2, t2, i2, n2, 23, 4), i2 + 4;
      }
      function hv(e2, t2, i2, n2, r2) {
        return r2 || ov(e2, 0, i2, 8), C_(e2, t2, i2, n2, 52, 8), i2 + 8;
      }
      I_.prototype.slice = function(e2, t2) {
        var i2, n2 = this.length;
        if ((e2 = ~~e2) < 0 ? (e2 += n2) < 0 && (e2 = 0) : e2 > n2 && (e2 = n2), (t2 = void 0 === t2 ? n2 : ~~t2) < 0 ? (t2 += n2) < 0 && (t2 = 0) : t2 > n2 && (t2 = n2), t2 < e2 && (t2 = e2), I_.TYPED_ARRAY_SUPPORT)
          (i2 = this.subarray(e2, t2)).__proto__ = I_.prototype;
        else {
          var r2 = t2 - e2;
          i2 = new I_(r2, void 0);
          for (var s2 = 0; s2 < r2; ++s2)
            i2[s2] = this[s2 + e2];
        }
        return i2;
      }, I_.prototype.readUIntLE = function(e2, t2, i2) {
        e2 |= 0, t2 |= 0, i2 || nv(e2, t2, this.length);
        for (var n2 = this[e2], r2 = 1, s2 = 0; ++s2 < t2 && (r2 *= 256); )
          n2 += this[e2 + s2] * r2;
        return n2;
      }, I_.prototype.readUIntBE = function(e2, t2, i2) {
        e2 |= 0, t2 |= 0, i2 || nv(e2, t2, this.length);
        for (var n2 = this[e2 + --t2], r2 = 1; t2 > 0 && (r2 *= 256); )
          n2 += this[e2 + --t2] * r2;
        return n2;
      }, I_.prototype.readUInt8 = function(e2, t2) {
        return t2 || nv(e2, 1, this.length), this[e2];
      }, I_.prototype.readUInt16LE = function(e2, t2) {
        return t2 || nv(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
      }, I_.prototype.readUInt16BE = function(e2, t2) {
        return t2 || nv(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
      }, I_.prototype.readUInt32LE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
      }, I_.prototype.readUInt32BE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
      }, I_.prototype.readIntLE = function(e2, t2, i2) {
        e2 |= 0, t2 |= 0, i2 || nv(e2, t2, this.length);
        for (var n2 = this[e2], r2 = 1, s2 = 0; ++s2 < t2 && (r2 *= 256); )
          n2 += this[e2 + s2] * r2;
        return n2 >= (r2 *= 128) && (n2 -= Math.pow(2, 8 * t2)), n2;
      }, I_.prototype.readIntBE = function(e2, t2, i2) {
        e2 |= 0, t2 |= 0, i2 || nv(e2, t2, this.length);
        for (var n2 = t2, r2 = 1, s2 = this[e2 + --n2]; n2 > 0 && (r2 *= 256); )
          s2 += this[e2 + --n2] * r2;
        return s2 >= (r2 *= 128) && (s2 -= Math.pow(2, 8 * t2)), s2;
      }, I_.prototype.readInt8 = function(e2, t2) {
        return t2 || nv(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
      }, I_.prototype.readInt16LE = function(e2, t2) {
        t2 || nv(e2, 2, this.length);
        var i2 = this[e2] | this[e2 + 1] << 8;
        return 32768 & i2 ? 4294901760 | i2 : i2;
      }, I_.prototype.readInt16BE = function(e2, t2) {
        t2 || nv(e2, 2, this.length);
        var i2 = this[e2 + 1] | this[e2] << 8;
        return 32768 & i2 ? 4294901760 | i2 : i2;
      }, I_.prototype.readInt32LE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
      }, I_.prototype.readInt32BE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
      }, I_.prototype.readFloatLE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), E_(this, e2, true, 23, 4);
      }, I_.prototype.readFloatBE = function(e2, t2) {
        return t2 || nv(e2, 4, this.length), E_(this, e2, false, 23, 4);
      }, I_.prototype.readDoubleLE = function(e2, t2) {
        return t2 || nv(e2, 8, this.length), E_(this, e2, true, 52, 8);
      }, I_.prototype.readDoubleBE = function(e2, t2) {
        return t2 || nv(e2, 8, this.length), E_(this, e2, false, 52, 8);
      }, I_.prototype.writeUIntLE = function(e2, t2, i2, n2) {
        (e2 = +e2, t2 |= 0, i2 |= 0, n2) || rv(this, e2, t2, i2, Math.pow(2, 8 * i2) - 1, 0);
        var r2 = 1, s2 = 0;
        for (this[t2] = 255 & e2; ++s2 < i2 && (r2 *= 256); )
          this[t2 + s2] = e2 / r2 & 255;
        return t2 + i2;
      }, I_.prototype.writeUIntBE = function(e2, t2, i2, n2) {
        (e2 = +e2, t2 |= 0, i2 |= 0, n2) || rv(this, e2, t2, i2, Math.pow(2, 8 * i2) - 1, 0);
        var r2 = i2 - 1, s2 = 1;
        for (this[t2 + r2] = 255 & e2; --r2 >= 0 && (s2 *= 256); )
          this[t2 + r2] = e2 / s2 & 255;
        return t2 + i2;
      }, I_.prototype.writeUInt8 = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 1, 255, 0), I_.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t2] = 255 & e2, t2 + 1;
      }, I_.prototype.writeUInt16LE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 2, 65535, 0), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : sv(this, e2, t2, true), t2 + 2;
      }, I_.prototype.writeUInt16BE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 2, 65535, 0), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : sv(this, e2, t2, false), t2 + 2;
      }, I_.prototype.writeUInt32LE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 4, 4294967295, 0), I_.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = 255 & e2) : av(this, e2, t2, true), t2 + 4;
      }, I_.prototype.writeUInt32BE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 4, 4294967295, 0), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : av(this, e2, t2, false), t2 + 4;
      }, I_.prototype.writeIntLE = function(e2, t2, i2, n2) {
        if (e2 = +e2, t2 |= 0, !n2) {
          var r2 = Math.pow(2, 8 * i2 - 1);
          rv(this, e2, t2, i2, r2 - 1, -r2);
        }
        var s2 = 0, a2 = 1, o2 = 0;
        for (this[t2] = 255 & e2; ++s2 < i2 && (a2 *= 256); )
          e2 < 0 && 0 === o2 && 0 !== this[t2 + s2 - 1] && (o2 = 1), this[t2 + s2] = (e2 / a2 >> 0) - o2 & 255;
        return t2 + i2;
      }, I_.prototype.writeIntBE = function(e2, t2, i2, n2) {
        if (e2 = +e2, t2 |= 0, !n2) {
          var r2 = Math.pow(2, 8 * i2 - 1);
          rv(this, e2, t2, i2, r2 - 1, -r2);
        }
        var s2 = i2 - 1, a2 = 1, o2 = 0;
        for (this[t2 + s2] = 255 & e2; --s2 >= 0 && (a2 *= 256); )
          e2 < 0 && 0 === o2 && 0 !== this[t2 + s2 + 1] && (o2 = 1), this[t2 + s2] = (e2 / a2 >> 0) - o2 & 255;
        return t2 + i2;
      }, I_.prototype.writeInt8 = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 1, 127, -128), I_.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = 255 & e2, t2 + 1;
      }, I_.prototype.writeInt16LE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 2, 32767, -32768), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : sv(this, e2, t2, true), t2 + 2;
      }, I_.prototype.writeInt16BE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 2, 32767, -32768), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : sv(this, e2, t2, false), t2 + 2;
      }, I_.prototype.writeInt32LE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 4, 2147483647, -2147483648), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24) : av(this, e2, t2, true), t2 + 4;
      }, I_.prototype.writeInt32BE = function(e2, t2, i2) {
        return e2 = +e2, t2 |= 0, i2 || rv(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), I_.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : av(this, e2, t2, false), t2 + 4;
      }, I_.prototype.writeFloatLE = function(e2, t2, i2) {
        return lv(this, e2, t2, true, i2);
      }, I_.prototype.writeFloatBE = function(e2, t2, i2) {
        return lv(this, e2, t2, false, i2);
      }, I_.prototype.writeDoubleLE = function(e2, t2, i2) {
        return hv(this, e2, t2, true, i2);
      }, I_.prototype.writeDoubleBE = function(e2, t2, i2) {
        return hv(this, e2, t2, false, i2);
      }, I_.prototype.copy = function(e2, t2, i2, n2) {
        if (i2 || (i2 = 0), n2 || 0 === n2 || (n2 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), n2 > 0 && n2 < i2 && (n2 = i2), n2 === i2)
          return 0;
        if (0 === e2.length || 0 === this.length)
          return 0;
        if (t2 < 0)
          throw new RangeError("targetStart out of bounds");
        if (i2 < 0 || i2 >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (n2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n2 > this.length && (n2 = this.length), e2.length - t2 < n2 - i2 && (n2 = e2.length - t2 + i2);
        var r2, s2 = n2 - i2;
        if (this === e2 && i2 < t2 && t2 < n2)
          for (r2 = s2 - 1; r2 >= 0; --r2)
            e2[r2 + t2] = this[r2 + i2];
        else if (s2 < 1e3 || !I_.TYPED_ARRAY_SUPPORT)
          for (r2 = 0; r2 < s2; ++r2)
            e2[r2 + t2] = this[r2 + i2];
        else
          Uint8Array.prototype.set.call(e2, this.subarray(i2, i2 + s2), t2);
        return s2;
      }, I_.prototype.fill = function(e2, t2, i2, n2) {
        if ("string" == typeof e2) {
          if ("string" == typeof t2 ? (n2 = t2, t2 = 0, i2 = this.length) : "string" == typeof i2 && (n2 = i2, i2 = this.length), 1 === e2.length) {
            var r2 = e2.charCodeAt(0);
            r2 < 256 && (e2 = r2);
          }
          if (void 0 !== n2 && "string" != typeof n2)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n2 && !I_.isEncoding(n2))
            throw new TypeError("Unknown encoding: " + n2);
        } else
          "number" == typeof e2 && (e2 &= 255);
        if (t2 < 0 || this.length < t2 || this.length < i2)
          throw new RangeError("Out of range index");
        if (i2 <= t2)
          return this;
        var s2;
        if (t2 >>>= 0, i2 = void 0 === i2 ? this.length : i2 >>> 0, e2 || (e2 = 0), "number" == typeof e2)
          for (s2 = t2; s2 < i2; ++s2)
            this[s2] = e2;
        else {
          var a2 = N_(e2) ? e2 : dv(new I_(e2, n2).toString()), o2 = a2.length;
          for (s2 = 0; s2 < i2 - t2; ++s2)
            this[s2 + t2] = a2[s2 % o2];
        }
        return this;
      };
      var cv = /[^+\/0-9A-Za-z-_]/g;
      function uv(e2) {
        return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
      }
      function dv(e2, t2) {
        var i2;
        t2 = t2 || 1 / 0;
        for (var n2 = e2.length, r2 = null, s2 = [], a2 = 0; a2 < n2; ++a2) {
          if ((i2 = e2.charCodeAt(a2)) > 55295 && i2 < 57344) {
            if (!r2) {
              if (i2 > 56319) {
                (t2 -= 3) > -1 && s2.push(239, 191, 189);
                continue;
              }
              if (a2 + 1 === n2) {
                (t2 -= 3) > -1 && s2.push(239, 191, 189);
                continue;
              }
              r2 = i2;
              continue;
            }
            if (i2 < 56320) {
              (t2 -= 3) > -1 && s2.push(239, 191, 189), r2 = i2;
              continue;
            }
            i2 = 65536 + (r2 - 55296 << 10 | i2 - 56320);
          } else
            r2 && (t2 -= 3) > -1 && s2.push(239, 191, 189);
          if (r2 = null, i2 < 128) {
            if ((t2 -= 1) < 0)
              break;
            s2.push(i2);
          } else if (i2 < 2048) {
            if ((t2 -= 2) < 0)
              break;
            s2.push(i2 >> 6 | 192, 63 & i2 | 128);
          } else if (i2 < 65536) {
            if ((t2 -= 3) < 0)
              break;
            s2.push(i2 >> 12 | 224, i2 >> 6 & 63 | 128, 63 & i2 | 128);
          } else {
            if (!(i2 < 1114112))
              throw new Error("Invalid code point");
            if ((t2 -= 4) < 0)
              break;
            s2.push(i2 >> 18 | 240, i2 >> 12 & 63 | 128, i2 >> 6 & 63 | 128, 63 & i2 | 128);
          }
        }
        return s2;
      }
      function pv(e2) {
        return function(e3) {
          var t2, i2, n2, r2, s2, a2;
          M_ || S_();
          var o2 = e3.length;
          if (o2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          s2 = "=" === e3[o2 - 2] ? 2 : "=" === e3[o2 - 1] ? 1 : 0, a2 = new b_(3 * o2 / 4 - s2), n2 = s2 > 0 ? o2 - 4 : o2;
          var l2 = 0;
          for (t2 = 0, i2 = 0; t2 < n2; t2 += 4, i2 += 3)
            r2 = y_[e3.charCodeAt(t2)] << 18 | y_[e3.charCodeAt(t2 + 1)] << 12 | y_[e3.charCodeAt(t2 + 2)] << 6 | y_[e3.charCodeAt(t2 + 3)], a2[l2++] = r2 >> 16 & 255, a2[l2++] = r2 >> 8 & 255, a2[l2++] = 255 & r2;
          return 2 === s2 ? (r2 = y_[e3.charCodeAt(t2)] << 2 | y_[e3.charCodeAt(t2 + 1)] >> 4, a2[l2++] = 255 & r2) : 1 === s2 && (r2 = y_[e3.charCodeAt(t2)] << 10 | y_[e3.charCodeAt(t2 + 1)] << 4 | y_[e3.charCodeAt(t2 + 2)] >> 2, a2[l2++] = r2 >> 8 & 255, a2[l2++] = 255 & r2), a2;
        }(function(e3) {
          if ((e3 = function(e4) {
            return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
          }(e3).replace(cv, "")).length < 2)
            return "";
          for (; e3.length % 4 != 0; )
            e3 += "=";
          return e3;
        }(e2));
      }
      function mv(e2, t2, i2, n2) {
        for (var r2 = 0; r2 < n2 && !(r2 + i2 >= t2.length || r2 >= e2.length); ++r2)
          t2[r2 + i2] = e2[r2];
        return r2;
      }
      function fv(e2) {
        return null != e2 && (!!e2._isBuffer || gv(e2) || function(e3) {
          return "function" == typeof e3.readFloatLE && "function" == typeof e3.slice && gv(e3.slice(0, 0));
        }(e2));
      }
      function gv(e2) {
        return !!e2.constructor && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
      }
      class _v extends Error {
        constructor(e2, t2, i2, ...n2) {
          Array.isArray(t2) && (t2 = t2.join(" ")), super(t2), void 0 !== Error.captureStackTrace && Error.captureStackTrace(this, _v), this.code = e2;
          for (const r2 of n2)
            for (const e3 in r2) {
              const t3 = r2[e3];
              this[e3] = fv(t3) ? t3.toString(i2.encoding) : null == t3 ? t3 : JSON.parse(JSON.stringify(t3));
            }
        }
      }
      const vv = function(e2) {
        return "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
      }, xv = function(e2) {
        const t2 = [];
        for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
          const n3 = e2[i2];
          if (null == n3 || false === n3)
            t2[i2] = { disabled: true };
          else if ("string" == typeof n3)
            t2[i2] = { name: n3 };
          else {
            if (!vv(n3))
              throw new _v("CSV_INVALID_COLUMN_DEFINITION", ["Invalid column definition:", "expect a string or a literal object,", `got ${JSON.stringify(n3)} at position ${i2}`]);
            if ("string" != typeof n3.name)
              throw new _v("CSV_OPTION_COLUMNS_MISSING_NAME", ["Option columns missing name:", `property "name" is required at position ${i2}`, "when column is an object literal"]);
            t2[i2] = n3;
          }
        }
        return t2;
      };
      class yv {
        constructor(e2 = 100) {
          this.size = e2, this.length = 0, this.buf = I_.allocUnsafe(e2);
        }
        prepend(e2) {
          if (fv(e2)) {
            const t2 = this.length + e2.length;
            if (t2 >= this.size && (this.resize(), t2 >= this.size))
              throw Error("INVALID_BUFFER_STATE");
            const i2 = this.buf;
            this.buf = I_.allocUnsafe(this.size), e2.copy(this.buf, 0), i2.copy(this.buf, e2.length), this.length += e2.length;
          } else {
            const t2 = this.length++;
            t2 === this.size && this.resize();
            const i2 = this.clone();
            this.buf[0] = e2, i2.copy(this.buf, 1, 0, t2);
          }
        }
        append(e2) {
          const t2 = this.length++;
          t2 === this.size && this.resize(), this.buf[t2] = e2;
        }
        clone() {
          return I_.from(this.buf.slice(0, this.length));
        }
        resize() {
          const e2 = this.length;
          this.size = 2 * this.size;
          const t2 = I_.allocUnsafe(this.size);
          this.buf.copy(t2, 0, 0, e2), this.buf = t2;
        }
        toString(e2) {
          return e2 ? this.buf.slice(0, this.length).toString(e2) : Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
        }
        toJSON() {
          return this.toString("utf8");
        }
        reset() {
          this.length = 0;
        }
      }
      const bv = function(e2) {
        return { bomSkipped: false, bufBytesStart: 0, castField: e2.cast_function, commenting: false, error: void 0, enabled: 1 === e2.from_line, escaping: false, escapeIsQuote: fv(e2.escape) && fv(e2.quote) && 0 === I_.compare(e2.escape, e2.quote), expectedRecordLength: Array.isArray(e2.columns) ? e2.columns.length : void 0, field: new yv(20), firstLineToHeaders: e2.cast_first_line_to_header, needMoreDataSize: Math.max(null !== e2.comment ? e2.comment.length : 0, ...e2.delimiter.map((e3) => e3.length), null !== e2.quote ? e2.quote.length : 0), previousBuf: void 0, quoting: false, stop: false, rawBuffer: new yv(100), record: [], recordHasError: false, record_length: 0, recordDelimiterMaxLength: 0 === e2.record_delimiter.length ? 2 : Math.max(...e2.record_delimiter.map((e3) => e3.length)), trimChars: [I_.from(" ", e2.encoding)[0], I_.from("	", e2.encoding)[0]], wasQuoting: false, wasRowDelimiter: false, timchars: [I_.from(I_.from([13], "utf8").toString(), e2.encoding), I_.from(I_.from([10], "utf8").toString(), e2.encoding), I_.from(I_.from([12], "utf8").toString(), e2.encoding), I_.from(I_.from([32], "utf8").toString(), e2.encoding), I_.from(I_.from([9], "utf8").toString(), e2.encoding)] };
      }, Mv = function(e2) {
        const t2 = {};
        for (const r2 in e2)
          t2[i2 = r2, i2.replace(/([A-Z])/g, function(e3, t3) {
            return "_" + t3.toLowerCase();
          })] = e2[r2];
        var i2;
        if (void 0 === t2.encoding || true === t2.encoding)
          t2.encoding = "utf8";
        else if (null === t2.encoding || false === t2.encoding)
          t2.encoding = null;
        else if ("string" != typeof t2.encoding && null !== t2.encoding)
          throw new _v("CSV_INVALID_OPTION_ENCODING", ["Invalid option encoding:", "encoding must be a string or null to return a buffer,", `got ${JSON.stringify(t2.encoding)}`], t2);
        if (void 0 === t2.bom || null === t2.bom || false === t2.bom)
          t2.bom = false;
        else if (true !== t2.bom)
          throw new _v("CSV_INVALID_OPTION_BOM", ["Invalid option bom:", "bom must be true,", `got ${JSON.stringify(t2.bom)}`], t2);
        if (t2.cast_function = null, void 0 === t2.cast || null === t2.cast || false === t2.cast || "" === t2.cast)
          t2.cast = void 0;
        else if ("function" == typeof t2.cast)
          t2.cast_function = t2.cast, t2.cast = true;
        else if (true !== t2.cast)
          throw new _v("CSV_INVALID_OPTION_CAST", ["Invalid option cast:", "cast must be true or a function,", `got ${JSON.stringify(t2.cast)}`], t2);
        if (void 0 === t2.cast_date || null === t2.cast_date || false === t2.cast_date || "" === t2.cast_date)
          t2.cast_date = false;
        else if (true === t2.cast_date)
          t2.cast_date = function(e3) {
            const t3 = Date.parse(e3);
            return isNaN(t3) ? e3 : new Date(t3);
          };
        else if ("function" != typeof t2.cast_date)
          throw new _v("CSV_INVALID_OPTION_CAST_DATE", ["Invalid option cast_date:", "cast_date must be true or a function,", `got ${JSON.stringify(t2.cast_date)}`], t2);
        if (t2.cast_first_line_to_header = null, true === t2.columns)
          t2.cast_first_line_to_header = void 0;
        else if ("function" == typeof t2.columns)
          t2.cast_first_line_to_header = t2.columns, t2.columns = true;
        else if (Array.isArray(t2.columns))
          t2.columns = xv(t2.columns);
        else {
          if (void 0 !== t2.columns && null !== t2.columns && false !== t2.columns)
            throw new _v("CSV_INVALID_OPTION_COLUMNS", ["Invalid option columns:", "expect an array, a function or true,", `got ${JSON.stringify(t2.columns)}`], t2);
          t2.columns = false;
        }
        if (void 0 === t2.group_columns_by_name || null === t2.group_columns_by_name || false === t2.group_columns_by_name)
          t2.group_columns_by_name = false;
        else {
          if (true !== t2.group_columns_by_name)
            throw new _v("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", ["Invalid option group_columns_by_name:", "expect an boolean,", `got ${JSON.stringify(t2.group_columns_by_name)}`], t2);
          if (false === t2.columns)
            throw new _v("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", ["Invalid option group_columns_by_name:", "the `columns` mode must be activated."], t2);
        }
        if (void 0 === t2.comment || null === t2.comment || false === t2.comment || "" === t2.comment)
          t2.comment = null;
        else if ("string" == typeof t2.comment && (t2.comment = I_.from(t2.comment, t2.encoding)), !fv(t2.comment))
          throw new _v("CSV_INVALID_OPTION_COMMENT", ["Invalid option comment:", "comment must be a buffer or a string,", `got ${JSON.stringify(t2.comment)}`], t2);
        const n2 = JSON.stringify(t2.delimiter);
        if (Array.isArray(t2.delimiter) || (t2.delimiter = [t2.delimiter]), 0 === t2.delimiter.length)
          throw new _v("CSV_INVALID_OPTION_DELIMITER", ["Invalid option delimiter:", "delimiter must be a non empty string or buffer or array of string|buffer,", `got ${n2}`], t2);
        if (t2.delimiter = t2.delimiter.map(function(e3) {
          if (null == e3 || false === e3)
            return I_.from(",", t2.encoding);
          if ("string" == typeof e3 && (e3 = I_.from(e3, t2.encoding)), !fv(e3) || 0 === e3.length)
            throw new _v("CSV_INVALID_OPTION_DELIMITER", ["Invalid option delimiter:", "delimiter must be a non empty string or buffer or array of string|buffer,", `got ${n2}`], t2);
          return e3;
        }), void 0 === t2.escape || true === t2.escape ? t2.escape = I_.from('"', t2.encoding) : "string" == typeof t2.escape ? t2.escape = I_.from(t2.escape, t2.encoding) : null !== t2.escape && false !== t2.escape || (t2.escape = null), null !== t2.escape && !fv(t2.escape))
          throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(t2.escape)}`);
        if (void 0 === t2.from || null === t2.from)
          t2.from = 1;
        else {
          if ("string" == typeof t2.from && /\d+/.test(t2.from) && (t2.from = parseInt(t2.from)), !Number.isInteger(t2.from))
            throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(t2.from)}`);
          if (t2.from < 0)
            throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(e2.from)}`);
        }
        if (void 0 === t2.from_line || null === t2.from_line)
          t2.from_line = 1;
        else {
          if ("string" == typeof t2.from_line && /\d+/.test(t2.from_line) && (t2.from_line = parseInt(t2.from_line)), !Number.isInteger(t2.from_line))
            throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(e2.from_line)}`);
          if (t2.from_line <= 0)
            throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(e2.from_line)}`);
        }
        if (void 0 === t2.ignore_last_delimiters || null === t2.ignore_last_delimiters)
          t2.ignore_last_delimiters = false;
        else if ("number" == typeof t2.ignore_last_delimiters)
          t2.ignore_last_delimiters = Math.floor(t2.ignore_last_delimiters), 0 === t2.ignore_last_delimiters && (t2.ignore_last_delimiters = false);
        else if ("boolean" != typeof t2.ignore_last_delimiters)
          throw new _v("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", ["Invalid option `ignore_last_delimiters`:", "the value must be a boolean value or an integer,", `got ${JSON.stringify(t2.ignore_last_delimiters)}`], t2);
        if (true === t2.ignore_last_delimiters && false === t2.columns)
          throw new _v("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", ["The option `ignore_last_delimiters`", "requires the activation of the `columns` option"], t2);
        if (void 0 === t2.info || null === t2.info || false === t2.info)
          t2.info = false;
        else if (true !== t2.info)
          throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(t2.info)}`);
        if (void 0 === t2.max_record_size || null === t2.max_record_size || false === t2.max_record_size)
          t2.max_record_size = 0;
        else if (Number.isInteger(t2.max_record_size) && t2.max_record_size >= 0)
          ;
        else {
          if ("string" != typeof t2.max_record_size || !/\d+/.test(t2.max_record_size))
            throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(t2.max_record_size)}`);
          t2.max_record_size = parseInt(t2.max_record_size);
        }
        if (void 0 === t2.objname || null === t2.objname || false === t2.objname)
          t2.objname = void 0;
        else if (fv(t2.objname)) {
          if (0 === t2.objname.length)
            throw new Error("Invalid Option: objname must be a non empty buffer");
          null === t2.encoding || (t2.objname = t2.objname.toString(t2.encoding));
        } else if ("string" == typeof t2.objname) {
          if (0 === t2.objname.length)
            throw new Error("Invalid Option: objname must be a non empty string");
        } else if ("number" != typeof t2.objname)
          throw new Error(`Invalid Option: objname must be a string or a buffer, got ${t2.objname}`);
        if (void 0 !== t2.objname) {
          if ("number" == typeof t2.objname) {
            if (false !== t2.columns)
              throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field");
          } else if (false === t2.columns)
            throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");
        }
        if (void 0 === t2.on_record || null === t2.on_record)
          t2.on_record = void 0;
        else if ("function" != typeof t2.on_record)
          throw new _v("CSV_INVALID_OPTION_ON_RECORD", ["Invalid option `on_record`:", "expect a function,", `got ${JSON.stringify(t2.on_record)}`], t2);
        if (null === t2.quote || false === t2.quote || "" === t2.quote)
          t2.quote = null;
        else if (void 0 === t2.quote || true === t2.quote ? t2.quote = I_.from('"', t2.encoding) : "string" == typeof t2.quote && (t2.quote = I_.from(t2.quote, t2.encoding)), !fv(t2.quote))
          throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(t2.quote)}`);
        if (void 0 === t2.raw || null === t2.raw || false === t2.raw)
          t2.raw = false;
        else if (true !== t2.raw)
          throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(t2.raw)}`);
        if (void 0 === t2.record_delimiter)
          t2.record_delimiter = [];
        else if ("string" == typeof t2.record_delimiter || fv(t2.record_delimiter)) {
          if (0 === t2.record_delimiter.length)
            throw new _v("CSV_INVALID_OPTION_RECORD_DELIMITER", ["Invalid option `record_delimiter`:", "value must be a non empty string or buffer,", `got ${JSON.stringify(t2.record_delimiter)}`], t2);
          t2.record_delimiter = [t2.record_delimiter];
        } else if (!Array.isArray(t2.record_delimiter))
          throw new _v("CSV_INVALID_OPTION_RECORD_DELIMITER", ["Invalid option `record_delimiter`:", "value must be a string, a buffer or array of string|buffer,", `got ${JSON.stringify(t2.record_delimiter)}`], t2);
        if (t2.record_delimiter = t2.record_delimiter.map(function(e3, i3) {
          if ("string" != typeof e3 && !fv(e3))
            throw new _v("CSV_INVALID_OPTION_RECORD_DELIMITER", ["Invalid option `record_delimiter`:", "value must be a string, a buffer or array of string|buffer", `at index ${i3},`, `got ${JSON.stringify(e3)}`], t2);
          if (0 === e3.length)
            throw new _v("CSV_INVALID_OPTION_RECORD_DELIMITER", ["Invalid option `record_delimiter`:", "value must be a non empty string or buffer", `at index ${i3},`, `got ${JSON.stringify(e3)}`], t2);
          return "string" == typeof e3 && (e3 = I_.from(e3, t2.encoding)), e3;
        }), "boolean" == typeof t2.relax_column_count)
          ;
        else {
          if (void 0 !== t2.relax_column_count && null !== t2.relax_column_count)
            throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(t2.relax_column_count)}`);
          t2.relax_column_count = false;
        }
        if ("boolean" == typeof t2.relax_column_count_less)
          ;
        else {
          if (void 0 !== t2.relax_column_count_less && null !== t2.relax_column_count_less)
            throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(t2.relax_column_count_less)}`);
          t2.relax_column_count_less = false;
        }
        if ("boolean" == typeof t2.relax_column_count_more)
          ;
        else {
          if (void 0 !== t2.relax_column_count_more && null !== t2.relax_column_count_more)
            throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(t2.relax_column_count_more)}`);
          t2.relax_column_count_more = false;
        }
        if ("boolean" == typeof t2.relax_quotes)
          ;
        else {
          if (void 0 !== t2.relax_quotes && null !== t2.relax_quotes)
            throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(t2.relax_quotes)}`);
          t2.relax_quotes = false;
        }
        if ("boolean" == typeof t2.skip_empty_lines)
          ;
        else {
          if (void 0 !== t2.skip_empty_lines && null !== t2.skip_empty_lines)
            throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(t2.skip_empty_lines)}`);
          t2.skip_empty_lines = false;
        }
        if ("boolean" == typeof t2.skip_records_with_empty_values)
          ;
        else {
          if (void 0 !== t2.skip_records_with_empty_values && null !== t2.skip_records_with_empty_values)
            throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(t2.skip_records_with_empty_values)}`);
          t2.skip_records_with_empty_values = false;
        }
        if ("boolean" == typeof t2.skip_records_with_error)
          ;
        else {
          if (void 0 !== t2.skip_records_with_error && null !== t2.skip_records_with_error)
            throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(t2.skip_records_with_error)}`);
          t2.skip_records_with_error = false;
        }
        if (void 0 === t2.rtrim || null === t2.rtrim || false === t2.rtrim)
          t2.rtrim = false;
        else if (true !== t2.rtrim)
          throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(t2.rtrim)}`);
        if (void 0 === t2.ltrim || null === t2.ltrim || false === t2.ltrim)
          t2.ltrim = false;
        else if (true !== t2.ltrim)
          throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(t2.ltrim)}`);
        if (void 0 === t2.trim || null === t2.trim || false === t2.trim)
          t2.trim = false;
        else if (true !== t2.trim)
          throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(t2.trim)}`);
        if (true === t2.trim && false !== e2.ltrim ? t2.ltrim = true : true !== t2.ltrim && (t2.ltrim = false), true === t2.trim && false !== e2.rtrim ? t2.rtrim = true : true !== t2.rtrim && (t2.rtrim = false), void 0 === t2.to || null === t2.to)
          t2.to = -1;
        else {
          if ("string" == typeof t2.to && /\d+/.test(t2.to) && (t2.to = parseInt(t2.to)), !Number.isInteger(t2.to))
            throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(e2.to)}`);
          if (t2.to <= 0)
            throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(e2.to)}`);
        }
        if (void 0 === t2.to_line || null === t2.to_line)
          t2.to_line = -1;
        else {
          if ("string" == typeof t2.to_line && /\d+/.test(t2.to_line) && (t2.to_line = parseInt(t2.to_line)), !Number.isInteger(t2.to_line))
            throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(e2.to_line)}`);
          if (t2.to_line <= 0)
            throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(e2.to_line)}`);
        }
        return t2;
      }, Sv = function(e2) {
        return e2.every((e3) => null == e3 || e3.toString && "" === e3.toString().trim());
      }, wv = { utf8: I_.from([239, 187, 191]), utf16le: I_.from([255, 254]) }, Tv = function(e2, t2 = {}) {
        "string" == typeof e2 && (e2 = I_.from(e2));
        const i2 = t2 && t2.objname ? {} : [], n2 = function(e3 = {}) {
          const t3 = Mv(e3);
          return { info: { bytes: 0, comment_lines: 0, empty_lines: 0, invalid_field_length: 0, lines: 1, records: 0 }, original_options: e3, options: t3, state: bv(t3), __needMoreData: function(e4, t4, i3) {
            if (i3)
              return false;
            const { quote: n3 } = this.options, { quoting: r3, needMoreDataSize: s3, recordDelimiterMaxLength: a3 } = this.state;
            return t4 - e4 - 1 < Math.max(s3, a3, r3 ? n3.length + a3 : 0);
          }, parse: function(e4, t4, i3, n3) {
            const { bom: r3, from_line: s3, ltrim: a3, max_record_size: o3, raw: l2, relax_quotes: h2, rtrim: c2, skip_empty_lines: u2, to: d2, to_line: p2 } = this.options;
            let { comment: m2, escape: f2, quote: g2, record_delimiter: _2 } = this.options;
            const { bomSkipped: v2, previousBuf: x2, rawBuffer: y2, escapeIsQuote: b2 } = this.state;
            let M2;
            if (void 0 === x2) {
              if (void 0 === e4)
                return void n3();
              M2 = e4;
            } else
              M2 = void 0 !== x2 && void 0 === e4 ? x2 : I_.concat([x2, e4]);
            if (false === v2)
              if (false === r3)
                this.state.bomSkipped = true;
              else if (M2.length < 3) {
                if (false === t4)
                  return void (this.state.previousBuf = M2);
              } else {
                for (const e5 in wv)
                  if (0 === wv[e5].compare(M2, 0, wv[e5].length)) {
                    const t5 = wv[e5].length;
                    this.state.bufBytesStart += t5, M2 = M2.slice(t5), this.options = Mv({ ...this.original_options, encoding: e5 }), { comment: m2, escape: f2, quote: g2 } = this.options;
                    break;
                  }
                this.state.bomSkipped = true;
              }
            const S2 = M2.length;
            let w2;
            for (w2 = 0; w2 < S2 && !this.__needMoreData(w2, S2, t4); w2++) {
              if (true === this.state.wasRowDelimiter && (this.info.lines++, this.state.wasRowDelimiter = false), -1 !== p2 && this.info.lines > p2)
                return this.state.stop = true, void n3();
              false === this.state.quoting && 0 === _2.length && this.__autoDiscoverRecordDelimiter(M2, w2) && (_2 = this.options.record_delimiter);
              const e5 = M2[w2];
              if (true === l2 && y2.append(e5), 13 !== e5 && 10 !== e5 || false !== this.state.wasRowDelimiter || (this.state.wasRowDelimiter = true), true === this.state.escaping)
                this.state.escaping = false;
              else {
                if (null !== f2 && true === this.state.quoting && this.__isEscape(M2, w2, e5) && w2 + f2.length < S2) {
                  if (!b2) {
                    this.state.escaping = true, w2 += f2.length - 1;
                    continue;
                  }
                  if (this.__isQuote(M2, w2 + f2.length)) {
                    this.state.escaping = true, w2 += f2.length - 1;
                    continue;
                  }
                }
                if (false === this.state.commenting && this.__isQuote(M2, w2))
                  if (true === this.state.quoting) {
                    const t6 = M2[w2 + g2.length], i4 = c2 && this.__isCharTrimable(M2, w2 + g2.length), n4 = null !== m2 && this.__compareBytes(m2, M2, w2 + g2.length, t6), r5 = this.__isDelimiter(M2, w2 + g2.length, t6), s4 = 0 === _2.length ? this.__autoDiscoverRecordDelimiter(M2, w2 + g2.length) : this.__isRecordDelimiter(t6, M2, w2 + g2.length);
                    if (null !== f2 && this.__isEscape(M2, w2, e5) && this.__isQuote(M2, w2 + f2.length))
                      w2 += f2.length - 1;
                    else {
                      if (!t6 || r5 || s4 || n4 || i4) {
                        this.state.quoting = false, this.state.wasQuoting = true, w2 += g2.length - 1;
                        continue;
                      }
                      if (false === h2) {
                        const e6 = this.__error(new _v("CSV_INVALID_CLOSING_QUOTE", ["Invalid Closing Quote:", `got "${String.fromCharCode(t6)}"`, `at line ${this.info.lines}`, "instead of delimiter, record delimiter, trimable character", "(if activated) or comment"], this.options, this.__infoField()));
                        if (void 0 !== e6)
                          return e6;
                      } else
                        this.state.quoting = false, this.state.wasQuoting = true, this.state.field.prepend(g2), w2 += g2.length - 1;
                    }
                  } else {
                    if (0 === this.state.field.length) {
                      this.state.quoting = true, w2 += g2.length - 1;
                      continue;
                    }
                    if (false === h2) {
                      const e6 = this.__error(new _v("INVALID_OPENING_QUOTE", ["Invalid Opening Quote:", `a quote is found inside a field at line ${this.info.lines}`], this.options, this.__infoField(), { field: this.state.field }));
                      if (void 0 !== e6)
                        return e6;
                    }
                  }
                if (false === this.state.quoting) {
                  const t6 = this.__isRecordDelimiter(e5, M2, w2);
                  if (0 !== t6) {
                    if (this.state.commenting && false === this.state.wasQuoting && 0 === this.state.record.length && 0 === this.state.field.length)
                      this.info.comment_lines++;
                    else {
                      if (false === this.state.enabled && this.info.lines + (true === this.state.wasRowDelimiter ? 1 : 0) >= s3) {
                        this.state.enabled = true, this.__resetField(), this.__resetRecord(), w2 += t6 - 1;
                        continue;
                      }
                      if (true === u2 && false === this.state.wasQuoting && 0 === this.state.record.length && 0 === this.state.field.length) {
                        this.info.empty_lines++, w2 += t6 - 1;
                        continue;
                      }
                      this.info.bytes = this.state.bufBytesStart + w2;
                      const e6 = this.__onField();
                      if (void 0 !== e6)
                        return e6;
                      this.info.bytes = this.state.bufBytesStart + w2 + t6;
                      const r6 = this.__onRecord(i3);
                      if (void 0 !== r6)
                        return r6;
                      if (-1 !== d2 && this.info.records >= d2)
                        return this.state.stop = true, void n3();
                    }
                    this.state.commenting = false, w2 += t6 - 1;
                    continue;
                  }
                  if (this.state.commenting)
                    continue;
                  if (0 !== (null === m2 ? 0 : this.__compareBytes(m2, M2, w2, e5))) {
                    this.state.commenting = true;
                    continue;
                  }
                  const r5 = this.__isDelimiter(M2, w2, e5);
                  if (0 !== r5) {
                    this.info.bytes = this.state.bufBytesStart + w2;
                    const e6 = this.__onField();
                    if (void 0 !== e6)
                      return e6;
                    w2 += r5 - 1;
                    continue;
                  }
                }
              }
              if (false === this.state.commenting && 0 !== o3 && this.state.record_length + this.state.field.length > o3)
                return this.__error(new _v("CSV_MAX_RECORD_SIZE", ["Max Record Size:", "record exceed the maximum number of tolerated bytes", `of ${o3}`, `at line ${this.info.lines}`], this.options, this.__infoField()));
              const t5 = false === a3 || true === this.state.quoting || 0 !== this.state.field.length || !this.__isCharTrimable(M2, w2), r4 = false === c2 || false === this.state.wasQuoting;
              if (true !== t5 || true !== r4) {
                if (true !== c2 || this.__isCharTrimable(M2, w2)) {
                  false === t5 && (w2 += this.__isCharTrimable(M2, w2) - 1);
                  continue;
                }
                return this.__error(new _v("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", ["Invalid Closing Quote:", "found non trimable byte after quote", `at line ${this.info.lines}`], this.options, this.__infoField()));
              }
              this.state.field.append(e5);
            }
            if (true === t4)
              if (true === this.state.quoting) {
                const e5 = this.__error(new _v("CSV_QUOTE_NOT_CLOSED", ["Quote Not Closed:", `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));
                if (void 0 !== e5)
                  return e5;
              } else if (true === this.state.wasQuoting || 0 !== this.state.record.length || 0 !== this.state.field.length) {
                this.info.bytes = this.state.bufBytesStart + w2;
                const e5 = this.__onField();
                if (void 0 !== e5)
                  return e5;
                const t5 = this.__onRecord(i3);
                if (void 0 !== t5)
                  return t5;
              } else
                true === this.state.wasRowDelimiter ? this.info.empty_lines++ : true === this.state.commenting && this.info.comment_lines++;
            else
              this.state.bufBytesStart += w2, this.state.previousBuf = M2.slice(w2);
            true === this.state.wasRowDelimiter && (this.info.lines++, this.state.wasRowDelimiter = false);
          }, __onRecord: function(e4) {
            const { columns: t4, group_columns_by_name: i3, encoding: n3, info: r3, from: s3, relax_column_count: a3, relax_column_count_less: o3, relax_column_count_more: l2, raw: h2, skip_records_with_empty_values: c2 } = this.options, { enabled: u2, record: d2 } = this.state;
            if (false === u2)
              return this.__resetRecord();
            const p2 = d2.length;
            if (true === t4)
              return true === c2 && Sv(d2) ? void this.__resetRecord() : this.__firstLineToColumns(d2);
            if (false === t4 && 0 === this.info.records && (this.state.expectedRecordLength = p2), p2 !== this.state.expectedRecordLength) {
              const e5 = false === t4 ? new _v("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH", ["Invalid Record Length:", `expect ${this.state.expectedRecordLength},`, `got ${p2} on line ${this.info.lines}`], this.options, this.__infoField(), { record: d2 }) : new _v("CSV_RECORD_INCONSISTENT_COLUMNS", ["Invalid Record Length:", `columns length is ${t4.length},`, `got ${p2} on line ${this.info.lines}`], this.options, this.__infoField(), { record: d2 });
              if (true === a3 || true === o3 && p2 < this.state.expectedRecordLength || true === l2 && p2 > this.state.expectedRecordLength)
                this.info.invalid_field_length++, this.state.error = e5;
              else {
                const t5 = this.__error(e5);
                if (t5)
                  return t5;
              }
            }
            if (true === c2 && Sv(d2))
              this.__resetRecord();
            else {
              if (true === this.state.recordHasError)
                return this.__resetRecord(), void (this.state.recordHasError = false);
              if (this.info.records++, 1 === s3 || this.info.records >= s3) {
                const { objname: s4 } = this.options;
                if (false !== t4) {
                  const a4 = {};
                  for (let e5 = 0, n4 = d2.length; e5 < n4; e5++)
                    void 0 === t4[e5] || t4[e5].disabled || (true === i3 && void 0 !== a4[t4[e5].name] ? Array.isArray(a4[t4[e5].name]) ? a4[t4[e5].name] = a4[t4[e5].name].concat(d2[e5]) : a4[t4[e5].name] = [a4[t4[e5].name], d2[e5]] : a4[t4[e5].name] = d2[e5]);
                  if (true === h2 || true === r3) {
                    const t5 = Object.assign({ record: a4 }, true === h2 ? { raw: this.state.rawBuffer.toString(n3) } : {}, true === r3 ? { info: this.__infoRecord() } : {}), i4 = this.__push(void 0 === s4 ? t5 : [a4[s4], t5], e4);
                    if (i4)
                      return i4;
                  } else {
                    const t5 = this.__push(void 0 === s4 ? a4 : [a4[s4], a4], e4);
                    if (t5)
                      return t5;
                  }
                } else if (true === h2 || true === r3) {
                  const t5 = Object.assign({ record: d2 }, true === h2 ? { raw: this.state.rawBuffer.toString(n3) } : {}, true === r3 ? { info: this.__infoRecord() } : {}), i4 = this.__push(void 0 === s4 ? t5 : [d2[s4], t5], e4);
                  if (i4)
                    return i4;
                } else {
                  const t5 = this.__push(void 0 === s4 ? d2 : [d2[s4], d2], e4);
                  if (t5)
                    return t5;
                }
              }
              this.__resetRecord();
            }
          }, __firstLineToColumns: function(e4) {
            const { firstLineToHeaders: t4 } = this.state;
            try {
              const i3 = void 0 === t4 ? e4 : t4.call(null, e4);
              if (!Array.isArray(i3))
                return this.__error(new _v("CSV_INVALID_COLUMN_MAPPING", ["Invalid Column Mapping:", "expect an array from column function,", `got ${JSON.stringify(i3)}`], this.options, this.__infoField(), { headers: i3 }));
              const n3 = xv(i3);
              return this.state.expectedRecordLength = n3.length, this.options.columns = n3, void this.__resetRecord();
            } catch (i3) {
              return i3;
            }
          }, __resetRecord: function() {
            true === this.options.raw && this.state.rawBuffer.reset(), this.state.error = void 0, this.state.record = [], this.state.record_length = 0;
          }, __onField: function() {
            const { cast: e4, encoding: t4, rtrim: i3, max_record_size: n3 } = this.options, { enabled: r3, wasQuoting: s3 } = this.state;
            if (false === r3)
              return this.__resetField();
            let a3 = this.state.field.toString(t4);
            if (true === i3 && false === s3 && (a3 = a3.trimRight()), true === e4) {
              const [e5, t5] = this.__cast(a3);
              if (void 0 !== e5)
                return e5;
              a3 = t5;
            }
            this.state.record.push(a3), 0 !== n3 && "string" == typeof a3 && (this.state.record_length += a3.length), this.__resetField();
          }, __resetField: function() {
            this.state.field.reset(), this.state.wasQuoting = false;
          }, __push: function(e4, t4) {
            const { on_record: i3 } = this.options;
            if (void 0 !== i3) {
              const t5 = this.__infoRecord();
              try {
                e4 = i3.call(null, e4, t5);
              } catch (n3) {
                return n3;
              }
              if (null == e4)
                return;
            }
            t4(e4);
          }, __cast: function(e4) {
            const { columns: t4, relax_column_count: i3 } = this.options;
            if (true === Array.isArray(t4) && i3 && this.options.columns.length <= this.state.record.length)
              return [void 0, void 0];
            if (null !== this.state.castField)
              try {
                const t5 = this.__infoField();
                return [void 0, this.state.castField.call(null, e4, t5)];
              } catch (n3) {
                return [n3];
              }
            if (this.__isFloat(e4))
              return [void 0, parseFloat(e4)];
            if (false !== this.options.cast_date) {
              const t5 = this.__infoField();
              return [void 0, this.options.cast_date.call(null, e4, t5)];
            }
            return [void 0, e4];
          }, __isCharTrimable: function(e4, t4) {
            return ((e5, t5) => {
              const { timchars: i3 } = this.state;
              e:
                for (let n3 = 0; n3 < i3.length; n3++) {
                  const r3 = i3[n3];
                  for (let i4 = 0; i4 < r3.length; i4++)
                    if (r3[i4] !== e5[t5 + i4])
                      continue e;
                  return r3.length;
                }
              return 0;
            })(e4, t4);
          }, __isFloat: function(e4) {
            return e4 - parseFloat(e4) + 1 >= 0;
          }, __compareBytes: function(e4, t4, i3, n3) {
            if (e4[0] !== n3)
              return 0;
            const r3 = e4.length;
            for (let s3 = 1; s3 < r3; s3++)
              if (e4[s3] !== t4[i3 + s3])
                return 0;
            return r3;
          }, __isDelimiter: function(e4, t4, i3) {
            const { delimiter: n3, ignore_last_delimiters: r3 } = this.options;
            if (true === r3 && this.state.record.length === this.options.columns.length - 1)
              return 0;
            if (false !== r3 && "number" == typeof r3 && this.state.record.length === r3 - 1)
              return 0;
            e:
              for (let s3 = 0; s3 < n3.length; s3++) {
                const r4 = n3[s3];
                if (r4[0] === i3) {
                  for (let i4 = 1; i4 < r4.length; i4++)
                    if (r4[i4] !== e4[t4 + i4])
                      continue e;
                  return r4.length;
                }
              }
            return 0;
          }, __isRecordDelimiter: function(e4, t4, i3) {
            const { record_delimiter: n3 } = this.options, r3 = n3.length;
            e:
              for (let s3 = 0; s3 < r3; s3++) {
                const r4 = n3[s3], a3 = r4.length;
                if (r4[0] === e4) {
                  for (let e5 = 1; e5 < a3; e5++)
                    if (r4[e5] !== t4[i3 + e5])
                      continue e;
                  return r4.length;
                }
              }
            return 0;
          }, __isEscape: function(e4, t4, i3) {
            const { escape: n3 } = this.options;
            if (null === n3)
              return false;
            const r3 = n3.length;
            if (n3[0] === i3) {
              for (let i4 = 0; i4 < r3; i4++)
                if (n3[i4] !== e4[t4 + i4])
                  return false;
              return true;
            }
            return false;
          }, __isQuote: function(e4, t4) {
            const { quote: i3 } = this.options;
            if (null === i3)
              return false;
            const n3 = i3.length;
            for (let r3 = 0; r3 < n3; r3++)
              if (i3[r3] !== e4[t4 + r3])
                return false;
            return true;
          }, __autoDiscoverRecordDelimiter: function(e4, t4) {
            const { encoding: i3 } = this.options, n3 = e4[t4];
            return 13 === n3 ? 10 === e4[t4 + 1] ? (this.options.record_delimiter.push(I_.from("\r\n", i3)), this.state.recordDelimiterMaxLength = 2, 2) : (this.options.record_delimiter.push(I_.from("\r", i3)), this.state.recordDelimiterMaxLength = 1, 1) : 10 === n3 ? (this.options.record_delimiter.push(I_.from("\n", i3)), this.state.recordDelimiterMaxLength = 1, 1) : 0;
          }, __error: function(e4) {
            const { encoding: t4, raw: i3, skip_records_with_error: n3 } = this.options, r3 = "string" == typeof e4 ? new Error(e4) : e4;
            return n3 ? (this.state.recordHasError = true, void (void 0 !== this.options.on_skip && this.options.on_skip(r3, i3 ? this.state.rawBuffer.toString(t4) : void 0))) : r3;
          }, __infoDataSet: function() {
            return { ...this.info, columns: this.options.columns };
          }, __infoRecord: function() {
            const { columns: e4, raw: t4, encoding: i3 } = this.options;
            return { ...this.__infoDataSet(), error: this.state.error, header: true === e4, index: this.state.record.length, raw: t4 ? this.state.rawBuffer.toString(i3) : void 0 };
          }, __infoField: function() {
            const { columns: e4 } = this.options, t4 = Array.isArray(e4);
            return { ...this.__infoRecord(), column: true === t4 ? e4.length > this.state.record.length ? e4[this.state.record.length].name : null : this.state.record.length, quoting: this.state.wasQuoting };
          } };
        }(t2), r2 = (e3) => {
          void 0 === n2.options.objname ? i2.push(e3) : i2[e3[0]] = e3[1];
        }, s2 = () => {
        }, a2 = n2.parse(e2, false, r2, s2);
        if (void 0 !== a2)
          throw a2;
        const o2 = n2.parse(void 0, true, r2, s2);
        if (void 0 !== o2)
          throw o2;
        return i2;
      };
      var Ev = { exports: {} };
      Ev.exports = Pv, Ev.exports.parse = Pv, Ev.exports.stringify = function e2(t2) {
        "Feature" === t2.type && (t2 = t2.geometry);
        function i2(e3) {
          return e3.join(" ");
        }
        function n2(e3) {
          return e3.map(i2).join(", ");
        }
        function r2(e3) {
          return e3.map(n2).map(s2).join(", ");
        }
        function s2(e3) {
          return "(" + e3 + ")";
        }
        switch (t2.type) {
          case "Point":
            return "POINT (" + i2(t2.coordinates) + ")";
          case "LineString":
            return "LINESTRING (" + n2(t2.coordinates) + ")";
          case "Polygon":
            return "POLYGON (" + r2(t2.coordinates) + ")";
          case "MultiPoint":
            return "MULTIPOINT (" + n2(t2.coordinates) + ")";
          case "MultiPolygon":
            return "MULTIPOLYGON (" + (t2.coordinates.map(r2).map(s2).join(", ") + ")");
          case "MultiLineString":
            return "MULTILINESTRING (" + r2(t2.coordinates) + ")";
          case "GeometryCollection":
            return "GEOMETRYCOLLECTION (" + t2.geometries.map(e2).join(", ") + ")";
          default:
            throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input");
        }
      };
      var Cv = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/, Av = new RegExp("^" + Cv.source + "(\\s" + Cv.source + "){1,}");
      function Pv(e2) {
        var t2 = e2.split(";"), i2 = t2.pop(), n2 = (t2.shift() || "").split("=").pop(), r2 = 0;
        function s2(e3) {
          var t3 = i2.substring(r2).match(e3);
          return t3 ? (r2 += t3[0].length, t3[0]) : null;
        }
        function a2() {
          s2(/^\s*/);
        }
        function o2() {
          a2();
          for (var e3, t3 = 0, i3 = [], n3 = [i3], r3 = i3; e3 = s2(/^(\()/) || s2(/^(\))/) || s2(/^(,)/) || s2(Av); ) {
            if ("(" === e3)
              n3.push(r3), r3 = [], n3[n3.length - 1].push(r3), t3++;
            else if (")" === e3) {
              if (0 === r3.length)
                return null;
              if (!(r3 = n3.pop()))
                return null;
              if (0 === --t3)
                break;
            } else if ("," === e3)
              r3 = [], n3[n3.length - 1].push(r3);
            else {
              if (e3.split(/\s/g).some(isNaN))
                return null;
              Array.prototype.push.apply(r3, e3.split(/\s/g).map(parseFloat));
            }
            a2();
          }
          return 0 !== t3 ? null : i3;
        }
        function l2() {
          for (var e3, t3, i3 = []; t3 = s2(Av) || s2(/^(,)/); )
            "," === t3 ? (i3.push(e3), e3 = []) : t3.split(/\s/g).some(isNaN) || (e3 || (e3 = []), Array.prototype.push.apply(e3, t3.split(/\s/g).map(parseFloat))), a2();
          return e3 ? (i3.push(e3), i3.length ? i3 : null) : null;
        }
        function h2() {
          return function() {
            if (!s2(/^(point(\sz)?)/i))
              return null;
            if (a2(), !s2(/^(\()/))
              return null;
            var e3 = l2();
            return e3 ? (a2(), s2(/^(\))/) ? { type: "Point", coordinates: e3[0] } : null) : null;
          }() || function() {
            if (!s2(/^(linestring(\sz)?)/i))
              return null;
            if (a2(), !s2(/^(\()/))
              return null;
            var e3 = l2();
            return e3 && s2(/^(\))/) ? { type: "LineString", coordinates: e3 } : null;
          }() || function() {
            if (!s2(/^(polygon(\sz)?)/i))
              return null;
            a2();
            var e3 = o2();
            return e3 ? { type: "Polygon", coordinates: e3 } : null;
          }() || function() {
            if (!s2(/^(multipoint)/i))
              return null;
            a2();
            var e3 = i2.substring(i2.indexOf("(") + 1, i2.length - 1).replace(/\(/g, "").replace(/\)/g, "");
            i2 = "MULTIPOINT (" + e3 + ")";
            var t3 = o2();
            return t3 ? (a2(), { type: "MultiPoint", coordinates: t3 }) : null;
          }() || function() {
            if (!s2(/^(multilinestring)/i))
              return null;
            a2();
            var e3 = o2();
            return e3 ? (a2(), { type: "MultiLineString", coordinates: e3 }) : null;
          }() || function() {
            if (!s2(/^(multipolygon)/i))
              return null;
            a2();
            var e3 = o2();
            return e3 ? { type: "MultiPolygon", coordinates: e3 } : null;
          }() || function() {
            var e3, t3 = [];
            if (!s2(/^(geometrycollection)/i))
              return null;
            if (a2(), !s2(/^(\()/))
              return null;
            for (; e3 = h2(); )
              t3.push(e3), a2(), s2(/^(,)/), a2();
            return s2(/^(\))/) ? { type: "GeometryCollection", geometries: t3 } : null;
          }();
        }
        return function(e3) {
          return e3 && n2.match(/\d+/) && (e3.crs = { type: "name", properties: { name: "urn:ogc:def:crs:EPSG::" + n2 } }), e3;
        }(h2());
      }
      const Rv = class extends fc {
        constructor(e2) {
          super(e2), __publicField(this, "_coordinatesKey", "coordinates"), __publicField(this, "_csvDataType"), __publicField(this, "_csvFeatures", []), __publicField(this, "_csvIndexMap", []), this.type = "CSVDataSource";
        }
        async _getFetchData(e2) {
          return await e2.text();
        }
        getOriginDataIndex(e2) {
          return e2 < this._templateDataLength ? this._csvIndexMap[e2] : [e2 - this._templateDataLength + this._csvFeatures.length, 0];
        }
        getOriginData(e2) {
          if (e2 < this._templateDataLength) {
            const t2 = this._csvIndexMap[e2];
            return this._csvFeatures[t2[0]];
          }
          return this._addCache[e2 - this._templateDataLength];
        }
        onClear() {
          this._csvDataType = void 0, this._csvFeatures = [];
        }
        _onProcessTemplateData(e2, t2) {
          return this._prepareFeatures(), this._parseFeature(e2, t2), e2;
        }
        _parseFeature(e2, t2) {
          let i2 = 0;
          for (let n2 = 0; n2 < this._csvFeatures.length; n2++) {
            const r2 = this._csvFeatures[n2], s2 = this._onDecomposeFeature(this._csvDataType, r2);
            for (let a2 = 0; a2 < s2.length; a2++) {
              const r3 = s2[a2];
              e2.position.push(r3.geometry[this.projectionName]), a2 > 0 && i2++, e2.index.push(n2 + i2), this._csvIndexMap[n2 + i2] = [n2, a2];
              let o2 = { position: r3.geometry[this.projectionName], index: n2 + i2 };
              for (const t3 of this._attributeMap.keys()) {
                let i3;
                r3.properties && void 0 !== r3.properties[this._attributeMap.get(t3)] && null !== r3.properties[this._attributeMap.get(t3)] ? i3 = r3.properties[this._attributeMap.get(t3)] : this._attributeMap.get(t3) instanceof Function && (i3 = this._attributeMap.get(t3)(r3.properties)), e2[t3].push(i3), o2[t3] = i3;
              }
              t2.push(o2);
            }
          }
        }
        _prepareFeatures() {
          this._csvFeatures = this.csvToFeatures(), this._getDataType();
        }
        csvToFeatures() {
          if (!this.origin)
            return [];
          let e2 = Tv(this.origin, { columns: true, skip_empty_lines: true });
          const t2 = [];
          for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = e2[i2], r2 = {};
            let s2;
            Object.keys(n2).forEach((e3) => {
              e3 === this._coordinatesKey ? s2 = { geometry: Ev.exports(n2[e3]), properties: r2 } : r2[e3] = n2[e3];
            }), Array.isArray(s2) ? t2.push(...s2) : t2.push(s2);
          }
          return $h(t2, this.projectionName);
        }
        _getDataType() {
          var e2, t2;
          this._csvDataType = super._getDataType(null == (t2 = null == (e2 = this._csvFeatures[0]) ? void 0 : e2.geometry) ? void 0 : t2.type);
        }
        get csvDataType() {
          return this._csvDataType;
        }
      };
      let Lv = Rv;
      __publicField(Lv, "fromUrl", async function(e2) {
        let t2 = new Rv();
        return await t2.load(e2), t2;
      });
      class Iv extends _c {
        constructor() {
          super(...arguments), __publicField(this, "isPoints", true), __publicField(this, "isEventEntitySupported", true);
        }
        get size() {
          return this.material.size;
        }
        set size(e2) {
          this.material.size = e2;
        }
        raycast(e2, t2) {
          const i2 = e2.params.Points.threshold;
          let n2 = i2 * this.size;
          this.material.uniforms.zoomUnits && (n2 *= this.material.uniforms.zoomUnits.value), e2.params.Points.threshold = n2, ha.prototype.raycast.call(this, e2, t2), e2.params.Points.threshold = i2;
        }
        getEntityByIndex(e2) {
          const t2 = this.dataSource.data, i2 = {};
          for (const n2 of Object.keys(t2))
            i2[n2] = t2[n2][e2];
          return i2;
        }
      }
      class Dv extends ri {
        constructor(e2) {
          super(e2), this.parameters = e2;
        }
        setData(e2) {
          const { vertexSizes: t2, vertexColors: i2, vertexOffsets: n2 } = this.parameters, { aPositions: r2, aObjectIndices: s2, aMapIndexs: a2, aColors: o2, aSizes: l2, aOffsets: h2 } = e2;
          this.setAttribute("position", new Jt(r2, 3)), this.setAttribute("objectIndex", new Jt(s2, 1)), this.setAttribute("aMapIndex", new Jt(a2, 1)), i2 && this.setAttribute("aColor", new Jt(o2, 4)), t2 && this.setAttribute("aSize", new Jt(l2, 1)), n2 && this.setAttribute("aOffset", new Jt(h2, 2));
        }
      }
      const Fv = new qa(), Ov = Ci.merge([Xi.fog, yh, { emissive: { value: [0, 0, 0] }, isEmissive: { value: false }, color: { value: [0, 1, 1, 1] }, size: { value: 30 }, uOffset: { value: [0, 0] }, ulength: { value: 0 }, useCanvasMap: { value: false }, vertexColors: { value: false }, vertextSizes: { value: false }, vertextOffsets: { value: false }, uShapeType: { value: 2 }, opacity: { value: 1 }, map: { value: null }, useMap: { value: false } }]);
      class Uv extends yc {
        constructor(e2) {
          super(), this.type = "IconPointMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    attribute float aSize;\n    varying float vSize;\n#endif\n\n#ifdef MVT_USE_VERTEX_OFFSET\n    attribute vec2 aOffset;\n#else\n    uniform vec2 uOffset;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n    varying vec4 vColor;\n#endif\n\n#ifdef MVT_USE_VERTEX_ICON\n    attribute float aMapIndex;\n    varying float vMapIndex;\n#endif\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    #ifdef MVT_USE_VERTEX_OFFSET\n        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;\n    #else\n        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;\n    #endif\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.xy = gl_Position.xy - offset;\n\n    #ifdef MVT_USE_VERTEX_SIZE\n        vSize = aSize * pixelRatio;\n        gl_PointSize = vSize;\n    #else\n        gl_PointSize = size * pixelRatio;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_ICON\n        vMapIndex = aMapIndex;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\nuniform vec4 color;\nuniform float uShapeType;\nuniform float opacity;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    varying float vSize;\n#else\n    uniform float size;\n#endif\n\n#ifdef MVT_USE_VERTEX_ICON\n    varying float vMapIndex;\n    uniform float ulength;\n#endif\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        gl_FragColor = vColor;\n    #else\n        gl_FragColor = color;\n    #endif\n\n    if (uShapeType == 2.) {\n        float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n        #ifdef MVT_USE_VERTEX_SIZE\n            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);\n        #else\n            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);\n        #endif\n        \n        if (alpha <= 0.) {\n            discard;\n        } else {\n            gl_FragColor.a *= alpha;\n        }\n    }\n \n    if (useMap) {\n        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);\n     //    gl_FragColor.a += tColor.a;\n        \n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);\n        // gl_FragColor.a += tColor.a;\n        // gl_FragColor = tColor;\n    }\n\n    #ifdef MVT_USE_VERTEX_ICON\n    if(useCanvasMap) {\n        vec4 tColor = texture2D(map, vec2(vMapIndex / ulength + 1.0 / ulength * gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n    }\n    #endif\n    \n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n}", this.isIconPointMaterial = true, this.transparent = true, Object.assign(this.uniforms, Ci.clone(Ov)), Eh(this), Mh(this, ["size", "uShapeType", "opacity", "emissive", "isEmissive"]), Sh(this, ["color"]), wh(this, [["offset", "uOffset"]]), Th(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"], ["vertexSizes", "MVT_USE_VERTEX_SIZE"], ["vertexIcons", "MVT_USE_VERTEX_ICON"], ["vertexOffsets", "MVT_USE_VERTEX_OFFSET"]]), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc, i2 = this.userData[this.urlCacheKey], n2 = this;
            if (i2 !== e3) {
              if (t2 && t2.dispose(), !e3)
                return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData[this.urlCacheKey];
              Fv.load(e3, function(t3) {
                t3.wrapS = t3.wrapT = h, n2.uniforms.map.value = t3, n2.userData[n2.urlCacheKey] = e3, n2.uniforms.useMap.value = true, n2.uniforms.useCanvasMap.value = false;
              });
            }
          } }, mapTexture: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            if (!e3)
              return this.uniforms.map.value = null, void (this.uniforms.useCanvasMap.value = false);
            e3.wrapS = e3.wrapT = h, this.uniforms.map.value = e3, this.uniforms.useMap.value = false, this.uniforms.useCanvasMap.value = true, delete this.userData[this.urlCacheKey];
          } } }), this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class zv extends Iv {
        constructor(e2) {
          super(e2), __publicField(this, "canvas"), __publicField(this, "ctx"), __publicField(this, "oldMapTextureRes"), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "vertexColors"), __publicField(this, "size"), __publicField(this, "vertexSizes"), __publicField(this, "mapSrc"), __publicField(this, "vertexIcons"), __publicField(this, "opacity"), __publicField(this, "getTextureAndHash", (e3, t2, i2, n2) => {
            const r2 = /* @__PURE__ */ new Map();
            if (!n2 && this.oldMapTextureRes)
              return this.oldMapTextureRes;
            if (!e3[0] || !e3[0][t2])
              return { texture: this.texture, iconUrlHash: r2 };
            const s2 = this;
            let a2 = 0;
            for (let o2 = 0; o2 < e3.length; o2++) {
              const i3 = e3[o2][t2];
              void 0 === r2.get(i3) && (r2.set(i3, a2), a2++);
            }
            return this.canvas.width = r2.size * i2, this.canvas.height = i2, this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), Array.from(r2).forEach((e4, t3) => {
              let n3 = new Image();
              n3.setAttribute("crossOrigin", "Anonymous"), n3.onload = function() {
                s2.ctx.drawImage(n3, t3 * i2, 0, i2, i2), s2.texture.needsUpdate = true;
              }, n3.src = e4[0];
            }), this.texture.dispose(), this.texture = new da(this.canvas), this.oldMapTextureRes = { texture: this.texture, iconUrlHash: r2 }, { texture: this.texture, iconUrlHash: r2 };
          }), this.parameters = e2, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.texture = new da(this.canvas), this.defineMaterialProxyProperties(["color", "size", "offset", "uShapeType", "opacity", "vertexColors", "vertexSizes", "vertexOffsets", "vertexIcons", "mapSrc", "mapTexture"]);
        }
        initObject() {
          this.geometry = new Dv(this.parameters), this.material = new Uv(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        collisionTest(e2) {
          let t2 = 0;
          return t2 = this.parameters.vertexSizes && e2.size ? e2.size : this.size, { width: t2, height: t2 };
        }
        setData() {
          const e2 = this.dataSource.data, { vertexIcons: t2, vertexColors: i2, vertexSizes: n2, vertexOffsets: r2, inconPropName: s2 = "icon", size: a2 = 30 } = this.parameters;
          let o2 = [];
          o2 = this._enableCollision && this._collisionData ? this._collisionData : this.dataSource.userData;
          const l2 = [], h2 = [];
          let c2 = "", u2 = {};
          const d2 = [], p2 = [], m2 = [], f2 = [];
          if (t2) {
            const e3 = this.getTextureAndHash(o2, s2, a2, true);
            c2 = e3.texture, u2 = e3.iconUrlHash, this.material.mapTexture = c2, this.material.uniforms.ulength.value = u2.size;
          }
          for (let g2 = 0; g2 < o2.length; g2++) {
            const a3 = o2[g2].position, c3 = o2[g2].position, _2 = e2.color ? o2[g2].color : this.parameters.color, v2 = e2.size ? o2[g2].size : this.parameters.size, x2 = e2.offset ? o2[g2].offset : this.parameters.offset;
            if (l2.push(...a3), h2.push(c3), t2 && d2.push(u2.get(o2[g2][s2])), i2) {
              let e3 = mh(_2);
              p2.push(...e3.toArray());
            }
            n2 && m2.push(v2), r2 && f2.push(x2);
          }
          this.geometry.setData({ aPositions: l2, aObjectIndices: h2, aMapIndexs: d2, aColors: p2, aSizes: m2, aOffsets: f2 }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, l2), this.needsUpdate = false;
        }
        onDispose() {
          this.texture && this.texture.dispose();
        }
      }
      class Nv {
        constructor(e2 = 0, t2 = 0) {
          this.isVector2 = true, this.x = e2, this.y = t2;
        }
        get width() {
          return this.x;
        }
        set width(e2) {
          this.x = e2;
        }
        get height() {
          return this.y;
        }
        set height(e2) {
          this.y = e2;
        }
        set(e2, t2) {
          return this.x = e2, this.y = t2, this;
        }
        setScalar(e2) {
          return this.x = e2, this.y = e2, this;
        }
        setX(e2) {
          return this.x = e2, this;
        }
        setY(e2) {
          return this.y = e2, this;
        }
        setComponent(e2, t2) {
          switch (e2) {
            case 0:
              this.x = t2;
              break;
            case 1:
              this.y = t2;
              break;
            default:
              throw new Error("index is out of range: " + e2);
          }
          return this;
        }
        getComponent(e2) {
          switch (e2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e2) {
          return this.x = e2.x, this.y = e2.y, this;
        }
        add(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this);
        }
        addScalar(e2) {
          return this.x += e2, this.y += e2, this;
        }
        addVectors(e2, t2) {
          return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
        }
        addScaledVector(e2, t2) {
          return this.x += e2.x * t2, this.y += e2.y * t2, this;
        }
        sub(e2, t2) {
          return void 0 !== t2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this);
        }
        subScalar(e2) {
          return this.x -= e2, this.y -= e2, this;
        }
        subVectors(e2, t2) {
          return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
        }
        multiply(e2) {
          return this.x *= e2.x, this.y *= e2.y, this;
        }
        multiplyScalar(e2) {
          return this.x *= e2, this.y *= e2, this;
        }
        divide(e2) {
          return this.x /= e2.x, this.y /= e2.y, this;
        }
        divideScalar(e2) {
          return this.multiplyScalar(1 / e2);
        }
        applyMatrix3(e2) {
          const t2 = this.x, i2 = this.y, n2 = e2.elements;
          return this.x = n2[0] * t2 + n2[3] * i2 + n2[6], this.y = n2[1] * t2 + n2[4] * i2 + n2[7], this;
        }
        min(e2) {
          return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
        }
        max(e2) {
          return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
        }
        clamp(e2, t2) {
          return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
        }
        clampScalar(e2, t2) {
          return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
        }
        clampLength(e2, t2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e2) {
          return this.x * e2.x + this.y * e2.y;
        }
        cross(e2) {
          return this.x * e2.y - this.y * e2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e2) {
          return Math.sqrt(this.distanceToSquared(e2));
        }
        distanceToSquared(e2) {
          const t2 = this.x - e2.x, i2 = this.y - e2.y;
          return t2 * t2 + i2 * i2;
        }
        manhattanDistanceTo(e2) {
          return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
        }
        setLength(e2) {
          return this.normalize().multiplyScalar(e2);
        }
        lerp(e2, t2) {
          return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
        }
        lerpVectors(e2, t2, i2) {
          return this.x = e2.x + (t2.x - e2.x) * i2, this.y = e2.y + (t2.y - e2.y) * i2, this;
        }
        equals(e2) {
          return e2.x === this.x && e2.y === this.y;
        }
        fromArray(e2, t2 = 0) {
          return this.x = e2[t2], this.y = e2[t2 + 1], this;
        }
        toArray(e2 = [], t2 = 0) {
          return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
        }
        fromBufferAttribute(e2, t2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this;
        }
        rotateAround(e2, t2) {
          const i2 = Math.cos(t2), n2 = Math.sin(t2), r2 = this.x - e2.x, s2 = this.y - e2.y;
          return this.x = r2 * i2 - s2 * n2 + e2.x, this.y = r2 * n2 + s2 * i2 + e2.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      function kv(e2, t2, i2 = 2e-7) {
        return Bv(e2, t2) < i2;
      }
      function Bv(e2, t2) {
        return Math.sqrt(Math.pow(e2[0] - t2[0], 2) + Math.pow(e2[1] - t2[1], 2) + Math.pow((e2[2] || 0) - (t2[2] || 0), 2));
      }
      function Vv(e2, t2, i2) {
        return e2 + (t2 - e2) * i2;
      }
      function Gv(e2, t2, i2) {
        return [e2[0] + (t2[0] - e2[0]) * i2, e2[1] + (t2[1] - e2[1]) * i2];
      }
      function Hv(e2, t2, i2) {
        return [e2[0] + (t2[0] - e2[0]) * i2, e2[1] + (t2[1] - e2[1]) * i2, e2[2] + (t2[2] - e2[2]) * i2];
      }
      function jv(e2, t2) {
        let i2 = new Nv();
        return i2.fromArray([t2[0] - e2[0], t2[1] - e2[1]]), i2.normalize(), i2;
      }
      function Wv(e2) {
        return new Nv(-e2.y, e2.x);
      }
      function Xv(e2, t2) {
        let i2 = new Nv();
        return i2.addVectors(e2, t2), i2.normalize(), Wv(i2);
      }
      class qv extends ri {
        constructor() {
          super(...arguments), __publicField(this, "_volumeSegmentLines", (e2, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2) => {
            let u2 = 0, d2 = new ie();
            const p2 = [a2[0], a2[1]];
            let m2 = jv([s2[0], s2[1]], p2);
            if (c2 && (d2 = Wv(m2), this._volumeExtrusions(e2, t2, n2, i2, s2, d2, l2)), o2) {
              let r3 = jv(p2, [o2[0], o2[1]]), s3 = new ie();
              s3.addVectors(m2, r3), s3.normalize();
              const h3 = Xv(m2, r3), c3 = Wv(m2), d3 = Math.min(l2, l2 / h3.dot(c3));
              this._volumeExtrusions(e2, t2, n2, i2, a2, h3, d3), u2 += 2;
            } else
              d2 = Wv(m2), this._volumeExtrusions(e2, t2, n2, i2, a2, d2, l2), u2 += 2;
            return u2;
          }), __publicField(this, "_volumeExtrusions", (e2, t2, i2, n2, r2, s2, a2) => {
            i2.push(s2.x, s2.y, 0, -s2.x, -s2.y, 0), e2.push(r2[0] + s2.x * a2 / 2, r2[1] + s2.y * a2 / 2, r2[2]), t2.push(r2[0] - s2.x * a2 / 2, r2[1] - s2.y * a2 / 2, r2[2]), n2.push(a2, a2);
          });
        }
        createVolumeGeometry(e2, t2) {
          let i2 = this.parameters.lineWidth * t2, n2 = [];
          for (let r2 = 0; r2 < e2.length; r2++) {
            const { vertices: t3 } = this.lineToShadowVolumeMesh(e2[r2], i2);
            n2.push([t3]);
          }
          return n2;
        }
        lineToShadowVolumeMesh(e2, t2) {
          let i2 = 0, n2 = null, r2 = null, s2 = null, a2 = null;
          const o2 = [], l2 = [], h2 = [], c2 = [], u2 = [], d2 = [];
          let p2 = true;
          for (let g2 = 1, _2 = e2.length - 1; g2 <= _2; g2++) {
            if (n2 = a2 || e2[g2 - 1], r2 = e2[g2], s2 = e2[g2 + 1], s2 && kv(r2, s2)) {
              a2 = n2;
              continue;
            }
            const o3 = this._volumeSegmentLines(u2, d2, c2, l2, h2, n2, r2, s2, t2, i2, p2);
            -1 !== o3 && (i2 += o3, a2 = null), p2 = false;
          }
          const m2 = this.conversion(u2, 3), f2 = this.conversion(d2, 3);
          return o2.push(...m2.concat(f2.reverse())), o2.push(o2[0]), { vertices: o2, indices: h2, normals: l2, widths: c2 };
        }
        conversion(e2, t2) {
          let i2 = e2.length, n2 = i2 % t2 == 0 ? i2 / t2 : Math.floor(i2 / t2 + 1), r2 = [];
          for (let s2 = 0; s2 < n2; s2++) {
            let i3 = e2.slice(s2 * t2, s2 * t2 + t2);
            r2.push(i3);
          }
          return r2;
        }
      }
      class Yv extends qv {
        constructor(e2) {
          super(), __publicField(this, "isFatLineGeometry", true), __publicField(this, "_segmentLines", (e3, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2, u2, d2, p2) => {
            let m2 = 0, f2 = new ie(), g2 = new ie(), _2 = new ie();
            const v2 = "square" === this.parameters.lineCap, x2 = "round" === this.parameters.lineCap, y2 = "bevel" === this.parameters.lineJoin, b2 = "round" === this.parameters.lineJoin, M2 = [h2[0], h2[1]], S2 = [l2[0], l2[1]];
            let w2 = jv(S2, M2), T2 = 0;
            if (this._needsCounter && (T2 = Bv(M2, S2), this._flags.totalDistance += T2), this._flags.normal || (this._flags.normal = new ie(), this._flags.normal = Wv(w2)), !this._flags.started)
              if (this._flags.started = true, v2) {
                const o3 = new ie(), h3 = new ie();
                o3.addVectors(this._flags.normal, w2), h3.subVectors(this._flags.normal, w2), s2.push(h3.x, h3.y, 0, -o3.x, -o3.y, 0), e3.push(l2[0], l2[1], l2[2], l2[0], l2[1], l2[2]), t2.push(this._flags.totalDistance - T2, 0, this._flags.totalDistance - T2, 1), i2.push(this._flags.totalDistance - T2, this._flags.totalDistance - T2), r2.push(u2, u2), n2.push(0, 0), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3]);
              } else if (x2) {
                const h3 = w2.clone();
                h3.negate();
                const c3 = new ie();
                c3.subVectors(this._flags.normal, w2), c3.normalize();
                const f3 = new ie();
                f3.addVectors(this._flags.normal, w2), f3.normalize();
                const g3 = this._flags.normal.clone(), _3 = this._flags.normal.clone();
                _3.negate(), s2.push(h3.x, h3.y, 0), s2.push(c3.x, c3.y, 0), s2.push(-f3.x, -f3.y, 0), s2.push(g3.x, g3.y, 0), s2.push(_3.x, _3.y, 0);
                for (let s3 = 0; s3 < 5; s3++)
                  e3.push(l2[0], l2[1], l2[2]), r2.push(u2), t2.push(this._flags.totalDistance - T2, 0), i2.push(this._flags.totalDistance - T2), n2.push(0), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3]);
                o2.push(p2 + 0, p2 + 2, p2 + 1, p2 + 1, p2 + 2, p2 + 3, p2 + 3, p2 + 2, p2 + 4), m2 += 3, p2 += 3;
              } else
                this._extrusions(e3, s2, t2, i2, n2, r2, a2, l2, this._flags.normal, this._flags.totalDistance - T2, u2, d2);
            if (o2.push(...-1 === this._flags.lastFlip ? [p2 + 0, p2 + 1, p2 + 2] : [p2 + 1, p2 + 0, p2 + 2]), c2) {
              g2 = jv(M2, [c2[0], c2[1]]), _2.addVectors(w2, g2), _2.normalize();
              const l3 = Xv(w2, g2), v3 = Wv(w2), x3 = u2 / l3.dot(v3);
              let S3 = _2.dot(this._flags.normal) > 0 ? -1 : 1, T3 = y2;
              if (!T3 && "miter" === this.parameters.lineJoin) {
                (Math.abs(x3) > this.parameters.miterLimit || 2 * u2) && (T3 = true);
              }
              if (T3) {
                const c3 = Math.min(2 * u2, Math.abs(x3));
                s2.push(this._flags.normal.x * S3, this._flags.normal.y * S3, 0), s2.push(-l3.x * S3, -l3.y * S3, 0), e3.push(h2[0], h2[1], h2[2], h2[0], h2[1], h2[2]), r2.push(u2, c3), i2.push(this._flags.totalDistance, this._flags.totalDistance), n2.push(0, 0), o2.push(...this._flags.lastFlip === -S3 ? -1 === this._flags.lastFlip ? [p2 + 2, p2 + 1, p2 + 3] : [p2 + 1, p2 + 2, p2 + 3] : -1 === this._flags.lastFlip ? [p2 + 0, p2 + 2, p2 + 3] : [p2 + 2, p2 + 0, p2 + 3]), f2 = Wv(g2), this._flags.normal.copy(f2), s2.push(this._flags.normal.x * S3, this._flags.normal.y * S3, 0), e3.push(h2[0], h2[1], h2[2]), r2.push(u2), i2.push(this._flags.totalDistance), n2.push(0), o2.push(...1 === S3 ? [p2 + 2, p2 + 3, p2 + 4] : [p2 + 3, p2 + 2, p2 + 4]), this._flipedUV(t2, this._flags.totalDistance, S3, true), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3]), m2 += 3;
              } else if (b2) {
                const c3 = Math.min(2 * u2, Math.abs(x3));
                s2.push(this._flags.normal.x * S3, this._flags.normal.y * S3, 0), e3.push(h2[0], h2[1], h2[2]), r2.push(u2), i2.push(this._flags.totalDistance), n2.push(0), s2.push(l3.x * S3, l3.y * S3, 0), e3.push(h2[0], h2[1], h2[2]), r2.push(u2), i2.push(this._flags.totalDistance), n2.push(0), s2.push(-l3.x * S3, -l3.y * S3, 0), e3.push(h2[0], h2[1], h2[2]), r2.push(c3), i2.push(this._flags.totalDistance), n2.push(0), o2.push(...this._flags.lastFlip === -S3 ? -1 === this._flags.lastFlip ? [p2 + 2, p2 + 1, p2 + 4, p2 + 2, p2 + 4, p2 + 3] : [p2 + 1, p2 + 2, p2 + 4, p2 + 4, p2 + 2, p2 + 3] : -1 === this._flags.lastFlip ? [p2 + 0, p2 + 2, p2 + 4, p2 + 2, p2 + 3, p2 + 4] : [p2 + 2, p2 + 0, p2 + 4, p2 + 3, p2 + 2, p2 + 4]), f2 = Wv(g2), this._flags.normal.copy(f2), s2.push(this._flags.normal.x * S3, this._flags.normal.y * S3, 0), e3.push(h2[0], h2[1], h2[2]), r2.push(u2), i2.push(this._flags.totalDistance), n2.push(0), o2.push(...-1 === S3 ? [p2 + 4, p2 + 3, p2 + 5] : [p2 + 3, p2 + 4, p2 + 5]), this._flipedUV(t2, this._flags.totalDistance, S3, false), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3]), m2 += 4;
              } else
                this._extrusions(e3, s2, t2, i2, n2, r2, a2, h2, l3, this._flags.totalDistance, x3, d2), o2.push(...-1 === this._flags.lastFlip ? [p2 + 2, p2 + 1, p2 + 3] : [p2 + 2, p2 + 0, p2 + 3]), S3 = -1, this._flags.normal.copy(l3), m2 += 2;
              this._flags.lastFlip = S3;
            } else {
              if (this._flags.normal = Wv(w2), v2) {
                const o3 = new ie(), l3 = new ie();
                o3.addVectors(w2, this._flags.normal), l3.subVectors(w2, this._flags.normal), s2.push(o3.x, o3.y, 0, l3.x, l3.y, 0), e3.push(h2[0], h2[1], h2[2], h2[0], h2[1], h2[2]), r2.push(u2, u2), t2.push(this._flags.totalDistance, 0, this._flags.totalDistance, 1), i2.push(this._flags.totalDistance, this._flags.totalDistance), n2.push(0, 0), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3], d2[0], d2[1], d2[2], d2[3]);
              } else
                this._extrusions(e3, s2, t2, i2, n2, r2, a2, h2, this._flags.normal, this._flags.totalDistance, u2, d2);
              if (o2.push(...-1 === this._flags.lastFlip ? [p2 + 2, p2 + 1, p2 + 3] : [p2 + 2, p2 + 0, p2 + 3]), m2 += 2, x2) {
                const l3 = new ie();
                l3.addVectors(w2, this._flags.normal), l3.normalize();
                const c3 = new ie();
                c3.subVectors(w2, this._flags.normal), c3.normalize();
                const f3 = w2.clone();
                s2.push(l3.x, l3.y, 0), s2.push(c3.x, c3.y, 0), s2.push(f3.x, f3.y, 0);
                for (let s3 = 0; s3 < 3; s3++)
                  e3.push(h2[0], h2[1], h2[2]), r2.push(u2), t2.push(this._flags.totalDistance, 0), i2.push(this._flags.totalDistance), n2.push(0), this.parameters.vertexColors && a2.push(d2[0], d2[1], d2[2], d2[3]);
                o2.push(p2 + 2, p2 + 3, p2 + 4, p2 + 4, p2 + 3, p2 + 5, p2 + 4, p2 + 5, p2 + 6), m2 += 3;
              }
            }
            return m2;
          }), __publicField(this, "_extrusions", (e3, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2, u2) => {
            t2.push(l2.x, l2.y, 0, -l2.x, -l2.y, 0), e3.push(o2[0], o2[1], o2[2], o2[0], o2[1], o2[2]), s2.push(c2, c2), i2.push(h2, 0, h2, 1), n2.push(h2, h2), r2.push(0, 0), this.parameters.vertexColors && a2.push(u2[0], u2[1], u2[2], u2[3], u2[0], u2[1], u2[2], u2[3]);
          }), this.parameters = e2, this._needsUpdate = false, this._needsCounter = false, this._flags = { lastFlip: -1, started: false, normal: null, totalDistance: 0 };
        }
        setData(e2) {
          this._needsUpdate = true, (this.parameters.dashed || this.parameters.enableAnimation || this.parameters.mapSrc || this.parameters.map) && (this._needsCounter = true), this.updateGeometry(e2);
        }
        updateGeometry(e2) {
          const t2 = [], i2 = [], n2 = [], r2 = [], s2 = [], a2 = [], o2 = [], l2 = [], h2 = [], c2 = [], u2 = [];
          let d2 = 0;
          for (let p2 = 0; p2 < e2.position.length; p2++) {
            const m2 = e2.position[p2], f2 = e2.index[p2], g2 = this.parameters.vertexWidths ? e2.lineWidth[p2] : this.parameters.lineWidth, _2 = this.parameters.vertexColors ? gh(e2.color[p2]) : gh(this.parameters.color);
            this._flags = { lastFlip: -1, started: false, normal: null, totalDistance: 0 };
            const v2 = m2.length;
            let x2 = t2.length / 3, y2 = null, b2 = Math.random();
            c2.push(b2, b2), n2.push(0, 0), u2.push(f2, f2);
            for (let e3 = 1; e3 < v2; e3++) {
              const p3 = y2 || m2[e3 - 1], M2 = m2[e3], S2 = e3 < v2 - 1 ? m2[e3 + 1] : null;
              if (S2 && kv(M2, S2)) {
                y2 = p3;
                continue;
              }
              const w2 = this._segmentLines(t2, i2, a2, h2, s2, l2, o2, r2, p3, M2, S2, g2, _2, x2);
              -1 !== w2 && (x2 += w2, y2 = null);
              for (let t3 = 0; t3 < w2; t3++)
                n2.push(e3 / v2), this._needsCounter && this.parameters.enableAnimationChaos && c2.push(b2), u2.push(f2);
              d2 = Math.max(this._flags.totalDistance, d2);
            }
            if (this._needsCounter)
              for (let e3 = 0; e3 < h2.length; e3++)
                h2[e3] = d2;
          }
          this.cachedPositions = t2, this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("uv", new Jt(i2, 2)), this.setAttribute("normal", new Jt(l2, 3)), this.setAttribute("aWidth", new Jt(s2, 1)), this.setAttribute("counter", new Jt(n2, 1)), this.setAttribute("objectIndex", new Jt(u2, 1)), this._needsCounter && (this.setAttribute("lengths", new Jt(a2, 1)), this.setAttribute("totalLength", new Jt(h2, 1)), this.setAttribute("randomFactor", new Jt(c2, 1))), this.parameters.vertexColors && this.setAttribute("aColor", new Jt(o2, 4)), this.setIndex(r2), this.computeBoundingSphere(), this._needsUpdate = false;
        }
        _flipedUV(e2, t2, i2, n2) {
          n2 ? -1 === i2 ? e2.push(t2, 1, t2, 0, t2, 1) : e2.push(t2, 0, t2, 1, t2, 0) : -1 === i2 ? e2.push(t2, 1, t2, 1, t2, 0, t2, 1) : e2.push(t2, 0, t2, 0, t2, 1, t2, 0);
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      const Zv = new qa(), Jv = Ci.merge([Xi.fog, yh, xh, { lineWidth: { value: 100 }, keepSize: { value: false }, map: { value: null }, useMap: { value: false }, uColor: { value: [0, 1, 1, 1] }, height: { value: 0 }, opacity: { value: 1 }, resolution: { value: new ie(1, 1) }, sizeAttenuation: { value: 1 }, dashArray: { value: 20 }, dashOffset: { value: 0 }, dashRatio: { value: 0.5 }, alphaTest: { value: 0 }, repeat: { value: new ie(1, 1) }, vertextColors: { value: false }, vertextZIndex: { value: false }, maxLayerIndex: { value: 0 }, elapsedTime: { value: 0 }, enableAnimation: { value: false }, enableAnimationChaos: { value: false }, animationInterval: { value: 0 }, animationSpeed: { value: 1 }, animationTailType: { value: 1 }, animationTailRatio: { value: 0.2 }, animationTailLength: { value: 100 }, animationIdle: { value: 1e3 } }]);
      class Kv extends yc {
        constructor(e2) {
          super(), this.type = "FatLineMaterial", this.isFatLineMaterial = true, this.fog = true, this.transparent = true, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform bool keepSize;\nuniform float lineWidth;\nuniform float opacity;\nuniform float alphaTest;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\n\n#ifdef USE_ANIMATION\nuniform float animationInterval;\nvarying float vAnimationOpacity;\n#endif\n\n#ifdef USE_DASH\nuniform float dashArray;\nuniform float dashOffset;\nuniform float dashRatio;\nvarying float vDashOpacity;\n#endif\n\nvoid main() {\n\n   vec4 c = vColor;\n\n    if(useMap) {\n        // icon之间的间隔，经验值为间隔50倍宽度，比较稀疏且好看\n        float margin = lineWidth * 50.0;\n        float halfMargin = margin / 2.0;\n        float texWidth = lineWidth;\n        if (keepSize) {\n            margin *= vZoomUnits;\n            texWidth *= vZoomUnits;\n        }\n        float delta = mod(vUV.x, texWidth + margin);\n        if (delta >= halfMargin && delta <= halfMargin + texWidth) {\n            float uvx = (delta - halfMargin) / texWidth;\n            vec4 texture = texture2D(map, vec2(uvx, vUV.y));\n            c = texture.a >= 0.5 ? texture : c;\n        }\n    }\n\n    #ifdef USE_ANIMATION\n        float animationAlpha = vAnimationOpacity;\n        if (animationInterval > 0.0) {\n            animationAlpha = mod(vAnimationOpacity, animationInterval);\n        }\n        if (animationAlpha > 1.0 || animationAlpha < 0.0) {\n            discard;\n        }\n        c.a *= animationAlpha;\n    #endif\n\n    #ifdef USE_DASH\n        float darray = dashArray;\n        if (keepSize) {\n            darray *= vZoomUnits;\n        }\n        c.a *= step(mod(vLength + dashOffset, darray), (darray * dashRatio));\n    #endif\n\n    if (c.a < alphaTest) {\n        discard;\n    }\n\n    gl_FragColor = c;\n    \n    gl_FragColor.a *= opacity;\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n    \n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef USE_A_COLOR\nattribute vec4 aColor;\n#endif\n\nattribute float totalLength;\nattribute float aWidth;\nattribute float lengths;\nattribute float randomFactor;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform vec4 uColor;\nuniform float lineWidth;\nuniform float height;\nuniform float opacity;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#ifdef MVT_USE_VERTEX_ZINDEX\nattribute float zIndex;\nuniform float maxLayerIndex;\n\n#define WORLD_DISTANCE_NEAR 100000.0\n#define WORLD_DISTANCE_MID 1500000.0\n#define WORLD_DISTANCE_FAR 6000000.0\n#define LAYER_INDEX (maxLayerIndex - zIndex)\n// 在mid和far交接那块，因为线数据特别碎，导致layerIndex很多，地面会陷很深，还没找到比较好的函数来解决这个case\n\nfloat y1(float x) {\n    return pow(LAYER_INDEX * log2(x * 5.), 1.5);\n}\n\nfloat y2(float x) {\n    float xx = x - WORLD_DISTANCE_NEAR;\n    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);\n}\n\nfloat y3(float x) {\n    float xx = x - WORLD_DISTANCE_MID;\n    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);\n}\n\nfloat y4(float x) {\n    return 100000. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);\n}\n\n/**\ny1 = pow(x, 2)                  x: (0, near]\ny2 = (x - near) + y1(near)      x: (near, mid]\ny3 = sqrt(x - mid) + y2(mid)    x: (mid, far]\ny4 = n + y3(far)                x: (far, +∞)\n*/\nfloat y(float x) {\n    if (x <= WORLD_DISTANCE_NEAR) {\n        return y1(x);\n    }\n    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {\n        return y2(x);\n    }\n    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {\n        return y3(x);\n    }\n    else if (x > WORLD_DISTANCE_FAR) {\n        return y4(x);\n    }\n}\n#endif\n\nvoid main() {\n\n    #ifdef USE_A_COLOR\n        vColor = aColor;\n    #else\n        vColor = uColor;\n    #endif\n\n    vUV = uv;\n    // vCounter = counter;\n    vLength = lengths;\n    vTotalLength = totalLength;\n\n    #include <begin_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    vZoomUnits = pixelSize;\n\n    vec2 extrude = normal.xy * aWidth / 2.0;\n    if (keepSize) {\n        extrude *= pixelSize;\n    }\n    worldPosition.xy += extrude;\n    worldPosition.z += height;\n\n    #ifdef MVT_USE_VERTEX_ZINDEX\n        vec3 worldToEye = cameraPosition - worldPosition.xyz;\n        float dis = length(worldToEye);\n        float layerGap = maxLayerIndex - zIndex;\n        // float zOffset = log2(layerGap * dis + 1.0);\n        // float zOffset = exp(layerGap * log2(dis * 10.0));\n        // float zOffset = pow(layerGap * log2(dis * 5.0), 1.5);\n        float zOffset = y(dis);\n        worldPosition.z -= zOffset;\n    #endif\n    \n    #ifdef USE_ANIMATION\n        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;\n\n        #ifdef ANIMATION_CHAOS\n            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;\n        #else\n            float currentTime = elapsedTime;\n        #endif\n        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);\n        vAnimationOpacity = (vLength - (currentLength - tailLength)) / tailLength;\n    #endif\n\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n\n    #include <beginnormal_vertex>\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n}", Object.assign(this.uniforms, Ci.clone(Jv)), Mh(this, ["map", "lineWidth", "keepSize", "height", "opacity", "dashArray", "dashOffset", "dashRatio", "alphaTest", "maxLayerIndex", "animationInterval", "animationSpeed", "animationTailType", "animationTailRatio", "animationTailLength", "animationIdle"]), wh(this, [["color", "uColor", mh]]), Th(this, [["vertexColors", "USE_A_COLOR"], ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"], ["enableAnimation", "USE_ANIMATION"], ["enableAnimationChaos", "ANIMATION_CHAOS"], ["dashed", "USE_DASH"]]), Ah(this), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc;
            if (this.userData.url_map === e3)
              return;
            if (t2 && t2.dispose(), !e3)
              return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData.url_map;
            const i2 = Zv.load(e3);
            i2.wrapS = i2.wrapT = h, this.uniforms.map.value = i2, this.userData.url_map = e3, this.uniforms.useMap.value = true;
          } } }), this.emissiveEnabled = true, this.emissive = [0, 0, 0], this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      var Qv = { exports: {} };
      function $v(e2, t2, i2) {
        i2 = i2 || 2;
        var n2, r2, s2, a2, o2, l2, h2, c2 = t2 && t2.length, u2 = c2 ? t2[0] * i2 : e2.length, d2 = ex(e2, 0, u2, i2, true), p2 = [];
        if (!d2 || d2.next === d2.prev)
          return p2;
        if (c2 && (d2 = function(e3, t3, i3, n3) {
          var r3, s3, a3, o3 = [];
          for (r3 = 0, s3 = t3.length; r3 < s3; r3++)
            (a3 = ex(e3, t3[r3] * n3, r3 < s3 - 1 ? t3[r3 + 1] * n3 : e3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(ux(a3));
          for (o3.sort(ox), r3 = 0; r3 < o3.length; r3++)
            i3 = lx(o3[r3], i3);
          return i3;
        }(e2, t2, d2, i2)), e2.length > 80 * i2) {
          n2 = s2 = e2[0], r2 = a2 = e2[1];
          for (var m2 = i2; m2 < u2; m2 += i2)
            (o2 = e2[m2]) < n2 && (n2 = o2), (l2 = e2[m2 + 1]) < r2 && (r2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
          h2 = 0 !== (h2 = Math.max(s2 - n2, a2 - r2)) ? 32767 / h2 : 0;
        }
        return ix(d2, p2, i2, n2, r2, h2, 0), p2;
      }
      function ex(e2, t2, i2, n2, r2) {
        var s2, a2;
        if (r2 === wx(e2, t2, i2, n2) > 0)
          for (s2 = t2; s2 < i2; s2 += n2)
            a2 = bx(s2, e2[s2], e2[s2 + 1], a2);
        else
          for (s2 = i2 - n2; s2 >= t2; s2 -= n2)
            a2 = bx(s2, e2[s2], e2[s2 + 1], a2);
        return a2 && fx(a2, a2.next) && (Mx(a2), a2 = a2.next), a2;
      }
      function tx(e2, t2) {
        if (!e2)
          return e2;
        t2 || (t2 = e2);
        var i2, n2 = e2;
        do {
          if (i2 = false, n2.steiner || !fx(n2, n2.next) && 0 !== mx(n2.prev, n2, n2.next))
            n2 = n2.next;
          else {
            if (Mx(n2), (n2 = t2 = n2.prev) === n2.next)
              break;
            i2 = true;
          }
        } while (i2 || n2 !== t2);
        return t2;
      }
      function ix(e2, t2, i2, n2, r2, s2, a2) {
        if (e2) {
          !a2 && s2 && function(e3, t3, i3, n3) {
            var r3 = e3;
            do {
              0 === r3.z && (r3.z = cx(r3.x, r3.y, t3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
            } while (r3 !== e3);
            r3.prevZ.nextZ = null, r3.prevZ = null, function(e4) {
              var t4, i4, n4, r4, s3, a3, o3, l3, h3 = 1;
              do {
                for (i4 = e4, e4 = null, s3 = null, a3 = 0; i4; ) {
                  for (a3++, n4 = i4, o3 = 0, t4 = 0; t4 < h3 && (o3++, n4 = n4.nextZ); t4++)
                    ;
                  for (l3 = h3; o3 > 0 || l3 > 0 && n4; )
                    0 !== o3 && (0 === l3 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, o3--) : (r4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = r4 : e4 = r4, r4.prevZ = s3, s3 = r4;
                  i4 = n4;
                }
                s3.nextZ = null, h3 *= 2;
              } while (a3 > 1);
            }(r3);
          }(e2, n2, r2, s2);
          for (var o2, l2, h2 = e2; e2.prev !== e2.next; )
            if (o2 = e2.prev, l2 = e2.next, s2 ? rx(e2, n2, r2, s2) : nx(e2))
              t2.push(o2.i / i2 | 0), t2.push(e2.i / i2 | 0), t2.push(l2.i / i2 | 0), Mx(e2), e2 = l2.next, h2 = l2.next;
            else if ((e2 = l2) === h2) {
              a2 ? 1 === a2 ? ix(e2 = sx(tx(e2), t2, i2), t2, i2, n2, r2, s2, 2) : 2 === a2 && ax(e2, t2, i2, n2, r2, s2) : ix(tx(e2), t2, i2, n2, r2, s2, 1);
              break;
            }
        }
      }
      function nx(e2) {
        var t2 = e2.prev, i2 = e2, n2 = e2.next;
        if (mx(t2, i2, n2) >= 0)
          return false;
        for (var r2 = t2.x, s2 = i2.x, a2 = n2.x, o2 = t2.y, l2 = i2.y, h2 = n2.y, c2 = r2 < s2 ? r2 < a2 ? r2 : a2 : s2 < a2 ? s2 : a2, u2 = o2 < l2 ? o2 < h2 ? o2 : h2 : l2 < h2 ? l2 : h2, d2 = r2 > s2 ? r2 > a2 ? r2 : a2 : s2 > a2 ? s2 : a2, p2 = o2 > l2 ? o2 > h2 ? o2 : h2 : l2 > h2 ? l2 : h2, m2 = n2.next; m2 !== t2; ) {
          if (m2.x >= c2 && m2.x <= d2 && m2.y >= u2 && m2.y <= p2 && dx(r2, o2, s2, l2, a2, h2, m2.x, m2.y) && mx(m2.prev, m2, m2.next) >= 0)
            return false;
          m2 = m2.next;
        }
        return true;
      }
      function rx(e2, t2, i2, n2) {
        var r2 = e2.prev, s2 = e2, a2 = e2.next;
        if (mx(r2, s2, a2) >= 0)
          return false;
        for (var o2 = r2.x, l2 = s2.x, h2 = a2.x, c2 = r2.y, u2 = s2.y, d2 = a2.y, p2 = o2 < l2 ? o2 < h2 ? o2 : h2 : l2 < h2 ? l2 : h2, m2 = c2 < u2 ? c2 < d2 ? c2 : d2 : u2 < d2 ? u2 : d2, f2 = o2 > l2 ? o2 > h2 ? o2 : h2 : l2 > h2 ? l2 : h2, g2 = c2 > u2 ? c2 > d2 ? c2 : d2 : u2 > d2 ? u2 : d2, _2 = cx(p2, m2, t2, i2, n2), v2 = cx(f2, g2, t2, i2, n2), x2 = e2.prevZ, y2 = e2.nextZ; x2 && x2.z >= _2 && y2 && y2.z <= v2; ) {
          if (x2.x >= p2 && x2.x <= f2 && x2.y >= m2 && x2.y <= g2 && x2 !== r2 && x2 !== a2 && dx(o2, c2, l2, u2, h2, d2, x2.x, x2.y) && mx(x2.prev, x2, x2.next) >= 0)
            return false;
          if (x2 = x2.prevZ, y2.x >= p2 && y2.x <= f2 && y2.y >= m2 && y2.y <= g2 && y2 !== r2 && y2 !== a2 && dx(o2, c2, l2, u2, h2, d2, y2.x, y2.y) && mx(y2.prev, y2, y2.next) >= 0)
            return false;
          y2 = y2.nextZ;
        }
        for (; x2 && x2.z >= _2; ) {
          if (x2.x >= p2 && x2.x <= f2 && x2.y >= m2 && x2.y <= g2 && x2 !== r2 && x2 !== a2 && dx(o2, c2, l2, u2, h2, d2, x2.x, x2.y) && mx(x2.prev, x2, x2.next) >= 0)
            return false;
          x2 = x2.prevZ;
        }
        for (; y2 && y2.z <= v2; ) {
          if (y2.x >= p2 && y2.x <= f2 && y2.y >= m2 && y2.y <= g2 && y2 !== r2 && y2 !== a2 && dx(o2, c2, l2, u2, h2, d2, y2.x, y2.y) && mx(y2.prev, y2, y2.next) >= 0)
            return false;
          y2 = y2.nextZ;
        }
        return true;
      }
      function sx(e2, t2, i2) {
        var n2 = e2;
        do {
          var r2 = n2.prev, s2 = n2.next.next;
          !fx(r2, s2) && gx(r2, n2, n2.next, s2) && xx(r2, s2) && xx(s2, r2) && (t2.push(r2.i / i2 | 0), t2.push(n2.i / i2 | 0), t2.push(s2.i / i2 | 0), Mx(n2), Mx(n2.next), n2 = e2 = s2), n2 = n2.next;
        } while (n2 !== e2);
        return tx(n2);
      }
      function ax(e2, t2, i2, n2, r2, s2) {
        var a2 = e2;
        do {
          for (var o2 = a2.next.next; o2 !== a2.prev; ) {
            if (a2.i !== o2.i && px(a2, o2)) {
              var l2 = yx(a2, o2);
              return a2 = tx(a2, a2.next), l2 = tx(l2, l2.next), ix(a2, t2, i2, n2, r2, s2, 0), void ix(l2, t2, i2, n2, r2, s2, 0);
            }
            o2 = o2.next;
          }
          a2 = a2.next;
        } while (a2 !== e2);
      }
      function ox(e2, t2) {
        return e2.x - t2.x;
      }
      function lx(e2, t2) {
        var i2 = function(e3, t3) {
          var i3, n3 = t3, r2 = e3.x, s2 = e3.y, a2 = -1 / 0;
          do {
            if (s2 <= n3.y && s2 >= n3.next.y && n3.next.y !== n3.y) {
              var o2 = n3.x + (s2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
              if (o2 <= r2 && o2 > a2 && (a2 = o2, i3 = n3.x < n3.next.x ? n3 : n3.next, o2 === r2))
                return i3;
            }
            n3 = n3.next;
          } while (n3 !== t3);
          if (!i3)
            return null;
          var l2, h2 = i3, c2 = i3.x, u2 = i3.y, d2 = 1 / 0;
          n3 = i3;
          do {
            r2 >= n3.x && n3.x >= c2 && r2 !== n3.x && dx(s2 < u2 ? r2 : a2, s2, c2, u2, s2 < u2 ? a2 : r2, s2, n3.x, n3.y) && (l2 = Math.abs(s2 - n3.y) / (r2 - n3.x), xx(n3, e3) && (l2 < d2 || l2 === d2 && (n3.x > i3.x || n3.x === i3.x && hx(i3, n3))) && (i3 = n3, d2 = l2)), n3 = n3.next;
          } while (n3 !== h2);
          return i3;
        }(e2, t2);
        if (!i2)
          return t2;
        var n2 = yx(i2, e2);
        return tx(n2, n2.next), tx(i2, i2.next);
      }
      function hx(e2, t2) {
        return mx(e2.prev, e2, t2.prev) < 0 && mx(t2.next, e2, e2.next) < 0;
      }
      function cx(e2, t2, i2, n2, r2) {
        return (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - i2) * r2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) | (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - n2) * r2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) << 1;
      }
      function ux(e2) {
        var t2 = e2, i2 = e2;
        do {
          (t2.x < i2.x || t2.x === i2.x && t2.y < i2.y) && (i2 = t2), t2 = t2.next;
        } while (t2 !== e2);
        return i2;
      }
      function dx(e2, t2, i2, n2, r2, s2, a2, o2) {
        return (r2 - a2) * (t2 - o2) >= (e2 - a2) * (s2 - o2) && (e2 - a2) * (n2 - o2) >= (i2 - a2) * (t2 - o2) && (i2 - a2) * (s2 - o2) >= (r2 - a2) * (n2 - o2);
      }
      function px(e2, t2) {
        return e2.next.i !== t2.i && e2.prev.i !== t2.i && !function(e3, t3) {
          var i2 = e3;
          do {
            if (i2.i !== e3.i && i2.next.i !== e3.i && i2.i !== t3.i && i2.next.i !== t3.i && gx(i2, i2.next, e3, t3))
              return true;
            i2 = i2.next;
          } while (i2 !== e3);
          return false;
        }(e2, t2) && (xx(e2, t2) && xx(t2, e2) && function(e3, t3) {
          var i2 = e3, n2 = false, r2 = (e3.x + t3.x) / 2, s2 = (e3.y + t3.y) / 2;
          do {
            i2.y > s2 != i2.next.y > s2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (s2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
          } while (i2 !== e3);
          return n2;
        }(e2, t2) && (mx(e2.prev, e2, t2.prev) || mx(e2, t2.prev, t2)) || fx(e2, t2) && mx(e2.prev, e2, e2.next) > 0 && mx(t2.prev, t2, t2.next) > 0);
      }
      function mx(e2, t2, i2) {
        return (t2.y - e2.y) * (i2.x - t2.x) - (t2.x - e2.x) * (i2.y - t2.y);
      }
      function fx(e2, t2) {
        return e2.x === t2.x && e2.y === t2.y;
      }
      function gx(e2, t2, i2, n2) {
        var r2 = vx(mx(e2, t2, i2)), s2 = vx(mx(e2, t2, n2)), a2 = vx(mx(i2, n2, e2)), o2 = vx(mx(i2, n2, t2));
        return r2 !== s2 && a2 !== o2 || (!(0 !== r2 || !_x(e2, i2, t2)) || (!(0 !== s2 || !_x(e2, n2, t2)) || (!(0 !== a2 || !_x(i2, e2, n2)) || !(0 !== o2 || !_x(i2, t2, n2)))));
      }
      function _x(e2, t2, i2) {
        return t2.x <= Math.max(e2.x, i2.x) && t2.x >= Math.min(e2.x, i2.x) && t2.y <= Math.max(e2.y, i2.y) && t2.y >= Math.min(e2.y, i2.y);
      }
      function vx(e2) {
        return e2 > 0 ? 1 : e2 < 0 ? -1 : 0;
      }
      function xx(e2, t2) {
        return mx(e2.prev, e2, e2.next) < 0 ? mx(e2, t2, e2.next) >= 0 && mx(e2, e2.prev, t2) >= 0 : mx(e2, t2, e2.prev) < 0 || mx(e2, e2.next, t2) < 0;
      }
      function yx(e2, t2) {
        var i2 = new Sx(e2.i, e2.x, e2.y), n2 = new Sx(t2.i, t2.x, t2.y), r2 = e2.next, s2 = t2.prev;
        return e2.next = t2, t2.prev = e2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function bx(e2, t2, i2, n2) {
        var r2 = new Sx(e2, t2, i2);
        return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
      }
      function Mx(e2) {
        e2.next.prev = e2.prev, e2.prev.next = e2.next, e2.prevZ && (e2.prevZ.nextZ = e2.nextZ), e2.nextZ && (e2.nextZ.prevZ = e2.prevZ);
      }
      function Sx(e2, t2, i2) {
        this.i = e2, this.x = t2, this.y = i2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function wx(e2, t2, i2, n2) {
        for (var r2 = 0, s2 = t2, a2 = i2 - n2; s2 < i2; s2 += n2)
          r2 += (e2[a2] - e2[s2]) * (e2[s2 + 1] + e2[a2 + 1]), a2 = s2;
        return r2;
      }
      Qv.exports = $v, Qv.exports.default = $v, $v.deviation = function(e2, t2, i2, n2) {
        var r2 = t2 && t2.length, s2 = r2 ? t2[0] * i2 : e2.length, a2 = Math.abs(wx(e2, 0, s2, i2));
        if (r2)
          for (var o2 = 0, l2 = t2.length; o2 < l2; o2++) {
            var h2 = t2[o2] * i2, c2 = o2 < l2 - 1 ? t2[o2 + 1] * i2 : e2.length;
            a2 -= Math.abs(wx(e2, h2, c2, i2));
          }
        var u2 = 0;
        for (o2 = 0; o2 < n2.length; o2 += 3) {
          var d2 = n2[o2] * i2, p2 = n2[o2 + 1] * i2, m2 = n2[o2 + 2] * i2;
          u2 += Math.abs((e2[d2] - e2[m2]) * (e2[p2 + 1] - e2[d2 + 1]) - (e2[d2] - e2[p2]) * (e2[m2 + 1] - e2[d2 + 1]));
        }
        return 0 === a2 && 0 === u2 ? 0 : Math.abs((u2 - a2) / a2);
      }, $v.flatten = function(e2) {
        for (var t2 = e2[0][0].length, i2 = { vertices: [], holes: [], dimensions: t2 }, n2 = 0, r2 = 0; r2 < e2.length; r2++) {
          for (var s2 = 0; s2 < e2[r2].length; s2++)
            for (var a2 = 0; a2 < t2; a2++)
              i2.vertices.push(e2[r2][s2][a2]);
          r2 > 0 && (n2 += e2[r2 - 1].length, i2.holes.push(n2));
        }
        return i2;
      };
      const Tx = [1, 1, 0, 1];
      class Ex extends ri {
        constructor(e2) {
          super(), __publicField(this, "isPolygonGeometry", true), __publicField(this, "_useUV", false), __publicField(this, "_useNormal", false), __publicField(this, "_sideUVNormalized", false), __publicField(this, "_sideUVReversed", false), __publicField(this, "_sideUVUseHeight", false), __publicField(this, "addGeoPolygonToVertices", (e3, t2, i2 = 0, n2 = 0, r2, s2, a2, o2, l2, h2, c2, u2, d2 = false) => {
            const p2 = e3.vertices, m2 = e3.dimensions;
            Array.isArray(h2) || (h2 = Tx);
            let f2 = 1 / 0, g2 = 1 / 0;
            for (let v2 = 0, x2 = p2.length - m2 + 1; v2 < x2; v2 += m2)
              f2 = p2[v2] < f2 ? p2[v2] : f2, g2 = p2[v2 + 1] < g2 ? p2[v2 + 1] : g2;
            for (let v2 = 0, x2 = p2.length - m2 + 1; v2 < x2; v2 += m2)
              2 === m2 ? r2.push(p2[v2], p2[v2 + 1], 0 + i2) : r2.push(p2[v2], p2[v2 + 1], p2[v2 + 2] + i2), a2.push(0, 0, 1), l2.push(h2[0], h2[1], h2[2], h2[3]), o2.push(p2[v2] - f2, p2[v2 + 1] - g2), c2.push(u2);
            let _2 = [];
            for (let v2 = 0, x2 = t2.length; v2 < x2; ++v2)
              _2.push(t2[v2] + n2);
            d2 ? s2.push(..._2.reverse()) : s2.push(..._2);
          }), __publicField(this, "isClockWise", (e3) => {
            let t2 = e3.length, i2 = 0;
            for (let n2 = t2 - 1, r2 = 0; r2 < t2; n2 = r2++)
              i2 += e3[n2][0] * e3[r2][1] - e3[r2][0] * e3[n2][1];
            return i2 < 0;
          }), __publicField(this, "addSideFace", (e3, t2, i2, n2, r2, s2, a2, o2, l2, h2, c2) => {
            let u2 = e3[0], d2 = i2;
            u2.length, this.isClockWise(u2) && (u2 = u2.reverse()), Array.isArray(l2) || (l2 = Tx);
            let p2 = 0;
            let m2 = 0, f2 = 0;
            for (let g2 = 0, _2 = u2.length - 1; g2 < _2; g2++) {
              n2.push(u2[g2][0], u2[g2][1], this._zOffset, u2[g2][0], u2[g2][1], this._zOffset + t2, u2[g2 + 1][0], u2[g2 + 1][1], this._zOffset + t2, u2[g2 + 1][0], u2[g2 + 1][1], this._zOffset), d2 = i2 + 4 * g2, r2.push(d2, d2 + 2, d2 + 1, d2, d2 + 3, d2 + 2);
              let e4 = u2[g2 + 1][0] - u2[g2][0], _3 = u2[g2 + 1][1] - u2[g2][1];
              const v2 = Math.sqrt(e4 * e4 + _3 * _3);
              e4 /= v2, _3 /= v2, s2.push(_3, -e4, 0, _3, -e4, 0, _3, -e4, 0, _3, -e4, 0), this._sideUVUseHeight ? (m2 = 1 * t2, f2 = 1 * t2) : (m2 = 0, f2 = 1 * t2, this._sideUVNormalized && (f2 = 1), this._sideUVReversed && (m2 = f2, f2 = 0)), a2.push(1 * p2, m2, 1 * p2, f2), p2 += v2, a2.push(1 * p2, f2, 1 * p2, m2), o2.push(l2[0], l2[1], l2[2], l2[3], l2[0], l2[1], l2[2], l2[3], l2[0], l2[1], l2[2], l2[3], l2[0], l2[1], l2[2], l2[3]), h2.push(c2, c2, c2, c2);
            }
          }), this.parameters = e2, this._needsUpdate = false, this._extrude = e2.extrude || false, this._extrudeValue = e2.extrudeValue || 0, this._enableBottomFace = e2.enableBottomFace || false, this._zOffset = e2.zOffset || 0, this.cachedPositions = [], this.cachedObjectIndices = [];
        }
        setData(e2) {
          this._needsUpdate = true, this.cachedData = e2, this.updateGeometry();
        }
        updateGeometry() {
          let e2 = this.cachedData, t2 = null, i2 = null;
          const n2 = [], r2 = [], s2 = [], a2 = [];
          let o2 = [];
          const l2 = [];
          for (let c2 = 0; c2 < e2.position.length; c2++) {
            const h3 = e2.position[c2], u2 = e2.index[c2], d2 = e2.color ? gh(e2.color[c2]) : Tx, p2 = this.parameters.vertexHeights ? e2.height[c2] : this.extrudeValue;
            t2 = Qv.exports.flatten(h3), i2 = Qv.exports(t2.vertices, t2.holes, t2.dimensions), this.extrude && this._enableBottomFace && this.addGeoPolygonToVertices(t2, i2, this._zOffset, n2.length / 3, n2, o2, r2, s2, l2, d2, a2, u2, true), this.addGeoPolygonToVertices(t2, i2, this._zOffset + p2, n2.length / 3, n2, o2, r2, s2, l2, d2, a2, u2);
          }
          const h2 = o2.length;
          if (this.extrude)
            for (let c2 = 0; c2 < e2.position.length; c2++) {
              const t3 = e2.position[c2], i3 = e2.index[c2], h3 = e2.color ? gh(e2.color[c2]) : Tx, u2 = this.parameters.vertexHeights ? e2.height[c2] : this.extrudeValue;
              u2 > 0 && this.addSideFace(t3, u2, n2.length / 3, n2, o2, r2, s2, l2, h3, a2, i3);
            }
          this.cachedPositions = n2, this.cachedObjectIndices = a2, this.setAttribute("position", new Jt(n2, 3)), this.parameters.vertexColors && this.setAttribute("aColor", new Jt(l2, 4)), this._useUV ? this.setAttribute("uv", new Jt(s2, 2)) : this.deleteAttribute("uv"), this._useNormal ? this.setAttribute("normal", new Jt(r2, 3)) : this.deleteAttribute("normal"), this.setIndex(o2), this.clearGroups(), this.addGroup(0, h2, 1), this.extrude && this.addGroup(h2, o2.length - h2, 0), this.computeBoundingSphere(), this._needsUpdate = false;
        }
        get extrude() {
          return this._extrude;
        }
        set extrude(e2) {
          const t2 = !!e2;
          t2 !== this._extrude && (this._extrude = t2, this._needsUpdate = true);
        }
        get extrudeValue() {
          return this._extrudeValue;
        }
        set extrudeValue(e2) {
          !isNaN(e2) && e2 >= 0 && e2 !== this._extrudeValue && (this._extrudeValue = e2, this._needsUpdate = true);
        }
        get sideUVNormalized() {
          return this._sideUVNormalized;
        }
        set sideUVNormalized(e2) {
          e2 !== this._sideUVNormalized && (this._extrude && (this._needsUpdate = true), this._sideUVNormalized = e2);
        }
        get sideUVReversed() {
          return this._sideUVReversed;
        }
        set sideUVReversed(e2) {
          e2 !== this._sideUVReversed && (this._extrude && (this._needsUpdate = true), this._sideUVReversed = e2);
        }
        get sideUVUseHeight() {
          return this._sideUVUseHeight;
        }
        set sideUVUseHeight(e2) {
          e2 !== this._sideUVUseHeight && (this._extrude && (this._needsUpdate = true), this._sideUVUseHeight = e2);
        }
        get useUV() {
          return this._useUV;
        }
        set useUV(e2) {
          e2 !== this._useUV && (this._needsUpdate = true, this._useUV = e2);
        }
        get useNormal() {
          return this._useNormal;
        }
        set useNormal(e2) {
          e2 !== this._useNormal && (this._needsUpdate = true, this._useNormal = e2);
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      const Cx = new qa(), Ax = Ci.merge([Xi.fog, yh, xh, { opacity: { value: 1 }, color: { value: [0, 1, 1, 1] }, vertextColors: { value: false }, map: { value: void 0 }, mapLength: { value: new ie() }, mapSrc: { value: "" }, mapScale: { value: 1 } }]);
      class Px extends yc {
        constructor(e2) {
          super(), this.type = "PolygonMaterial", this.isPolygonMaterial = true, this.fog = true, this.transparent = true, this.depthWrite = true, this.depthTest = true, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform sampler2D map;\n    uniform vec2 mapLength;\n#else\n    #ifdef MVT_USE_VERTEX_COLOR\n        varying vec4 vColor;\n    #endif\n#endif\n\nuniform vec4 color;\nuniform float opacity;\n\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    #ifdef USE_MAP\n        gl_FragColor = texture2D(map, vec2(mod(vUv.x, mapLength.x) / mapLength.x, mod(vUv.y, mapLength.y) / mapLength.y));\n    #else\n        #ifdef MVT_USE_VERTEX_COLOR\n            gl_FragColor = vColor;\n        #else\n            gl_FragColor = color;\n        #endif\n    #endif\n\n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #include <mvt_selective_fragment>\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    \n}\n\n", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform float mapScale;\n#else\n    #ifdef MVT_USE_VERTEX_COLOR\n        attribute vec4 aColor;\n        varying vec4 vColor;\n    #endif\n#endif\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n\n    #ifdef USE_MAP\n        vUv = uv / mapScale;\n    #else\n        #ifdef MVT_USE_VERTEX_COLOR\n            vColor = aColor;\n        #endif\n    #endif\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n\n}\n\n", Object.defineProperty(this, "mapSrc", { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc, i2 = this.userData[this.urlCacheKey], n2 = this;
            if (i2 !== e3) {
              if (t2 && t2.dispose(), !e3)
                return this.uniforms.map.value = null, delete this.defines.USE_MAP, void delete this.userData[this.urlCacheKey];
              Cx.load(e3, function(t3) {
                t3.encoding = 3001, n2.uniforms.map.value = t3, n2.uniforms.mapLength.value = new ie(t3.image.naturalWidth, t3.image.naturalHeight), n2.userData[n2.urlCacheKey] = e3, n2.defines.USE_MAP = true, n2.needsUpdate = true;
              });
            }
          } }), Object.assign(this.uniforms, Ci.clone(Ax)), e2.mapSrc && (this.mapSrc = e2.mapSrc, delete e2.mapSrc), Mh(this, ["opacity", "mapScale"]), Sh(this, ["color"]), Th(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"]]), Eh(this), Ah(this), this.emissiveEnabled = true, this.emissive = [0, 0, 0], this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class Rx extends vc {
        constructor(e2) {
          super(), __publicField(this, "isEventEntitySupported", true), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "extrude"), __publicField(this, "extrudeValue"), __publicField(this, "color"), __publicField(this, "vertexColors"), __publicField(this, "emissive"), __publicField(this, "opacity"), __publicField(this, "mapSrc"), __publicField(this, "mapScale"), this.parameters = e2, this.defineGeometryProxyProperties(["extrude", "extrudeValue", "vertexHeights", "enableBottomFace", "zOffset"]), this.defineMaterialProxyProperties(["opacity", "color", "vertexColors", "emissive", "mapSrc", "mapScale", "side", "depthWrite", "colorWrite", "stencilWrite", "stencilFunc", "stencilZFail", "stencilZPass"]);
        }
        initObject() {
          const { extrude: e2, extrudeValue: t2, vertexHeights: i2, enableBottomFace: n2, zOffset: r2, ...s2 } = this.parameters;
          this.geometry = new Ex(this.parameters);
          (this.material = new Px(s2)).setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          let e2 = this.dataSource.data;
          this.geometry.setData(e2), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.needsUpdate = false;
        }
        afterGeometryUpdate() {
          this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
        }
        getEntityIndexByFace(e2, t2) {
          return this.geometry.cachedObjectIndices[t2];
        }
        raycast(e2, t2) {
          Mi.prototype.raycast.call(this, e2, t2);
        }
      }
      new Ae(), new Ae();
      const Lx = new st(), Ix = new rt(), Dx = new Je();
      class Fx extends vc {
        constructor(e2) {
          super(), __publicField(this, "isEventEntitySupported", true), __publicField(this, "_dataSource", new gc()), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "lineJoin"), __publicField(this, "lineCap"), __publicField(this, "miterLimit"), __publicField(this, "keepSize"), __publicField(this, "color"), __publicField(this, "vertextColors"), __publicField(this, "emissive"), __publicField(this, "map"), __publicField(this, "opacity"), __publicField(this, "alphaTest"), __publicField(this, "dashed"), __publicField(this, "dashArray"), __publicField(this, "dashOffset"), __publicField(this, "dashRatio"), __publicField(this, "enbaleAnimation"), __publicField(this, "enableAnimationChaos"), __publicField(this, "animationSpeed"), __publicField(this, "animationTailType"), __publicField(this, "animationTailRatio"), __publicField(this, "animationTailLength"), __publicField(this, "animationIdle"), this.parameters = e2, this.defineGeometryProxyProperties(["lineJoin", "lineCap", "miterLimit"]), this.defineMaterialProxyProperties(["map", "height", "keepSize", "opacity", "alphaTest", "dashed", "dashArray", "dashOffset", "dashRatio", "enableAnimation", "enableAnimationChaos", "animationInterval", "animationSpeed", "animationTailType", "animationTailRatio", "animationTailLength", "animationIdle", "color", "vertexColors", "vertexWidths", "emissive"]);
        }
        createVolumeDataSource() {
          const { data: e2, userData: t2, _attributeMap: i2 } = this.dataSource;
          let n2 = 1;
          if (this.keepSize) {
            const e3 = this.engine.map.getZoomUnits();
            e3 === Math.min() || Number.isNaN(e3) || (n2 = e3);
          }
          const r2 = { position: this.geometry.createVolumeGeometry(e2.position, n2), index: e2.index, payload: t2 }, s2 = new gc();
          let a2 = i2.keys();
          for (let o2 of a2) {
            const e3 = i2.get(o2);
            "string" == typeof e3 ? s2.setAttribute(o2, e3) : s2.setAttribute(o2);
          }
          return s2.setData(r2), s2;
        }
        specifiedVolumeClass() {
          this._VolumeClass = Rx;
        }
        getDefaultParams() {
          return { lineWidth: 4 };
        }
        initObject() {
          const { lineJoin: e2, lineCap: t2, ...i2 } = this.parameters;
          this.geometry = new Yv(this.parameters);
          (this.material = new Kv(i2)).setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          const e2 = this.dataSource.data;
          this.geometry.setData(e2), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = false;
        }
        get lineWidth() {
          return this.parameters.lineWidth;
        }
        set lineWidth(e2) {
          this.parameters.lineWidth = e2;
        }
        raycast(e2, t2) {
          const i2 = this.geometry, n2 = this.matrixWorld, r2 = e2.params.Line.threshold, s2 = i2.drawRange;
          let a2 = this.lineWidth / 2;
          if (this.material.keepSize && (a2 *= this.material.uniforms.zoomUnits.value), null === i2.boundingSphere && i2.computeBoundingSphere(), Dx.copy(i2.boundingSphere), Dx.applyMatrix4(n2), Dx.radius += a2, false === e2.ray.intersectsSphere(Dx))
            return;
          Lx.copy(n2).invert(), Ix.copy(e2.ray).applyMatrix4(Lx);
          const o2 = a2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), l2 = o2 * o2, h2 = new Ae(), c2 = new Ae(), u2 = new Ae(), d2 = new Ae(), p2 = this.isLineSegments ? 2 : 1;
          if (i2.isBufferGeometry) {
            const n3 = i2.index, r3 = i2.attributes, a3 = r3.position, o3 = r3.objectIndex;
            if (null !== n3) {
              for (let i3 = Math.max(0, s2.start), r4 = Math.min(n3.count, s2.start + s2.count) - 1; i3 < r4; i3 += p2) {
                const r5 = n3.getX(i3), s3 = n3.getX(i3 + 1);
                h2.fromBufferAttribute(a3, r5), c2.fromBufferAttribute(a3, s3);
                if (Ix.distanceSqToSegment(h2, c2, d2, u2) > l2)
                  continue;
                d2.applyMatrix4(this.matrixWorld);
                const p3 = e2.ray.origin.distanceTo(d2);
                p3 < e2.near || p3 > e2.far || t2.push({ distance: p3, point: u2.clone().applyMatrix4(this.matrixWorld), index: o3.getX(r5), face: null, faceIndex: null, object: this });
              }
            } else {
              for (let i3 = Math.max(0, s2.start), n4 = Math.min(a3.count, s2.start + s2.count) - 1; i3 < n4; i3 += p2) {
                h2.fromBufferAttribute(a3, i3), c2.fromBufferAttribute(a3, i3 + 1);
                if (Ix.distanceSqToSegment(h2, c2, d2, u2) > l2)
                  continue;
                d2.applyMatrix4(this.matrixWorld);
                const n5 = e2.ray.origin.distanceTo(d2);
                n5 < e2.near || n5 > e2.far || t2.push({ distance: n5, point: u2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
              }
            }
          }
          e2.params.Line.threshold = r2;
        }
      }
      class Ox extends Rt {
        constructor() {
          super(...arguments), __publicField(this, "_enabled", false), __publicField(this, "_drawedGraph", []), __publicField(this, "_transformBox", null), __publicField(this, "_trnasformIndex", null), __publicField(this, "_completedDataSource", null), __publicField(this, "_completedElement", null), __publicField(this, "_selectedIndex", -1), __publicField(this, "_stage", 0), __publicField(this, "_isAdd", false);
        }
        afterAddToEngine() {
          this.initObjects();
        }
        initObjects() {
        }
        initEvents() {
        }
        reset() {
          this.clearBuffers(), this._trnasformIndex = null, this._transformBox = null, this._stage = 0;
        }
        clearAll() {
          this.complete(), this._drawedGraph = [], this._completedDataSource.setData(), this._engine.requestRender();
        }
        attachTransform(e2, t2 = "z") {
          const i2 = new wi(1, 1, 1), n2 = new jt();
          this._transformBox = new Mi(i2, n2), this._transformBox.position.set(...e2);
          let r2 = this._getNodeNormal(this._transformIndex).angle();
          this._transformBox.rotation[t2] = r2, this._transformBox.scale.set(2, 2, 2), this._engine.add(this._transformBox), this._transformBox.visible = false, this._engine.selection.attachTransform(this._transformBox);
        }
        detachTransform() {
          this._transformBox && (this._engine.selection.transformControl.removeEventListener("objectChange", this._handleTransformChanging), this._engine.selection.transformControl.removeEventListener("mouseUp", this._handleTransformChanged), this._engine.selection.detachTransform(), this._engine.remove(this._transformBox), this._transformBox = null);
        }
        _getTransformBoxState() {
          const e2 = this._transformBox, t2 = new Ae(), i2 = new Ae(), n2 = new Ce(), r2 = new ft();
          e2.matrixWorld.decompose(t2, n2, i2), r2.setFromQuaternion(n2);
          const s2 = this._engine, a2 = [t2.x, t2.y, t2.z], o2 = s2.map.unprojectPointArr(a2), l2 = [r2.x, r2.y, r2.z], h2 = i2.x, c2 = i2.y;
          return { point: o2, position: a2, width: h2, height: i2.z, length: c2, angle: l2 };
        }
        clearBuffers() {
        }
        unbindEvents() {
        }
        _getNodeNormal() {
          return new ie(0, 0);
        }
        complete() {
          if (1 !== this._stage && this._enabled) {
            if (this._isAdd) {
              const e2 = this.graphInfo(this.drawedGraph.length);
              this._drawedGraph.push(e2);
            } else if (-1 !== this._selectedIndex) {
              const e2 = this.graphInfo(this._selectedIndex);
              this._drawedGraph.splice(this._selectedIndex, 1, e2);
            }
            this._completedDataSource.setData();
            for (let e2 = 0; e2 < this._drawedGraph.length; e2++)
              this._completedDataSource.add(this._drawedGraph[e2].dataItem);
            this.detachTransform(), this.reset(), this.clearBuffers(), this.clearObjects(), this._engine.event.unbind(this._helpers, "click", this._handleNodeClick), this.initEvents(), this._isAdd = false, this._selectedIndex = -1, this._engine.requestRender();
          }
        }
        graphInfo() {
        }
        get drawedGraph() {
          return this._drawedGraph;
        }
        get selectedIndex() {
          return this._selectedIndex;
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(e2) {
          e2 !== this._enabled && (e2 ? (this._selectedIndex = -1, this.reset(), this.initEvents()) : (this.complete(), this.detachTransform(), this.unbindEvents(), this.clearObjects()), this._enabled = e2);
        }
      }
      class Ux {
        constructor() {
          __publicField(this, "_process", []), __publicField(this, "_hasTime", false);
        }
        provide(e2) {
          let t2 = 0;
          this._hasTime || (t2 = new Date().valueOf());
          for (let i2 = 0; i2 < e2.length; i2++) {
            const n2 = e2[i2];
            for (let e3 = 0; e3 < this._process.length; e3++) {
              const t3 = this._process[e3];
              "string" == typeof t3[1] && n2[t3[1]] ? n2[t3[0]] = n2[t3[1]] : t3[1] instanceof Function ? n2[t3[0]] = t3[1](n2) : n2[t3[0]] = void 0;
            }
            this._hasTime || (n2.time = t2);
          }
          return e2;
        }
        process(e2, t2) {
          return "time" === e2 && (this._hasTime = true), this._process.push([e2, t2]), this;
        }
      }
      class zx {
        constructor(e2) {
          __publicField(this, "id", null), __publicField(this, "data", []), __publicField(this, "interpolateDirectThreshold", 10), e2 && "number" == typeof e2 && (this.data = new Array(e2));
        }
        tick(e2, t2) {
          let i2 = this.data[0], n2 = this.data[1];
          if (!i2 || !n2)
            return null;
          const r2 = (t2 - i2.time) / (n2.time - i2.time), s2 = Hv(i2.point, n2.point, r2), a2 = e2.map.projectPointArr(s2);
          let o2 = i2.dir, l2 = Bv(a2, e2.map.projectPointArr(n2.point));
          return l2 < this.interpolateDirectThreshold && (o2 = Vv(o2, n2.dir, 1 - l2 / this.interpolateDirectThreshold)), { ...i2, id: this.id, modelType: i2.modelType, ratio: r2, point: s2, position: a2, dir: o2 };
        }
        push(e2) {
          if (!this.id && e2 && (this.id = e2.id, this.modelType = e2.modelType), this.id)
            return this.data.push(e2);
        }
        shift() {
          return this.data.shift();
        }
        splice(e2, t2, ...i2) {
          return this.data.splice(e2, t2, ...i2);
        }
        get length() {
          return this.data.length;
        }
        get empty() {
          return !("" !== this.data.join(""));
        }
      }
      class Nx {
        constructor(e2) {
          __publicField(this, "_entities", /* @__PURE__ */ new Map()), __publicField(this, "_entityCacheTimes", []), __publicField(this, "_startTime", 1 / 0), __publicField(this, "_timeOffset", 0), this.delay = e2.delay;
        }
        push(e2) {
          const t2 = e2[0].time, i2 = this._entities;
          for (let n2 = 0; n2 < e2.length; n2++) {
            const t3 = e2[n2];
            i2.get(t3.id) || i2.set(t3.id, new zx(this._entityCacheTimes.length)), i2.get(t3.id).push(t3);
          }
          Array.from(i2.entries()).forEach(([e3, t3]) => {
            t3.length === this._entityCacheTimes.length && t3.push(void 0);
          }), this._entityCacheTimes.push(t2);
        }
        shift(e2) {
          const t2 = this._entities, i2 = this._entityCacheTimes;
          let n2 = 0, r2 = [];
          for (let s2 = 1; s2 < i2.length; s2++) {
            const t3 = i2[s2];
            if (e2 - this.delay - this.timeOffset < t3)
              break;
            n2 += 1;
          }
          return i2.splice(0, n2), Array.from(t2.entries()).forEach(([e3, i3]) => {
            i3.splice(0, n2), i3.empty && (t2.delete(e3), r2.push(e3));
          }), r2;
        }
        tick(e2, t2) {
          if (t2 - this.delay < this._startTime)
            return {};
          this.shift(t2);
          const i2 = Array.from(this._entities.values()), n2 = [], r2 = [], s2 = [], a2 = [], o2 = [], l2 = [], h2 = [], c2 = [], u2 = {};
          for (let d2 = 0; d2 < i2.length; d2++) {
            let p2 = i2[d2].tick(e2, t2 - this.delay - this.timeOffset);
            p2 && (n2.push(p2.id), r2.push(n2.length - 1), s2.push(p2.position), a2.push(...p2.position), o2.push(0, 0, p2.dir), l2.push(1, 1, 1), h2.push(p2.modelType), c2.push(p2), u2[p2.modelType] ? u2[p2.modelType].push(n2.length - 1) : u2[p2.modelType] = [n2.length - 1]);
          }
          return { buffers: { id: n2, index: r2, position: s2, translation: a2, rotation: o2, scale: l2, modelType: h2, payload: c2 }, modelIndexMap: u2 };
        }
        get startTime() {
          return this._startTime;
        }
        set startTime(e2) {
          this._startTime = e2;
        }
        get timeOffset() {
          return this._timeOffset;
        }
        set timeOffset(e2) {
          this._timeOffset = e2;
        }
      }
      const kx = new Pp();
      new st(), new rt(), new Je();
      let Bx = new st(), Vx = new st(), Gx = new st(), Hx = new Mi(), jx = [], Wx = new Ae(), Xx = new Se();
      class qx extends _c {
        constructor(e2, t2) {
          super(), __publicField(this, "type", "InstancedMesh"), __publicField(this, "isMesh", true), __publicField(this, "isInstancedMesh", true), __publicField(this, "frustumCulled", false), __publicField(this, "instanceColor", null), __publicField(this, "count", 0), __publicField(this, "instanceMatrix"), __publicField(this, "_enableInstanceColor", false), __publicField(this, "instanceMorphMatrix", new st()), __publicField(this, "isEventEntitySupported", true), __publicField(this, "getInstanceLocalMatrix", (e3, t3, i2) => null), __publicField(this, "addCustomAttributes", () => {
          }), this.geometry = e2, this.material = t2, this.instanceMatrix = new Vs(new Float32Array(0), 16);
        }
        set enableInstanceColor(e2) {
          e2 !== this._enableInstanceColor && (this._enableInstanceColor = e2, this.needsUpdate = true);
        }
        get enableInstanceColor() {
          return this._enableInstanceColor;
        }
        collisionTest(e2) {
          let t2 = this.material.keepSize ? this.size : 0;
          return { width: t2, height: t2 };
        }
        setData() {
          let e2 = [];
          e2 = this._enableCollision && this._collisionData ? this._collisionData : this.dataSource.userData;
          const t2 = [], i2 = [], n2 = [];
          let r2 = 1 / 0, s2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, l2 = -1 / 0, h2 = -1 / 0;
          for (let u2 = 0; u2 < e2.length; u2++) {
            const t3 = e2[u2].position, [i3, n3, c3 = 0] = t3;
            i3 < r2 && (r2 = i3), i3 > o2 && (o2 = i3), n3 < s2 && (s2 = n3), n3 > l2 && (l2 = n3), c3 < a2 && (a2 = c3), c3 > h2 && (h2 = c3);
          }
          let c2 = [(r2 + o2) / 2, (s2 + l2) / 2, (a2 + h2) / 2 || 0];
          for (let u2 = 0; u2 < e2.length; u2++) {
            const r3 = e2[u2].position;
            e2[u2].index;
            const s3 = this.getInstanceLocalMatrix(r3, this.dataSource.getOriginData(u2), u2), a3 = new st();
            a3.makeTranslation(r3[0] - c2[0], r3[1] - c2[1], (r3[2] || 0) - c2[2]);
            let o3 = null;
            s3 ? (o3 = new st(), o3.multiplyMatrices(a3, s3)) : o3 = a3;
            const l3 = o3.elements;
            if (t2.push(l3[0], l3[1], l3[2], l3[3], l3[4], l3[5], l3[6], l3[7], l3[8], l3[9], l3[10], l3[11], l3[12], l3[13], l3[14], l3[15]), i2.push(Math.random()), this._enableInstanceColor) {
              let t3 = _h(e2[u2].color);
              n2.push(t3[0], t3[1], t3[2]);
            }
          }
          this.geometry.setAttribute("instancedRandomFactor", new Vs(new Float32Array(i2), 1)), this.addCustomAttributes(this.geometry, this.dataSource), this.geometry.computeBoundingSphere(), this.geometry.instanceCount = t2.length / 16, this.instanceMatrix = new Vs(new Float32Array(t2), 16), this._enableInstanceColor && (this.instanceColor = new Vs(new Float32Array(n2), 3)), this.count = this.geometry.instanceCount, this.makeMeshPositionOffset(c2), this.needsUpdate = false;
        }
        computeInstanceMorphMatrix() {
          const e2 = this.material;
          let t2 = e2.height || 0, i2 = 1;
          if (e2.keepSize && (i2 = e2.zoomUnits || 1), e2.isUseSize3) {
            const t3 = e2.size3;
            Wx.set(t3[0] * i2, t3[1] * i2, t3[2] * i2);
          } else if (e2.isUseSize2) {
            const t3 = e2.size2;
            Wx.set(t3[0] * i2, t3[1] * i2, i2);
          } else {
            let t3 = e2.size || 1;
            Wx.set(t3 * i2, t3 * i2, t3 * i2);
          }
          this.instanceMorphMatrix.identity().scale(Wx).premultiply(Gx.identity().makeTranslation(0, 0, t2 * i2));
        }
        getEntityByIndex(e2) {
          const t2 = this.dataSource, i2 = { index: e2, value: t2.getOriginData(e2), itemIndex: t2.getOriginDataIndex(e2), pairs: {} }, n2 = t2.data;
          for (const r2 of Object.keys(n2))
            i2.pairs[r2] = n2[r2][e2];
          return i2;
        }
        raycast(e2, t2) {
          if (!this.visible)
            return;
          let i2 = this.geometry, n2 = this.material, r2 = this.matrixWorld;
          if (!n2 || !i2)
            return;
          const s2 = this.instanceMatrix;
          if (!s2)
            return;
          const a2 = s2.array;
          this.computeInstanceMorphMatrix();
          const o2 = this.count;
          if (Hx.geometry = this.geometry.getInstanceGeometry ? this.geometry.getInstanceGeometry() : this.geometry, Hx.material = n2, n2.isInstancedBallonMaterial) {
            const i3 = e2.camera, s3 = n2.resolution, l2 = e2.mouse, h2 = n2.size / s3[0], c2 = n2.size / s3[1], u2 = 2 * (n2.height + n2.size / 2) / s3[1], d2 = l2.x - h2, p2 = l2.x + h2, m2 = l2.y - c2 - u2, f2 = l2.y + c2 - u2;
            Gx.multiplyMatrices(i3.matrixWorldInverse, r2), Gx.multiplyMatrices(i3.projectionMatrix, Gx);
            for (let n3 = 0; n3 < o2; ++n3)
              if (Vx.fromArray(a2, 16 * n3), Xx.set(0, 0, 0, 1).applyMatrix4(Vx).applyMatrix4(Gx).divideScalar(Xx.w), Xx.x >= d2 && Xx.y >= m2 && Xx.x <= p2 && Xx.y <= f2) {
                Wx.set(Vx.elements[12], Vx.elements[13], Vx.elements[14]);
                const i4 = e2.ray.origin.distanceTo(Wx);
                i4 >= e2.near && i4 <= e2.far && (jx[0] = { distance: i4, point: Wx.clone(), itemIndex: n3, object: this }, t2.push(jx[0]), jx.length = 0);
              }
          } else
            for (let l2 = 0; l2 < o2; ++l2)
              Vx.fromArray(a2, 16 * l2), Bx.multiplyMatrices(Vx, this.instanceMorphMatrix), Bx.multiplyMatrices(r2, Bx), Hx.matrixWorld = Bx, Hx.raycast(e2, jx), jx.length > 0 && (jx[0].instanceId = l2, jx[0].object = this, t2.push(jx[0]), jx.length = 0);
        }
      }
      class Yx extends ri {
        constructor(e2) {
          super(e2), this.parameters = e2;
        }
        setData(e2) {
          const { vertexSizes: t2, vertexColors: i2 } = this.parameters, { aPositions: n2, aObjectIndices: r2, aMapIndexs: s2, aColors: a2, aSizes: o2 } = e2;
          this.setAttribute("position", new Jt(n2, 3)), this.setAttribute("objectIndex", new Jt(r2, 1)), this.setAttribute("aMapIndex", new Jt(s2, 1)), i2 && this.setAttribute("aColor", new Jt(a2, 4)), t2 && this.setAttribute("aSize", new Jt(o2, 1));
        }
      }
      const Zx = new qa(), Jx = Ci.merge([Xi.fog, yh, { emissive: { value: [0, 0, 0] }, isEmissive: { value: false }, color: { value: [0, 1, 1, 1] }, size: { value: 30 }, vertexColors: { value: false }, vertexSizes: { value: false }, uShapeType: { value: 2 }, opacity: { value: 1 }, map: { value: null }, useMap: { value: false }, uOffset: { value: [0, 0] } }]);
      class Kx extends yc {
        constructor(e2) {
          super(), this.type = "SimplePointMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_SIZE\n    attribute float aSize;\n    varying float vSize;\n#endif\n\n#ifdef MVT_USE_VERTEX_OFFSET\n    attribute vec2 aOffset;\n#else\n    uniform vec2 uOffset;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n    varying vec4 vColor;\n#endif\n\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    #ifdef MVT_USE_VERTEX_OFFSET\n        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;\n    #else\n        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;\n    #endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.xy = gl_Position.xy - offset;\n\n    #ifdef MVT_USE_VERTEX_SIZE\n        vSize = aSize * pixelRatio;\n        gl_PointSize = vSize;\n    #else\n        gl_PointSize = size * pixelRatio;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\nuniform vec4 color;\nuniform float uShapeType;\nuniform float opacity;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    varying float vSize;\n#else\n    uniform float size;\n#endif\nuniform bool useMap;\nuniform sampler2D map;\n\n#include <mvt_selective_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        gl_FragColor = vColor;\n    #else\n        gl_FragColor = color;\n    #endif\n\n    if (uShapeType == 2.) {\n        float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n        #ifdef MVT_USE_VERTEX_SIZE\n            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);\n        #else\n            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);\n        #endif\n        \n        if (alpha <= 0.) {\n            discard;\n        } else {\n            gl_FragColor.a *= alpha;\n        }\n    }\n \n    if (useMap) {\n        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);\n     //    gl_FragColor.a += tColor.a;\n        \n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);\n        // gl_FragColor.a += tColor.a;\n        // gl_FragColor = tColor;\n    }\n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    #include <mvt_selective_fragment> \n    #include <mvt_emissive_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n    \n}", this.isSimplePointMaterial = true, this.transparent = true, Object.assign(this.uniforms, Ci.clone(Jx)), Eh(this), Mh(this, ["size", "uShapeType", "opacity", "emissive", "isEmissive"]), wh(this, [["offset", "uOffset"]]), Sh(this, ["color"]), Th(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"], ["vertexSizes", "MVT_USE_VERTEX_SIZE"]]), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc;
            if (this.userData.url_map === e3)
              return;
            if (t2 && t2.dispose(), !e3)
              return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData.url_map;
            const i2 = Zx.load(e3);
            i2.wrapS = i2.wrapT = h, this.uniforms.map.value = i2, this.userData.url_map = e3, this.uniforms.useMap.value = true;
          } } }), this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      let Qx = new Le(), $x = new Ae();
      class ey extends co {
        constructor() {
          super(...arguments), __publicField(this, "isCustomInstancedBufferGeometry", true), __publicField(this, "instanceGeometry", null);
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Le());
          const e2 = this.attributes.instancedPosition;
          void 0 !== e2 ? this.boundingBox.setFromBufferAttribute(e2) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Je());
          let e2 = this.attributes.instancedPosition;
          if (e2) {
            let t2 = this.boundingSphere.center;
            Qx.setFromBufferAttribute(e2), Qx.getCenter(t2);
            let i2 = 0;
            for (let n2 = 0, r2 = e2.count; n2 < r2; n2++)
              $x.fromBufferAttribute(e2, n2), i2 = Math.max(i2, t2.distanceToSquared($x));
            this.boundingSphere.radius = Math.sqrt(i2), 1 === e2.count && (this.boundingSphere.radius = 1e5), isNaN(this.boundingSphere.radius) && console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.', this);
          }
        }
        getInstanceGeometry() {
          return this.instanceGeometry || (this.instanceGeometry = new ri(), this.instanceGeometry.attributes = this.attributes, this.instanceGeometry.index = this.index), this.instanceGeometry;
        }
      }
      class ty extends ey {
        constructor() {
          super(), __publicField(this, "setModelData", () => {
            this.setAttribute("position", new Jt([-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0], 3)), this.setAttribute("uv", new Jt([0, 0, 0, 1, 1, 1, 1, 0], 2)), this.setIndex([0, 2, 1, 0, 3, 2]);
          }), this.setModelData();
        }
      }
      const iy = (e2) => {
        Object.defineProperties(e2, { color: { get: function() {
          return this.uniforms.color.value;
        }, set: function(e3) {
          this.uniforms.color.value = mh(e3);
        } }, height: { get: function() {
          return this.uniforms.height.value;
        }, set: function(e3) {
          this.uniforms.height.value = e3;
        } }, size: { get: function() {
          return this.uniforms.size.value;
        }, set: function(e3) {
          this.uniforms.size.value = e3;
        } }, size3: { get: function() {
          return this.uniforms.size3.value;
        }, set: function(e3) {
          Array.isArray(e3) && 3 === e3.length && (this.uniforms.size3.value = e3);
        } }, useSize3: { get: function() {
          return this.defines.USE_SIZE3;
        }, set: function(e3) {
          e3 === this.defines.USE_SIZE3 && (this.defines.USE_SIZE3 = !!e3), this.needsUpdate = true;
        } }, opacity: { get: function() {
          return this.uniforms.opacity.value;
        }, set: function(e3) {
          this.uniforms.opacity.value = e3;
        } } });
      }, ny = (e2) => {
        Object.defineProperties(e2, { animationRotate: { get: function() {
          return !!this.defines.ENABLE_ANIMATION_ROTATE;
        }, set: function(e3) {
          e3 !== this.animationRotate && (e3 ? this.defines.ENABLE_ANIMATION_ROTATE = true : delete this.defines.ENABLE_ANIMATION_ROTATE, this.needsUpdate = true);
        } }, animationRotatePeriod: { get: function() {
          return this.uniforms.animationRotatePeriod.value;
        }, set: function(e3) {
          this.uniforms.animationRotatePeriod.value = e3;
        } }, animationJump: { get: function() {
          return !!this.defines.ENABLE_ANIMATION_JUMP;
        }, set: function(e3) {
          e3 !== this.animationJump && (e3 ? this.defines.ENABLE_ANIMATION_JUMP = true : delete this.defines.ENABLE_ANIMATION_JUMP, this.needsUpdate = true);
        } }, animationJumpPeriod: { get: function() {
          return this.uniforms.animationJumpPeriod.value;
        }, set: function(e3) {
          this.uniforms.animationJumpPeriod.value = e3;
        } }, animationJumpHeight: { get: function() {
          return this.uniforms.animationJumpHeight.value;
        }, set: function(e3) {
          this.uniforms.animationJumpHeight.value = e3;
        } }, animationPeriodOffset: { get: function() {
          return this.uniforms.animationPeriodOffset.value;
        }, set: function(e3) {
          this.uniforms.animationPeriodOffset.value = e3;
        } }, animationEffect: { get: function() {
          return this.uniforms.animationEffect.value;
        }, set: function(e3) {
          this.uniforms.animationEffect.value = e3;
        } }, animationEffectPeriod: { get: function() {
          return this.uniforms.animationEffectPeriod.value;
        }, set: function(e3) {
          this.uniforms.animationEffectPeriod.value = e3;
        } } });
      }, ry = Ci.merge([Xi.fog, { height: { value: 0 }, size: { value: 1 }, size3: { value: [1, 1, 1] }, resolution: { value: [1, 1] }, zoomUnits: { value: 1 }, color: { value: [1, 0, 0, 1] }, opacity: { value: 1 } }, { animationRotatePeriod: { value: 4e3 }, animationJumpPeriod: { value: 4e3 }, animationJumpHeight: { value: 30 }, animationPeriodOffset: { value: false }, animationEffect: { value: true }, animationEffectPeriod: { value: 4e3 } }, yh, bh, { isCesium: { value: false } }]);
      class sy extends yc {
        constructor(e2) {
          super(), this.type = "InstancedEffectPointMaterial", this.isInstancedEffectPointMaterial = true, this.lights = false, this.transparent = true, Object.assign(this.uniforms, Ci.clone(ry)), iy(this), ny(this), Eh(this), Ch(this), this.setValues(e2);
        }
      }
      const ay = Ci.merge([Xi.fog, yh, { elapsedTime: { value: 0 } }]);
      class oy extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "SpecialPointMaterial"), __publicField(this, "isSpecialPointMaterial", true), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\nvarying vec2 vUV;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n    vUV = uv;\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n \n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n  \n    #include <mvt_keepsize_vertex>\n\n    // gl_Position = projectionMatrix * modelViewMatrix * \n    //     vec4(instancedPosition + transformed, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n}", this.fragmentShader = "#define GLSLIFY 1\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nuniform float ratio;\n\nfloat PI = 3.1415926;\nuniform float elapsedTime;\nuniform vec2 resolution; \nvarying vec2 vPosition;\nvarying vec2 vUV;\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * elapsedTime / 1000.;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n        d = normalize(d);\n        //compute gradient based on angle difference to theta0\n        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n        + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n        + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n        + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n        return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*elapsedTime / 1000., 80.0);\n    return (0.5-0.5*cos(30.0*elapsedTime / 1000.)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid main() { \n    vec2 _uv = vec2(vPosition.x * resolution.x, vPosition.y * resolution.y);\n    vec3 finalColor;\n    vec2 uv = _uv;\n    //center of the image\n    vec2 c = vec2(vUV.x / 2.0, vUV.y / 2.0);\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime / 1000.)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime / 1000.)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n        vec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*elapsedTime / 1000.);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*elapsedTime / 1000.)+0.15*elapsedTime / 1000.);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*elapsedTime / 1000.+7.0)+0.2*elapsedTime / 1000.);\n        // finalColor += bip2(uv,c+p) * red;\n    }\n\n    gl_FragColor = vec4( finalColor, 1.0 );\n    // gl_FragColor.a *= finalColor.r;\n    \n}", this.transparent = true, this.side = 2, this.depthWrite = false, Object.assign(this.uniforms, Ci.clone(ay)), Mh(this, ["elapsedTime"]), this.setValues(e2);
        }
      }
      const ly = "#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUV;\nuniform float size;\nvarying vec2 vPosition;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n    vUV = uv;\n    vec3 transformed = vec3(position);\n    vPosition = position.xy;\n\n    transformed *= size;\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( transformed, 1.0 );\n    #include <logdepthbuf_vertex>\n}";
      let hy = Ci.merge([{ speed: { value: 1 }, color: { value: [1, 0, 0, 1] }, size: { value: 100 } }]);
      class cy extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "InstancedFanMaterial"), __publicField(this, "isInstancedFanMaterial", true), this.depthWrite = false, Mh(this, ["speed"]), "Fan" === e2.type ? (this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform float speed;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n   \n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n \n    float elapsedTime = elapsedTime * speed * .5;\n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n  \n    #include <mvt_keepsize_vertex>\n\n    // gl_Position = projectionMatrix * modelViewMatrix * \n    //     vec4(instancedPosition + transformed, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n// #include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n// #include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n   \n    float bb = atan(vPosition.y, vPosition.x) + 3.15;\n\n    float pi = 3.14 * 1.;\n    // bb = mod(bb, 6.28);\n    if (bb > pi) {\n        discard;\n    } else { \n        float aa = mod(bb / pi, 1.0);\n        float dis = distance(vPosition, vec2(0, 0));\n        if (dis > 0.5) {\n            discard;\n        } else {\n            gl_FragColor = color;\n            gl_FragColor.a *= aa;\n        }\n    }\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    \n    // #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}") : "Radar" === e2.type ? (hy = Ci.merge([hy, { segmentAngle: { value: 0.25 * Math.PI } }]), Mh(this, ["segmentAngle"]), this.vertexShader = "#include <common>\nprecision mediump float;\nprecision mediump int;\n#define GLSLIFY 1\n#include <mvt_animation_pars_vertex>\nvarying vec2 vPosition;\nuniform float elapsedTime;\nuniform float speed;\nattribute float instancedRandomFactor;\nuniform float size;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {   \n    vec3 transformed = vec3(position);\n    float elapsedTime = elapsedTime * speed * .5;\n    #include <mvt_animation_vertex>\n    transformed *= size;\n    vPosition = position.xy;\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4( transformed, 1.0 );\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\nuniform float segmentAngle;\nuniform vec4 color;\nvarying vec2 vPosition;\n\n#define PI 3.1415926\n#define radius .5\n#include <logdepthbuf_pars_fragment>\n\nfloat cros(vec2 line1, vec2 line2){\n    return line1.x * line2.y - line2.x * line1.y;\n}\n\nvoid main() {\n    bool crossNPI = false;\n    float wholeAng = abs(mod(segmentAngle , PI * 2.));\n    float dis = length(vec2(vPosition.xy - vec2(0.0)));\n\n    // if(wholeAng < -1.0*PI){\n    //     crossNPI = true;\n    //     wholeAng = 2.0*PI + endAng-startAng;\n    // }\n    if (dis<radius) {\n        vec2 nV = normalize(vPosition.xy);\n        float angle = 0.0;\n        if(nV.x > 0.0 && abs(nV.y) < 0.01) {\n            angle = 0.5*PI;\n        }\n        else if (nV.x<0.0 && abs(nV.y) < 0.01) {\n            angle = -0.5*PI;\n        }\n        else {\n            angle = atan(nV.x,nV.y);\n        }\n\n        if (angle<.0) {\n            angle = 2. * PI + angle;\n        }\n\n        float alpha = 0.1;\n\n        if (angle > 0. && angle < wholeAng) {\n            // alpha = 1.1 - (endAng-angle)/wholeAng;\n            alpha = 1.1 - (1. - (wholeAng-angle) / wholeAng);\n        }\n        \n        gl_FragColor = color;\n        gl_FragColor.a = alpha;\n    }\n    else {\n        discard;\n    }\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <logdepthbuf_fragment>\n}") : "RadarLayered" === e2.type ? (hy = Ci.merge([hy, { sideColor: { value: [0.87, 0.98, 1, 1] } }]), Sh(this, ["sideColor"]), this.vertexShader = ly, this.fragmentShader = "#define GLSLIFY 1\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n// #define blue1 vec4(0.74,0.95,1.00,1.)\n// #define blue2 vec4(0.87,0.98,1.00,1.)\n// #define blue3 vec4(0.35,0.76,0.83,1.)\n// #define blue4 vec4(0.953,0.969,0.89,1.)\n// #define red   vec4(1.00,0.38,0.227,1.)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n// #define elapsedTime 0.01\nuniform float elapsedTime;\nuniform float speed;\nvarying vec2 vPosition;\nuniform vec4 color;\nuniform vec4 sideColor;\n#include <logdepthbuf_pars_fragment>\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * elapsedTime * speed *.0006;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) )* 500.;\n        d = normalize(d);\n        //compute gradient based on angle difference to theta0\n        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.3,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n    \n    float circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return smoothstep(radius-width,radius,r)-smoothstep(radius,radius+width,r);\n    // return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n    \nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n    \nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x * 100.);\n    int y = int(d.y * 100.);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\n\nvoid main() {\n    vec4 finalColor = vec4(0.0, .0, .0, .0);\n    vec2 uv = vPosition.xy;\n    #include <logdepthbuf_fragment>\n    //center of the image\n    vec2 c = vec2(0.0, 0.0);\n    finalColor += 0.3*_cross( vPosition.xy, c, .5);\n    finalColor += ( circle(uv, c, .3, .01)\n                  + circle(uv, c, .4, .01) ) * color;\n    finalColor += (circle(uv, c, .5, .02) ) * sideColor;//+ dots(uv,c,240.0)) * blue4;\n    // finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    // finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime * speed *.0006)) * blue2;\n    finalColor += movingLine(uv, c, .5) * color;\n    finalColor += circle(uv, c, .05, .01) * color;\n    // finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime * speed *.0006)) * blue3;\n    if( length(uv-c) < .5 ) {\n        if( length(finalColor)<0.2) {\n            discard;\n        }\n    }\n    else{\n        discard;\n    }\n    if (finalColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = finalColor;\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n}") : (this.vertexShader = ly, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUV;\nuniform vec4 color;\nuniform float speed;\nuniform float elapsedTime;\n\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n    in float frontierBorder, in float timeResetSeconds, \n    in float radarPingSpeed, in float fadeDistance, float t) {\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(t, timeResetSeconds) * radarPingSpeed;\n    \n    float circle;\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n    circle *= smoothstep(fadeDistance, 0.25, r); // fade to 0 after fadeDistance\n            \n    return vec3(circle);\n}\n#include <logdepthbuf_pars_fragment>\nvoid main() {	\n    // gl_FragColor = vec4(1.,.0,.0,1.);\n    //normalize coordinates \n    vec2 uv = vUV; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    #include <logdepthbuf_fragment>\n    vec3 color1;\n    // generate some radar pings\n    float fadeDistance = 0.8;\n    float resetTimeSec = 3.0;\n    float radarPingSpeed = 0.2;\n    vec2 greenPing = vec2(0.0, 0.0);\n    color1 += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006) * vec3(color.rgb);\n    // color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,\n    //    radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 1.) * uColor;\n    color1 += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 2.) * vec3(color.rgb);\n    //return the new color\n    if(length(color1)<0.001){\n        discard;\n    }else{\n        gl_FragColor = vec4(color1,clamp(length(color1),0.0,1.0));\n    }\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n}"), Object.assign(this.uniforms, Ci.clone(hy)), this.setValues(e2);
        }
      }
      const uy = "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\nvoid main() {\n   \n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n \n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n  \n    #include <mvt_keepsize_vertex>\n    \n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #include <logdepthbuf_vertex>\n}", dy = Ci.merge([{ color: { value: [1, 1, 0, 1] }, size: { value: 10 }, duration: { value: 2e3 }, trail: { value: 0.5 }, center: { value: 0.1 }, radius: { value: 0.5 }, radiusDiff: { value: 0.08 } }]);
      class py extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "InstancedBubbleMaterial"), __publicField(this, "isInstancedBubbleMaterial", true), this.depthTest = false, this.depthWrite = false, "Breath" == e2.type ? (this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\nvoid main() {\n   \n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n \n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n  \n    #include <mvt_keepsize_vertex>\n\n    if (animationEffect) {\n        vEffectRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;\n        if (animationPeriodOffset) {\n            vEffectRatio += instancedRandomFactor;\n        }\n        vEffectRatio = mod(vEffectRatio, 1.0);\n        transformed *= vEffectRatio;\n    } else {\n        vEffectRatio = 1.0;\n    }\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n\n    gl_FragColor = color;\n    \n    gl_FragColor.a *= opacity;\n    if (animationEffect) {\n        if (vEffectRatio > 0.7) {\n            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;\n        }\n    }\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n    \n}") : "Wave" == e2.type ? (this.vertexShader = uy, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float trail;\nuniform float radiusDiff;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > radius) {\n        discard;\n    }\n    vec4 vColor = color;\n    \n    float alpha = sin((radiusDiff - d) / radiusDiff * trail * 2.0  * 3.14 + elapsedTime / duration * 10.);\n    // 中心点\n    if (d <= center){\n      if (d > 0.9 * center && d <= center) {\n        if (alpha >= 0.5) {\n          vColor.a = 1.0;\n        } else {\n          vColor.a = 1.0 - smoothstep(center - 0.0001, center, d);\n        }\n      }\n    }\n    else {\n      if (alpha >= 0.6) {\n        vColor.a = 1.0 - d / radius;\n        if (alpha >= 0.5 && alpha <= 0.6) {\n            vColor.a *= smoothstep(0.0, 0.1, alpha - 0.5);\n        }\n        \n        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {\n            vColor.a *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);\n        }\n        \n      }\n      else {\n        vColor.a = 0.0;\n      }\n    }\n    gl_FragColor = vColor;\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n	  #include <encodings_fragment>\n    \n}") : (this.vertexShader = uy, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float trail;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n    vec4 vColor = color;\n    float range = mod(elapsedTime, (duration + trail));\n    float percent = 0.0;\n    if (range <= duration) {\n      percent = range / duration * 2.0;\n    } else {\n      percent = 1.0;\n    }\n    float r = radius * percent;\n    \n    // 中心点\n    if (d <= center){\n      if(d > 0.99 * center && d <= center) {\n        vColor.a = 1.0 - smoothstep(0.99 * center, center, d);\n      }\n    }\n    else {\n      if (d < r) {\n        vColor.a = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);\n        // 边缘抗锯齿\n        if (d >= 0.99 * r && d <= r) {\n          vColor.a *= 1.0 - smoothstep(0.99, 1.0, d / r);\n        }\n        // 拖尾渐隐\n        if (range > duration) {\n          vColor.a *= 1.0 - (range - duration) / trail;\n        }\n      }\n      else {\n        vColor.a = 0.0;\n      }\n      \n    }\n    gl_FragColor = vColor;\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n	  #include <encodings_fragment>\n    \n}"), Object.assign(this.uniforms, Ci.clone(dy)), Mh(this, ["duration", "trail"]), this.setValues(e2);
        }
      }
      const my = new Ae();
      new st();
      const fy = new st();
      new st();
      class gy extends ey {
        constructor(e2) {
          super(e2), __publicField(this, "_shapeType", "cube"), __publicField(this, "fillNoLine", (e3, t2, i2, n2, r2) => {
            for (let s2 = 0, a2 = e3.length; s2 < a2 - 2; s2 += 3)
              i2.push(e3[s2], e3[s2 + 1], e3[s2 + 2]), t2.push(0), n2.push(0), r2.push(0);
          }), __publicField(this, "generateLines", (e3, t2, i2, n2, r2, s2, a2) => {
            const o2 = t2.length / 3;
            let l2, h2, c2, u2, d2, p2, m2, f2;
            for (let g2 = 0, _2 = e3.length; g2 < _2; ++g2) {
              m2 = 3 * e3[g2][0], f2 = 3 * e3[g2][1], l2 = t2[m2], h2 = t2[m2 + 1], c2 = t2[m2 + 2], u2 = t2[f2], d2 = t2[f2 + 1], p2 = t2[f2 + 2], t2.push(l2, h2, c2, l2, h2, c2, u2, d2, p2, u2, d2, p2), i2.push(1, 1, 1, 1), n2.push(u2, d2, p2, u2, d2, p2, l2, h2, c2, l2, h2, c2), r2.push(1, 1, 0, 0), s2.push(1, -1, 1, -1);
              const _3 = o2 + 4 * g2;
              a2.push(_3, _3 + 1, _3 + 2, _3 + 2, _3 + 1, _3 + 3);
            }
          }), __publicField(this, "applyTransformToPositions", (e3, t2) => {
            const i2 = [];
            for (let n2 = 0, r2 = e3.length; n2 < r2 - 2; n2 += 3)
              my.set(e3[n2], e3[n2 + 1], e3[n2 + 2]), my.applyMatrix4(t2), i2.push(my.x, my.y, my.z);
            return i2;
          }), this.parameters = e2, this.shapeType = this.parameters.shapeType;
        }
        get shapeType() {
          return this._shapeType;
        }
        set shapeType(e2) {
          this._shapeType = e2, this.geometry && this.geometry.dispose();
          let t2 = null, i2 = null, n2 = null, r2 = [], s2 = [], a2 = [], o2 = [];
          if ("cube" === e2) {
            t2 = new wi(1, 1, 1), i2 = Array.from(t2.attributes.position.array), n2 = Array.from(t2.index.array), fy.identity().makeTranslation(0, 0, 0.5), i2 = this.applyTransformToPositions(i2, fy), this.fillNoLine(i2, r2, s2, a2, o2);
            const e3 = [];
            for (let t3 = 0; t3 < 24; t3 += 4)
              e3.push([t3, t3 + 1], [t3 + 3, t3 + 2], [t3 + 2, t3]);
            this.generateLines(e3, i2, r2, s2, a2, o2, n2);
          } else if ("octahedron" === e2) {
            i2 = [0, 0, 1, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0, 0, 0], n2 = [0, 1, 4, 0, 4, 3, 0, 3, 2, 0, 2, 1, 1, 5, 4, 4, 5, 3, 3, 5, 2, 2, 5, 1], this.fillNoLine(i2, r2, s2, a2, o2);
            const e3 = [[0, 1], [0, 2], [0, 3], [0, 4], [1, 4], [4, 3], [3, 2], [2, 1], [1, 5], [2, 5], [3, 5], [4, 5]];
            this.generateLines(e3, i2, r2, s2, a2, o2, n2);
          } else if ("pyramid" === e2) {
            i2 = [-0.5, -0.5, 1, -0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, -0.5, 1, 0, 0, 0, -0.25, -0.25, 0.5, -0.25, 0.25, 0.5, 0.25, 0.25, 0.5, 0.25, -0.25, 0.5], n2 = [0, 2, 1, 0, 3, 2, 1, 0, 4, 0, 3, 4, 3, 2, 4, 2, 1, 4], this.fillNoLine(i2, r2, s2, a2, o2);
            const e3 = [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 4], [2, 4], [3, 4], [6, 5], [5, 8], [8, 7], [7, 6]];
            this.generateLines(e3, i2, r2, s2, a2, o2, n2);
          }
          t2 && t2.dispose(), i2 && (this.setAttribute("position", new Jt(new Float32Array(i2), 3)), this.setAttribute("isLine", new Jt(new Float32Array(r2), 1)), this.setAttribute("adjacentPoint", new Jt(new Float32Array(s2), 3)), this.setAttribute("isLineStart", new Jt(new Float32Array(a2), 1)), this.setAttribute("lineSide", new Jt(new Float32Array(o2), 1)), this.setIndex(n2), this.computeBoundingSphere(), console.log(this.boundingSphere));
        }
        dispose() {
        }
      }
      const _y = Ci.merge([{ lineWidth: { value: 2 }, lineColor: { value: [1, 1, 0, 1] }, isCesium: { value: false } }]);
      class vy extends sy {
        constructor(e2) {
          super(), this.type = "InstancedShapeMaterial", this.isInstancedShapeMaterial = true, this.isUseSize3 = true, this.side = 2, this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\nattribute float isLine;\nattribute float isLineStart;\nattribute float lineSide;\nattribute vec3 adjacentPoint;\n// attribute mat4 instanceMatrix;\n\nuniform bool isCesium;\n\nuniform float height;\nuniform vec3 size3;\nuniform float time;\nuniform float lineWidth;\nvarying float vIsLine;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#define MVT_KEEP_PROJECTION_POSITION\n\nvec3 transformPosition(vec3 p) {\n    vec3 transformed = vec3(p);\n\n    #include <mvt_animation_vertex>\n\n    transformed *= size3;\n    transformed.z += height;\n\n    #include <mvt_keepsize_vertex>\n\n    return transformed;\n}\nvoid main() {\n    \n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n    if (isLine == 1.0) {\n        vIsLine = 1.0;\n        mat4 m = projectionMatrix * modelViewMatrix * instanceMatrix;\n        vec4 p1 = m * vec4(transformPosition(position), 1.0);\n        vec4 p2 = m * vec4(transformPosition(adjacentPoint), 1.0);\n        mvp_projectPosition = vec4(p1);\n        p1 /= p1.w;\n        p2 /= p2.w;\n        vec2 dir;\n        if (isLineStart == 1.0) {\n            dir = normalize(p2.xy - p1.xy);\n        } else {\n            dir = normalize(p1.xy - p2.xy);\n        }\n        vec2 _normal = vec2(-dir.y, dir.x);\n        // multiply by 2 and then divide by 2\n        vec2 offset = _normal * lineSide / resolution * lineWidth;\n        gl_Position = p1;\n        gl_Position.xy += offset;\n    } else {\n        vIsLine = 0.0;\n        vec3 transformed = transformPosition(position);\n        // mat4 tm = mat4(\n        //     1,0,0,0,\n        //     0,1,0,0,\n        //     0,0,1,0,\n        //     instanceMatrix[3][0],4826138.4,0,1\n        // );\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *\n            vec4(transformed, 1.0);\n        // gl_Position = projectionMatrix * viewMatrix *\n        //     vec4(transformed.x + 12957564.9, transformed.y + 4826138.4, transformed.z + 0.0, 1.0);\n        // vTest.x = instanceMatrix[1][1];\n        //  gl_Position = projectionMatrix * viewMatrix * \n        //     vec4(instancedPosition + transformed, 1.0);\n        mvp_projectPosition = gl_Position;\n    }\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform vec4 lineColor;\nuniform float opacity;\n\nvarying float vIsLine;\n\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    if (vIsLine == 1.0) {\n        gl_FragColor = lineColor;\n    }\n    else {\n        gl_FragColor = color;\n        // test\n        // gl_FragColor.r = vTest.x;\n        // gl_FragColor.g = vTest.y;\n        // gl_FragColor.b = vTest.z;\n        // gl_FragColor.a = 1.0;\n        // test end\n    }\n    gl_FragColor.a *= opacity;\n    #include <mvt_selective_fragment>\n}", Object.assign(this.uniforms, Ci.clone(_y)), Mh(this, ["lineWidth"]), Sh(this, ["lineColor"]), this.setValues(e2);
        }
      }
      const xy = new qa(), yy = Ci.merge([Xi.fog, yh, bh, { emissive: { value: [0, 0, 0] }, isEmissive: { value: false }, width: { value: 12 }, height: { value: 12 }, offset: { value: [0, 0] }, ulength: { value: 1 }, useCanvasMap: { value: false }, vertexIcons: { value: false }, opacity: { value: 1 }, map: { value: null }, useMap: { value: false }, uScale: { value: 1 }, uFlat: { value: false }, keepSize: { value: true } }]);
      class by extends yc {
        constructor(e2) {
          super(), this.type = "IconMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float uScale;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform bool uFlat;\nuniform bool keepSize;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (uFlat) {\n        float hw = width * 0.5;\n        float hh = height * 0.5;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n        }\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n            \n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = width / resolution.x * uScale;\n        float hh = height / resolution.y * uScale;\n        vec2 o = offset;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", this.isIconMaterial = true, this.transparent = true, Object.assign(this.uniforms, Ci.clone(yy)), Ch(this), Eh(this), Mh(this, ["width", "height", "offset", "opacity", "emissive", "isEmissive"]), wh(this, [["scale", "uScale"], ["flat", "uFlat"]]), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc, i2 = this.userData[this.urlCacheKey], n2 = this;
            if (i2 !== e3) {
              if (t2 && t2.dispose(), !e3)
                return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData[this.urlCacheKey];
              xy.load(e3, function(t3) {
                t3.wrapS = t3.wrapT = h, t3.encoding = 3001, n2.uniforms.map.value = t3, n2.userData[n2.urlCacheKey] = e3, n2.uniforms.useMap.value = true, n2.uniforms.useCanvasMap.value = false;
              });
            }
          } }, mapTexture: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            if (!e3)
              return this.uniforms.map.value = null, void (this.uniforms.useCanvasMap.value = false);
            e3.wrapS = e3.wrapT = h, e3.encoding = 3001, this.uniforms.map.value = e3, this.uniforms.useMap.value = false, this.uniforms.useCanvasMap.value = true, delete this.userData[this.urlCacheKey];
          } } }), this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class My extends ri {
        constructor(e2) {
          super(e2), this.parameters = e2;
        }
        setData(e2) {
          const { aPositions: t2, aObjectIndices: i2, aUvs: n2, pIndices: r2, indices: s2 } = e2;
          this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("pIndex", new Jt(r2, 1)), this.setAttribute("objectIndex", new Jt(i2, 1)), this.setAttribute("uv", new Jt(n2, 2)), this.setIndex(s2);
        }
      }
      const Sy = new Ae(), wy = new Se(), Ty = new st();
      class Ey extends vc {
        constructor(e2) {
          super(e2), __publicField(this, "isEventEntitySupported", true), __publicField(this, "_padding"), __publicField(this, "oldMapTextureRes", /* @__PURE__ */ new Map()), __publicField(this, "texture"), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "canvas"), __publicField(this, "ctx"), __publicField(this, "iconUrlHash", /* @__PURE__ */ new Map()), __publicField(this, "getTextureAndHash", (e3, t3, i2, n2, r2) => {
            const s2 = this, a2 = this.engine.rendering.pixelRatio, o2 = this.iconUrlHash;
            if (!r2 && this.oldMapTextureRes)
              return this.oldMapTextureRes;
            if (!e3[0] || !e3[0][t3])
              return { texture: this.texture, iconUrlHash: o2 };
            let l2 = o2.size, h2 = o2.size, c2 = /* @__PURE__ */ new Map();
            for (let f2 = 0; f2 < e3.length; f2++) {
              const i3 = e3[f2][t3];
              void 0 === o2.get(i3) && (o2.set(i3, l2), c2.set(i3, l2), l2++);
            }
            if (h2 === o2.size)
              return this.oldMapTextureRes;
            let u2 = this.canvas.toDataURL();
            const d2 = o2.size * (i2 + this.padding[0]), p2 = n2 + this.padding[1];
            this.canvas.width = d2 * a2, this.canvas.height = p2 * a2, this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            let m2 = new Image();
            return m2.setAttribute("crossOrigin", "Anonymous"), m2.onload = function() {
              s2.ctx.save(), s2.ctx.scale(a2, a2), s2.ctx.drawImage(m2, 0, 0, h2 * (i2 + s2.padding[0]), n2 + s2.padding[1]), s2.ctx.restore(), s2.texture.dispose(), s2.texture = new da(s2.canvas), s2.oldMapTextureRes = { texture: s2.texture, iconUrlHash: o2 }, s2.material.mapTexture = s2.texture;
            }, m2.src = u2, Array.from(c2).forEach((e4, t4) => {
              let r3 = new Image();
              r3.setAttribute("crossOrigin", "Anonymous"), r3.onload = function() {
                s2.ctx.save(), s2.ctx.scale(a2, a2), s2.ctx.drawImage(r3, 0, 0, r3.width, r3.height, e4[1] * i2 + s2.padding[0] * (e4[1] + 0.5), s2.padding[1] / 2, i2, n2), s2.ctx.restore(), s2.texture.dispose(), s2.texture = new da(s2.canvas), s2.oldMapTextureRes = { texture: s2.texture, iconUrlHash: o2 }, s2.material.mapTexture = s2.texture;
              }, r3.src = e4[0];
            }), this.texture.dispose(), this.texture = new da(this.canvas), this.oldMapTextureRes = { texture: this.texture, iconUrlHash: o2 }, { texture: this.texture, iconUrlHash: o2 };
          }), this.parameters = e2, this._padding = void 0 !== this.parameters.padding ? this.parameters.padding : [2, 2];
          const t2 = this.canvas = document.createElement("canvas");
          t2.width = t2.height = 1, this.ctx = t2.getContext("2d"), this.texture = new da(t2), this.defineMaterialProxyProperties(["width", "height", "offset", "map", "opacity", "flat", "keepSize"]);
        }
        initObject() {
          let { vertexIcons: e2, ...t2 } = this.parameters;
          this.geometry = new My(this.parameters), this.material = new by(t2), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        getDefaultParams() {
          return { width: 12, height: 12 };
        }
        collisionTest(e2) {
          return { width: this.width, height: this.height };
        }
        setData() {
          const { vertexIcons: e2, inconPropName: t2 = "icon", width: i2, height: n2 } = this.parameters;
          let r2 = [];
          r2 = this._enableCollision && this._collisionData ? this._collisionData : this.dataSource.userData;
          const s2 = [], a2 = [], o2 = [], l2 = [], h2 = [];
          let c2 = "", u2 = {};
          if (e2) {
            const d2 = this.getTextureAndHash(r2, t2, i2, n2, true);
            c2 = d2.texture, u2 = d2.iconUrlHash || {}, this.material.mapTexture = c2, this.material.uniforms.ulength.value = u2.size;
            for (let i3 = 0; i3 < r2.length; i3++) {
              console.log(r2[i3]);
              const n3 = r2[i3].position, c3 = r2[i3].index;
              for (let e3 = 0; e3 < 4; e3++)
                s2.push(...n3), a2.push(e3), o2.push(c3);
              e2 ? l2.push(u2.get(r2[i3][t2]) / u2.size, 0, u2.get(r2[i3][t2]) / u2.size, 1, (u2.get(r2[i3][t2]) + 1) / u2.size, 1, (u2.get(r2[i3][t2]) + 1) / u2.size, 0) : l2.push(0, 0, 0, 1, 1, 1, 1, 0);
              const d3 = 4 * i3;
              h2.push(d3, d3 + 2, d3 + 1, d3, d3 + 3, d3 + 2);
            }
          } else
            for (let d2 = 0; d2 < r2.length; d2++) {
              const e3 = r2[d2].position, t3 = r2[d2].index;
              for (let n3 = 0; n3 < 4; n3++)
                s2.push(...e3), a2.push(n3), o2.push(t3);
              l2.push(0, 0, 0, 1, 1, 1, 1, 0);
              const i3 = 4 * d2;
              h2.push(i3, i3 + 2, i3 + 1, i3, i3 + 3, i3 + 2);
            }
          this.geometry.setData({ aPositions: s2, pIndices: a2, aObjectIndices: o2, aUvs: l2, indices: h2 }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, s2), this.needsUpdate = false;
        }
        getEntityByIndex(e2) {
          const t2 = this.dataSource, i2 = { index: e2, value: t2.getOriginData(e2), itemIndex: t2.getOriginDataIndex(e2), pairs: {} }, n2 = t2.data;
          for (const r2 of Object.keys(n2))
            i2.pairs[r2] = n2[r2][e2];
          return i2;
        }
        raycast(e2, t2) {
          if (this.flat)
            return;
          const i2 = this.geometry, n2 = i2.getAttribute("position");
          if (!n2 || !n2.array || 0 === !n2.array.length)
            return;
          const r2 = i2.getAttribute("offset");
          let s2 = [];
          r2 && (s2 = r2.array);
          const a2 = e2.camera, o2 = e2.mouse, l2 = this.material.uniforms.resolution.value, h2 = o2.x, c2 = o2.y, u2 = this.width / l2[0], d2 = this.height / l2[0];
          let p2 = 0, m2 = 0, f2 = 0, g2 = 0, _2 = 0, v2 = 0;
          Ty.multiplyMatrices(a2.projectionMatrix, a2.matrixWorldInverse), Ty.multiplyMatrices(Ty, this.matrixWorld);
          const x2 = n2.array;
          let y2 = 0;
          for (let b2 = 0, M2 = x2.length - 11; b2 < M2; b2 += 12)
            if (wy.set(x2[b2], x2[b2 + 1], x2[b2 + 2], 1), wy.applyMatrix4(Ty), wy.divideScalar(wy.w), this.parameters.vertexOffsets ? (y2 = b2 / 12 * 8, _2 = s2[y2] || 0, v2 = s2[y2 + 1] || 0) : (_2 = this.parameters.offset && this.parameters.offset[0] || 0, v2 = this.parameters.offset && this.parameters.offset[1] || 0), wy.x += 2 * _2 / l2[0], wy.y -= 2 * v2 / l2[1], p2 = wy.x - u2, f2 = wy.x + u2, m2 = wy.y - d2, g2 = wy.y + d2, p2 <= h2 && f2 >= h2 && m2 <= c2 && g2 >= c2) {
              Sy.set(x2[b2], x2[b2 + 1], x2[b2 + 2]), Sy.applyMatrix4(this.matrixWorld);
              const e3 = { instanceId: b2 / 12, object: this, distance: Sy.distanceTo(a2.position) };
              t2.push(e3);
            }
        }
        onDispose() {
          this.texture && this.texture.dispose();
        }
        set padding(e2) {
          this._padding = e2;
        }
        get padding() {
          return this._padding;
        }
      }
      const Cy = new Se(), Ay = new st(), Py = new ie();
      const Ry = new qa(), Ly = Ci.merge([Xi.fog, yh, bh, { emissive: { value: [0, 0, 0] }, isEmissive: { value: false }, width: { value: 12 }, height: { value: 12 }, offset: { value: [0, 0] }, ulength: { value: 1 }, useCanvasMap: { value: false }, vertexIcons: { value: false }, opacity: { value: 1 }, map: { value: null }, useMap: { value: false }, uFlat: { value: false }, keepSize: { value: true } }]);
      class Iy extends yc {
        constructor(e2) {
          super(), this.type = "LabelMaterial", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform bool uFlat;\nuniform bool keepSize;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (uFlat) {\n        float hw = width * 0.5;\n        float hh = height * 0.5;\n        vec2 o = offset;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n            o *= pixelSize;\n        }\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n            \n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = width / resolution.x;\n        float hh = height / resolution.y;\n        vec2 o = offset;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n}", this.isLabelMaterial = true, this.transparent = true, Object.assign(this.uniforms, Ci.clone(Ly)), Ch(this), Eh(this), wh(this, [["flat", "uFlat"]]), Mh(this, ["width", "height", "offset", "opacity", "emissive", "isEmissive"]), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc, i2 = this.userData[this.urlCacheKey], n2 = this;
            if (i2 !== e3) {
              if (t2 && t2.dispose(), !e3)
                return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData[this.urlCacheKey];
              Ry.load(e3, function(t3) {
                t3.wrapS = t3.wrapT = h, t3.encoding = 3001, n2.uniforms.map.value = t3, n2.userData[n2.urlCacheKey] = e3, n2.uniforms.useMap.value = true, n2.uniforms.useCanvasMap.value = false;
              });
            }
          } }, mapTexture: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            if (!e3)
              return this.uniforms.map.value = null, void (this.uniforms.useCanvasMap.value = false);
            e3.wrapS = e3.wrapT = h, e3.encoding = 3001, this.uniforms.map.value = e3, this.uniforms.useMap.value = false, this.uniforms.useCanvasMap.value = true, delete this.userData[this.urlCacheKey];
          } } }), this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class Dy extends ri {
        constructor(e2) {
          super(e2), this.parameters = e2;
        }
        setData(e2) {
          const { aPositions: t2, aObjectIndices: i2, aUvs: n2, pIndices: r2, indices: s2 } = e2;
          this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("pIndex", new Jt(r2, 1)), this.setAttribute("objectIndex", new Jt(i2, 1)), this.setAttribute("uv", new Jt(n2, 2)), this.setIndex(s2);
        }
      }
      const Fy = new Ae(), Oy = new Se(), Uy = new st();
      class zy extends vc {
        constructor(e2) {
          super(e2), __publicField(this, "isEventEntitySupported", true), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "canvas"), __publicField(this, "ctx"), __publicField(this, "texture"), __publicField(this, "iconUrlHash", /* @__PURE__ */ new Map()), __publicField(this, "labelHash", /* @__PURE__ */ new Map()), __publicField(this, "boxHash", /* @__PURE__ */ new Map()), __publicField(this, "gap", [2, 2]), __publicField(this, "_padding"), __publicField(this, "_fillStyle"), __publicField(this, "oldMapTextureRes", {}), __publicField(this, "getTextureAndHash", async (e3, t3, i2, n2, r2) => {
            const s2 = this.ctx, a2 = this.labelHash, o2 = this.iconUrlHash;
            if (!r2 && this.oldMapTextureRes)
              return this.oldMapTextureRes;
            if (!e3[0] || !e3[0][n2])
              return { texture: this.texture, labelHash: a2 };
            let l2 = a2.size, h2 = a2.size, c2 = /* @__PURE__ */ new Map();
            for (let d2 = 0; d2 < e3.length; d2++) {
              const r3 = this.parameters.vertexBackgrounds ? e3[d2][i2] : t3, s3 = e3[d2][n2], h3 = JSON.stringify({ icon: r3, text: s3 });
              void 0 === o2.get(r3) && (o2.set(r3, r3), c2.set(r3, r3)), void 0 === a2.get(h3) && (a2.set(h3, l2), l2++);
            }
            if (h2 === a2.size)
              return this.oldMapTextureRes;
            let u2 = Array.from(o2.entries()).filter((e4) => "string" == typeof e4[1]).map(([e4, t4]) => new Promise((t5, i3) => {
              this.url2canvas(e4, (i4) => {
                o2.set(e4, i4), t5(e4);
              });
            }));
            return await Promise.all(u2).then((e4) => {
              if (!this.canvas)
                return this.oldMapTextureRes;
              let t4 = [];
              for (let [s3, l3] of a2) {
                const e5 = JSON.parse(s3).icon, i4 = JSON.parse(s3).text, n4 = o2.get(e5);
                if ("string" == typeof n4)
                  continue;
                const r4 = n4.width, a3 = n4.height, l4 = r4 + this.gap[0], h3 = a3 + this.gap[1];
                t4.push({ w: l4, h: h3, width: r4, height: a3, key: s3, icon: n4, text: i4 });
              }
              const i3 = xc(t4);
              for (let s3 = 0; s3 < t4.length; s3++) {
                const e5 = t4[s3];
                this.boxHash.get(e5.key) || this.boxHash.set(e5.key, e5);
              }
              const n3 = i3.w, r3 = i3.h;
              this.canvas.width = n3 || 1, this.canvas.height = r3 || 1, s2.save();
              for (let a3 = 0; a3 < t4.length; a3++) {
                const e5 = t4[a3], i4 = e5.icon, n4 = e5.text;
                s2.drawImage(i4, e5.x + this.gap[0], e5.y + this.gap[1], e5.width, e5.height);
                let r4 = this.parameters.fontSize;
                "auto" === r4 && (r4 = this.getFontSize(n4, e5.width, e5.height)), s2.font = `${r4}px Microsoft Yahei`, s2.fillStyle = this._fillStyle, s2.textBaseline = "top", s2.fillText(n4, e5.x + this.gap[0] / 2 + this.padding[3], e5.y + this.gap[1] / 2 + this.padding[0]);
              }
              return s2.restore(), this.texture.dispose(), this.texture = new da(this.canvas), this.oldMapTextureRes = { texture: this.texture, labelHash: a2 }, { texture: this.texture, labelHash: a2 };
            });
          }), this.parameters = e2, this._padding = [0, 0, 0, 0], this.parameters.padding && (this.padding = this.parameters.padding), this._fillStyle = this.parameters.fillStyle || "#fff";
          const t2 = this.canvas = document.createElement("canvas");
          t2.width = t2.height = 1;
          (this.ctx = t2.getContext("2d")).textAlign = "start", this.texture = new da(t2), this.defineMaterialProxyProperties(["width", "height", "offset", "opacity", "flat", "keepSize"]);
        }
        initObject() {
          const { background: e2, vertexBackgrounds: t2, fontSize: i2, padding: n2, fillStyle: r2, ...s2 } = this.parameters;
          this.geometry = new Dy(this.parameters), this.material = new Iy(s2), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        getDefaultParams() {
          return { width: 12, height: 12, fontSize: 14 };
        }
        collisionTest(e2) {
          return { width: this.width, height: this.height };
        }
        async setData() {
          const { vertexBackgrounds: e2, background: t2, bgPropName: i2 = "background", textPropName: n2 = "text" } = this.parameters;
          let r2 = [];
          r2 = this._enableCollision && this._collisionData ? this._collisionData : this.dataSource.userData;
          const s2 = await this.getTextureAndHash(r2, t2, i2, n2, true);
          if (!s2 || !s2.texture || !s2.labelHash)
            return;
          let a2 = s2.texture, o2 = s2.labelHash;
          this.material.mapTexture = a2, this.material.uniforms.ulength.value = o2.size;
          const l2 = [], h2 = [], c2 = [], u2 = [], d2 = [];
          for (let p2 = 0; p2 < r2.length; p2++) {
            const s3 = r2[p2].position, a3 = r2[p2].index, o3 = JSON.stringify({ icon: e2 ? r2[p2][i2] : t2, text: r2[p2][n2] }), m2 = this.boxHash.get(o3);
            if (!m2)
              continue;
            for (let e3 = 0; e3 < 4; e3++)
              l2.push(...s3), h2.push(e3), c2.push(a3);
            const f2 = m2.x / this.canvas.width, g2 = (m2.x + m2.w) / this.canvas.width, _2 = (m2.y + m2.h) / this.canvas.height, v2 = m2.y / this.canvas.height;
            u2.push(f2, _2, f2, v2, g2, v2, g2, _2);
            const x2 = 4 * p2;
            d2.push(x2, x2 + 2, x2 + 1, x2, x2 + 3, x2 + 2);
          }
          this.geometry.setData({ aPositions: l2, pIndices: h2, aObjectIndices: c2, aUvs: u2, indices: d2 }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, l2), this.needsUpdate = false, this.engine.requestRender();
        }
        url2canvas(e2, t2) {
          if ("object" == typeof e2)
            t2(e2);
          else {
            let i2 = new Image();
            i2.crossOrigin = "anonymous", i2.onload = function() {
              let e3 = i2.width, n2 = i2.height, r2 = document.createElement("canvas");
              r2.width = e3, r2.height = n2, r2.getContext("2d").drawImage(i2, 0, 0, e3, n2), t2(r2);
            }, i2.onerror = function() {
              let e3 = document.createElement("canvas");
              e3.width = 20, e3.height = 40;
              let i3 = e3.getContext("2d");
              i3.fillStyle = "red", i3.beginPath(), i3.lineTo(0, 0), i3.lineTo(20, 0), i3.lineTo(10, 40), i3.closePath(), i3.fill(), t2(e3);
            }, i2.src = e2;
          }
        }
        getFontSize(e2, t2, i2, n2 = 1) {
          const r2 = this.ctx, s2 = this.padding;
          return r2.font = `${n2}px Microsoft Yahei`, r2.textBaseline = "top", r2.measureText(e2).width + s2[1] + s2[3] >= t2 || n2 + s2[0] + s2[2] >= i2 ? n2 - 1 : this.getFontSize(e2, t2, i2, n2 + 1);
        }
        getEntityByIndex(e2) {
          const t2 = this.dataSource, i2 = { index: e2, value: t2.getOriginData(e2), itemIndex: t2.getOriginDataIndex(e2), pairs: {} }, n2 = t2.data;
          for (const r2 of Object.keys(n2))
            i2.pairs[r2] = n2[r2][e2];
          return i2;
        }
        raycast(e2, t2) {
          if (this.flat)
            return;
          const i2 = this.geometry, n2 = i2.getAttribute("position");
          if (!n2 || !n2.array || 0 === !n2.array.length)
            return;
          const r2 = i2.getAttribute("offset");
          let s2 = [];
          r2 && (s2 = r2.array);
          const a2 = e2.camera, o2 = e2.mouse, l2 = this.material.uniforms.resolution.value, h2 = o2.x, c2 = o2.y, u2 = this.width / l2[0], d2 = this.height / l2[0];
          let p2 = 0, m2 = 0, f2 = 0, g2 = 0, _2 = 0, v2 = 0;
          Uy.multiplyMatrices(a2.projectionMatrix, a2.matrixWorldInverse), Uy.multiplyMatrices(Uy, this.matrixWorld);
          const x2 = n2.array;
          let y2 = 0;
          for (let b2 = 0, M2 = x2.length - 11; b2 < M2; b2 += 12)
            if (Oy.set(x2[b2], x2[b2 + 1], x2[b2 + 2], 1), Oy.applyMatrix4(Uy), Oy.divideScalar(Oy.w), this.parameters.vertexOffsets ? (y2 = b2 / 12 * 8, _2 = s2[y2] || 0, v2 = s2[y2 + 1] || 0) : (_2 = this.parameters.offset && this.parameters.offset[0] || 0, v2 = this.parameters.offset && this.parameters.offset[1] || 0), Oy.x += 2 * _2 / l2[0], Oy.y -= 2 * v2 / l2[1], p2 = Oy.x - u2, f2 = Oy.x + u2, m2 = Oy.y - d2, g2 = Oy.y + d2, p2 <= h2 && f2 >= h2 && m2 <= c2 && g2 >= c2) {
              Fy.set(x2[b2], x2[b2 + 1], x2[b2 + 2]), Fy.applyMatrix4(this.matrixWorld);
              const e3 = { instanceId: b2 / 12, object: this, distance: Fy.distanceTo(a2.position) };
              t2.push(e3);
            }
        }
        set padding(e2) {
          2 === e2.length ? this._padding = [e2[0], e2[1], e2[0], e2[1]] : 3 === e2.length ? this._padding = [e2[0], e2[1], e2[2], e2[1]] : e2.length >= 4 && (this._padding = [e2[0], e2[1], e2[2], e2[3]]);
        }
        get padding() {
          return this._padding;
        }
        onDispose() {
          this.texture && this.texture.dispose(), this.canvas && (this.canvas = null), this.iconUrlHash.clear(), this.labelHash.clear(), this.boxHash.clear();
        }
      }
      function Ny(e2, t2, i2, n2, r2, s2) {
        if (r2 - n2 <= i2)
          return;
        const a2 = n2 + r2 >> 1;
        ky(e2, t2, a2, n2, r2, s2 % 2), Ny(e2, t2, i2, n2, a2 - 1, s2 + 1), Ny(e2, t2, i2, a2 + 1, r2, s2 + 1);
      }
      function ky(e2, t2, i2, n2, r2, s2) {
        for (; r2 > n2; ) {
          if (r2 - n2 > 600) {
            const a3 = r2 - n2 + 1, o3 = i2 - n2 + 1, l3 = Math.log(a3), h2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * h2 * (a3 - h2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            ky(e2, t2, i2, Math.max(n2, Math.floor(i2 - o3 * h2 / a3 + c2)), Math.min(r2, Math.floor(i2 + (a3 - o3) * h2 / a3 + c2)), s2);
          }
          const a2 = t2[2 * i2 + s2];
          let o2 = n2, l2 = r2;
          for (By(e2, t2, n2, i2), t2[2 * r2 + s2] > a2 && By(e2, t2, n2, r2); o2 < l2; ) {
            for (By(e2, t2, o2, l2), o2++, l2--; t2[2 * o2 + s2] < a2; )
              o2++;
            for (; t2[2 * l2 + s2] > a2; )
              l2--;
          }
          t2[2 * n2 + s2] === a2 ? By(e2, t2, n2, l2) : (l2++, By(e2, t2, l2, r2)), l2 <= i2 && (n2 = l2 + 1), i2 <= l2 && (r2 = l2 - 1);
        }
      }
      function By(e2, t2, i2, n2) {
        Vy(e2, i2, n2), Vy(t2, 2 * i2, 2 * n2), Vy(t2, 2 * i2 + 1, 2 * n2 + 1);
      }
      function Vy(e2, t2, i2) {
        const n2 = e2[t2];
        e2[t2] = e2[i2], e2[i2] = n2;
      }
      function Gy(e2, t2, i2, n2) {
        const r2 = e2 - i2, s2 = t2 - n2;
        return r2 * r2 + s2 * s2;
      }
      const Hy = (e2) => e2[0], jy = (e2) => e2[1];
      class Wy {
        constructor(e2, t2 = Hy, i2 = jy, n2 = 64, r2 = Float64Array) {
          this.nodeSize = n2, this.points = e2;
          const s2 = e2.length < 65536 ? Uint16Array : Uint32Array, a2 = this.ids = new s2(e2.length), o2 = this.coords = new r2(2 * e2.length);
          for (let l2 = 0; l2 < e2.length; l2++)
            a2[l2] = l2, o2[2 * l2] = t2(e2[l2]), o2[2 * l2 + 1] = i2(e2[l2]);
          Ny(a2, o2, n2, 0, a2.length - 1, 0);
        }
        range(e2, t2, i2, n2) {
          return function(e3, t3, i3, n3, r2, s2, a2) {
            const o2 = [0, e3.length - 1, 0], l2 = [];
            let h2, c2;
            for (; o2.length; ) {
              const u2 = o2.pop(), d2 = o2.pop(), p2 = o2.pop();
              if (d2 - p2 <= a2) {
                for (let a3 = p2; a3 <= d2; a3++)
                  h2 = t3[2 * a3], c2 = t3[2 * a3 + 1], h2 >= i3 && h2 <= r2 && c2 >= n3 && c2 <= s2 && l2.push(e3[a3]);
                continue;
              }
              const m2 = Math.floor((p2 + d2) / 2);
              h2 = t3[2 * m2], c2 = t3[2 * m2 + 1], h2 >= i3 && h2 <= r2 && c2 >= n3 && c2 <= s2 && l2.push(e3[m2]);
              const f2 = (u2 + 1) % 2;
              (0 === u2 ? i3 <= h2 : n3 <= c2) && (o2.push(p2), o2.push(m2 - 1), o2.push(f2)), (0 === u2 ? r2 >= h2 : s2 >= c2) && (o2.push(m2 + 1), o2.push(d2), o2.push(f2));
            }
            return l2;
          }(this.ids, this.coords, e2, t2, i2, n2, this.nodeSize);
        }
        within(e2, t2, i2) {
          return function(e3, t3, i3, n2, r2, s2) {
            const a2 = [0, e3.length - 1, 0], o2 = [], l2 = r2 * r2;
            for (; a2.length; ) {
              const h2 = a2.pop(), c2 = a2.pop(), u2 = a2.pop();
              if (c2 - u2 <= s2) {
                for (let r3 = u2; r3 <= c2; r3++)
                  Gy(t3[2 * r3], t3[2 * r3 + 1], i3, n2) <= l2 && o2.push(e3[r3]);
                continue;
              }
              const d2 = Math.floor((u2 + c2) / 2), p2 = t3[2 * d2], m2 = t3[2 * d2 + 1];
              Gy(p2, m2, i3, n2) <= l2 && o2.push(e3[d2]);
              const f2 = (h2 + 1) % 2;
              (0 === h2 ? i3 - r2 <= p2 : n2 - r2 <= m2) && (a2.push(u2), a2.push(d2 - 1), a2.push(f2)), (0 === h2 ? i3 + r2 >= p2 : n2 + r2 >= m2) && (a2.push(d2 + 1), a2.push(c2), a2.push(f2));
            }
            return o2;
          }(this.ids, this.coords, e2, t2, i2, this.nodeSize);
        }
      }
      const Xy = { minZoom: 0, maxZoom: 16, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 };
      class qy {
        constructor(e2) {
          this.options = tb(Object.create(Xy), e2), this.trees = new Array(this.options.maxZoom + 1);
        }
        load(e2) {
          const { log: t2, minZoom: i2, maxZoom: n2, nodeSize: r2 } = this.options;
          t2 && console.time("total time");
          const s2 = `prepare ${e2.length} points`;
          t2 && console.time(s2), this.points = e2;
          let a2 = [];
          for (let o2 = 0; o2 < e2.length; o2++) {
            const t3 = e2[o2];
            (Array.isArray(t3) || t3.geometry) && a2.push(Zy(t3, o2));
          }
          this.trees[n2 + 1] = new Wy(a2, ib, nb, r2, Float32Array), t2 && console.timeEnd(s2);
          for (let o2 = n2; o2 >= i2; o2--) {
            const e3 = +Date.now();
            a2 = this._cluster(a2, o2), this.trees[o2] = new Wy(a2, ib, nb, r2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", o2, a2.length, +Date.now() - e3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let i2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const n2 = Math.max(-90, Math.min(90, e2[1]));
          let r2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const s2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            i2 = -180, r2 = 180;
          else if (i2 > r2) {
            const e3 = this.getClusters([i2, n2, 180, s2], t2), a3 = this.getClusters([-180, n2, r2, s2], t2);
            return e3.concat(a3);
          }
          const a2 = this.trees[this._limitZoom(t2)], o2 = a2.range(Qy(i2), $y(s2), Qy(r2), $y(n2)), l2 = [];
          for (const h2 of o2) {
            const e3 = a2.points[h2];
            l2.push(e3.numPoints ? Jy(e3) : this.points[e3.index]);
          }
          return l2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), i2 = this._getOriginZoom(e2), n2 = "No cluster with the specified id.", r2 = this.trees[i2];
          if (!r2)
            throw new Error(n2);
          const s2 = r2.points[t2];
          if (!s2)
            throw new Error(n2);
          const a2 = this.options.radius / (this.options.extent * Math.pow(2, i2 - 1)), o2 = r2.within(s2.x, s2.y, a2), l2 = [];
          for (const h2 of o2) {
            const t3 = r2.points[h2];
            t3.parentId === e2 && l2.push(t3.numPoints ? Jy(t3) : this.points[t3.index]);
          }
          if (0 === l2.length)
            throw new Error(n2);
          return l2;
        }
        getLeaves(e2, t2, i2) {
          t2 = t2 || 10, i2 = i2 || 0;
          const n2 = [];
          return this._appendLeaves(n2, e2, t2, i2, 0), n2;
        }
        getTile(e2, t2, i2) {
          const n2 = this.trees[this._limitZoom(e2)], r2 = Math.pow(2, e2), { extent: s2, radius: a2 } = this.options, o2 = a2 / s2, l2 = (i2 - o2) / r2, h2 = (i2 + 1 + o2) / r2, c2 = { features: [] };
          return this._addTileFeatures(n2.range((t2 - o2) / r2, l2, (t2 + 1 + o2) / r2, h2), n2.points, t2, i2, r2, c2), 0 === t2 && this._addTileFeatures(n2.range(1 - o2 / r2, l2, 1, h2), n2.points, r2, i2, r2, c2), t2 === r2 - 1 && this._addTileFeatures(n2.range(0, l2, o2 / r2, h2), n2.points, -1, i2, r2, c2), c2.features.length ? c2 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (; t2 <= this.options.maxZoom; ) {
            const i2 = this.getChildren(e2);
            if (t2++, 1 !== i2.length)
              break;
            e2 = i2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, i2, n2, r2) {
          const s2 = this.getChildren(t2);
          for (const a2 of s2) {
            const t3 = a2.properties;
            if (t3 && t3.cluster ? r2 + t3.point_count <= n2 ? r2 += t3.point_count : r2 = this._appendLeaves(e2, t3.cluster_id, i2, n2, r2) : r2 < n2 ? r2++ : e2.push(a2), e2.length === i2)
              break;
          }
          return r2;
        }
        _addTileFeatures(e2, t2, i2, n2, r2, s2) {
          for (const a2 of e2) {
            const e3 = t2[a2], o2 = e3.numPoints, l2 = { type: 1, geometry: [[Math.round(this.options.extent * (e3.x * r2 - i2)), Math.round(this.options.extent * (e3.y * r2 - n2))]], tags: o2 ? Ky(e3) : this.points[e3.index].properties };
            let h2;
            o2 ? h2 = e3.id : this.options.generateId ? h2 = e3.index : this.points[e3.index].id && (h2 = this.points[e3.index].id), void 0 !== h2 && (l2.id = h2), s2.features.push(l2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(e2, this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const i2 = [], { radius: n2, extent: r2, reduce: s2 } = this.options, a2 = n2 / (r2 * Math.pow(2, t2));
          for (let o2 = 0; o2 < e2.length; o2++) {
            const n3 = e2[o2];
            if (n3.zoom <= t2)
              continue;
            n3.zoom = t2;
            const r3 = this.trees[t2 + 1], l2 = r3.within(n3.x, n3.y, a2);
            let h2 = n3.numPoints || 1, c2 = n3.x * h2, u2 = n3.y * h2, d2 = s2 && h2 > 1 ? this._map(n3, true) : null;
            const p2 = (o2 << 5) + (t2 + 1) + this.points.length;
            for (const e3 of l2) {
              const i3 = r3.points[e3];
              if (i3.zoom <= t2)
                continue;
              i3.zoom = t2;
              const a3 = i3.numPoints || 1;
              c2 += i3.x * a3, u2 += i3.y * a3, h2 += a3, i3.parentId = p2, s2 && (d2 || (d2 = this._map(n3, true)), s2(d2, this._map(i3)));
            }
            1 === h2 ? i2.push(n3) : (n3.parentId = p2, i2.push(Yy(c2 / h2, u2 / h2, p2, h2, d2)));
          }
          return i2;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2) {
          if (e2.numPoints)
            return t2 ? tb({}, e2.properties) : e2.properties;
          const i2 = this.points[e2.index].properties, n2 = this.options.map(i2);
          return t2 && n2 === i2 ? tb({}, n2) : n2;
        }
      }
      function Yy(e2, t2, i2, n2, r2) {
        return { x: e2, y: t2, zoom: 1 / 0, id: i2, parentId: -1, numPoints: n2, properties: r2 };
      }
      function Zy(e2, t2) {
        const [i2, n2] = Array.isArray(e2) ? e2 : e2.geometry.coordinates;
        return { x: Qy(i2), y: $y(n2), zoom: 1 / 0, index: t2, parentId: -1 };
      }
      function Jy(e2) {
        return { type: "Feature", id: e2.id, properties: Ky(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), eb(e2.y)] } };
        var t2;
      }
      function Ky(e2) {
        const t2 = e2.numPoints, i2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
        return tb(tb({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: i2 });
      }
      function Qy(e2) {
        return e2 / 360 + 0.5;
      }
      function $y(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), i2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return i2 < 0 ? 0 : i2 > 1 ? 1 : i2;
      }
      function eb(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function tb(e2, t2) {
        for (const i2 in t2)
          e2[i2] = t2[i2];
        return e2;
      }
      function ib(e2) {
        return e2.x;
      }
      function nb(e2) {
        return e2.y;
      }
      class rb extends _c {
        constructor() {
          super(...arguments), __publicField(this, "isEventEntitySupported", true);
        }
        addComponent(e2) {
          if (!e2.isGeoObject)
            return void console.warn("Only GeoObject can be added");
          e2.__eventProxyByParent = true, this.add(e2), e2.afterAddToEngine(this.engine);
          const t2 = this.getChildDataSource(e2);
          return t2 && (e2.dataSource = t2), this.needsUpdate = true, e2;
        }
        removeComponent(e2) {
          this.remove(e2), e2.__eventProxyByParent = false, e2.dataSource = null, e2.beforeRemoveFromEngine(this.engine), this.needsUpdate = true;
        }
        getChildDataSource(e2) {
          return this.dataSource;
        }
        onBeforeScenePrepareRender(e2, t2, i2, n2) {
          super.onBeforeScenePrepareRender && super.onBeforeScenePrepareRender(e2, t2, i2, n2);
          for (const r2 of this.children)
            r2.onBeforeScenePrepareRender && r2.onBeforeScenePrepareRender(e2, t2, i2, n2);
        }
        onBeforeSceneRender(e2, t2, i2, n2) {
          super.onBeforeSceneRender && super.onBeforeSceneRender(e2, t2, i2, n2);
          for (const r2 of this.children)
            r2.onBeforeSceneRender && r2.onBeforeSceneRender(e2, t2, i2, n2);
        }
        setDataSource(e2) {
          super.setDataSource(e2);
          for (const t2 of this.children)
            t2.setDataSource(this.getChildDataSource(t2));
        }
        setData() {
          for (const e2 of this.children)
            e2.needsUpdate && e2.setData();
          this.needsUpdate = false;
        }
        dispose() {
          for (const e2 of this.children)
            e2.dispose();
        }
      }
      const sb = { width: 30, height: 30, mapSrc: "https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png" }, ab = { collides: false, fillStyle: "#ccc", fontSize: 16, flat: false }, ob = { maxZoom: 18, minZoom: 5, radius: 50 };
      const lb = Ci.merge([{ emissive: { value: [0, 0, 0] } }]);
      class hb extends sy {
        constructor(e2) {
          super(), this.type = "InstancedEffectModelMaterial", this.isInstancedEffectModelMaterial = true, this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float height;\n#if defined(USE_SIZE3)\nuniform vec3 size3;\n#else\nuniform float size;\n#endif\n\nuniform float elapsedTime;\nattribute float instancedRandomFactor;\n\n#if defined(VERTEX_COLOR4)\n    attribute vec4 color;\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    attribute vec3 color;\n    varying vec3 vColor;\n#endif\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#define MVT_KEEP_PROJECTION_POSITION\n\n#include <logdepthbuf_pars_vertex>\nvec3 transformPosition(vec3 p) {\n    vec3 transformed = vec3(p);\n\n    #include <mvt_animation_vertex>\n\n    #if defined(USE_SIZE3)\n        transformed *= size3;\n    #else\n        transformed *= size;\n    #endif\n    transformed.z += height;\n\n    #include <mvt_keepsize_vertex>\n\n    return transformed;\n}\nvoid main() {\n    \n    #if defined(VERTEX_COLOR4)\n        vColor = vec4(color);\n    #elif defined(VERTEX_COLOR3)\n        vColor = vec3(color);\n    #endif\n\n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n\n    vec3 transformed = transformPosition(position);\n    \n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *\n        vec4(transformed, 1.0);\n    \n    mvp_projectPosition = gl_Position;\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#if defined(VERTEX_COLOR4)\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    varying vec3 vColor;\n#else\n    uniform vec4 color;\n#endif\n\nuniform float opacity;\nuniform vec3 emissive;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#define MVT_EMISSIVE_SHADER\nvoid main() {\n\n    #include <logdepthbuf_fragment> \n\n    #if defined(VERTEX_COLOR4)\n        gl_FragColor = vColor;\n    #elif defined(VERTEX_COLOR3)\n        gl_FragColor = vec4(vColor, 1.0);\n    #else\n        gl_FragColor = color;\n    #endif\n      \n    gl_FragColor.a *= opacity;\n    vec4 out_emissive = vec4(emissive, 1.0);\n    #include <mvt_selective_fragment>\n\n    #include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", Object.assign(this.uniforms, Ci.clone(lb)), this.defines = {}, Mh(this, ["emissive"]), this.setValues(e2);
        }
        get vertexColors4() {
          return this.defines.VERTEX_COLOR4 = true;
        }
        set vertexColors4(e2) {
          e2 !== this.defines.VERTEX_COLOR4 && (this.defines.VERTEX_COLOR4 = !!e2, this.needsUpdate = true);
        }
        get vertexColors3() {
          return this.defines.VERTEX_COLOR3 = true;
        }
        set vertexColors3(e2) {
          e2 !== this.defines.VERTEX_COLOR3 && (this.defines.VERTEX_COLOR3 = !!e2, this.needsUpdate = true);
        }
      }
      const cb = { normalize: true, rotateToZUp: true, keepSize: true };
      class ub extends _c {
        constructor() {
          super(...arguments), __publicField(this, "isLine", true), __publicField(this, "isLineSegments", true);
        }
      }
      class db extends ri {
        constructor(e2) {
          super(e2), this.parameters = e2;
        }
        setData(e2) {
          const { vertexColors: t2, vertexHeights: i2 } = this.parameters, { aPositions: n2, indices: r2, aColors: s2, aHeights: a2, aLengths: o2 } = e2;
          this.setAttribute("position", new Jt(n2, 3)), this.setAttribute("aLength", new Jt(o2, 1)), t2 && this.setAttribute("aColor", new Jt(s2, 4)), i2 && this.setAttribute("aHeight", new Jt(a2, 1)), this.setIndex(r2);
        }
      }
      const pb = Ci.merge([Xi.fog, yh, xh, { color: { value: [1, 1, 0, 1] }, height: { value: 100 }, vertexColors: { value: false }, vertexHeights: { value: false }, tailLength: { value: 50 }, speed: { value: 1 }, idle: { value: 2e3 } }]);
      class mb extends yc {
        constructor(e2) {
          super(), this.type = "SparkMaterial", this.isSparkMaterial = true, this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute float aLength;\n\nuniform float elapsedTime;\nuniform float tailLength;\nuniform float speed;\nuniform float idle;\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec4 color;\n#endif\n\n#ifdef MVT_USE_VERTEX_HEIGHT\n    attribute float aHeight;\n#else\n    uniform float height;\n#endif\n\nvarying float vOpacity;\nvarying vec4 vColor;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    #include <mvt_selective_vertex>\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = color;\n    #endif\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float total = aHeight + tailLength;\n    #else\n        float total = height + tailLength;\n    #endif\n    float currentHeight = mod(elapsedTime * speed, total + idle * speed);\n    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;\n    // vOpacity = 1.;\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nvarying vec4 vColor;\nvarying float vOpacity;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    if (vOpacity > 1.0 || vOpacity < 0.0) {\n        discard;\n    }\n    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}\n", this.transparent = true, Object.assign(this.uniforms, Ci.clone(pb)), Eh(this), Mh(this, ["height", "tailLength", "speed", "idle"]), Sh(this, ["color"]), Th(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"], ["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]]), Ah(this), this.emissiveEnabled = true, this.emissive = [0, 0, 0], this.setValues(e2);
        }
      }
      let fb = Ci.merge([xh, { color: { value: [1, 0.5, 0, 1] }, borderColor: { value: [0, 1, 0, 1] }, opacity: { value: 1 }, radius: { value: 0.5 }, borderWidth: { value: 1 } }]);
      class gb extends sy {
        constructor(e2) {
          super(), __publicField(this, "type", "CircleMaterial"), __publicField(this, "isCircleMaterial", true), this.depthTest = false, this.depthWrite = false, e2.vertexSizes || (fb = Ci.merge([fb, { size: { value: 100 } }])), Object.assign(this.uniforms, Ci.clone(fb)), Mh(this, ["borderWidth", "opacity"]), Sh(this, ["borderColor"]), Th(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"], ["vertexSizes", "MVT_USE_VERTEX_SIZE"]]), Ah(this), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\n#ifndef MVT_USE_VERTEX_SIZE\n    uniform float size;\n#endif\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n   \n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    \n    vec3 transformed = vec3(position);\n    #ifdef MVT_USE_VERTEX_SIZE\n        vScale = instanceMatrix[0][0];\n    #else\n        vScale = size;\n        transformed *= size;\n    #endif\n\n    #include <mvt_keepsize_vertex>\n\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #include <logdepthbuf_vertex>\n\n    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)\n        vColor.xyz = instanceColor.xyz;\n        vColor.a = 1.0;\n    #endif\n}", "Gradient" === e2.type ? this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec4 color;\n#endif\nuniform float radius;\n\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n    #ifdef MVT_USE_VERTEX_COLOR\n        vec4 fillColor = vColor;\n    #else\n        vec4 fillColor = color;\n    #endif\n    \n    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));\n    // 边缘抗锯齿\n    if(d >- 0.99 * radius) {\n        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); \n    }\n    gl_FragColor = fillColor;\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment>   \n}" : this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec4 color;\n#endif\nuniform vec4 borderColor;\nuniform float opacity;\nuniform float radius;\nuniform float borderWidth;\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    float dis = distance(vPosition, vec2(0, 0));\n\n    // 用来保持边框的宽度不会随着缩放而变化\n    float radius2 = radius - (borderWidth / vScale) * radius;\n\n    // 用于抗锯齿\n    float blur = 0.001;\n    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));\n    #ifdef MVT_USE_VERTEX_COLOR\n        vec4 currentColor = mix(vColor, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #else\n        vec4 currentColor = mix(color, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #endif\n    \n    // 设置的自身颜色的透明度优先级高于设置的opacity优先级\n    if(currentColor.a == 1.0) {\n        gl_FragColor = vec4(currentColor.rgb, pct * opacity);\n    } else {\n        gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);\n    }\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}", this.emissiveEnabled = true, this.emissive = [0, 0, 0], this.setValues(e2);
        }
      }
      const _b = Ci.merge([Xi.fog, { heatmap: { value: null }, heatmapDepth: { value: null }, gradientMap: { value: null }, opacity: { value: 1 } }]);
      class vb extends yc {
        constructor(e2) {
          super(e2), this.type = "HeatmapMaterial", this.isHeatmapMaterial = true, this.fog = true, this.lights = false, this.transparent = true, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D heatmap;\nuniform sampler2D gradientMap;\nuniform sampler2D heatmapDepth;\nuniform float opacity;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n#include <packing>\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n#endif\n\nvoid main() {\n    vec4 color = texture2D(heatmap, vUv);\n    \n    if (color.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));\n    float addAlpha = 1.0;\n    if (color.a < 0.3) {\n        addAlpha = color.a * 3.3;\n    }\n    // if (color.a < 0.3) {\n    //     gl_FragColor.a = color.a * 3.3;\n    // } else {\n    //     gl_FragColor.a = 1.0;\n    // }\n    gl_FragColor.a *= color.a;\n    gl_FragColor.a *= opacity;\n\n    vec4 depthColor = texture2D(heatmapDepth, vUv);\n\n    #if defined( USE_LOGDEPTHBUF ) \n        gl_FragDepthEXT = unpackRGBAToDepth(depthColor);\n    #endif\n    // gl_FragColor = depthColor;\n    // #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n    //    int r = int(color.r * 255.0);\n    //    int g = int(color.g * 255.0);\n    //    int b = int(color.b * 255.0);\n    //    int d = r << 16 + g << 8 + b;\n    //    float z = float(d) / 16581375.0;\n    //    gl_FragDepthEXT = z;\n        //gl_FragDepthEXT = color.r;\n       // gl_FragColor = vec4(1.0, 0, 0, color.r);\n       // gl_FragDepthEXT = log2( color.r ) * logDepthBufFC * 0.5;\n       // gl_FragDepthEXT = 1.0;\n\n    //    float depth = dot( vec2(color.r, color.g), 1.0 / vec2(1.0, 256.0) );\n    //    gl_FragDepthEXT = depth * (256.0*256.0) / (256.0*256.0 - 1.0);\n// gl_FragColor = vec4(gl_FragDepthEXT, gl_FragDepthEXT, 0, 1.0);\n    // #endif\n    // gl_FragColor.a = color.a * 0.8;\n    // gl_FragColor = vec4(vUv, 0, 1.0);\n    // gl_FragColor = vec4(1.0, 0,0, 0.8);\n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\nuniform sampler2D gradientMap;\n\nvarying vec2 vUv;\n\nvoid main() { \n    \n    gl_Position = vec4(position, 1.0);\n    // vUv = position.xy;\n    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);\n    // vec4 gray = texture2D(gradientMap, vUv);\n\n    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);\n    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);\n    // m0 /= m0.w;\n    // m1 /= m1.w;\n    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);\n    // pixel.z = 100. * gray.a;\n\n    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);\n}", Object.assign(this.uniforms, Ci.clone(_b)), Mh(this, ["opacity", "resolution"]), wh(this, []), Th(this, []), this._cachedGradient = null, Object.defineProperties(this, { gradient: { get: function() {
            return this._cachedGradient;
          }, set: function(e3) {
            this._cachedGradient = e3, this.updateGradientMap();
          } } }), this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap, this.setValues(e2);
        }
        createGradientMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 2;
          let t2 = e2.getContext("2d"), i2 = t2.createLinearGradient(0, 0, 64, 0);
          i2.addColorStop(0, "rgba(0,0,255,1)"), i2.addColorStop(0.3, "rgba(0,255,0,1)"), i2.addColorStop(0.6, "rgba(255,255,0,1)"), i2.addColorStop(1, "rgba(255,0,0,1)"), t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap = new da(e2);
        }
        updateGradientMap() {
          let e2 = this._cachedGradient;
          if ("[object Object]" !== Object.prototype.toString.call(e2))
            return;
          let t2 = this._cachedGradientMap.image.getContext("2d");
          t2.clearRect(0, 0, 64, 2);
          let i2 = t2.createLinearGradient(0, 0, 64, 0);
          for (const n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && i2.addColorStop(n2, e2[n2]);
          t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap.needsUpdate = true;
        }
        dispose() {
          this._cachedGradientMap && this._cachedGradientMap.dispose(), super.dispose();
        }
      }
      const xb = Ci.merge([Xi.fog, { radius: { value: 30 }, circleMap: { value: null }, minValue: { value: 0 }, maxValue: { value: 100 }, keepSize: { value: false }, attenuateMValueFactor: { value: 0 } }]);
      class yb extends yc {
        constructor(e2) {
          super(e2), this.type = "HeatmapTextureMaterial", this.isHeatmapTextureMaterial = true, this.fog = true, this.lights = false, this.transparent = true, this.depthTest = false, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D circleMap;\n\nvarying vec2 vUv;\nvarying float vWeight;\nvarying float vZDepth;\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;\n    // gl_FragColor.a = 1.;\n    //#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);\n        // int d = int(gl_FragDepthEXT * 16581375.0);\n        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;\n        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;\n        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;\n        // gl_FragColor.r = gl_FragDepthEXT; // a\n        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);\n        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);\n        // int d = int(gl_FragDepthEXT * 10000000.0);\n        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; \n        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; \n        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; \n        // gl_FragColor.r = gl_FragDepthEXT;\n        // gl_FragColor.r = gl_FragCoord.z;\n\n        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);\n        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );\n        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;\n        // gl_FragColor.rgb = encode;\n\n    // #else \n    //     gl_FragColor.r = gl_FragCoord.z;\n    // #endif\n    // gl_FragColor.r = 1.0;\n    // gl_FragColor.a = gl_FragCoord.z;\n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute float instancedWeight;\n\nuniform float radius;\nuniform float maxValue;\nuniform float minValue;\nuniform bool keepSize;\nuniform float attenuateMValueFactor;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\nvarying float vWeight;\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n\n    float range = (maxValue - minValue) * attenuateMValueFactor;\n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    if (keepSize) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);\n        range *= pixelSize;\n    } else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);\n    }\n    \n    // gl_Position = vec4(position, 1.0);\n    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;\n   \n    vUv = vec2(position.x + 0.5, position.y + 0.5);\n    \n    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);\n\n    #include <logdepthbuf_vertex>\n}", Object.assign(this.uniforms, Ci.clone(xb)), Mh(this, ["radius", "minValue", "maxValue", "keepSize", "attenuateMValueFactor"]), wh(this, []), Th(this, []);
          const t2 = this.createCircleMap();
          this.uniforms.circleMap.value = t2, this.setValues(e2), this.blending = 5, this.blendSrc = n, this.blendDst = 200, this.blendSrcAlpha = n, this.blendDstAlpha = n;
        }
        createCircleMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 64;
          let t2 = e2.getContext("2d"), i2 = t2.createRadialGradient(32, 32, 0, 32, 32, 32);
          return i2.addColorStop(0, "rgba(0,0,0,1)"), i2.addColorStop(1, "rgba(0,0,0,0)"), t2.fillStyle = i2, t2.arc(32, 32, 32, 0, 2 * Math.PI, false), t2.fill(), new da(e2);
        }
        dispose() {
          this.uniforms.circleMap.value && this.uniforms.circleMap.value.dispose(), super.dispose();
        }
      }
      const bb = Ci.merge([Xi.fog, { radius: { value: 30 }, circleMap: { value: null }, minValue: { value: 0 }, maxValue: { value: 100 }, keepSize: { value: false }, attenuateMValueFactor: { value: 0 } }]);
      class Mb extends yc {
        constructor(e2) {
          super(e2), this.type = "HeatmapDepthTextureMaterial", this.isHeatmapDepthTextureMaterial = true, this.fog = true, this.lights = false, this.transparent = true, this.depthTest = false, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n\n    #if defined( USE_LOGDEPTHBUF ) \n    \n        gl_FragColor = packDepthToRGBA(gl_FragDepthEXT);\n    #else\n        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n    #endif\n    \n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\nattribute vec3 instancedPosition;\n\nuniform float radius;\nuniform bool keepSize;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (keepSize) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize * 1.1, 1.0);\n    } else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * 1.1, 1.0);\n    }\n    #include <logdepthbuf_vertex>\n}", Object.assign(this.uniforms, Ci.clone(bb)), Mh(this, ["radius", "minValue", "maxValue", "keepSize", "attenuateMValueFactor"]), wh(this, []), Th(this, []), this.setValues(e2);
        }
      }
      class Sb extends co {
        constructor() {
          super();
          const e2 = this.geometry = new ji();
          this.setAttribute("position", e2.attributes.position), this.setAttribute("uv", e2.attributes.uv), this.setIndex(e2.index);
        }
        dispose() {
          this.geometry.dispose();
        }
      }
      const wb = Ci.merge([Xi.fog, { heightRatio: { value: 100 }, opacity: { value: 1 }, map: { value: null } }]);
      class Tb extends yc {
        constructor(e2) {
          super(e2), this.type = "HeatmapMaterial", this.isHeatmapMaterial = true, this.fog = true, this.lights = false, this.transparent = true, this.depthWrite = true, this.depthTest = true, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D map;\nuniform float opacity;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vUv);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment> \n\n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float heightRatio;\nuniform sampler2D map;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n\n    vUv = vec2(uv.x, 1. - uv.y);\n	#include <begin_vertex>\n\n    transformed.z = texture2D(map, vUv).a * heightRatio;\n\n	#include <project_vertex>\n    #include <logdepthbuf_vertex>\n}", Object.assign(this.uniforms, Ci.clone(wb)), Mh(this, ["heightRatio", "resolution", "opacity", "map"]), this.setValues(e2);
        }
      }
      var Eb = { exports: {} };
      !function(e2) {
        function t2(e3) {
          if (!(this instanceof t2))
            return new t2(e3);
          this._canvas = e3 = "string" == typeof e3 ? document.getElementById(e3) : e3, this._ctx = e3.getContext("2d"), this._width = e3.width, this._height = e3.height, this._max = 1, this._data = [];
        }
        e2.exports = t2, t2.prototype = { defaultRadius: 25, defaultGradient: { 0.4: "blue", 0.6: "cyan", 0.7: "lime", 0.8: "yellow", 1: "red" }, data: function(e3) {
          return this._data = e3, this;
        }, max: function(e3) {
          return this._max = e3, this;
        }, add: function(e3) {
          return this._data.push(e3), this;
        }, clear: function() {
          return this._data = [], this;
        }, radius: function(e3, t3) {
          t3 = void 0 === t3 ? 15 : t3;
          var i2 = this._circle = this._createCanvas(), n2 = i2.getContext("2d"), r2 = this._r = e3 + t3;
          return i2.width = i2.height = 2 * r2, n2.shadowOffsetX = n2.shadowOffsetY = 2 * r2, n2.shadowBlur = t3, n2.shadowColor = "black", n2.beginPath(), n2.arc(-r2, -r2, e3, 0, 2 * Math.PI, true), n2.closePath(), n2.fill(), this;
        }, resize: function() {
          this._width = this._canvas.width, this._height = this._canvas.height;
        }, gradient: function(e3) {
          var t3 = this._createCanvas(), i2 = t3.getContext("2d"), n2 = i2.createLinearGradient(0, 0, 0, 256);
          for (var r2 in t3.width = 1, t3.height = 256, e3)
            n2.addColorStop(+r2, e3[r2]);
          return i2.fillStyle = n2, i2.fillRect(0, 0, 1, 256), this._grad = i2.getImageData(0, 0, 1, 256).data, this;
        }, draw: function(e3) {
          this._circle || this.radius(this.defaultRadius), this._grad || this.gradient(this.defaultGradient);
          var t3 = this._ctx;
          t3.clearRect(0, 0, this._width, this._height);
          for (var i2, n2 = 0, r2 = this._data.length; n2 < r2; n2++)
            i2 = this._data[n2], t3.globalAlpha = Math.max(i2[2] / this._max, void 0 === e3 ? 0.05 : e3), t3.drawImage(this._circle, i2[0] - this._r, i2[1] - this._r);
          var s2 = t3.getImageData(0, 0, this._width, this._height);
          return this._colorize(s2.data, this._grad), t3.putImageData(s2, 0, 0), this;
        }, _colorize: function(e3, t3) {
          for (var i2, n2 = 0, r2 = e3.length; n2 < r2; n2 += 4)
            (i2 = 4 * e3[n2 + 3]) && (e3[n2] = t3[i2], e3[n2 + 1] = t3[i2 + 1], e3[n2 + 2] = t3[i2 + 2]);
        }, _createCanvas: function() {
          return "undefined" != typeof document ? document.createElement("canvas") : new this._canvas.constructor();
        } };
      }(Eb);
      const Cb = Eb.exports;
      function Ab(e2, t2) {
        let i2 = document.createElement("canvas");
        return e2 && (i2.width = e2), t2 && (i2.height = t2), i2;
      }
      class Pb extends ri {
        constructor(e2) {
          super(), __publicField(this, "isWallGeometry", true), __publicField(this, "_needsUpdate", false), this.parameters = e2;
        }
        setData(e2) {
          this._needsUpdate = true, this.cachedData = e2, this.updateGeometry();
        }
        updateGeometry() {
          let e2 = this.cachedData;
          const t2 = [], i2 = [], n2 = [], r2 = [], s2 = [], a2 = [], o2 = [];
          for (let l2 = 0; l2 < e2.position.length; l2++) {
            const h2 = e2.position[l2];
            e2.index[l2];
            const c2 = this.parameters.vertexColors ? gh(e2.color[l2]) : gh(this.parameters.color), u2 = this.parameters.vertexHeights ? e2.height[l2] : this.parameters.height;
            let d2 = 0;
            const p2 = h2.length;
            let m2 = t2.length / 3;
            for (let e3 = 0; e3 < p2; e3++) {
              const o3 = h2[e3], l3 = [h2[e3][0], h2[e3][1], h2[e3][2] + u2], f2 = e3 < p2 - 1 ? h2[e3 + 1] : null;
              if ((!f2 || !kv(o3, f2)) && (t2.push(...o3, ...l3), a2.push(...c2, ...c2), n2.push(e3 / (p2 - 1), e3 / (p2 - 1)), s2.push(d2, d2), i2.push(d2, 0, d2, 1), e3 < p2 - 1)) {
                d2 += Bv(o3, f2);
                let t3 = m2 + 2 * e3;
                r2.push(t3, t3 + 2, t3 + 1, t3 + 1, t3 + 2, t3 + 3);
              }
            }
            for (let e3 = 0; e3 < p2; e3++)
              o2.push(d2, d2);
            m2 += 2 * p2;
          }
          this.cachedPositions = t2, this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("uv", new Jt(i2, 2)), this.setAttribute("counter", new Jt(n2, 1)), this.setAttribute("distances", new Jt(s2, 1)), this.setAttribute("totalDistance", new Jt(o2, 1)), this.parameters.vertexColors && this.setAttribute("aColor", new Jt(a2, 4)), this.setIndex(r2), this.computeBoundingSphere(), this._needsUpdate = false;
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      const Rb = new qa(), Lb = Ci.merge([Xi.fog, yh, xh, { map: { value: null }, useMap: { value: false }, uColor: { value: [0, 1, 1, 1] }, minOpacity: { value: 0 }, maxOpacity: { value: 1 }, opacity: { value: 1 }, vertextColors: { value: false }, elapsedTime: { value: 0 }, enableAnimation: { value: false }, animationSpeed: { value: 1 }, animationTailType: { value: 3 }, animationTailRatio: { value: 0.2 }, animationTailLength: { value: 100 }, animationIdle: { value: 1e3 }, animationRatio: { value: 0.5 }, animationBales: { value: 5 } }]);
      class Ib extends yc {
        constructor(e2) {
          super(), this.type = "WallMaterial", this.isWallMaterial = true, this.fog = true, this.transparent = true, this.depthWrite = false, this.side = 2, this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_fragment>\n\n#include <logdepthbuf_pars_fragment>\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform float minOpacity;\nuniform float maxOpacity;\nuniform float opacity;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\n#ifdef USE_ANIMATION\nuniform float animationRatio;\nuniform float animationBales;\nuniform float animationSpeed;\nvarying float vAnimationOpacity;\nvarying float vAnimationTailType;\n#endif\n\nvoid main() {\n\n    vec4 c = vColor;\n\n    if(useMap) {\n        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));\n        c *= texture;\n    }\n\n    #ifdef USE_ANIMATION\n        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {\n            c.a = 0.0;\n        }\n\n        if(vAnimationTailType == 4.) {\n            float ratio = animationRatio;\n            float bales = animationBales;\n            if(animationRatio > 1.) {\n                ratio = 1.;\n            }\n            if(animationRatio < .0) {\n                ratio = .0;\n            }\n            if(animationBales < 1.) {\n                bales = 1.;\n            }\n            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {\n                c.a = (1. - vUV.y) * maxOpacity;\n            } else {\n                c.a = minOpacity;\n            }\n        } else {\n            c.a *= vAnimationOpacity;\n        }\n    #endif\n\n    gl_FragColor = c;\n    gl_FragColor.a *= opacity;\n\n    if (maxOpacity > minOpacity) {\n        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);\n    }\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n}", this.vertexShader = "#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#ifdef USE_A_COLOR\nattribute vec4 aColor;\n#endif\n\nattribute float counter;\nattribute float totalDistance;\nattribute float distances;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform vec4 uColor;\nuniform float opacity;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\nvarying float vAnimationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\nvoid main() {\n\n    #ifdef USE_A_COLOR\n        vColor = aColor;\n    #else\n        vColor = uColor;\n    #endif\n\n    vUV = uv;\n    vCounter = counter;\n    vDistance = distances;\n    vTotalDistance = totalDistance;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #ifdef USE_ANIMATION\n        if (animationTailType < 3.0) {\n            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;\n            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);\n            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;\n        }\n        else if (animationTailType == 3.0) {\n            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;\n        } \n        else if (animationTailType == 4.0) {\n            vAnimationTailType = animationTailType;\n        }\n    #endif\n\n    #include <beginnormal_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <fog_vertex>\n\n    #include <logdepthbuf_vertex>\n}", Object.assign(this.uniforms, Ci.clone(Lb)), Mh(this, ["map", "minOpacity", "maxOpacity", "opacity", "elapsedTime", "animationSpeed", "animationTailType", "animationTailRatio", "animationTailLength", "animationIdle", "animationBales", "animationRatio"]), wh(this, [["color", "uColor", mh]]), Th(this, [["vertexColors", "USE_A_COLOR"], ["enableAnimation", "USE_ANIMATION"]]), Ah(this), Object.defineProperties(this, { mapSrc: { get: function() {
            return this.uniforms.map.value;
          }, set: function(e3) {
            const t2 = this.mapSrc;
            if (this.userData.url_map === e3)
              return;
            if (t2 && t2.dispose(), !e3)
              return this.uniforms.map.value = null, this.uniforms.useMap.value = false, void delete this.userData.url_map;
            const i2 = Rb.load(e3);
            i2.wrapS = i2.wrapT = h, this.uniforms.map.value = i2, this.userData.url_map = e3, this.uniforms.useMap.value = true;
          } } }), this.emissiveEnabled = true, this.emissive = [0, 0, 0], this.setValues(e2);
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      class Db extends ey {
        constructor(e2) {
          super(e2), __publicField(this, "isLightSphereGeometry", true), __publicField(this, "_needsUpdate", false), __publicField(this, "setModelData", () => {
            this._needsUpdate = true, this.updateGeometry();
          }), this.type = "LightSphereGeometry", this.parameters = e2, this.setModelData();
        }
        updateGeometry() {
          const e2 = [], t2 = [], i2 = [], n2 = [];
          let r2 = this.parameters.radius || 10, s2 = this.parameters.widthSegments || 32, a2 = this.parameters.heightSegments || 16, o2 = this.parameters.phiStart || 0, l2 = this.parameters.phiLength || 2 * Math.PI, h2 = this.parameters.thetaStart || 0, c2 = this.parameters.thetaLength || Math.PI;
          this.parameters.widthSegments = Math.max(3, Math.floor(s2)), this.parameters.heightSegments = Math.max(2, Math.floor(a2));
          const u2 = Math.min(h2 + c2, Math.PI);
          let d2 = 0;
          const p2 = [], m2 = new Ae(), f2 = new Ae();
          for (let g2 = 0; g2 <= a2; g2++) {
            const e3 = [], _2 = g2 / a2;
            let v2 = 0;
            0 === g2 && 0 === h2 ? v2 = 0.5 / s2 : g2 === a2 && u2 === Math.PI && (v2 = -0.5 / s2);
            for (let a3 = 0; a3 <= s2; a3++) {
              const u3 = a3 / s2;
              m2.x = -r2 * Math.cos(o2 + u3 * l2) * Math.sin(h2 + _2 * c2), m2.y = r2 * Math.cos(h2 + _2 * c2), m2.z = r2 * Math.sin(o2 + u3 * l2) * Math.sin(h2 + _2 * c2), t2.push(m2.x, m2.y, m2.z), f2.copy(m2).normalize(), i2.push(f2.x, f2.y, f2.z), n2.push(u3 + v2, 1 - _2), e3.push(d2++);
            }
            p2.push(e3);
          }
          for (let g2 = 0; g2 < a2; g2++)
            for (let t3 = 0; t3 < s2; t3++) {
              const i3 = p2[g2][t3 + 1], n3 = p2[g2][t3], r3 = p2[g2 + 1][t3], s3 = p2[g2 + 1][t3 + 1];
              (0 !== g2 || h2 > 0) && e2.push(i3, n3, s3), (g2 !== a2 - 1 || u2 < Math.PI) && e2.push(n3, r3, s3);
            }
          this.setIndex(e2), this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("normal", new Jt(i2, 3)), this.setAttribute("uv", new Jt(n2, 2)), this._needsUpdate = false;
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      const Fb = Ci.merge([{ color: { value: [0, 0.7, 1, 1] } }]);
      class Ob extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "LightSphereMaterial"), __publicField(this, "isLightSphereMaterial", true), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vNormal;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvoid main() {\n    vNormal = normalize(normalMatrix * normal); // 顶点的法向量执行插值计算\n    if (animationEffect) {\n        float scaleRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;\n        float t = sin(scaleRatio * 2.0 * PI) * 0.5 + 0.5;\n        vec3 newPosition = mix(position, position * 2.0, t);\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(newPosition, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    }\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vNormal;\nuniform vec4 color;\n\nvoid main() {\n    vec3 z = vec3(0.0, 0.0, 1.0); // z轴方向单位向量\n    float x = abs(dot(vNormal, z)); // 点乘结果余弦值绝对值范围[0,1]\n    float alpha = pow(1.0 - x, 2.0);\n    gl_FragColor = vec4(vec3(color[0], color[1], color[2]), alpha);\n}", Object.assign(this.uniforms, Ci.clone(Fb)), this.setValues(e2);
        }
      }
      class Ub extends ey {
        constructor(e2) {
          super(e2), __publicField(this, "_needsUpdate", false), __publicField(this, "setModelData", () => {
            this._needsUpdate = true, this.updateGeometry();
          }), this.parameters = { ...e2, radiusTop: e2.radiusTop || e2.radius || 6, radiusBottom: e2.radiusBottom || e2.radius || 6, height: e2.height || 50, openEnded: e2.openEnded || false, color: e2.color || [80, 20, 170, 0.8], isLight: e2.isLight || true, lightPos: e2.lightPos || 60 }, this.parameters.radialSegments = e2.radialSegments ? Math.floor(e2.radialSegments) : 4, this.parameters.heightSegments = e2.heightSegments ? Math.floor(e2.heightSegments) : 1, this.setModelData();
        }
        updateGeometry() {
          const e2 = [], t2 = [], i2 = [], n2 = [], r2 = [];
          let s2 = { index: 0, indexArray: [], halfHeight: 0, groupStart: 0 };
          this.generateTorso(e2, t2, i2, n2, r2, s2), false === this.parameters.openEnded && (this.parameters.radiusTop > 0 && this.generateCap(true, e2, t2, i2, n2, r2, s2), this.parameters.radiusBottom > 0 && this.generateCap(false, e2, t2, i2, n2, r2, s2)), this.addCustomGeometry(e2, t2, i2, n2, r2, s2), this.setIndex(e2), this.setAttribute("position", new Jt(t2, 3)), this.setAttribute("normal", new Jt(i2, 3)), this.setAttribute("uv", new Jt(n2, 2)), this.addCustomAttribute(r2), this._needsUpdate = false;
        }
        addCustomGeometry() {
        }
        addCustomAttribute() {
        }
        generateCap(e2, t2, i2, n2, r2, s2, a2) {
        }
        generateTorso(e2, t2, i2, n2, r2, s2) {
        }
        get needsUpdate() {
          return this._needsUpdate;
        }
        set needsUpdate(e2) {
          this._needsUpdate = e2;
        }
      }
      class zb extends Ub {
        constructor(e2) {
          super(e2), this.type = "GridGeometry", this.parameters.multiColor = e2.multiColor || [], this.parameters.isMultiColor = e2.isMultiColor || false;
        }
        generateTorso(e2, t2, i2, n2, r2, s2) {
          const a2 = new Ae(), o2 = new Ae();
          let l2 = 0;
          const h2 = (this.parameters.radiusBottom - this.parameters.radiusTop) / this.parameters.height;
          for (let c2 = 0; c2 <= this.parameters.heightSegments; c2++) {
            const e3 = [], l3 = c2 / this.parameters.heightSegments, u2 = (1 - l3) * this.parameters.radiusBottom + l3 * this.parameters.radiusTop;
            for (let c3 = 0; c3 <= this.parameters.radialSegments; c3++) {
              const d2 = c3 / this.parameters.radialSegments, p2 = 2 * d2 * Math.PI, m2 = Math.sin(p2), f2 = Math.cos(p2);
              o2.x = u2 * m2, o2.y = u2 * f2, o2.z = l3 * this.parameters.height, t2.push(o2.x, o2.y, o2.z), this.parameters.isMultiColor && Array.isArray(this.parameters.multiColor) && this.addMultiColors("torso", r2, o2.z), a2.set(m2, f2, h2).normalize(), i2.push(a2.x, a2.y, a2.z), n2.push(d2, l3), e3.push(s2.index++);
            }
            s2.indexArray.push(e3);
          }
          for (let c2 = 0; c2 < this.parameters.radialSegments; c2++)
            for (let t3 = 0; t3 < this.parameters.heightSegments; t3++) {
              const i3 = s2.indexArray[t3][c2], n3 = s2.indexArray[t3 + 1][c2], r3 = s2.indexArray[t3 + 1][c2 + 1], a3 = s2.indexArray[t3][c2 + 1];
              e2.push(i3, n3, a3), e2.push(n3, r3, a3), l2 += 6;
            }
          this.addGroup(s2.groupStart, l2, 0), s2.groupStart += l2;
        }
        generateCap(e2, t2, i2, n2, r2, s2, a2) {
          const o2 = a2.index, l2 = new ie(), h2 = new Ae();
          let c2 = 0;
          const u2 = true === e2 ? this.parameters.radiusTop : this.parameters.radiusBottom, d2 = true === e2 ? 1 : 0, p2 = e2 ? 1 : -1;
          for (let f2 = 1; f2 <= this.parameters.radialSegments; f2++)
            this.parameters.isMultiColor && Array.isArray(this.parameters.multiColor) && this.addMultiColors("cap", s2, this.parameters.height * d2), i2.push(0, 0, this.parameters.height * d2), n2.push(0, 0, p2), r2.push(0.5, 0.5), a2.index++;
          const m2 = a2.index;
          for (let f2 = 0; f2 <= this.parameters.radialSegments; f2++) {
            const e3 = 2 * (f2 / this.parameters.radialSegments) * Math.PI, t3 = Math.cos(e3), o3 = Math.sin(e3);
            h2.x = u2 * o3, h2.y = u2 * t3, h2.z = this.parameters.height * d2, i2.push(h2.x, h2.y, h2.z), this.parameters.isMultiColor && Array.isArray(this.parameters.multiColor) && this.addMultiColors("cap", s2, h2.z), n2.push(0, 0, p2), l2.x = 0.5 * t3 + 0.5, l2.y = 0.5 * o3 * d2 + 0.5, r2.push(l2.x, l2.y), a2.index++;
          }
          for (let f2 = 0; f2 < this.parameters.radialSegments; f2++) {
            const i3 = o2 + f2, n3 = m2 + f2;
            true === e2 ? t2.push(n3, n3 + 1, i3) : t2.push(n3 + 1, n3, i3), c2 += 3;
          }
          this.addGroup(a2.groupStart, c2, true === e2 ? 1 : 2), a2.groupStart += c2;
        }
        addCustomAttribute(e2) {
          this.parameters.isMultiColor && this.setAttribute("mColor", new Jt(e2, 4));
        }
        addMultiColors(e2, t2, i2) {
          const n2 = this.parameters.multiColor.map((e3) => gh(e3));
          if ("cap" === e2)
            i2 === this.parameters.height ? t2.push(...n2[n2.length - 1]) : t2.push(...n2[0]);
          else if ("torso" === e2 && this.parameters.heightSegments <= n2.length) {
            const e3 = this.parameters.height / this.parameters.heightSegments;
            for (let r2 = 0; r2 <= this.parameters.heightSegments; r2++)
              i2 === e3 * r2 && t2.push(...n2[r2]);
          }
        }
      }
      const Nb = Ci.merge([{ color: { value: [0, 0.7, 0.9, 1] }, lightPos: { value: 60 } }]);
      class kb extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "GridMaterial"), __publicField(this, "isGridMaterial", true), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nattribute vec4 mColor;\n\nvarying vec3 vPosition;\nvarying vec4 vColor;\nuniform vec4 color;\n\nvoid main() {\n\n    #ifdef USE_MULTICOLOR\n        vColor = mColor;\n    #else\n        vColor = color;\n    #endif\n\n    vPosition = position;\n\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vPosition;\nuniform vec4 color;\nuniform float lightPos;\nvarying vec4 vColor;\n\nvoid main() {\n\n    #ifdef USE_LIGHT\n        float a = 1.0 - vPosition.z / lightPos;\n        if (a <= 0.) {\n            discard;\n        }\n    #else\n        float a = 1.0;\n    #endif\n    \n    gl_FragColor = vec4(vec3(vColor[0], vColor[1], vColor[2]), a);\n}", this.side = 2, this.transparent = true, Object.assign(this.uniforms, Ci.clone(Nb)), Mh(this, ["lightPos"]), Th(this, [["isMultiColor", "USE_MULTICOLOR"], ["isLight", "USE_LIGHT"]]), this.setValues(e2);
        }
      }
      class Bb extends Ub {
        constructor(e2) {
          super(e2), this.type = "PillarGeometry";
        }
        generateTorso(e2, t2, i2, n2, r2, s2) {
          const a2 = new Ae(), o2 = new Ae();
          let l2 = 0;
          for (let h2 = 0; h2 <= this.parameters.heightSegments; h2++) {
            const e3 = [], r3 = h2 / this.parameters.heightSegments, l3 = this.parameters.radius;
            for (let h3 = 0; h3 <= this.parameters.radialSegments; h3++) {
              const c2 = h3 / this.parameters.radialSegments, u2 = 2 * c2 * Math.PI, d2 = Math.sin(u2), p2 = Math.cos(u2);
              o2.x = l3 * d2, o2.y = l3 * p2, this.parameters.vertexHeights ? o2.z = r3 : o2.z = r3 * this.parameters.height, t2.push(o2.x, o2.y, o2.z), a2.set(d2, p2, 0).normalize(), i2.push(a2.x, a2.y, a2.z), n2.push(c2, r3), e3.push(s2.index++);
            }
            s2.indexArray.push(e3);
          }
          for (let h2 = 0; h2 < this.parameters.radialSegments; h2++)
            for (let t3 = 0; t3 < this.parameters.heightSegments; t3++) {
              const i3 = s2.indexArray[t3][h2], n3 = s2.indexArray[t3 + 1][h2], r3 = s2.indexArray[t3 + 1][h2 + 1], a3 = s2.indexArray[t3][h2 + 1];
              e2.push(i3, n3, a3), e2.push(n3, r3, a3), l2 += 6;
            }
          this.addGroup(s2.groupStart, l2, 0), s2.groupStart += l2;
        }
        generateCap(e2, t2, i2, n2, r2, s2, a2) {
          const o2 = a2.index, l2 = new Ae();
          let h2 = 0;
          const c2 = this.parameters.radius, u2 = true === e2 ? 1 : 0, d2 = e2 ? 1 : -1;
          for (let m2 = 1; m2 <= this.parameters.radialSegments; m2++)
            this.parameters.vertexHeights ? i2.push(0, 0, u2) : i2.push(0, 0, u2 * this.parameters.height), n2.push(0, 0, d2), r2.push(0.5, u2), a2.index++;
          const p2 = a2.index;
          for (let m2 = 0; m2 <= this.parameters.radialSegments; m2++) {
            const e3 = 2 * (m2 / this.parameters.radialSegments) * Math.PI, t3 = Math.cos(e3), s3 = Math.sin(e3);
            l2.x = c2 * s3, l2.y = c2 * t3, this.parameters.vertexHeights ? l2.z = u2 : l2.z = u2 * this.parameters.height, i2.push(l2.x, l2.y, l2.z), n2.push(0, 0, d2), r2.push(0.5, u2), a2.index++;
          }
          for (let m2 = 0; m2 < this.parameters.radialSegments; m2++) {
            const i3 = o2 + m2, n3 = p2 + m2;
            true === e2 ? t2.push(n3, n3 + 1, i3) : t2.push(n3 + 1, n3, i3), h2 += 3;
          }
          this.addGroup(a2.groupStart, h2, true === e2 ? 1 : 2), a2.groupStart += h2;
        }
      }
      const Vb = Ci.merge([{ color: { value: [0, 0.7, 0.9, 1] }, lightPos: { value: 60 }, gradientMap: { value: null }, maxHeight: { value: 50 }, vertexHeights: { value: false } }]);
      class Gb extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "PillarMaterial"), __publicField(this, "isGridMaterial", true), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float maxHeight;\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float instanceHeight = instanceMatrix[2][2];\n        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));\n    #else\n        vUv = uv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n}", this.side = 2, this.transparent = true, Mh(this, ["maxHeight"]), Th(this, [["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]]), Object.assign(this.uniforms, Ci.clone(Vb)), this._cachedGradient = null, Object.defineProperties(this, { gradient: { get: function() {
            return this._cachedGradient;
          }, set: function(e3) {
            this._cachedGradient = e3, this.updateGradientMap();
          } } }), this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap, this.setValues(e2);
        }
        createGradientMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 2;
          let t2 = e2.getContext("2d"), i2 = t2.createLinearGradient(0, 0, 64, 0);
          i2.addColorStop(0, "rgba(0,0,255,1)"), i2.addColorStop(0.3, "rgba(0,255,0,1)"), i2.addColorStop(0.6, "rgba(255,255,0,1)"), i2.addColorStop(1, "rgba(255,0,0,1)"), t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap = new da(e2);
        }
        updateGradientMap() {
          let e2 = this._cachedGradient;
          if ("[object Object]" !== Object.prototype.toString.call(e2))
            return;
          let t2 = this._cachedGradientMap.image.getContext("2d");
          t2.clearRect(0, 0, 64, 2);
          let i2 = t2.createLinearGradient(0, 0, 64, 0);
          for (const n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && i2.addColorStop(n2, e2[n2]);
          t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap.needsUpdate = true;
        }
        dispose() {
          this._cachedGradientMap && this._cachedGradientMap.dispose(), super.dispose();
        }
      }
      class Hb extends Ub {
        constructor(e2) {
          super(e2), this.type = "PillarGeometry";
        }
        addRadiusFunc(e2) {
          return 1 - Math.sqrt(e2);
        }
        generateTorso(e2, t2, i2, n2, r2, s2) {
          const a2 = new Ae();
          let o2 = 0;
          for (let l2 = 0; l2 <= this.parameters.heightSegments; l2++) {
            const e3 = [], i3 = l2 / this.parameters.heightSegments;
            let r3 = this.addRadiusFunc(i3);
            this.parameters.vertexSizes || (r3 *= this.parameters.size);
            for (let o3 = 0; o3 <= this.parameters.radialSegments; o3++) {
              const l3 = o3 / this.parameters.radialSegments, h2 = 2 * l3 * Math.PI, c2 = Math.sin(h2), u2 = Math.cos(h2);
              a2.x = r3 * c2, a2.y = r3 * u2, this.parameters.vertexHeights ? a2.z = i3 : a2.z = i3 * this.parameters.height, t2.push(a2.x, a2.y, a2.z), n2.push(l3, i3), e3.push(s2.index++);
            }
            s2.indexArray.push(e3);
          }
          for (let l2 = 0; l2 < this.parameters.radialSegments; l2++)
            for (let t3 = 0; t3 < this.parameters.heightSegments; t3++) {
              const i3 = s2.indexArray[t3][l2], n3 = s2.indexArray[t3 + 1][l2], r3 = s2.indexArray[t3 + 1][l2 + 1], a3 = s2.indexArray[t3][l2 + 1];
              e2.push(i3, n3, a3), e2.push(n3, r3, a3), o2 += 6;
            }
          this.addGroup(s2.groupStart, o2, 0), s2.groupStart += o2;
        }
        generateCap(e2, t2, i2, n2, r2, s2, a2) {
          if (e2)
            return;
          const o2 = a2.index, l2 = new Ae();
          let h2 = 0;
          const c2 = this.parameters.vertexSizes ? 1 : this.parameters.size, u2 = true === e2 ? 1 : 0;
          for (let p2 = 1; p2 <= this.parameters.radialSegments; p2++)
            this.parameters.vertexHeights ? i2.push(0, 0, u2) : i2.push(0, 0, u2 * this.parameters.height), r2.push(0.5, u2), a2.index++;
          const d2 = a2.index;
          for (let p2 = 0; p2 <= this.parameters.radialSegments; p2++) {
            const e3 = 2 * (p2 / this.parameters.radialSegments) * Math.PI, t3 = Math.cos(e3), n3 = Math.sin(e3);
            l2.x = c2 * n3, l2.y = c2 * t3, this.parameters.vertexHeights ? l2.z = u2 : l2.z = u2 * this.parameters.height, i2.push(l2.x, l2.y, l2.z), r2.push(0.5, u2), a2.index++;
          }
          for (let p2 = 0; p2 < this.parameters.radialSegments; p2++) {
            const i3 = o2 + p2, n3 = d2 + p2;
            true === e2 ? t2.push(n3, n3 + 1, i3) : t2.push(n3 + 1, n3, i3), h2 += 3;
          }
          this.addGroup(a2.groupStart, h2, true === e2 ? 1 : 2), a2.groupStart += h2;
        }
        generateTopSphere(e2, t2, i2, n2, r2, s2) {
          this.parameters.sphereIndex = s2.index;
          const a2 = new Ae(), o2 = s2.indexArray.length;
          let l2 = 0;
          for (let h2 = 0; h2 <= 16; h2++) {
            const e3 = h2 * Math.PI / 16, i3 = Math.sin(e3), r3 = Math.cos(e3), o3 = [];
            for (let l3 = 0; l3 <= 32; l3++) {
              const e4 = 2 * l3 * Math.PI / 32, h3 = Math.sin(e4), c2 = Math.cos(e4);
              a2.x = 10 * h3 * i3, a2.y = 10 * c2 * i3, a2.z = 10 * r3, this.parameters.vertexHeights || (a2.z += this.parameters.height), t2.push(a2.x, a2.y, a2.z), n2.push(0.5, 1), o3.push(s2.index++);
            }
            s2.indexArray.push(o3);
          }
          for (let h2 = 0; h2 < 16; h2++)
            for (let t3 = 0; t3 < 32; t3++) {
              const i3 = o2 + h2, n3 = s2.indexArray[i3][t3 + 1], r3 = s2.indexArray[i3][t3], a3 = s2.indexArray[i3 + 1][t3], c2 = s2.indexArray[i3 + 1][t3 + 1];
              e2.push(n3, r3, c2), e2.push(r3, a3, c2), l2 += 6;
            }
          this.addGroup(s2.groupStart, l2, 0), s2.groupStart += l2;
        }
        addCustomGeometry(e2, t2, i2, n2, r2, s2) {
          this.generateTopSphere(e2, t2, i2, n2, r2, s2);
        }
      }
      const jb = Ci.merge([{ color: { value: [0, 0.7, 0.9, 1] }, gradientMap: { value: null }, maxHeight: { value: 50 }, sphereIndex: { value: 0 }, vertexHeights: { value: false } }]);
      class Wb extends sy {
        constructor(e2) {
          super(e2), __publicField(this, "type", "PillarMaterial"), __publicField(this, "isGridMaterial", true), this.vertexShader = "#define GLSLIFY 1\n#include <common>\n\nuniform float maxHeight;\nuniform int sphereIndex;\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n    // 球体和非球体部分使用不同的规则\n    if(gl_VertexID < sphereIndex) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    } else {\n        float xOffset = instanceMatrix[3][0];\n        float yOffset = instanceMatrix[3][1];\n        float height = instanceMatrix[2][2];\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + xOffset\n        , position.y + yOffset\n        , position.z + height, 1.0);\n    }\n    \n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float instanceHeight = instanceMatrix[2][2];\n        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));\n    #else\n        vUv = uv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}\n", this.fragmentShader = "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n}", this.side = 0, this.transparent = true, Mh(this, ["maxHeight", "sphereIndex"]), Th(this, [["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]]), Object.assign(this.uniforms, Ci.clone(jb)), this._cachedGradient = null, Object.defineProperties(this, { gradient: { get: function() {
            return this._cachedGradient;
          }, set: function(e3) {
            this._cachedGradient = e3, this.updateGradientMap();
          } } }), this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap, this.setValues(e2);
        }
        createGradientMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 2;
          let t2 = e2.getContext("2d"), i2 = t2.createLinearGradient(0, 0, 64, 0);
          i2.addColorStop(0, "rgba(0,0,255,1)"), i2.addColorStop(0.3, "rgba(0,255,0,1)"), i2.addColorStop(0.6, "rgba(255,255,0,1)"), i2.addColorStop(1, "rgba(255,0,0,1)"), t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap = new da(e2);
        }
        updateGradientMap() {
          let e2 = this._cachedGradient;
          if ("[object Object]" !== Object.prototype.toString.call(e2))
            return;
          let t2 = this._cachedGradientMap.image.getContext("2d");
          t2.clearRect(0, 0, 64, 2);
          let i2 = t2.createLinearGradient(0, 0, 64, 0);
          for (const n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && i2.addColorStop(n2, e2[n2]);
          t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap.needsUpdate = true;
        }
        dispose() {
          this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
        }
      }
      const Xb = { pars: "\n        uniform float minAltitude;\n        uniform float maxAltitude;\n        #ifdef USE_NOISE_MAP\n            varying vec2 vWorldXy;\n        #endif\n    ", main_after: "\n        vUv.x = (clamp(position.y, minAltitude, maxAltitude) - minAltitude) / (maxAltitude - minAltitude);\n        vUv.y = 0.5;\n        #ifdef USE_NOISE_MAP\n            vWorldXy = worldPosition.xy;\n        #endif\n    " }, qb = { pars: "\n        #ifdef USE_NOISE_MAP\n            uniform sampler2D noiseMap;\n            uniform float noiseUvScale;\n            uniform float noiseScale;\n            uniform float noiseBais;\n            varying vec2 vWorldXy;\n        #endif\n    ", main_before: "\n        #ifdef USE_NOISE_MAP\n            vec2 noiseUv = mod(vWorldXy, 1000.0) * noiseUvScale;\n            uv.x = clamp(uv.x + noiseScale * (texture2D(noiseMap, noiseUv).y + noiseBais), 0.0, 1.0);\n        #endif\n    ", color_after: "\n    // diffuseColor.x = uv.x;\n    // diffuseColor.y = 0.0;\n    // diffuseColor.z = 0.0;\n    " };
      e.BubblePoint = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "size"), __publicField(this, "duration"), __publicField(this, "trail"), __publicField(this, "type"), this.parameters = e2, this.defineMaterialProxyProperties(["color", "size", "duration", "trail", "size3", "height", "opacity"]);
        }
        initObject() {
          this.geometry = new ty(), this.material = new py(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
      }, e.CSVDataSource = Lv, e.Circle = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "size"), __publicField(this, "opacity"), __publicField(this, "type"), __publicField(this, "borderColor"), __publicField(this, "borderWidth"), __publicField(this, "getInstanceLocalMatrix", (e3, t2, i2) => {
            const { vertexSizes: n2 } = this.parameters, { size: r2 } = this.dataSource.data;
            if (n2 && r2) {
              const e4 = new st();
              return e4.makeScale(r2[i2], r2[i2], r2[i2]), e4;
            }
            return null;
          }), __publicField(this, "addCustomAttributes", () => {
            const { vertexColors: e3 } = this.parameters, { color: t2 } = this.dataSource.data, i2 = [];
            e3 && t2 && t2.forEach((e4) => {
              const t3 = fh(e4);
              i2.push(...t3.toArray());
            }), this.instanceColor = new Vs(new Float32Array(i2), 3);
          }), this.parameters = e2, this.defineMaterialProxyProperties(["color", "size", "size3", "opacity", "borderWidth", "borderColor", "radius", "keepSize"]);
        }
        initObject() {
          this.geometry = new ty(), this.material = new gb(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        collisionTest(e2) {
          let t2 = 0;
          return this.material.keepSize && (t2 = this.parameters.vertexSizes && e2.size ? e2.size : this.size), { width: t2, height: t2 };
        }
      }, e.ClusterPoint = class extends rb {
        constructor(e2 = {}) {
          super(e2), __publicField(this, "_ready"), __publicField(this, "_cluster"), __publicField(this, "_clusterDataSource"), __publicField(this, "_icon"), __publicField(this, "_label"), __publicField(this, "_minUpdateInterval"), __publicField(this, "isEventEntitySupported", true), __publicField(this, "_minUpdateInterval", 300), __publicField(this, "_lastUpdateTime", 0), __publicField(this, "_updateTimeoutHandler", null), __publicField(this, "_updateRenderingData", () => {
            const { map: e3 } = this.engine, t2 = e3.getBoundingBox(), i2 = Math.round(e3.getZoom()), n2 = this._cluster.getClusters([t2.min.x, t2.min.y, t2.max.x, t2.max.y], i2);
            this._clusterDataSource.setData(n2), this._clusterDataSource.update();
            for (const r2 of this.children)
              r2.setData();
          }), this.parameters = e2, this._ready = false, this._cluster = new qy(Object.assign({}, ob, e2.cluster)), this._cluster.load([]);
          (this._clusterDataSource = new __()).setAttribute("size").setAttribute("icon").setAttribute("text", (e3) => (e3 && e3.cluster ? e3.point_count : 0) + "");
        }
        initObject() {
        }
        afterAddToEngine(e2) {
          super.afterAddToEngine(e2);
          const t2 = this.parameters;
          t2.icon && (this._icon = this.addComponent(new Ey(Object.assign({}, sb, t2.icon)))), t2.label && (this._label = this.addComponent(new zy(Object.assign({}, ab, t2.label)))), this._ready = true;
        }
        setData() {
          let e2 = this.dataSource.data;
          this.cachedData = e2, this._cluster.load(this.dataSource._geoFeatures), this.needsUpdate = false;
        }
        onBeforeScenePrepareRender(e2, t2, i2, n2) {
          if (!this._ready || !this.dataSource)
            return;
          this._needsUpdate && this._updateRenderingData(), clearTimeout(this._updateTimeoutHandler);
          const r2 = n2.time;
          if (r2 - this._lastUpdateTime > this._minUpdateInterval)
            return this._updateRenderingData(), void (this._lastUpdateTime = r2);
          this._updateTimeoutHandler = setTimeout(() => {
            this._updateRenderingData(), e2.requestRender();
          }, this._minUpdateInterval), super.onBeforeScenePrepareRender(e2, t2, i2, n2);
        }
        getChildDataSource() {
          return this._clusterDataSource;
        }
        getEntityByIndex(e2) {
          const t2 = this._clusterDataSource;
          if (!t2)
            return;
          const i2 = { index: e2, value: t2.getOriginData(e2), itemIndex: t2.getOriginDataIndex(e2), pairs: {} }, n2 = t2.data;
          for (const r2 of Object.keys(n2))
            i2.pairs[r2] = n2[r2][e2];
          return i2;
        }
        get minUpdateInterval() {
          return this._minUpdateInterval;
        }
        set minUpdateInterval(e2) {
          e2 < 16 && (e2 = 16), this._minUpdateInterval = e2;
        }
        get clusterDataSource() {
          return this._clusterDataSource;
        }
      }, e.Cone = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "opacity"), __publicField(this, "height"), __publicField(this, "size"), __publicField(this, "getInstanceLocalMatrix", (e3, t2, i2) => {
            const { vertexHeights: n2, vertexSizes: r2 } = this.parameters, { height: s2, size: a2 } = this.dataSource.data;
            let o2 = new st();
            if (n2 && s2) {
              const e4 = new st();
              e4.makeScale(1, 1, s2[i2]), o2.multiply(e4);
            }
            if (r2 && a2) {
              const e4 = new st();
              e4.makeScale(a2[i2], a2[i2], 1), o2.multiply(e4);
            }
            return o2;
          }), __publicField(this, "addCustomAttributes", () => {
            this.calcMaxHeight(), this.getSphereIndex();
          }), this.parameters = e2, this.defineMaterialProxyProperties(["opacity", "color", "size"]);
        }
        initObject() {
          this.geometry = new Hb(this.parameters), this.material = new Wb(this.parameters);
        }
        calcMaxHeight() {
          const { vertexHeights: e2 } = this.parameters, { height: t2 } = this.dataSource.data;
          let i2 = -1;
          if (!e2 || !t2)
            return i2;
          for (let n2 = 0; n2 < t2.length; n2++)
            i2 < t2[n2] && (i2 = t2[n2]);
          this.material.uniforms.maxHeight.value = i2;
        }
        getSphereIndex() {
          const { sphereIndex: e2 } = this.geometry.parameters;
          this.material.uniforms.sphereIndex.value = e2;
        }
      }, e.CustomStaticSky = fp, e.DataItem = lc, e.DataSource = fc, e.Default3DTiles = class extends Rt {
        constructor(e2) {
          super(), __publicField(this, "options", null), __publicField(this, "_tilesRenderer", null), __publicField(this, "_elementsManager", null), __publicField(this, "_elementsGroup", null), __publicField(this, "_editableElementManager", null), __publicField(this, "engine", null), __publicField(this, "_tileMaxLevel", 19), __publicField(this, "is3DTiles", true), __publicField(this, "_materialManager", null), __publicField(this, "_debugTilesRenderer", null), __publicField(this, "_freezeUpdate", false), __publicField(this, "_excludeCastShadowMaterials", { road: true, green: true, isolation: true }), __publicField(this, "_instancedElementManager", null), __publicField(this, "_identityType", 1), __publicField(this, "_visibile", true), __publicField(this, "_loaders", []), __publicField(this, "handleBeforeRender", (e3, t3) => {
            this._debugTilesRenderer || (!this._freezeUpdate && this._visibile && (this._elementsManager && this._elementsManager.tick(t3), this._tilesRenderer.update()), this._editableElementManager.refreshTiles());
          }), __publicField(this, "handleLoadTileSet", (e3, t3, i3) => {
            this.engine.requestRender();
          }), __publicField(this, "handleUpdateModel", (e3) => {
            this._materialManager ? e3.traverse((e4) => {
              if (e4.originalMaterial) {
                const t3 = e4.originalMaterialName, i3 = this._materialManager.getMaterialByKey(t3);
                e4.material = i3 || e4.originalMaterial;
              }
            }) : e3.traverse((e4) => {
              e4.originalMaterial && (e4.material = e4.originalMaterial);
            }), this.engine.requestRender();
          }), __publicField(this, "parseTileInfo", (e3) => {
            const t3 = e3.content.uri, i3 = t3.substring(t3.lastIndexOf("/") + 1).split(".")[0], n3 = i3.split("-");
            e3.__id = i3, e3.__level = parseInt(n3[0], 10), e3.__lodLevel = this._tileMaxLevel - e3.__level;
          }), __publicField(this, "handleLoadModel", (e3, t3) => {
            this._materialManager && e3.traverse((e4) => {
              if (e4.material) {
                const t4 = e4.material.name;
                e4.originalMaterial = e4.material, e4.originalMaterialName = t4;
                const i3 = this._materialManager.getMaterialByKey(t4);
                i3 && (e4.material = i3), this._excludeCastShadowMaterials[t4] || (e4.castShadow = true), e4.receiveShadow = true;
              }
            }), e3._tileUri = t3.content.uri, this.parseTileInfo(t3), this._instancedElementManager.onTileLoad(t3, e3), this._elementsManager.onTileLoad(t3, e3), this._editableElementManager.onTileLoad(t3, e3), this.engine.requestRender();
          }), __publicField(this, "handleDisposeModel", (e3, t3) => {
            this._instancedElementManager.onTileDispose(t3, e3), this._elementsManager.onTileDispose(t3, e3), this._editableElementManager.onTileDispose(t3, e3);
          }), __publicField(this, "handleTileVisibleChanged", (e3, t3) => {
            t3 ? (this._editableElementManager.onTileShow(e3), this._instancedElementManager.onTileShow(e3), this._elementsManager.onTileShow(e3)) : (this._editableElementManager.onTileHide(e3), this._instancedElementManager.onTileHide(e3), this._elementsManager.onTileHide(e3));
          }), __publicField(this, "handleDebugBeforeengineRender", () => {
            this._freezeUpdate || this._debugTilesRenderer.update();
          }), __publicField(this, "_updateTilesCustomLoaders", (e3) => {
            for (const t3 of this._loaders)
              e3.manager.addHandler(t3[0], t3[1]);
          }), __publicField(this, "handleDebugLoadTileSet", () => {
            this.engine.requestRender();
          }), __publicField(this, "handleDebugLoadModel", () => {
            this.engine.requestRender();
          }), __publicField(this, "transformFromEcefToPlane", (e3, t3, i3 = 0) => {
            let n3 = Zg.eastNorthUpToFixedFrame(Zg.lnglatToEcef(e3, t3, i3));
            n3.invert();
            const r2 = new st(), s2 = Xh([e3, t3]);
            r2.makeTranslation(s2[0], s2[1], 0);
            const a2 = new st();
            a2.multiplyMatrices(r2, n3), a2.decompose(this.position, this.quaternion, this.scale);
          }), __publicField(this, "disposeTilesRender", (e3) => {
            e3.forEachLoadedModel((t3, i3) => {
              e3.disposeTile(i3);
            });
          }), this.options = e2;
          const t2 = this._tilesRenderer = new mg(this.options.url);
          t2.errorTarget = e2.errorTarget || 64, this.add(t2.group);
          const i2 = this._elementsGroup = new vs();
          this.add(i2);
          (this._elementsManager = new Sg(this._elementsGroup)).tilesRenderer = t2;
          const n2 = this._instancedElementManager = new Ng();
          n2.tilesRenderer = t2, this.add(n2.group);
          (this._editableElementManager = new kg()).tilesRenderer = t2, Array.isArray(e2.loaders) ? this._loaders = e2.loaders : this._loaders = [], this._updateTilesCustomLoaders(t2);
        }
        afterAddToEngine(e2) {
          this.engine = e2;
          const t2 = this._tilesRenderer;
          t2.setCamera(e2.camera), t2.setResolutionFromRenderer(e2.camera, e2.renderer), t2.onLoadTileSet = this.handleLoadTileSet, t2.onLoadModel = this.handleLoadModel, t2.onDisposeModel = this.handleDisposeModel, t2.onTileVisibleChanged = this.handleTileVisibleChanged, e2.addBeforeRenderListener(this.handleBeforeRender), this._instancedElementManager.engine = e2, this._elementsManager.engine = e2, this._editableElementManager.engine = e2;
        }
        getBounds() {
          const e2 = new Le(), t2 = this._tilesRenderer.getBounds(e2);
          return t2 && e2.applyMatrix4(this.matrixWorld), t2 ? e2 : null;
        }
        createDebugTilesRenderer() {
          this._tilesRenderer.group.visible = false;
          const e2 = this._debugTilesRenderer = new Mg(this.options.url), t2 = this.engine;
          e2.setCamera(t2.camera), e2.setResolutionFromRenderer(t2.camera, t2.renderer), e2.errorTarget = this._tilesRenderer.errorTarget, e2.displayBoxBounds = true, e2.onLoadTileSet = this.handleLoadTileSet, e2.onLoadModel = this.handleLoadModel, t2.addBeforeRenderListener(this.handleDebugBeforeengineRender), this._updateTilesCustomLoaders(e2), this.add(this._debugTilesRenderer.group);
        }
        isEntityVisible(e2) {
          return !e2.id || !this._editableElementManager.hasDeletedId(e2.id);
        }
        destoryDebugTilesRenderer() {
          this.remove(this._debugTilesRenderer.group), this.engine.removeBeforeRenderListener(this.handleDebugBeforeengineRender), this.disposeTilesRender(this._debugTilesRenderer), this._debugTilesRenderer.dispose(), this._tilesRenderer.group.visible = true;
        }
        dispose() {
          this.disposeTilesRender(this._tilesRenderer), this._tilesRenderer.dispose(), this._debugTilesRenderer && (this.disposeTilesRender(this._debugTilesRenderer), this._debugTilesRenderer.dispose());
        }
        set materialManager(e2) {
          e2 && (e2.engine = this.engine, e2.tiles = this, e2.init(), e2.Identity3DTilesMaterialManager && (e2.type = this._identityType)), this._materialManager = e2, this._tilesRenderer.forEachLoadedModel(this.handleUpdateModel);
        }
        get materialManager() {
          return this._materialManager;
        }
        set showDebug(e2) {
          e2 ? this._debugTilesRenderer || this.createDebugTilesRenderer() : this._debugTilesRenderer && (this.destoryDebugTilesRenderer(), this._debugTilesRenderer = null), this.engine.requestRender();
        }
        get showDebug() {
          return !!this._debugTilesRenderer;
        }
        get debugTilesRenderer() {
          return this._debugTilesRenderer;
        }
        get elementsManager() {
          return this._elementsManager;
        }
        get freezeUpdate() {
          return this._freezeUpdate;
        }
        set freezeUpdate(e2) {
          this._freezeUpdate = e2;
        }
        get errorTarget() {
          return this._tilesRenderer.errorTarget;
        }
        set errorTarget(e2) {
          this._tilesRenderer.errorTarget = e2, this._debugTilesRenderer && (this._debugTilesRenderer.errorTarget = e2), this.engine.requestRender();
        }
        get tilesGroup() {
          return this._tilesRenderer.group;
        }
        get tilesRenderer() {
          return this._tilesRenderer;
        }
        get instancedElementManager() {
          return this._instancedElementManager;
        }
        get editableElementManager() {
          return this._editableElementManager;
        }
        get identityType() {
          return this._identityType;
        }
        set identityType(e2) {
          this._identityType = e2, this._materialManager && this._materialManager.isIdentity3DTilesMaterialManager && (this._materialManager.type = e2);
        }
        set visible(e2) {
          this._visibile = e2, this._tilesRenderer && (this._tilesRenderer.group.visible = e2);
        }
        get visible() {
          return this._visibile;
        }
      }, e.Default3DTilesMaterialManager = h_, e.DomPoints = class extends _c {
        constructor(e2) {
          super(e2), __publicField(this, "isDomPoints", true), __publicField(this, "frustumCulled", false), __publicField(this, "onBeforeScenePrepareRenderHook", (e3, t2, i2) => {
            this.container = e3.map.container;
            let n2 = e3.renderer;
            const r2 = this.points, s2 = this.nodes;
            n2.getSize(Py), Ay.multiplyMatrices(i2.matrixWorldInverse, this.matrixWorld), Ay.multiplyMatrices(i2.projectionMatrix, Ay);
            for (let a2 = 0; a2 < r2.length; a2++) {
              Cy.set(r2[a2][0], r2[a2][1], r2[a2][2], 1), Cy.applyMatrix4(Ay), Cy.divideScalar(Cy.w);
              const e4 = (Cy.x + 1) / 2 * Py.x, t3 = (1 - Cy.y) / 2 * Py.y;
              if (!s2[a2])
                return;
              s2[a2].style.left = e4 + this.offset[0] + "px", s2[a2].style.top = t3 + this.offset[1] + "px";
            }
          }), this.points = [], this.nodes = [], this.offset = [0, 0], this.parameters = e2;
        }
        renderItem(e2, t2) {
          const i2 = document.createElement("div");
          return i2.style.position = "absolute", i2.style.width = "60px", i2.style.height = "40px", i2.style.background = "#FFFFFF", i2;
        }
        setData() {
          const e2 = this.engine, t2 = e2.camera, i2 = e2.renderer, { offset: n2 } = this.parameters;
          for (let a2 = 0; a2 < this.nodes.length; a2++)
            this.nodes[a2].remove();
          this.nodes = [], this.points = [];
          const r2 = this.dataSource;
          if (!r2)
            return;
          r2.needsUpdate && r2.update(), i2.getSize(Py), Ay.multiplyMatrices(t2.matrixWorldInverse, this.matrixWorld), Ay.multiplyMatrices(t2.projectionMatrix, Ay);
          const s2 = r2.data && r2.data.position || [];
          for (let a2 = 0, o2 = r2.size; a2 < o2; a2++) {
            const e3 = s2[a2];
            this.points.push(e3);
            const t3 = this.renderItem(r2.getOriginData(a2));
            Cy.set(e3[0], e3[1], e3[2], 1), Cy.applyMatrix4(Ay), Cy.divideScalar(Cy.w);
            const i3 = (Cy.x + 1) / 2 * Py.x, o3 = (1 - Cy.y) / 2 * Py.y;
            t3.style.position = "absolute", t3.style.left = i3 + n2[0] + "px", t3.style.top = o3 + n2[1] + "px", t3.style.pointerEvents = "none", this.nodes.push(t3), this.container.appendChild(t3);
          }
          this.offset = n2, this.needsUpdate = false, this.engine && this.engine.requestRender();
        }
        onDispose() {
          this.nodes && this.nodes.length && this.nodes.forEach((e2) => {
            e2.remove();
          });
        }
        set visible(e2) {
          let t2 = true == !!e2 ? "" : "hidden";
          this.nodes && this.nodes.length && this.nodes.forEach((e3) => {
            e3.style.visibility = t2;
          });
        }
        get visible() {
          return !this.nodes || !this.nodes.length || "hidden" !== this.nodes[0].style.visibility;
        }
      }, e.DynamicInstancedMesh = wg, e.DynamicSky = Rm, e.DynamicWeather = gl, e.EffectModelPoint = class extends _c {
        constructor(e2) {
          super(), __publicField(this, "_model"), __publicField(this, "_normalize"), __publicField(this, "_rotateToZUp"), __publicField(this, "_keepSize"), __publicField(this, "_size"), __publicField(this, "_size3"), __publicField(this, "_useSize3"), __publicField(this, "_height"), __publicField(this, "_animationRotate"), __publicField(this, "_animationRotatePeriod"), __publicField(this, "_animationJump"), __publicField(this, "_animationJumpPeriod"), __publicField(this, "_animationJumpHeight"), __publicField(this, "isEventEntitySupported", true), __publicField(this, "_model", null), __publicField(this, "_normalize", true), __publicField(this, "_rotateToZUp", true), __publicField(this, "_keepSize", true), __publicField(this, "_size", 1), __publicField(this, "_size3", [1, 1, 1]), __publicField(this, "_useSize3", false), __publicField(this, "_height", 0), __publicField(this, "_animationRotate", false), __publicField(this, "_animationRotatePeriod", 3e3), __publicField(this, "_animationJump", false), __publicField(this, "_animationJumpPeriod", 3e3), __publicField(this, "_animationJumpHeight", 30), __publicField(this, "_updateModel", () => {
            this._cleanOldMesh();
            const e3 = Fg(this._model, this._normalize, this._rotateToZUp);
            for (const t2 of e3) {
              const e4 = t2.material;
              let i2 = new hb();
              i2.setCommonUniforms(this.engine.rendering.uniforms), i2.transparent = e4.transparent, i2.opacity = e4.opacity, i2.side = e4.side, i2.depthWrite = e4.depthWrite, i2.depthTest = e4.depthTest, i2.depthFunc = e4.depthFunc, i2.blendDst = e4.blendDst, i2.blendDstAlpha = e4.blendDstAlpha, i2.blendEquation = e4.blendEquation, i2.blendEquationAlpha = e4.blendEquationAlpha, i2.blending = e4.blending, i2.blendSrc = e4.blendSrc, i2.blendSrcAlpha = e4.blendSrcAlpha, i2.premultipliedAlpha = e4.premultipliedAlpha, i2.color = e4.color, i2.colorWrite = e4.colorWrite, i2.emissive = e4.emissive, i2.keepSize = this._keepSize, i2.size = this._size, i2.size3 = this._size3, i2.useSize3 = this._useSize3, i2.height = this._height, i2.animationRotate = this._animationRotate, i2.animationRotatePeriod = this._animationRotatePeriod, i2.animationJump = this._animationJump, i2.animationJumpPeriod = this._animationJumpPeriod, i2.animationJumpHeight = this._animationJumpHeight;
              const n2 = t2.geometry, r2 = n2.getAttribute("color");
              r2 && (4 === r2.itemSize ? i2.vertexColors4 = true : 3 === r2.itemSize && (i2.vertexColors3 = true));
              const s2 = new qx(n2, i2);
              s2.engine = this.engine, s2.dataAutoUpdate = false, s2.__eventProxyByParent = true, this.dataSource && (s2.dataSource = this.dataSource), this.add(s2);
            }
            this.needsUpdate = true;
          }), __publicField(this, "_cleanOldMesh", () => {
            const e3 = this.children;
            for (const t2 of e3)
              this.remove(t2), t2.geometry && t2.geometry.dispose(), t2.material && t2.material.dispose();
          }), __publicField(this, "_defineChildrenMaterialProperty", (e3) => {
            Object.defineProperty(this, e3, { get: function() {
              return this["_" + e3];
            }, set: function(t2) {
              this["_" + e3] = t2;
              for (const i2 of this.children)
                i2.material[e3] = t2;
            } });
          }), e2 = Object.assign({}, cb, e2), this._normalize = e2.normalize, this._rotateToZUp = e2.rotateToZUp, ["size", "size3", "useSize3", "height", "keepSize", "animationRotate", "animationRotatePeriod", "animationJump", "animationJumpPeriod", "animationJumpHeight"].forEach((t2) => {
            void 0 !== e2[t2] && (this["_" + t2] = e2[t2]), this._defineChildrenMaterialProperty(t2);
          });
        }
        setData() {
          const e2 = this.dataSource;
          for (const t2 of this.children)
            t2.dataSource = e2, t2.setData();
          this.needsUpdate = false;
        }
        onDispose() {
          this._cleanOldMesh();
        }
        set model(e2) {
          e2 !== this._model && (this._model = e2, this._updateModel());
        }
        get model() {
          return this._model;
        }
      }, e.EmptySky = tl, e.Engine = class {
        constructor(e2, t2 = {}) {
          __publicField(this, "_container"), __publicField(this, "_event"), __publicField(this, "_map"), __publicField(this, "_rendering"), __publicField(this, "_selection"), __publicField(this, "isEngine", true), this._container = e2, this._event = new Kc(this, t2.event), this._map = new Pd(this, t2.map), this._map.init();
          const i2 = this.map.getResolution();
          this._rendering = new Yc(this, { resolution: i2, ...t2.rendering }), this._rendering.init(), this._map.afterInit(), this._rendering.startRenderLoop(), this._selection = new cp(this, t2.selection), this.trackingRequest();
        }
        add(e2) {
          return this._rendering.add(e2);
        }
        remove(e2) {
          this._rendering.remove(e2);
        }
        requestRender() {
          this._rendering.requestRender();
        }
        addBeforeRenderListener(e2) {
          this._rendering.addBeforeRenderListener(e2);
        }
        removeBeforeRenderListener(e2) {
          this._rendering.removeBeforeRenderListener(e2);
        }
        addBeforePrepareRenderObject(e2) {
          this._rendering.addBeforePrepareRenderObject(e2);
        }
        removeBeforePrepareRenderObject(e2) {
          this._rendering.removeBeforePrepareRenderObject(e2);
        }
        addBeforeRenderObject(e2) {
          this._rendering.addBeforeRenderObject(e2);
        }
        removeBeforeRenderObject(e2) {
          this._rendering.removeBeforeRenderObject(e2);
        }
        lockCamera() {
          this.camera._isLocked = true;
        }
        unlockCamera() {
          this.camera._isLocked = false;
        }
        get container() {
          return this._container;
        }
        get map() {
          return this._map;
        }
        get rendering() {
          return this._rendering;
        }
        get renderer() {
          return this._rendering.renderer;
        }
        get scene() {
          return this._rendering.scene;
        }
        get camera() {
          return this._rendering.camera;
        }
        get event() {
          return this._event;
        }
        get selection() {
          return this._selection;
        }
        dispose() {
          this._event.dispose(), this._selection.dispose(), this._rendering.dispose(), this._map.dispose();
        }
        trackingRequest() {
          const e2 = `http://api.map.baidu.com/images/blank.gif?product=jsapi&sub_product=mapvthree&usebmap=${window.BMapGL ? 1 : 0}&ak=${window.BMAP_AUTHENTIC_KEY}`;
          let t2 = new Image();
          t2.src = e2, t2.onload = () => {
            t2 = null;
          }, t2.onerror = () => {
            t2 = null;
          };
        }
      }, e.EngineEvent = Kc, e.EngineMap = Pd, e.EngineRendering = Yc, e.ExtendMeshStandardMaterial = Ag, e.FanPoint = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "opacity"), __publicField(this, "size"), __publicField(this, "height"), __publicField(this, "speed"), __publicField(this, "type"), __publicField(this, "segmentAngle"), __publicField(this, "sideColor"), this.parameters = e2, this.defineMaterialProxyProperties(["color", "size", "size3", "height", "opacity", "speed", "segmentAngle", "sideColor"]);
        }
        initObject() {
          this.geometry = new ty(), this.material = new cy(this.parameters), this.material.animationRotate = true, this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
      }, e.FatLine = Fx, e.FlyManager = class extends Rt {
        constructor() {
          super(...arguments), __publicField(this, "_engine"), __publicField(this, "_isRunning", false), __publicField(this, "_animationStartTime", 0), __publicField(this, "_animationDuration", 0), __publicField(this, "_animationStartState", null), __publicField(this, "_animationFinishState", null), __publicField(this, "restrictHeading", (e2, t2) => Math.abs(t2 - e2 + 360) < 180 ? t2 + 360 : Math.abs(t2 - e2 - 360) < 180 ? t2 - 360 : t2);
        }
        afterAddToEngine(e2) {
          this._engine = e2;
        }
        onBeforeScenePrepareRender(e2, t2, i2, n2) {
          if (!this._isRunning)
            return;
          const r2 = n2.time - this._animationStartTime;
          let s2 = 1;
          this._animationDuration > 0 && (s2 = r2 / this._animationDuration), s2 > 1 && (s2 = 1);
          const a2 = this._animationStartState, o2 = this._animationFinishState, l2 = this._engine.map;
          let h2 = {};
          void 0 !== a2.heading && (h2.heading = Vv(a2.heading, o2.heading, s2)), void 0 !== a2.pitch && (h2.pitch = Vv(a2.pitch, o2.pitch, s2)), void 0 !== a2.zoom && (h2.zoom = Vv(a2.zoom, o2.zoom, s2)), void 0 !== a2.range && (h2.range = Vv(a2.range, o2.range, s2));
          let c2 = Gv(a2.center, o2.center, s2);
          l2.lookAt(c2, h2), r2 >= this._animationDuration || s2 >= 1 ? (this._isRunning = false, this.onFinish && this.onFinish()) : this._engine.requestRender();
        }
        flyTo(e2, t2 = {}) {
          let { center: i2, pitch: n2, heading: r2, zoom: s2, range: a2 } = e2;
          const { duration: o2 = 300 } = t2, l2 = {}, h2 = {}, c2 = this._engine.map;
          l2.center = c2.getCenter(), h2.center = i2 || c2.getCenter(), isNaN(n2) || (l2.pitch = c2.getPitch(), h2.pitch = n2), isNaN(r2) || (r2 = this.restrictHeading(c2.getHeading(), r2), l2.heading = c2.getHeading(), h2.heading = r2), isNaN(s2) || (l2.zoom = c2.getZoom(), h2.zoom = s2), isNaN(a2) || (l2.range = c2.getCameraDistance(), h2.range = a2), this._animationStartState = l2, this._animationFinishState = h2, this._animationDuration = o2, this._isRunning = true, this._animationStartTime = new Date().getTime(), this._engine.requestRender(), this.onStart && this.onStart();
        }
      }, e.FoliageLeafMaterial = Lg, e.GeoInstancedMesh = qx, e.GeoJSONDataSource = __, e.Grid = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "height"), __publicField(this, "radialSegments"), __publicField(this, "radiusTop"), __publicField(this, "radiusBottom"), __publicField(this, "openEnded"), __publicField(this, "heightSegments"), __publicField(this, "isMultiColor"), __publicField(this, "multiColor"), __publicField(this, "isLight"), __publicField(this, "lightPos"), this.parameters = e2, this.defineGeometryProxyProperties(["height", "radiusTop", "radiusBottom", "height", "radialSegments", "heightSegments", "openEnded"]), this.defineMaterialProxyProperties(["color", "multiColor", "isMultiColor", "lightPos"]);
        }
        initObject() {
          this.geometry = new zb(this.parameters), this.material = new kb(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
      }, e.Heatmap = class extends vc {
        constructor(e2) {
          super(e2), __publicField(this, "isHeatmap", true), __publicField(this, "frustumCulled", false), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "scene"), __publicField(this, "pointMesh"), __publicField(this, "pointMaterial"), __publicField(this, "pointGeometry"), __publicField(this, "renderTarget"), __publicField(this, "depthMaterial"), __publicField(this, "depthRenderTarget"), this.parameters = e2, this.defineMaterialProxyProperties(["resolution"]);
        }
        getDefaultParams() {
          return { radius: 100, maxValue: 1, gradient: { 0: "rgba(0,0,255,1)", 0.3: "rgba(0,255,0,1)", 0.6: "rgba(255,255,0,1)", 1: "rgba(255,0,0,1)" } };
        }
        initObject() {
          let e2 = this.parameters;
          const t2 = this.geometry = new ri();
          t2.setAttribute("position", new qt(new Float32Array([-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]), 3)), t2.setAttribute("uv", new qt(new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), 2)), t2.setIndex([0, 2, 1, 2, 3, 1]);
          (this.material = new vb({})).setCommonUniforms(this.engine.rendering.uniforms);
          const [i2, n2] = this.resolution || [], r2 = this.scene = new Es();
          this.renderTarget = new we(i2, n2), this.depthRenderTarget = new we(i2, n2, {}), this.depthMaterial = new Mb({ keepSize: this.parameters.keepSize });
          const s2 = this.pointGeometry = new Sb(), a2 = this.pointMaterial = new yb({ keepSize: this.parameters.keepSize });
          a2.setCommonUniforms(this.engine.rendering.uniforms), this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);
          const o2 = this.pointMesh = new qx(s2, a2);
          o2.engine = this.engine, this.pointMesh.matrixAutoUpdate = true, o2.frustumCulled = false, r2.add(o2), this.material.uniforms.heatmap.value = this.renderTarget.texture, this.material.uniforms.heatmapDepth.value = this.depthRenderTarget.texture, void 0 !== e2.gradient && (this.gradient = e2.gradient), void 0 !== e2.radius && (this.radius = e2.radius), void 0 !== e2.minValue && (this.minValue = e2.minValue), void 0 !== e2.maxValue && (this.maxValue = e2.maxValue), void 0 !== e2.opacity && (this.opacity = e2.opacity), void 0 !== e2.keepSize && (this.keepSize = e2.keepSize), void 0 !== e2.attenuateMValueFactor && (this.attenuateMValueFactor = e2.attenuateMValueFactor);
        }
        onBeforeSceneRenderHook(e2, t2, i2, n2) {
          let r2 = e2.renderer;
          this.scene.position.set(-n2.cameraOffsetX, -n2.cameraOffsetY, 0), r2.setRenderTarget(this.renderTarget), false === r2.autoClear && r2.clear(), r2.render(this.scene, i2), r2.setRenderTarget(this.depthRenderTarget), false === r2.autoClear && r2.clear(), this.scene.overrideMaterial = this.depthMaterial, r2.render(this.scene, i2), this.scene.overrideMaterial = null, r2.setRenderTarget(null);
        }
        set dataSource(e2) {
          this.pointMesh.dataSource = e2;
        }
        get dataSource() {
          return this.pointMesh.dataSource;
        }
        setData() {
          this.pointMesh.dataSource && (this.pointMesh.addCustomAttributes = (e2, t2) => {
            let i2 = t2.data, n2 = [];
            for (let r2 = 0; r2 < i2.position.length; r2++) {
              const e3 = i2.count[r2] ? i2.count[r2] : 1;
              n2.push(e3);
            }
            e2.setAttribute("instancedWeight", new Vs(new Float32Array(n2), 1));
          }, this.pointMesh.setData());
        }
        dispose() {
          this.material.dispose(), this.geometry.dispose(), this.pointGeometry.dispose(), this.pointMaterial.dispose(), this.renderTarget.dispose(), this.depthMaterial.dispose(), this.depthRenderTarget.dispose();
        }
        set gradient(e2) {
          "[object Object]" === Object.prototype.toString.call(e2) && (this.material.gradient = e2);
        }
        set radius(e2) {
          !isNaN(e2) && e2 > 0 && (this.pointMaterial.radius = e2, this.depthMaterial.radius = e2);
        }
        get radius() {
          return this.pointMaterial.radius;
        }
        set minValue(e2) {
          isNaN(e2) || (this.pointMaterial.minValue = e2);
        }
        get minValue() {
          return this.pointMaterial.minValue;
        }
        set maxValue(e2) {
          isNaN(e2) || (this.pointMaterial.maxValue = e2);
        }
        get maxValue() {
          return this.pointMaterial.maxValue;
        }
        set opacity(e2) {
          isNaN(e2) || (this.material.opacity = e2);
        }
        get opacity() {
          return this.material.opacity;
        }
        set keepSize(e2) {
          this.pointMaterial.keepSize = e2, this.depthMaterial.keepSize = e2;
        }
        get keepSize() {
          return this.pointMaterial.keepSize;
        }
        set attenuateMValueFactor(e2) {
          this.pointMaterial.attenuateMValueFactor = e2;
        }
      }, e.Heatmap3D = class extends vc {
        constructor(e2) {
          super(e2), __publicField(this, "_gradient"), __publicField(this, "_radius"), __publicField(this, "_maxValue"), __publicField(this, "isHeatmap3D", true), __publicField(this, "frustumCulled", false), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "opacity"), __publicField(this, "heightRatio"), this.parameters = e2, this._gradient = void 0 !== this.parameters.gradient ? this.parameters.gradient : { 0.4: "rgba(0,0,255,1)", 0.6: "rgba(0,255,0,1)", 0.8: "rgba(255,255,0,1)", 1: "rgba(255,0,0,1)" }, this._radius = void 0 !== this.parameters.radius ? this.parameters.radius : 100, this._maxValue = void 0 !== this.parameters.maxValue ? this.parameters.maxValue : 1, this.defineMaterialProxyProperties(["resolution", "opacity", "heightRatio"]);
        }
        initObject() {
          const { radius: e2, maxValue: t2, ...i2 } = this.parameters;
          this.geometry = new ji();
          (this.material = new Tb(i2)).setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          let e2 = this.dataSource.data, t2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, a2 = -1 / 0, o2 = [];
          for (let v2 = 0; v2 < e2.position.length; v2++) {
            const l3 = e2.position[v2], h3 = e2.count ? e2.count[v2] : 1;
            t2 = Math.min(l3[0], t2), i2 = Math.min(l3[1], i2), n2 = Math.min(l3[2], n2), r2 = Math.max(l3[0], r2), s2 = Math.max(l3[1], s2), a2 = Math.max(l3[2], a2), o2.push([l3[0], l3[1], h3]);
          }
          let l2 = [(t2 + r2) / 2, (i2 + s2) / 2, (n2 + a2) / 2];
          this.position.set(...l2);
          let h2 = Math.ceil(r2 - t2) + 2 * this._radius, c2 = Math.ceil(s2 - i2) + 2 * this._radius;
          let u2 = Math.min(h2 * c2 / 4e4, 2048), d2 = u2 / 2, p2 = new Ab(u2, u2);
          o2.forEach((e3) => {
            e3[0] = e3[0] - t2 + this._radius, e3[1] = e3[1] - i2 + this._radius;
          });
          let m2 = Cb(p2), f2 = m2._ctx;
          f2.save(), f2.scale(u2 / h2, u2 / c2), m2.data(o2).radius(this._radius).max(this._maxValue).gradient(this._gradient).draw(), f2.restore(), this.geometry && this.geometry.dispose();
          const g2 = this.geometry = new ji(h2, c2, d2, d2);
          g2.computeBoundingSphere(), g2.computeBoundingBox(), this.texture && this.texture.dispose();
          let _2 = this.texture = new da(p2);
          this.material.uniforms.map.value = _2, this.needsUpdate = false;
        }
        onDispose() {
          this.texture && this.texture.dispose();
        }
        get gradient() {
          return this._gradient;
        }
        set gradient(e2) {
          this._gradient = e2;
        }
        get radius() {
          return this._radius;
        }
        set radius(e2) {
          this._radius = e2;
        }
        get maxValue() {
          return this._maxValue;
        }
        set maxValue(e2) {
          this._maxValue = e2;
        }
      }, e.Icon = Ey, e.IconPoint = zv, e.Identity3DTilesMaterialManager = class extends h_ {
        constructor() {
          super(), __publicField(this, "_type", 1), __publicField(this, "isIdentity3DTilesMaterialManager", true), this.material = new f_({ color: 35020 });
        }
        onInit() {
          this.updateType();
        }
        updateType() {
          this.tiles.instancedElementManager.idEnabled = 1 === this._type, this.tiles.instancedElementManager.dataTypeEnabled = 2 === this._type, this.material.type = this._type;
        }
        getMaterialByKey(e2) {
          return this.material;
        }
        dispose() {
          this.material.dispose();
        }
        set type(e2) {
          this._type = e2, this.updateType();
        }
        get type() {
          return this._type;
        }
      }, e.LODDynamicInstancedMesh = Tg, e.Label = zy, e.LightSphere = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "radius"), __publicField(this, "color"), __publicField(this, "widthSegments"), __publicField(this, "heightSegments"), __publicField(this, "phiStart"), __publicField(this, "phiLength"), __publicField(this, "thetaStart"), __publicField(this, "thetaLength"), __publicField(this, "animationEffect"), __publicField(this, "animationEffectPeriod"), this.parameters = e2, this.defineMaterialProxyProperties(["radius", "color", "widthSegments", "heightSegments", "phiStart", "phiLength", "thetaStart", "thetaLength"]);
        }
        initObject() {
          this.geometry = new Db(this.parameters), this.material = new Ob(this.parameters), this.material.animationRotate = true, this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
      }, e.MeshHeightMaterial = class extends Ag {
        constructor(e2) {
          super({ uniforms: { minAltitude: { value: 0 }, maxAltitude: { value: 870 }, noiseMap: { value: null }, noiseUvScale: { value: 1e-3 }, noiseScale: { value: 0.21 }, noiseBais: { value: -0.2 } } }), __publicField(this, "_gradient", null), __publicField(this, "_cachedGradientMap", null), __publicField(this, "isMeshHeightMaterial", true), this.defineMaterialNormalProperties(this, ["minAltitude", "maxAltitude", "noiseUvScale", "noiseScale", "noiseBais"]), this.vertexShaderChunks = Xb, this.fragmentShaderChunks = qb, this.createGradientMap(), this.setValues(e2);
        }
        get gradient() {
          return this._gradient;
        }
        set gradient(e2) {
          this._gradient = e2, this.updateGradientMap();
        }
        get noiseMap() {
          return this.uniforms.noiseMap.value;
        }
        set noiseMap(e2) {
          this.uniforms.noiseMap.value = e2, e2 ? this.defines.USE_NOISE_MAP = true : delete this.defines.USE_NOISE_MAP, this.needsUpdate = true;
        }
        createGradientMap() {
          let e2 = document.createElement("canvas");
          e2.width = 64, e2.height = 2;
          let t2 = e2.getContext("2d"), i2 = t2.createLinearGradient(0, 0, 64, 0);
          i2.addColorStop(0, "#062516"), i2.addColorStop(0.2, "#85765d"), i2.addColorStop(0.6, "#032a21"), i2.addColorStop(0.9, "#001323"), i2.addColorStop(0.95, "#051420"), i2.addColorStop(1, "#263241"), t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap = new da(e2), this.map = this._cachedGradientMap;
        }
        updateGradientMap() {
          let e2 = this._cachedGradient;
          if ("[object Object]" !== Object.prototype.toString.call(e2))
            return;
          let t2 = this._cachedGradientMap.image.getContext("2d");
          t2.clearRect(0, 0, 64, 2);
          let i2 = t2.createLinearGradient(0, 0, 64, 0);
          for (const n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && i2.addColorStop(n2, e2[n2]);
          t2.fillStyle = i2, t2.fillRect(0, 0, 64, 2), this._cachedGradientMap.needsUpdate = true;
        }
        dispose() {
          this.noiseMap && this.noiseMap.dispose(), super.dispose();
        }
      }, e.PathTracker = class extends Rt {
        constructor() {
          super(...arguments), __publicField(this, "_isRunning", false), __publicField(this, "_animationStartTime", 0), __publicField(this, "_animationDuration", 0), __publicField(this, "_animationTransform", {}), __publicField(this, "_engine", null), __publicField(this, "_track", null), __publicField(this, "_sampledPath", []), __publicField(this, "_object", null), __publicField(this, "_interpolateDirectThreshold", 10), __publicField(this, "_lockView", true);
        }
        afterAddToEngine(e2) {
          this._engine = e2, "blank" !== e2.map.mapType && "blank_3dcontrol" !== e2.map.mapType && console.error("PathTracker is not compatible with current type of Map.");
        }
        onBeforeScenePrepareRender(e2, t2, i2, n2) {
          if (!this._isRunning)
            return;
          const r2 = n2.time - this._animationStartTime;
          let s2 = 1;
          this._animationDuration > 0 && (s2 = r2 / this._animationDuration), s2 > 1 && (s2 = 1);
          const a2 = this._interpolatePath(s2), o2 = this._engine.map;
          if (void 0 !== a2.position && void 0 !== a2.pitch && void 0 !== a2.direction) {
            let e3 = new ie(...a2.direction).angle();
            const t3 = this._engine._container.clientHeight;
            let n3 = this._animationTransform.distance / (t3 / 2) * Math.tan(o2.fov / 2 * Math.PI / 180), r3 = this._engine.map.getZoomByZoomUnits(n3);
            this._updateCamera(i2, a2.position, r3, n3, e3 - Math.PI / 2, a2.pitch), this.object && (this.object.position.set(...a2.position), this.object.rotation.y = e3, this.object.rotation.z = a2.pitch);
          }
          r2 >= this._animationDuration || s2 >= 1 ? this.stop() : this._engine.requestRender();
        }
        _updateCamera(e2, t2, i2, n2, r2, s2) {
          let a2 = this._engine.map;
          "blank" === a2.mapType ? this._computeCameraMatrixBlankMap(e2, t2, i2, n2, r2, s2) : "blank_3dcontrol" === a2.mapType && this._computeCameraMatrixBlankMap3D(e2, t2, i2, n2, r2, s2);
        }
        _computeCameraMatrixBlankMap(e2, t2, i2, n2, r2, s2) {
          const a2 = this._engine.map, { distance: o2, heading: l2, pitch: h2 } = this._animationTransform, c2 = this._engine._container.clientWidth, u2 = this._engine._container.clientHeight;
          if (e2.position.set(0, 0, 0), e2.quaternion.set(0, 0, 0, 1), e2.up.set(0, 0, 1), e2.translateX(t2[0]), e2.translateY(t2[1]), t2[2] && e2.translateZ(t2[2]), this.lockView)
            e2.rotateOnAxis(new Ae(0, 0, 1), l2 * Math.PI / 180 + r2), e2.rotateOnAxis(new Ae(1, 0, 0), h2 * Math.PI / 180 + s2), e2.translateZ(o2);
          else {
            e2.rotateOnAxis(new Ae(0, 0, 1), a2.getHeading() * Math.PI / 180), e2.rotateOnAxis(new Ae(1, 0, 0), a2.getPitch() * Math.PI / 180);
            const t3 = u2 / 2 / Math.tan(a2.fov / 2 * Math.PI / 180) * a2.getZoomUnits();
            e2.translateZ(t3);
          }
          e2.updateMatrix(), e2.updateMatrixWorld(), e2.aspect = c2 / u2;
          let d2 = n2;
          d2 < 1 && (d2 = 1), e2.near = a2.near, e2.far = a2.far * d2, e2.updateProjectionMatrix(), a2.map.center = t2, this.lockView && (a2.map.cameraDistance = o2, a2.map.zoomUnits = n2, a2.map.zoom = i2, a2.map.heading = l2 + r2 / Math.PI * 180, a2.map.pitch = h2 + s2 / Math.PI * 180);
        }
        _computeCameraMatrixBlankMap3D(e2, t2, i2, n2, r2, s2) {
          const a2 = this._engine.map, { distance: o2, heading: l2, pitch: h2 } = this._animationTransform;
          let c2 = a2.unprojectPointArr(t2);
          this.lockView ? a2.lookAt(c2, { heading: l2 + te.radToDeg(r2), pitch: h2 + te.radToDeg(s2), range: o2 }) : a2.lookAt(c2, { heading: a2.getHeading(), pitch: a2.getPitch(), range: a2.getCameraDistance() });
        }
        _interpolatePath(e2) {
          const t2 = this._engine.map;
          for (let i2 = 1; i2 < this._sampledPath.length; i2++) {
            const n2 = this._sampledPath[i2], r2 = this._sampledPath[i2 - 1];
            if (e2 >= r2.percent && e2 < n2.percent) {
              const i3 = (e2 - r2.percent) / (n2.percent - r2.percent), s2 = Hv(r2.point, n2.point, i3);
              return { percent: e2, point: s2, position: t2.projectPointArr(s2), distance: Vv(r2.distance, n2.distance, i3), direction: Gv(r2.direction, n2.direction, i3), pitch: Vv(r2.pitch, n2.pitch, i3) };
            }
          }
          return this._sampledPath[this._sampledPath.length - 1];
        }
        _createSampledPath(e2) {
          const t2 = this._engine.map;
          if (!e2)
            return;
          let i2 = 0, n2 = [0], r2 = [], s2 = [];
          for (let o2 = 1; o2 < e2.length; o2++) {
            const a3 = e2[o2], l2 = e2[o2 - 1], h2 = e2[o2 + 1], c2 = Bv(t2.projectPointArr(l2), t2.projectPointArr(a3));
            if (n2[o2] = c2 + i2, i2 += c2, 1 === o2 && (r2[0] = jv(l2, a3).toArray(), s2[0] = this._getRadians(l2, a3)), h2) {
              const e3 = Gv(jv(l2, a3).toArray(), jv(a3, h2).toArray(), 0.5);
              r2[o2] = e3;
              const t3 = this._getRadians(l2, a3), i3 = this._getRadians(a3, h2);
              s2[o2] = Vv(t3, i3, 0.5);
            } else
              r2[o2] = jv(l2, a3).toArray(), s2[o2] = this._getRadians(l2, a3);
          }
          const a2 = [];
          for (let o2 = 0; o2 < e2.length; o2++) {
            const l2 = e2[o2][2] ? e2[o2] : [e2[o2][0], e2[o2][1], 0];
            if (n2[o2] - this.interpolateDirectThreshold > n2[o2 - 1] && 0 !== o2 && o2 !== e2.length - 1) {
              const r3 = e2[o2 - 1][2] ? e2[o2 - 1] : [e2[o2 - 1][0], e2[o2 - 1][1], 0], s3 = n2[o2] - this.interpolateDirectThreshold, h2 = Hv(r3, l2, 1 - this.interpolateDirectThreshold / (n2[o2] - n2[o2 - 1]));
              a2.push({ percent: (s3 / i2).toFixed(6), point: h2, position: t2.projectPointArr(h2), distance: s3, direction: jv(r3, l2).toArray(), pitch: this._getRadians(r3, l2) });
            }
            if (a2.push({ percent: (n2[o2] / i2).toFixed(6), point: l2, position: t2.projectPointArr(l2), distance: n2[o2], direction: r2[o2], pitch: s2[o2] }), n2[o2] + this.interpolateDirectThreshold < n2[o2 + 1] && 0 !== o2 && o2 !== e2.length - 1) {
              const r3 = e2[o2 + 1][2] ? e2[o2 + 1] : [e2[o2 + 1][0], e2[o2 + 1][1], 0], s3 = n2[o2] + this.interpolateDirectThreshold, h2 = Hv(l2, r3, this.interpolateDirectThreshold / (n2[o2 + 1] - n2[o2]));
              a2.push({ percent: (s3 / i2).toFixed(6), point: h2, position: t2.projectPointArr(h2), distance: s3, direction: jv(l2, r3).toArray(), pitch: this._getRadians(l2, r3) });
            }
          }
          return a2.sort((e3, t3) => e3.percent - t3.percent), this._sampledPath = a2, a2;
        }
        _getRadians(e2, t2) {
          const i2 = this._engine.map, n2 = Bv(e2 = i2.projectPointArr([e2[0], e2[1], e2[2] || 0]), t2 = i2.projectPointArr([t2[0], t2[1], t2[2] || 0])), r2 = (s2 = e2, a2 = t2, Math.sqrt(Math.pow(s2[0] - a2[0], 2) + Math.pow(s2[1] - a2[1], 2)));
          var s2, a2;
          const o2 = Math.acos(r2 / n2);
          return e2[2] >= t2[2] ? -o2 : o2;
        }
        start(e2 = {}) {
          const { duration: t2 = 1e3, heading: i2 = 0, pitch: n2 = 60, distance: r2 = 100 } = e2;
          this.track && (this._isRunning || (this._isRunning = true, this._animationTransform = { heading: i2, pitch: n2, distance: r2 }, this.lockView && this._engine.lockCamera(), this._animationDuration = t2, this._animationStartTime = new Date().getTime(), this._engine.requestRender(), this.onStart && this.onStart()));
        }
        stop() {
          this._isRunning && (this._isRunning = false, this._engine.unlockCamera(), this._engine.requestRender(), this.onFinish && this.onFinish());
        }
        set track(e2) {
          e2 ? e2 instanceof Array && e2[0] instanceof Array && "number" == typeof e2[0][0] && e2.length >= 2 ? (this._track = e2, this._createSampledPath(e2)) : e2.constructor === Object && e2.geometry && "LineString" === e2.geometry.type && Array.isArray(e2.geometry.coordinates) && (this._track = e2.geometry.coordinates, this._createSampledPath(e2.geometry.coordinates)) : this._track = null;
        }
        get track() {
          return this._track;
        }
        set interpolateDirectThreshold(e2) {
          this._interpolateDirectThreshold !== e2 && (this._interpolateDirectThreshold = e2, this._createSampledPath(this.track));
        }
        get interpolateDirectThreshold() {
          return this._interpolateDirectThreshold;
        }
        set lockView(e2) {
          this._lockView = e2, this._isRunning && true === e2 ? this._engine.lockCamera() : this._engine.unlockCamera();
        }
        get lockView() {
          return this._lockView;
        }
        set object(e2) {
          this._object = e2;
        }
        get object() {
          return this._object;
        }
      }, e.Pillar = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "opacity"), __publicField(this, "height"), __publicField(this, "radiusSegments"), __publicField(this, "radius"), __publicField(this, "gradient"), __publicField(this, "vertexHeights"), __publicField(this, "openEnded"), __publicField(this, "getInstanceLocalMatrix", (e3, t2, i2) => {
            const { vertexHeights: n2 } = this.parameters, { height: r2 } = this.dataSource.data;
            if (n2 && r2) {
              const e4 = new st();
              return e4.makeScale(1, 1, r2[i2]), e4;
            }
            return null;
          }), __publicField(this, "addCustomAttributes", () => {
            const { vertexHeights: e3 } = this.parameters, { height: t2 } = this.dataSource.data;
            let i2 = -1;
            if (!e3 || !t2)
              return i2;
            for (let n2 = 0; n2 < t2.length; n2++)
              i2 < t2[n2] && (i2 = t2[n2]);
            this.material.uniforms.maxHeight.value = i2;
          }), this.parameters = e2;
        }
        initObject() {
          this.geometry = new Bb(this.parameters), this.material = new Gb(this.parameters);
        }
      }, e.PointGroup = rb, e.Polygon = Rx, e.Realistic3DTilesMaterialManager = class extends h_ {
        constructor() {
          super(...arguments), __publicField(this, "isRealistic3DTilesMaterialManager", true), __publicField(this, "_autoTimingLight", true), __publicField(this, "_nightLightDensity", 0), __publicField(this, "getTexture", (e2, t2, i2, n2, r2) => {
            const s2 = p_.load(Jo(Qo(), "assets/textures/realistic", `TexturesCom_${e2}_${t2}.${n2.format || "jpg"}`), r2);
            return s2.wrapS = s2.wrapT = l, s2.repeat = i2, s2;
          }), __publicField(this, "createPbrMaterial", (e2, t2, i2, n2 = {}, r2 = {}) => {
            i2 || (i2 = new ie(0.5, 0.5)), t2 || (t2 = { albedo: true, normal: true, roughness: true, ao: false });
            const s2 = { ...n2, envMapIntensity: 2 };
            t2.albedo && (s2.map = this.getTexture(e2, "albedo", i2, r2)), t2.normal && (s2.normalMap = this.getTexture(e2, "normal", i2, r2)), t2.roughness && (s2.roughnessMap = this.getTexture(e2, "roughness", i2, r2)), t2.ao && (s2.aoMap = this.getTexture(e2, "ao", i2, r2)), t2.emissive && (s2.emissiveMap = this.getTexture(e2, "emissive", i2, r2));
            return new xa(s2);
          }), __publicField(this, "createBuildingMaterial", () => {
            const e2 = p_.load($o("assets/textures/building/building3_atlas_diffuse.jpg"));
            e2.wrapS = e2.wrapT = l;
            const t2 = p_.load($o("assets/textures/building/building3_atlas_normal.jpg"));
            t2.wrapS = t2.wrapT = l;
            const i2 = p_.load($o("assets/textures/building/building3_atlas_metallic_roughness.jpg"));
            i2.wrapS = i2.wrapT = l;
            const n2 = p_.load($o("assets/textures/building/building_atlas_emissive.jpg"));
            n2.wrapS = n2.wrapT = l;
            const r2 = p_.load($o("assets/textures/building/ac1.png"));
            r2.flipY = false;
            const s2 = new Ag({ roughness: 0.5, metalness: 0.2, map: e2, normalMap: t2, roughnessMap: i2, metalnessMap: i2, emissiveMap: n2, uniforms: { acMap: { value: r2 } }, vertexShaderChunks: { pars: "\n                    attribute float _mt;\n                    varying float vMt;\n                ", main_before: "\n                    vMt = _mt;\n                " }, fragmentShaderChunks: { pars: "\n                    uniform sampler2D acMap;\n                    varying float vMt;\n                    #define USE_CUSTOM_MAP\n                ", main_before: "\n                    if (vMt < 100.0) {\n                        float row = floor(vMt / 4.0);\n                        float col = mod(vMt, 4.0);\n                        uv.x = col * 0.25 + mod(vUv.x / 36.0,  0.25);\n                        if (vUv.y < 3.0) {\n                            uv.y = 0.02;\n                            uv.x = 0.02;\n                        } else {\n                            // uv.y = vUv.y / 9.0;\n                            uv.y = 1.0 - (row * 0.25 + 0.25 - mod(vUv.y / 36.0,  0.25));\n                        }\n                    }\n                ", custom_map: "\n                    vec4 sampledDiffuseColor;\n                    if (vMt < 100.0) {\n                        sampledDiffuseColor = texture2D( map, uv );\n                    }\n                    else {\n                        sampledDiffuseColor = texture2D( acMap, vUv );\n                    }\n                ", color_after: "\n                    // diffuseColor.xyz = vec3(vMt / 15.0, 0, 0);\n                " } });
            return s2.uniforms.acMap.value = r2, s2;
          }), __publicField(this, "handleWeatherChanged", (e2) => {
            let t2 = 0.8, i2 = 1, n2 = false;
            "cloudy" === e2 || "partlyCloudy" === e2 ? (t2 = 0.4, i2 = 1) : "rainy" === e2 ? (t2 = 0.2, i2 = 1, n2 = true) : "snow" === e2 && (t2 = 0.2, i2 = 0.2);
            const r2 = this._materrialMap.get("road");
            if (r2.envMapIntensity = t2, r2.roughness = i2, n2) {
              const e3 = this.getTexture("Ground_MudWet_512", "roughness", new ie(0.1, 0.1), {}, () => {
                this.engine.requestRender();
              });
              r2._roughnessMap = r2.roughnessMap, r2.roughnessMap = e3, r2.map.repeat = new ie(0.05, 0.05);
            } else
              r2._roughnessMap && (r2.roughnessMap = r2._roughnessMap, r2._roughnessMap = null, r2.map.repeat = new ie(0.5, 0.5));
            this._materrialMap.get("buildingSide").envMapIntensity = t2;
          }), __publicField(this, "handleTimeChanged", (e2) => {
            if (!this._autoTimingLight)
              return;
            let t2 = 0;
            t2 = e2 > 66600 || e2 < 19800 ? 1 : e2 > 63e3 ? (e2 - 63e3) / 3600 : e2 < 23400 ? (23400 - e2) / 3600 : 0, this.updateLightDensity(t2);
          });
        }
        onInit() {
          this.addMaterials();
          const e2 = this.engine, t2 = e2.rendering.sky;
          t2 && (t2.addTimeChangedListener(this.handleTimeChanged), this.handleTimeChanged(t2.time));
          const i2 = e2.rendering.weather;
          i2 && (i2.addWeatherChangedListener(this.handleWeatherChanged), this.handleWeatherChanged(i2.weather));
        }
        addMaterials() {
          this._materrialMap.set("road", this.createPbrMaterial("Asphalt_Base10_2x2_512", null, null, { color: 11184810, roughness: 0.8, side: 2, emissiveIntensity: 0, emissive: new ge(920067) })), this._materrialMap.set("isolation", this.createPbrMaterial("Nature_Pebbles_512", null, null, {})), this._materrialMap.set("green", this.createPbrMaterial("Nature_Moss_512", null, null, { color: 13434828 })), this._materrialMap.set("buildingSide", this.createBuildingMaterial()), this._materrialMap.set("buildingRoof", this.createPbrMaterial("Roofing_Bitumen_512", {}, new ie(1, 1), { color: 5592405, metalness: 0.2, roughness: 0.8 }, { format: "jpg" }));
          const e2 = new d_();
          this._materrialMap.set("water", e2);
          this.engine.addBeforeRenderObject(e2);
        }
        updateLightDensity(e2) {
          const t2 = this._materrialMap.get("buildingSide");
          this._materrialMap.get("road"), t2.uniforms.emissive.value.copy(m_).multiplyScalar(0.3 * e2);
        }
        get autoTimingLight() {
          return this._autoTimingLight;
        }
        set autoTimingLight(e2) {
          if (e2 = !!e2, this._autoTimingLight = e2, e2) {
            const e3 = this.engine.sky;
            e3 && this.handleTimeChanged(e3.time);
          } else
            this.updateLightDensity(this._nightLightDensity);
        }
        get nightLightDensity() {
          return this._nightLightDensity;
        }
        set nightLightDensity(e2) {
          this._nightLightDensity = e2, this._autoTimingLight || this.updateLightDensity(e2);
        }
      }, e.RoadLight3DTilesElement = class extends Bg {
        constructor() {
          super(...arguments), __publicField(this, "subscribedDataTypeIds", [101]), __publicField(this, "_tickInterval", 0), __publicField(this, "_scaleSize", 0.04), __publicField(this, "_powerStates", /* @__PURE__ */ new Set()), __publicField(this, "_colorStates", /* @__PURE__ */ new Map()), __publicField(this, "_allPowerOn", false);
        }
        createMeshFromGeometry(e2) {
          return new Vg(e2);
        }
        _refreshPowerViewState(e2, t2) {
          this._allPowerOn || this._powerStates.has(e2) ? (t2.visible = true, this._colorStates.has(e2) && (t2.color = this._colorStates.get(e2))) : t2.visible = false;
        }
        onEntityShow(e2, t2) {
          this._refreshPowerViewState(e2, t2);
        }
        setPowerState(e2, t2) {
          if (t2 ? this._powerStates.add(e2) : this._powerStates.delete(e2), this._visibleIdMap.has(e2)) {
            const t3 = this._visibleIdMap.get(e2);
            this._refreshPowerViewState(e2, t3), this.engine.requestRender();
          }
        }
        togglePowerState(e2) {
          this.setPowerState(e2, !this.isPowerOn(e2)), this.engine.requestRender();
        }
        isPowerOn(e2) {
          return this._powerStates.has(e2);
        }
        setColor(e2, t2) {
          if (this._colorStates.set(e2, t2), this._visibleIdMap.has(e2)) {
            const t3 = this._visibleIdMap.get(e2);
            this._refreshPowerViewState(e2, t3), this.engine.requestRender();
          }
        }
        set allPowerOn(e2) {
          this._allPowerOn = e2;
        }
        get allPowerOn() {
          return this._allPowerOn;
        }
      }, e.ShapePoint = class extends qx {
        constructor(e2) {
          super(e2), this.parameters = e2, this.defineGeometryProxyProperties(["shapeType"]);
        }
        getDefaultParams() {
          return { shapeType: "cube" };
        }
        initObject() {
          const { shapeType: e2, ...t2 } = this.parameters;
          this.geometry = new gy(this.parameters), this.material = new vy(t2), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
      }, e.SimplePoint = class extends Iv {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "vertexColors"), __publicField(this, "size"), __publicField(this, "vertexSizes"), __publicField(this, "opacity"), __publicField(this, "emissive"), this.parameters = e2, this.defineMaterialProxyProperties(["size", "uShapeType", "opacity", "emissive", "vertexColors", "vertexSizes", "color", "mapSrc"]);
        }
        collisionTest(e2) {
          return this.parameters.vertexSizes && e2.size ? { width: e2.size, height: e2.size } : { width: this.size, height: this.size };
        }
        initObject() {
          this.geometry = new Yx(this.parameters), this.material = new Kx(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          const e2 = this.dataSource.data, { vertexSizes: t2, vertexColors: i2 } = this.parameters;
          let n2 = [];
          n2 = this._enableCollision && this._collisionData ? this._collisionData : this.dataSource.userData;
          const r2 = [], s2 = [], a2 = [], o2 = [];
          for (let l2 = 0; l2 < n2.length; l2++) {
            const h2 = n2[l2].position, c2 = n2[l2].index;
            if (r2.push(...h2), s2.push(c2), i2 && e2.color) {
              let e3 = mh(n2[l2].color);
              a2.push(...e3.toArray());
            }
            t2 && e2.size && o2.push(n2[l2].size);
          }
          this.geometry.setData({ aPositions: r2, aObjectIndices: s2, aColors: a2, aSizes: o2 }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, r2), this.needsUpdate = false;
        }
      }, e.Spark = class extends ub {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "vertexColors"), __publicField(this, "height"), __publicField(this, "vertexHeights"), __publicField(this, "speed"), __publicField(this, "tailLength"), __publicField(this, "idle"), __publicField(this, "emissive"), this.parameters = e2, this.defineMaterialProxyProperties(["color", "height", "tailLength", "speed", "idle", "emissive", "vertexColors", "vertexHeights"]);
        }
        getDefaultParams() {
          return { height: 100 };
        }
        initObject() {
          this.geometry = new db(this.parameters), this.material = new mb(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          const e2 = this.dataSource.data, t2 = [], i2 = [], n2 = [], r2 = [], s2 = [];
          for (let a2 = 0; a2 < e2.position.length; a2++) {
            let o2 = e2.position[a2];
            if (t2.push(o2[0], o2[1], o2[2]), this.parameters.vertexHeights && e2.height ? (t2.push(o2[0], o2[1], o2[2] + e2.height[a2]), n2.push(e2.height[a2]), r2.push(0, e2.height[a2])) : (t2.push(o2[0], o2[1], o2[2] + this.parameters.height), r2.push(0, this.parameters.height)), this.parameters.vertexColors && e2.color) {
              let t3 = mh(e2.color[a2]);
              i2.push(...t3.toArray(), ...t3.toArray());
            }
            s2.push(2 * a2, 2 * a2 + 1);
          }
          this.geometry.setData({ aPositions: t2, aColors: i2, aHeights: n2, aLengths: r2, indices: s2 }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, t2), this.needsUpdate = false;
        }
      }, e.SpecialPoint = class extends qx {
        constructor(e2) {
          super(e2), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "color"), __publicField(this, "opacity"), __publicField(this, "size"), __publicField(this, "height"), this.parameters = e2, this.defineMaterialProxyProperties(["color", "size", "height", "opacity"]);
        }
        initObject() {
          this.geometry = new ty(), this.material = new oy(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms), this.needsUpdate = true;
        }
      }, e.SplineEditor = class extends Ox {
        constructor(e2, t2 = {}) {
          super(), __publicField(this, "_virtualLineBuffer", { position: [[]], index: [], payload: [] }), __publicField(this, "_splineBuffer", { position: [[]], index: [], payload: [] }), __publicField(this, "_helpersBuffer", { position: [], index: [], payload: [] }), __publicField(this, "_engine"), __publicField(this, "_options"), __publicField(this, "_virtualLine"), __publicField(this, "_virtualLineDataSource"), __publicField(this, "_helpers"), __publicField(this, "_helpersDataSource"), __publicField(this, "_spline"), __publicField(this, "_splineDataSource"), __publicField(this, "_completedDataSource"), __publicField(this, "_completedElement"), __publicField(this, "_isAdd"), __publicField(this, "_selectedIndex"), __publicField(this, "_stage"), __publicField(this, "_transformIndex"), __publicField(this, "_lastDataItem"), __publicField(this, "_handleCompleteClick", (e3) => {
            if (1 !== this._stage) {
              this.complete(), this._selectedIndex = e3.entity.value.index, this._engine.event.unbind("click", this._handleAddClick), this._lastDataItem = this._drawedGraph.slice(this._selectedIndex, this._selectedIndex + 1), this._stage = 2, this._completedDataSource.setData();
              for (let e4 = 0; e4 < this._drawedGraph.length; e4++)
                e4 !== this._selectedIndex && this._completedDataSource.add(this._drawedGraph[e4].dataItem);
              this._splineBuffer = this._lastDataItem[0].splineBuffer, this._splineDataSource.setData(this._splineBuffer), this._helpersBuffer = this._lastDataItem[0].helpersBuffer, this._helpersDataSource.setData(this._helpersBuffer), this._engine.event.bind(this._helpers, "click", this._handleNodeClick), this._engine.requestRender();
            }
          }), __publicField(this, "_handleAddClick", (e3) => {
            this._isAdd = true;
            let t3 = this.length;
            if (0 === this._stage || 1 === this._stage) {
              if (this._stage = 1, this.length > 2 && kv(e3.position, this._helpersBuffer.position.slice(-1)[0]))
                return this.addNode(t3, e3.position, e3.point), void this._handleAddFinish();
              this.addNode(t3, e3.position, e3.point), this.dispatchEvent({ type: "addNode", value: this.data }), this._engine.event.bind("mousemove", this._handleAddMove);
            }
            this._engine.requestRender();
          }), __publicField(this, "_handleAddMove", (e3) => {
            let t3 = this._helpersBuffer.position[this.length - 1], i2 = e3.position;
            this._virtualLineBuffer.position[0] = [t3, i2], this._virtualLineBuffer.index = [0], this._virtualLineDataSource.setData(this._virtualLineBuffer), this.dispatchEvent({ type: "moveNode", value: i2 });
          }), __publicField(this, "_handleAddFinish", (e3) => {
            if (2 !== this.length) {
              if (1 === this._stage) {
                this._stage = 2;
                let e4 = this.length - 1;
                this._virtualLineDataSource.setData(), this.removeNode(e4);
                for (let t3 = 0; t3 < this.length; t3++) {
                  this._splineBuffer.payload[t3].angle = this._getNodeNormal(t3).angle();
                }
                this.dispatchEvent({ type: "change", value: this.data });
              }
              this._engine.requestRender(), this._engine.event.unbind("click", this._handleAddClick), this._engine.event.unbind("mousemove", this._handleAddMove), this._engine.event.bind(this._helpers, "click", this._handleNodeClick), this._engine.event.bind("click", this._handleCancelEdit);
            }
          }), __publicField(this, "_handleNodeClick", (e3) => {
            e3.domEvent ? e3.event.domEvent.preventDefault() : e3.event.preventDefault(), !e3.entity || 2 !== this._stage && 3 !== this._stage || (this._transformIndex = e3.entity.index, this.attachTransform(e3.entity.position), this._stage = 3, this._engine.selection.transformControl.addEventListener("objectChange", this._handleTransformChanging), this._engine.selection.transformControl.addEventListener("mouseUp", this._handleTransformChanged));
          }), __publicField(this, "_handleTransformChanging", (e3) => {
            let t3 = this._getTransformBoxState();
            if (3 === this._stage)
              if (0 === this._transformIndex) {
                let e4 = t3.position, i2 = this._helpersBuffer.position[this._transformIndex + 1];
                this._virtualLineBuffer.position[0] = [e4, i2], this._virtualLineBuffer.index = [0], this._virtualLineDataSource.setData(this._virtualLineBuffer);
              } else if (this._transformIndex === this.length - 1) {
                let e4 = this._helpersBuffer.position[this._transformIndex - 1], i2 = t3.position;
                this._virtualLineBuffer.position[0] = [e4, i2], this._virtualLineBuffer.index = [0], this._virtualLineDataSource.setData(this._virtualLineBuffer);
              } else {
                let e4 = this._helpersBuffer.position[this._transformIndex - 1], i2 = t3.position, n2 = this._helpersBuffer.position[this._transformIndex + 1];
                this._virtualLineBuffer.position[0] = [e4, i2, n2], this._virtualLineBuffer.index = [0, 1], this._virtualLineDataSource.setData(this._virtualLineBuffer);
              }
            3 !== this._stage && 4 !== this._stage || (this.updateNode(this._transformIndex, t3), this.dispatchEvent({ type: "change", value: this.data }), this._stage = 4);
          }), __publicField(this, "_handleTransformChanged", (e3) => {
            let t3 = this._getTransformBoxState();
            4 === this._stage && (this.updateNode(this._transformIndex, t3), this._virtualLineDataSource.setData(), this.dispatchEvent({ type: "change", value: this.data }), this._stage = 3);
          }), __publicField(this, "_handleCancelEdit", (e3) => {
            3 === this._stage && (this.detachTransform(), this._stage = 2);
          }), this._engine = e2, t2.lineColor || (t2.lineColor = "rgb(200, 200, 50)"), this._options = t2;
        }
        initSpline() {
          let e2 = this._splineDataSource = new gc(), t2 = this._spline = this._engine.add(new Fx({ lineWidth: 3, color: this._options.lineColor, keepSize: true, lineJoin: "round" }));
          return t2.dataSource = e2, t2;
        }
        initVirtualLine() {
          let e2 = this._virtualLineDataSource = new gc(), t2 = this._virtualLine = this._engine.add(new Fx({ lineWidth: 2, color: this._options.lineColor, opacity: 0.2, keepSize: true, lineJoin: "round" }));
          return t2.dataSource = e2, t2;
        }
        initHelpers() {
          let e2 = this._helpersDataSource = new gc(), t2 = this._helpers = this._engine.add(new zv({ color: "rgba(0, 0, 0, 0)", mapSrc: $o("assets/images/node.png"), size: 10, uShapeType: 1 }));
          return t2.dataSource = e2, t2;
        }
        initCompeleteElement() {
          let e2 = this._completedDataSource = new gc(), t2 = this._completedElement = this._engine.add(new Fx({ lineWidth: 3, color: this._options.lineColor, keepSize: true, lineJoin: "round" }));
          t2.dataSource = e2, this._engine.event.bind(t2, "click", this._handleCompleteClick);
        }
        initObjects() {
          this.initSpline(), this.initHelpers(), this.initVirtualLine(), this.initCompeleteElement();
        }
        initEvents() {
          this._engine.event.bind("click", this._handleAddClick), this._drawedGraph.length > 0 && (this._engine.event.bind("click", this._handleCancelEdit), this._engine.event.bind(this._completedElement, "click", this._handleCompleteClick));
        }
        graphInfo(e2) {
          const t2 = new lc(this._splineBuffer.position[0], this._splineBuffer.payload);
          return t2.index = e2, { splineBuffer: this._splineBuffer, helpersBuffer: this._helpersBuffer, dataItem: t2 };
        }
        _getNodeNormal(e2) {
          if (0 === e2) {
            return Wv(jv(this._helpersBuffer.position[e2], this._helpersBuffer.position[e2 + 1]));
          }
          if (e2 === this.length - 1) {
            return Wv(jv(this._helpersBuffer.position[e2 - 1], this._helpersBuffer.position[e2]));
          }
          let t2 = this._helpersBuffer.position[e2 - 1], i2 = this._helpersBuffer.position[e2], n2 = this._helpersBuffer.position[e2 + 1], r2 = jv(t2, i2), s2 = jv(i2, n2), a2 = new ie();
          return a2.addVectors(r2, s2), Wv(a2);
        }
        addNode(e2, t2, i2) {
          this._splineBuffer.position[0].splice(e2, 0, t2), this._splineBuffer.payload.splice(e2, 0, { point: i2, position: t2, scale: 2 }), this._splineBuffer.index.push(this.length), this._splineDataSource.setData(this._splineBuffer), this._helpersBuffer.position.splice(e2, 0, t2), this._helpersBuffer.payload.splice(e2, 0, { point: i2, position: t2, scale: 2 }), this._helpersBuffer.index.push(this.length), this._helpersDataSource.setData(this._helpersBuffer);
        }
        removeNode(e2) {
          this._splineBuffer.position[0].splice(e2, 1), this._splineBuffer.payload.splice(e2, 1), this._splineBuffer.index.pop(), this._splineDataSource.setData(this._splineBuffer), this._helpersBuffer.position.splice(e2, 1), this._helpersBuffer.payload.pop(), this._helpersBuffer.index.pop(), this._helpersDataSource.setData(this._helpersBuffer);
        }
        updateNode(e2, t2) {
          let { point: i2, position: n2 } = t2;
          this._splineBuffer.position[0].splice(e2, 1, n2), this._splineBuffer.payload.splice(e2, 1, { point: i2, position: n2, scale: t2.width, angle: t2.angle[2] }), this._splineDataSource.setData(this._splineBuffer), this._helpersBuffer.position.splice(e2, 1, n2), this._helpersBuffer.payload.splice(e2, 1, { point: i2, position: n2, scale: t2.width, angle: t2.angle[2] }), this._helpersDataSource.setData(this._helpersBuffer);
        }
        overwriteNodes(e2) {
          this.clearBuffers();
          for (let t2 = 0; t2 < e2.length; t2++) {
            const i2 = e2[t2];
            this._splineBuffer.position[0].push(i2.position), this._splineBuffer.index.push(t2), this._helpersBuffer.position.push(i2.position), this._helpersBuffer.index.push(t2);
          }
          this._splineBuffer.payload = e2, this._splineDataSource.setData(this._splineBuffer), this._helpersDataSource.setData(this._helpersBuffer);
        }
        unbindEvents() {
          this._engine.event.unbind("click", this._handleAddClick), this._engine.event.unbind("click", this._handleCancelEdit), this._engine.event.unbind("mousemove", this._handleAddMove), this._engine.event.unbind(this._helpers, "click", this._handleNodeClick), this._engine.event.unbind(this._completedElement, "click", this._handleCompleteClick), this._engine.selection.transformControl.removeEventListener("objectChange", this._handleTransformChanging), this._engine.selection.transformControl.removeEventListener("mouseUp", this._handleTransformChanged);
        }
        clearBuffers() {
          this._virtualLineBuffer = { position: [[]], index: [], payload: [] }, this._splineBuffer = { position: [[]], index: [], payload: [] }, this._helpersBuffer = { position: [], index: [], payload: [] };
        }
        clearObjects() {
          this._splineDataSource.setData(), this._helpersDataSource.setData(), this._virtualLineDataSource.setData(), this._engine.requestRender();
        }
        dispose() {
          this.enabled = false, this._engine.remove(this._spline), this._engine.remove(this._helpers), this._engine.remove(this._virtualLine);
        }
        set data(e2) {
          this.overwriteNodes(e2), this._handleCancelEdit(), this._stage = 2, this._engine.event.bind(this._helpers, "click", this._handleNodeClick), this._engine.event.bind("click", this._handleCancelEdit), this.dispatchEvent({ type: "change", value: e2 }), this._engine.requestRender();
        }
        get data() {
          return this._splineBuffer.payload;
        }
        get length() {
          return this._helpersBuffer.index.length;
        }
      }, e.StaticSky = class extends fp {
        constructor() {
          super(), __publicField(this, "isStaticSky", true), __publicField(this, "_phase", "default"), __publicField(this, "_lastPhase", null), __publicField(this, "_lastWeather", null), __publicField(this, "_nightStartTime", 64800), __publicField(this, "_nightEndTime", 21600), __publicField(this, "_afternoonTime", 55800), __publicField(this, "_duskTime", 61200), __publicField(this, "_engine", null), __publicField(this, "_PMREMGenerator", null), this.time = 43200;
        }
        afterAddToEngine(e2) {
          super.afterAddToEngine(e2), this._engine = e2, this._PMREMGenerator = new cn(e2.renderer), this.loadSkyTexture();
        }
        onTimeChanged(e2) {
          e2 >= this._nightStartTime || e2 <= this._nightEndTime ? this._phase = "night" : e2 >= this._duskTime ? this._phase = "dusk" : e2 >= this._afternoonTime ? this._phase = "afternoon" : this._phase = "default", this.loadSkyTexture();
        }
        onWeatherChanged(e2) {
          this._weather = e2, this.loadSkyTexture();
        }
        loadSkyTexture() {
          if (!this._engine || this._phase === this._lastPhase && this.weather === this._lastWeather)
            return;
          let e2 = Jo(Qo(), "assets/textures/sky", this.weather, this._phase, "/" + this._phase + ".jpg");
          this.textureURL = e2, this._lastPhase = this._phase, this._lastWeather = this._weather;
        }
      }, e.TerrainMap = class extends Rt {
        constructor(e2 = {}) {
          super(), __publicField(this, "visible", true), __publicField(this, "freezeUpdate", false), __publicField(this, "_engine"), __publicField(this, "_mapView"), __publicField(this, "handleNodeCreated", (e3) => {
            this._engine && this._engine.requestRender(), e3.receiveShadow = this.tileReceiveShadow, e3.castShadow = this.tileCastShadow;
          }), __publicField(this, "handleStateChange", () => {
            this._engine && this._engine.requestRender();
          });
          let t2 = new rf();
          this.tileReceiveShadow = e2.receiveShadow || false, this.tileCastShadow = e2.castShadow || false;
          let i2 = new sf();
          i2.getUrl = e2.getTerrainUrl;
          const n2 = this._mapView = new tf(tf.HEIGHT, t2, i2, e2.overrideMaterial);
          n2.rotateX(Math.PI / 2), this.add(n2), n2.onNodeReady = this.handleStateChange, n2.onNodeCreated = this.handleNodeCreated, n2.onNodeSubdivided = this.handleStateChange, n2.children[0].receiveShadow = this.tileReceiveShadow, n2.children[0].castShadow = this.tileCastShadow;
        }
        afterAddToEngine(e2) {
          this._engine = e2;
        }
        onBeforeScenePrepareRender() {
          if (!this.visible || this.freezeUpdate)
            return;
          this._mapView.update(this._engine.rendering.camera);
        }
        get mapView() {
          return this._mapView;
        }
      }, e.TextMesh = Sc, e.TrafficLight3DTilesElement = class extends Bg {
        constructor(e2) {
          super(e2), __publicField(this, "subscribedDataTypeIds", [110, 111, 112, 113]), __publicField(this, "_tickInterval", 1e3), __publicField(this, "_typeConfigMap", { 110: { slots: [0, 0, 0], stateType: 1 }, 111: { slots: [1, 1, 1] }, 112: { slots: [4, 5] }, 113: { slots: [-1] }, xxx: { slots: [0, 0, 0, -1] }, xxx1: { slots: [0, 0, -1], stateType: 2 } }), __publicField(this, "_scaleSize", 0.1), __publicField(this, "_stateMap", /* @__PURE__ */ new Map()), __publicField(this, "_timeTableMap", /* @__PURE__ */ new Map()), __publicField(this, "_refreshObjectViewState", (e3, t2) => {
            if (this._timeTableMap.has(e3))
              t2.timeTable = this._timeTableMap.get(e3);
            else if (t2.timeTable = null, this._stateMap.has(e3)) {
              const i2 = this._stateMap.get(e3);
              t2.lightState = i2.state, t2.number = i2.number, t2.stateStartTime = i2.startAt;
            } else
              t2.lightState = null;
            t2.updateState(Date.now() / 1e3);
          });
        }
        createMeshFromGeometry(e2, t2) {
          const i2 = new qg(e2);
          i2.lightStatus = -1, i2.dataType = t2.dataType;
          const n2 = this._typeConfigMap[t2.dataType];
          return i2.slots = n2.slots, i2.stateType = n2.stateType, i2;
        }
        tickObject(e2, t2) {
          e2.updateState(t2);
        }
        onEntityShow(e2, t2) {
          this._refreshObjectViewState(e2, t2);
        }
        setLightState(e2, t2, i2 = 0) {
          if (null != t2 ? this._stateMap.set(e2, { state: t2, number: i2, startAt: Date.now() / 1e3 }) : this._stateMap.delete(e2), this._visibleIdMap.has(e2)) {
            const t3 = this._visibleIdMap.get(e2);
            this._refreshObjectViewState(e2, t3), this.engine.requestRender();
          }
        }
        setTimeTable(e2, t2) {
          if (t2 ? this._timeTableMap.set(e2, t2) : this._timeTableMap.delete(e2), this._visibleIdMap.has(e2)) {
            const t3 = this._visibleIdMap.get(e2);
            this._refreshObjectViewState(e2, t3), this.engine.requestRender();
          }
        }
        getTimeTable(e2) {
          return this._timeTableMap.get(e2);
        }
        getLightState(e2) {
          return this._stateMap.get(e2);
        }
        getRealtimeState(e2) {
          let t2 = this._visibleIdMap.get(e2);
          if (t2) {
            const i2 = this._timeTableMap.get(e2);
            if (i2)
              t2 = Yg, t2.timeTable = i2;
            else {
              const i3 = this.getLightState(e2);
              i3 && (t2 = Yg, t2.lightState = i3.state, t2.number = i3.number, t2.stateStartTime = i3.startAt);
            }
          }
          return t2 ? (t2.updateStatus(Date.now()), { lightState: t2.lightState, number: t2.number }) : null;
        }
      }, e.TransformControl = hp, e.Twin = class extends Rt {
        constructor(e2 = {}) {
          super(), __publicField(this, "engine", null), __publicField(this, "_dataProvider", null), __publicField(this, "_modelConfig", {}), __publicField(this, "_modelLoaded", true), __publicField(this, "_buffers", {}), __publicField(this, "_instances", {}), __publicField(this, "_objects", []), __publicField(this, "_objectAttributes", {}), __publicField(this, "handleBeforeRender", (e3, t2) => {
            if (!this._entityManager)
              return;
            let { buffers: i2, modelIndexMap: n2 } = this._entityManager.tick(e3, t2.time);
            if (this._buffers = i2, this._modelLoaded) {
              Object.keys(this._instances).forEach((e4) => {
                let t3 = this._instances[e4], i3 = this._filterBuffer(n2, e4);
                t3 && (t3.setBufferData(i3), t3.update());
              });
              for (let e4 = 0; e4 < this._objects.length; e4++) {
                this._objects[e4].dataSource.setData(i2);
              }
              this.onTicking && this.onTicking(i2);
            }
          }), this.options = e2, e2.modelConfig && (this.modelConfig = e2.modelConfig), this._delay = e2.delay || 2e3, this._objectAttributes = e2.objectAttributes || {}, this._dataProvider = new Ux(), this._entityManager = new Nx({ delay: this._delay });
        }
        afterAddToEngine(e2) {
          this.engine = e2, this.objects = this.options.objects || [], e2.addBeforeRenderListener(this.handleBeforeRender);
        }
        push(e2) {
          if (!e2 || 0 === e2.length)
            return;
          let t2 = this._dataProvider.provide(e2);
          if (!this._isStarted) {
            this._isStarted = true;
            const e3 = new Date().valueOf();
            this._entityManager.startTime = e3, this._entityManager.timeOffset = e3 - t2[0].time;
          }
          this._entityManager.push(t2);
        }
        _filterBuffer(e2, t2) {
          if (!e2 || !e2[t2])
            return null;
          const i2 = e2[t2], n2 = [], r2 = [], s2 = [], a2 = [], o2 = [];
          for (let l2 = 0; l2 < i2.length; l2++) {
            const e3 = i2[l2];
            n2.push(this._buffers.id[e3]), r2.push(this._buffers.translation[3 * e3], this._buffers.translation[3 * e3 + 1], this._buffers.translation[3 * e3 + 2]), s2.push(this._buffers.rotation[3 * e3], this._buffers.rotation[3 * e3 + 1], this._buffers.rotation[3 * e3 + 2]), a2.push(this._buffers.scale[3 * e3], this._buffers.scale[3 * e3 + 1], this._buffers.scale[3 * e3 + 2]), o2.push(this._buffers.modelType[e3]);
          }
          return { id: n2, translation: r2, rotation: s2, scale: a2, modelType: o2 };
        }
        loadModelAsync(e2) {
          return new Promise((t2, i2) => {
            kx.load(e2, (e3) => {
              let i3 = Fg(e3.scene, false, true);
              t2(i3);
            });
          });
        }
        modelClear() {
          this._modelConfig = {}, Object.values(this._instances).forEach((e2) => {
            this.engine.remove(e2);
          }), this._instances = {};
        }
        getCurrentBuffers() {
          return this._buffers;
        }
        get dataProvider() {
          return this._dataProvider;
        }
        get entityManager() {
          return this._entityManager;
        }
        get objectAttributes() {
          return this._objectAttributes;
        }
        set objectAttributes(e2) {
          this._objectAttributes = e2;
        }
        get objects() {
          return this._objects;
        }
        set objects(e2) {
          for (let t2 = 0; t2 < this._objects.length; t2++) {
            const e3 = this._objects[t2];
            this.engine.remove(e3);
          }
          this._objects = e2;
          for (let t2 = 0; t2 < this._objects.length; t2++) {
            const e3 = this._objects[t2];
            e3.__initInEngine || this.engine.add(e3);
            const i2 = new gc();
            i2.setAttributes(this._objectAttributes), e3.dataSource = i2;
          }
        }
        get modelConfig() {
          return this._modelConfig;
        }
        set modelConfig(e2) {
          this._modelLoaded = false;
          let t2 = Object.keys(e2), i2 = Object.values(e2).map((e3) => this.loadModelAsync(e3));
          Promise.all(i2).then((e3) => {
            this.modelClear();
            for (let i3 = 0; i3 < t2.length; i3++) {
              const n2 = t2[i3], r2 = e3[i3];
              this._modelConfig[n2] = r2, this._instances[n2] = this.engine.add(new wg(r2));
            }
            this._modelLoaded = true;
          });
        }
      }, e.UltraDynamicSky = Rm, e.Wall = class extends vc {
        constructor(e2) {
          super(), __publicField(this, "geometry"), __publicField(this, "material"), __publicField(this, "height"), __publicField(this, "color"), __publicField(this, "vertextColors"), __publicField(this, "emissive"), __publicField(this, "map"), __publicField(this, "opacity"), __publicField(this, "minOpacity"), __publicField(this, "maxOpacity"), __publicField(this, "enableAnimation"), __publicField(this, "animationSpeed"), __publicField(this, "animationTailType"), __publicField(this, "animationTailRatio"), __publicField(this, "animationTailLength"), __publicField(this, "animationIdle"), __publicField(this, "animationRatio"), __publicField(this, "animationBales"), this.parameters = e2, this.defineGeometryProxyProperties(["height"]), this.defineMaterialProxyProperties(["color", "vertexColors", "emissive", "map", "opacity", "minOpacity", "maxOpacity", "enableAnimation", "animationSpeed", "animationTailType", "animationTailRatio", "animationTailLength", "animationIdle", "animationBales", "animationRatio"]);
        }
        getDefaultParams() {
          return { height: 100 };
        }
        initObject() {
          const { height: e2, ...t2 } = this.parameters;
          this.geometry = new Pb(this.parameters);
          (this.material = new Ib(t2)).setCommonUniforms(this.engine.rendering.uniforms);
        }
        setData() {
          const e2 = this.dataSource.data;
          this.geometry.setData(e2), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = false;
        }
      }, e.WaterMaterial = d_, e.Wireframe3DTilesMaterialManager = class extends h_ {
        constructor() {
          super(), this.material = new jt({ color: 35020, wireframe: true });
        }
        getMaterialByKey(e2) {
          return this.material;
        }
        dispose() {
          this.material.dispose();
        }
      }, e.colorUtils = vh, e.geojsonUtils = oc, e.modelUtils = Ug, e.urlUtils = el, Object.defineProperties(e, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  }
});
export default require_mapvthree_umd();
/*! Bundled license information:

mapv-three/dist/mapvthree.umd.js:
  (**
     * @license
     * Copyright 2010-2022 Three.js Authors
     * SPDX-License-Identifier: MIT
     *)
  (*!
    * Proton v1.1.2
    * https://github.com/JackXie60/shader-particle-system
    * Copyright 2022-2022, JackXie60
    * Licensed under the MIT license
    * http://www.opensource.org/licenses/mit-license
    *
    *)
  (*! *****************************************************************************
    	Copyright (c) Microsoft Corporation.
    
    	Permission to use, copy, modify, and/or distribute this software for any
    	purpose with or without fee is hereby granted.
    
    	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    	PERFORMANCE OF THIS SOFTWARE.
    	***************************************************************************** *)
*/
//# sourceMappingURL=mapv-three.js.map
