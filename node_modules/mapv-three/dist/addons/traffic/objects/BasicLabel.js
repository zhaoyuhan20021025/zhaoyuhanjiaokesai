/*
 * @Author: wangchen35
 * @Date: 2021-08-07 16:54:31
 * @LastEditors: wangchen35
 * @LastEditTime: 2022-12-29 15:56:28
 * @Description: file content
 */
import {
    Texture,
    MathUtils,
    NearestFilter,
    SpriteMaterial,
    Sprite,
    Vector2,
    Color,
    MeshBasicMaterial,
    PlaneBufferGeometry,
    Mesh,
} from 'bmap-three';
import {MAP_CACHE, setLabelScale, disposeObject} from '../utils/BasicLabel';
import {TrafficObject} from './TrafficObject';

/**
 * 标签
 * ```
 * const label = new BasicLabel({
 *       scaleNum: 2,
 *       sizeAttenuation: true,
 *       center: { x: 0, y: 0 },
 *       // 画布样式
 *       style: {
 *           // 宽
 *           width: 200,
 *           // 高
 *           height: 100,
 *           // 背景图
 *           // backgroundImage: 'https://mapdata.bj.bcebos.com/images/guangzhou/q-robocop-info-mini@3x.png',
 *           // 上内边距
 *           paddingTop: 42,
 *           // 左内边距
 *           paddingLeft: 42,
 *           // 背景颜色
 *           backgroundColor: '#333',
 *           // 边框颜色
 *           borderColor: '#fff',
 *           // 边框宽度
 *           borderWidth: 2
 *       },
 *       content: [
 *           // 内容配置
 *           {
 *               // 宽
 *               width: 30,
 *               // 高
 *               height: 30,
 *               // 背景色
 *               backgroundColor: 'green',
 *               // 文字列表
 *               textList: [
 *                   {
 *                       text: '测试',
 *                       fontSize: 12,
 *                       color: '#E2EBFA',
 *                       position: [8, 3],
 *                       textAlign: 'left',
 *                       fontFamily: 'FZLTZHK--GBK1-0'
 *                   },
 *                   {
 *                       text: '123',
 *                       fontSize: 12,
 *                       color: '#E2EBFA',
 *                       position: [8, 20],
 *                       textAlign: 'left',
 *                       fontFamily: 'HyperspaceRace-Bold'
 *                   }
 *               ]
 *           },
 *           {
 *               // 宽
 *               width: 30,
 *               // 高
 *               height: 30,
 *               // 背景图
 *               backgroundImage: 'https://mapdata.bj.bcebos.com/images/yizhuang/cross-circle.png',
 *               // 文字列表
 *               textList: [
 *                   {
 *                       // iconfont编号
 *                       icon: '&#xe64c;',
 *                       fontSize: 12,
 *                       color: '#E2EBFA',
 *                       position: [8, 3],
 *                       textAlign: 'left',
 *                       // iconfont字体
 *                       fontFamily: 'NewIconFont'
 *                   }
 *               ]
 *           },
 *       ]
 *   });
 * ```
 */
export class BasicLabel extends TrafficObject {
    /** @private */ _point;
    /** @private */ _position;
    /** @private */ _visible;
    /** @private */ name;
    /** @private */ needTrans;
    /** @private */ matrixWorldNeedsUpdate;
    /** @private */ mainView;
    /** @private */ texture;
    /** @private */ sprite;
    /** @private */ scaleNum;
    /** @private */ center;
    /** @private */ offset;
    /** @private */ sizeAttenuation;
    /** @private */ constructionConfig;
    /** @private */ offset;
    /** @private */ factor;
    /** @private */ animateId;
    /** @private */ animationCanvas;
    /** @private */ drawCanvas;
    /** @private */ style;

    /** 热区列表 */ activeAreaList
    /** 是否始终朝向屏幕 */ alwaysToScreen
    /** 当前模板放大倍数 */ size
    /** 标签类型 */ labelType
    /** 额外附加属性 */ extraProps
    /** 引擎核心 */ engine
    constructor(args) {
        /**
         * @ignore
         */
        super();
        this.name = args.name || '';
        this.scaleNum = args.scaleNum || 0.3;
        this.center = args.center || {x: 0.12, y: 0};
        this.offset = args.offset || {x: 0, y: 0};
        this.sizeAttenuation = args.sizeAttenuation || false;
        this.constructionConfig = args.constructionConfig || {};
        this.labelType = args.labelType || 'sprite';
        this.alwaysToScreen = args.alwaysToScreen || false;

        let setArgs = args;
        if (this.labelType === 'mesh' || this.sizeAttenuation) {
            setArgs = setLabelScale(this.scaleNum, args);
        }
        this.style = setArgs.style;
        this.drawCanvas = document.createElement('canvas');
        this.animationCanvas = document.createElement('canvas');
        this.mainView = null;
        this.sprite = null;
        this.texture = null;
        this.animateId = null;
        this.size = 20;
        this.activeAreaList = [];
        this.extraProps = {args};
        if (!setArgs.style) {
            console.warn('请正确设置BasicLabel的style');
            return;
        }
        this.init(setArgs).then(() => {
            this.matrixWorldNeedsUpdate = true;
        });
        if (this.labelType === 'mesh') {
            this.matrixWorldNeedsUpdate = true;
            this._visible = true;
            Object.defineProperty(this, 'visible', {
                get() {
                    return this._visible;
                },
                set(value) {
                    if (this._visible !== value && value) {
                        this.matrixWorldNeedsUpdate = true;
                    }
                    this._visible = value;
                },
            });
        }
    }
    /**
     * @ignore
     * @param args
     */
    async init(args = {}) {
        const {height, width} = this.style;
        this.mainView = document.createElement('canvas');
        const config = await BasicLabel.initBackGround(this.style, this.mainView);
        this.drawCanvas.width = this.animationCanvas.width = config.width;
        this.drawCanvas.height = this.animationCanvas.height = config.height;
        this.factor = config.factor;

        this.texture = new Texture(this.mainView);
        // 纹理缩放方式
        this.texture.minFilter = NearestFilter;
        // 纹理缩放方式
        this.texture.magFilter = NearestFilter;
        this.texture.anisotropy = this.constructionConfig.anisotropy || 1;
        this.texture.needsUpdate = true;

        if (this.labelType === 'sprite') {
            const spriteMaterial = new SpriteMaterial({
                depthTest: true,
                depthWrite: false,
                transparent: true,
                ...this.constructionConfig,
            });

            this.sprite = new Sprite(spriteMaterial);
            this.sprite.material.map = this.texture;
            const scaleResult = this.sizeAttenuation ? 1 : this.scaleNum;
            this.sprite.scale.set(
                (width / 100) * scaleResult,
                (height / 100) * scaleResult,
                (height / 100) * scaleResult
            );
            const {x, y} = this.center;
            this.sprite.center = new Vector2(x, y);
        } else {
            this.sprite = BasicLabel.getRectangle(width, height, this.texture, this.constructionConfig);
            this.sprite.position.x = this.offset.x || 0;
            this.sprite.position.y = this.offset.y || 0;
            this.sprite.position.z = this.offset.z || 0;
        }
        this.sprite && this.add(this.sprite);
        this.dispatchEvent({
            type: 'loaded',
            label: this,
        });
        if (args.content) {
            await this.drawContent(args.content, true);
        }
    }
    /**
     * 重新绘制标签内容
     * @param contextList
     */
    async drawContent(contextList, setScaleStatus = false) {
        if (!setScaleStatus && (this.labelType === 'mesh' || this.sizeAttenuation)) {
            contextList = setLabelScale(this.scaleNum, {
                content: contextList,
            }).content;
        }
        if (this.activeAreaList.length) {
            this.activeAreaList.forEach(area => {
                area.material.map && area.material.map.dispose();
                area.material.dispose();
                this.remove(area);
            });
            this.activeAreaList = [];
        }
        const drawCtx = this.drawCanvas.getContext('2d');
        const {width: oriWidth, height: oriHeight} = this.drawCanvas;

        drawCtx.clearRect(0, 0, oriWidth, oriHeight);
        drawCtx.drawImage(this.mainView, 0, 0, oriWidth, oriHeight);

        const activeAreaList = await BasicLabel.renderContent(this.style, contextList, this.drawCanvas, this.factor);
        activeAreaList.length && activeAreaList.forEach(activeArea => {
            this.add(activeArea);
            activeArea.addEventListener('mouseup', () => {
                this.dispatchEvent({
                    type: 'itemClick',
                    id: activeArea.customId,
                });
            });
        });

        if (this.texture && this.sprite) {
            this.texture.image = this.drawCanvas;
            this.texture.needsUpdate = true;
            this.sprite.material.map = this.texture;
        }

        this.dispatchEvent({
            type: 'contentLoaded',
            label: this,
        });
    }
    /**
     * @ignore
     * @param type
     * @param time
     * @param range
     */
    startAnimation(type, time, range = 60) {
        const {xScale, yScale} = this.factor;
        this.animateId && cancelAnimationFrame(this.animateId);
        const animationCtx = this.animationCanvas.getContext('2d');
        const {width: oriWidth, height: oriHeight} = this.drawCanvas;
        let drawWidth = 0;
        switch (type) {
            case 'leftToRight':
                animationCtx.clearRect(0, 0, oriWidth, oriHeight);
                setInterval(
                    () => {
                        animationCtx.drawImage(
                            this.drawCanvas,
                            drawWidth,
                            0,
                            oriWidth / range,
                            oriHeight,
                            drawWidth,
                            0,
                            oriWidth / range,
                            oriHeight
                        );
                        if (this.texture && this.sprite) {
                            this.texture.image = this.animationCanvas;
                            this.texture.needsUpdate = true;
                            this.sprite.material.map = this.texture;
                        }
                        if (drawWidth >= oriWidth) {
                            cancelAnimationFrame(this.animateId);
                            this.animateId = null;
                            return;
                        }
                        drawWidth += oriWidth / range;
                    },
                    time / range,
                    id => {
                        this.animateId = id;
                    }
                );
                break;
            default:
                break;
        }
    }
    /**
     * @ignore
     * @param raycaster
     * @param intersects
     * @returns
     */
    raycast(raycaster, intersects) {
        const _point = raycaster.intersectObject(this.sprite);
        if (_point.length) {
            intersects.push({object: this, point: _point[0], distance: _point[0].distance});
        } else {
            return;
        }
        return intersects;
    }
    /**
     *
     * 内存释放
     *
     */
    dispose() {
        this.children.forEach(child => {
            disposeObject(child);
        });
        this.sprite = null;
        this.texture = null;
        this.drawCanvas = null;
        this.animationCanvas = null;
        this.mainView = null;
        this.activeAreaList = [];
        // this.sprite && this.sprite.material && this.sprite.material.map && this.sprite.material.map.dispose();
        // this.texture && this.texture.dispose();
        // this.sprite && this.sprite.material.dispose();
        // if (this.activeAreaList.length) {
        //     this.activeAreaList.forEach((area) => {
        //         area.material.map && area.material.map.dispose();
        //         area.material.dispose();
        //         this.remove(area);
        //     });
        //     this.activeAreaList = [];
        // }
    }
    /**
     * @ignore
     * @param camera
     */
    faceToCamera(camera) {
        const theta = camera.rotation.z;
        if (this.sprite && this.labelType === 'mesh') {
            if (this.alwaysToScreen) {
                this.sprite.rotation.set(camera.rotation.x, 0, camera.rotation.z, 'ZXY');
            } else {
                !this.sprite.hasRotateX && this.sprite.rotateX(Math.PI * 0.5);
                this.sprite.hasRotateX = true;
                this.sprite.rotation.y = theta;
            }
            this.sprite.position.x = Math.cos(theta) * this.offset.x;
            this.sprite.position.y = Math.sin(theta) * this.offset.x;
        }
    }
    /**
     * @private
     * @param {*} style
     * @param {*} canvas
     * @returns
     */
    static async initBackGround(style, canvas) {
        const {
            height: originHeight,
            width: originWidth,
            backgroundImage,
            borderRadius,
            borderColor,
            borderWidth,
            backgroundColor,
        } = style;
        const width = originWidth;
        const height = originHeight;
        const ctx = canvas.getContext('2d');

        const ptWidth = MathUtils.ceilPowerOfTwo(width);
        // const ptHeight = MathUtils.ceilPowerOfTwo(height);
        const config = {
            width: ptWidth,
            height: ptWidth * (height / width),
            factor: {
                xScale: ptWidth / width,
                yScale: ptWidth / width,
            },
        };

        canvas.width = config.width;
        canvas.height = config.height;

        const {xScale, yScale} = config.factor;

        if (backgroundImage) {
            const img = await BasicLabel.loadImg(backgroundImage, '');
            ctx.drawImage(img, 0, 0, width * xScale, height * yScale);
        } else if (borderColor || backgroundColor) {
            ctx.strokeStyle = borderColor;
            ctx.fillStyle = backgroundColor;
            ctx.lineWidth = borderWidth ? borderWidth * xScale : 1 * xScale;
            BasicLabel.roundRect(
                ctx,
                ctx.lineWidth * xScale,
                ctx.lineWidth * yScale,
                (width - ctx.lineWidth * 2) * xScale,
                (height - ctx.lineWidth * 2) * yScale,
                borderRadius ? borderRadius * xScale : 0
            );

            backgroundColor && ctx.fill();
            borderColor && ctx.stroke();
        }

        return config;
    }
    /**
     * @private
     * 绘制内容
     * @param {*} style
     * @param {*} contextList
     * @param {*} canvas
     * @param {*} factor
     * @returns
     */
    static async renderContent(style, contextList, canvas, factor) {
        const drawCtx = canvas.getContext('2d');
        const {width: oriWidth, height: oriHeight} = canvas;

        const {paddingTop, paddingLeft} = style;
        let lineHeight = 0;
        let MaxLineHeight = 0;
        let baseHeight = 0;
        let xGap = 0;
        const {xScale, yScale} = factor;
        const left = paddingLeft ? paddingLeft * xScale : 0;
        const top = paddingTop ? paddingTop * yScale : 0;

        const start = [left, top];
        const activeAreaList = [];
        for (let index = 0; index < contextList.length; index++) {
            const context = contextList[index];

            const {
                width,
                height,
                textList,
                marginRight,
                marginBottom,
                backgroundImage,
                borderRadius,
                borderColor,
                borderWidth,
                backgroundColor,
                position,
                id,
                activeInfo = {},
            } = context;

            if (position) {
                const [x, y] = position;
                start[0] = left + x * xScale;
                start[1] = top + y * yScale;
                lineHeight = 0;
                MaxLineHeight = 0;
                baseHeight = 0;
                xGap = 0;
            }

            if (width && height) {
                if (start[0] + width * xScale > oriWidth) {
                    baseHeight += lineHeight;
                    if (baseHeight + height * yScale <= MaxLineHeight) {
                        start[0] = xGap;
                        start[1] += lineHeight;
                    } else {
                        start[0] = paddingLeft ? paddingLeft * xScale : 0;
                        start[1] += lineHeight;
                        MaxLineHeight = 0;
                        xGap = 0;
                    }
                }

                if (backgroundImage) {
                    try {
                        const img = await BasicLabel.loadImg(backgroundImage, '');
                        drawCtx.drawImage(img, start[0], start[1], width * xScale, height * yScale);
                    } catch (error) {
                        console.log(error);
                    }
                } else if (backgroundColor) {
                    drawCtx.strokeStyle = borderColor;
                    drawCtx.fillStyle = backgroundColor;
                    drawCtx.lineWidth = borderWidth ? borderWidth * xScale : 1 * xScale;
                    BasicLabel.roundRect(
                        drawCtx,
                        start[0] + drawCtx.lineWidth * xScale,
                        start[1] + drawCtx.lineWidth * xScale,
                        (width - drawCtx.lineWidth * 2) * xScale,
                        (height - drawCtx.lineWidth * 2) * yScale,
                        borderRadius ? borderRadius * xScale : 0
                    );

                    backgroundColor && drawCtx.fill();
                    borderColor && drawCtx.stroke();
                }

                textList
                    && textList.forEach(textInfo => {
                        const [textX, textY] = textInfo.position;
                        const textPos = [start[0] + textX * xScale, start[1] + textY * yScale];
                        BasicLabel.drawText(drawCtx, textInfo, factor, textPos);
                    });

                const centerX = start[0] === (paddingLeft ? paddingLeft * xScale : 0) * xScale ? -0.16 : -1.3;
                const centerY = -(oriHeight - start[1] - 25 * yScale) * (2.05 / (107 * yScale)) + 0.1;

                if (id) {
                    const {
                        position,
                        style = {
                            width: 5,
                            height: 0.95,
                        },
                    } = activeInfo;
                    const activeArea = BasicLabel.addActiveArea(position || {x: centerX, y: centerY}, style);
                    activeArea.customId = id;
                    activeAreaList.push(activeArea);
                }

                start[0] += (width + (marginRight || 0)) * xScale;
                lineHeight = (height + (marginBottom || 0)) * yScale;
                if (lineHeight > MaxLineHeight) {
                    MaxLineHeight = lineHeight;
                    xGap = start[0];
                }
            } else {
                textList
                    && textList.forEach(textInfo => {
                        const [textX, textY] = textInfo.position;
                        const textPos = [start[0] + textX * xScale, start[1] + textY * yScale];
                        BasicLabel.drawText(drawCtx, textInfo, factor, textPos);
                    });
            }
        }

        return activeAreaList;
    }
    /**
     * @ignore
     * @param width
     * @param height
     * @param texture
     * @returns
     */
    static getRectangle(width, height, texture, config = {}) {
        const material = new MeshBasicMaterial({
            map: texture,
            transparent: true,
            fog: true,
            depthWrite: false,
            ...config,
        });
        if (material.map) {
            material.map.needsUpdate = true;
        }
        material.transparent = true;
        const setWidth = (width * 0.01).toFixed(2);
        const setHeight = (height * 0.01).toFixed(2);
        const geometry = new PlaneBufferGeometry(Number(setWidth), Number(setHeight), 1, 1);
        const mesh = new Mesh(geometry, material);
        mesh.setWidth = setWidth;
        mesh.setHeight = setHeight;
        return mesh;
    }
    /**
     * @ignore
     * @param url
     * @param resourcePath
     * @returns
     */
    static loadImg(url, resourcePath = '') {
        if (MAP_CACHE[resourcePath + url]) {
            return new Promise(resolve => {
                resolve(MAP_CACHE[resourcePath + url]);
            });
        }
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = resourcePath + url;
        return new Promise((resolve, reject) => {
            img.addEventListener('load', () => {
                MAP_CACHE[resourcePath + url] = img;
                resolve(img);
            });
            img.onerror = err => {
                reject(err);
            };
        });
    }
    /**
     * @ignore
     * @param ctx
     * @param content
     * @param factor
     * @param position
     * @returns
     */
    static drawText(
        ctx,
        content,
        factor,
        position
    ) {
        const {xScale} = factor;
        const [x, y] = position;
        const {text, fontSize, fontFamily, color, textAlign, icon} = content;
        let drawText;
        if (!text && typeof text !== 'number' && !icon) {
            return;
        }
        if (text && icon) {
            console.warn('BasicLabel Warning：text和icon不要同时设置');
            return;
        }
        drawText = text;
        ctx.font = `${fontSize * xScale}px ${fontFamily}`;
        ctx.fillStyle = color;
        ctx.textAlign = textAlign || 'left';
        ctx.textBaseline = 'top';

        if (icon) {
            let iconStr = icon;
            if (icon.indexOf('&amp;') !== -1) {
                iconStr = icon.replace('&amp;', '&');
            }
            if (icon.indexOf('&amp') !== -1) {
                iconStr = icon.replace('&amp', '&');
            }
            // drawText = (function() {
            //     eval('("' + `${iconStr}`.replace('&#x', '\\u').replace(';', '') + '")');
            // }());
            drawText = new Function('return ("' + `${iconStr}`.replace('&#x', '\\u').replace(';', '') + '")')();
        }
        const textWidth = ctx.measureText(drawText).width;
        ctx.fillText(drawText, x, y);
    }
    /**
     * @ignore
     * @param position
     * @param size
     * @returns
     */
    static addActiveArea(position, size) {
        const {width, height} = size;
        const {x, y} = position;
        const spriteMaterial = new SpriteMaterial({
            depthTest: true,
            depthWrite: false,
            transparent: true,
            sizeAttenuation: true,
            opacity: 0,
        });
        const material = spriteMaterial;

        const sprite = new Sprite(material);
        // console.log(this.factor);
        sprite.scale.set(width, height, 1);
        // sprite.position.set(, 100, 0);
        sprite.material.color = new Color('#58d2d4');
        sprite.center.set(x, y);
        // sprite.position.set(, 0);
        return sprite;
    }

    /**
     *
     * 利用canvas绘制矩形框
     * @param {Object} ctx canvasContainer
     * @param {number} x 左侧开始位置
     * @param {number} y 上侧开始位置
     * @param {number} w 宽度
     * @param {number} h 高度
     * @param {number} r 圆角半径
     *
     */
    static roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    /**
     * @ignore
     * @description: 基于requestAnimationFrame的setInterval
     * @param {*} cb 执行函数
     * @param {*} range 执行间隔
     * @return {*} requestAnimationFrame
     */

    static setInterval(cb, range, setCallback) {
        // 实现setInterval功能
        const now = Date.now;
        let startTime = now();
        let endTime = startTime;
        let interval;
        const loop = () => {
            interval = requestAnimationFrame(loop);
            endTime = now();
            setCallback(interval);
            if (endTime - startTime > range) {
                startTime = now();
                endTime = startTime;
                cb(interval);
            }
        };
        interval = requestAnimationFrame(loop);

        return interval;
    }
}
