/**
 * @file 模型类
 *
 */
import {
    Object3D,
    Color,
    Vector3,
    AnimationMixer,
    AnimationUtils,
    LoopOnce,
    Box3,
    BoxBufferGeometry,
    Mesh,
    MeshBasicMaterial,
    Skeleton,
    LinearEncoding,
    sRGBEncoding,
} from 'bmap-three';
import * as Utils from '../utils/index';
import {getColor, getVector3} from '../utils/MapMath';
// import {TextSprite} from './Label';
import {clone as skeletonClone} from 'bmap-three/examples/jsm/utils/SkeletonUtils.js';
import {TrafficObject} from './TrafficObject';

/**
 * 统一作为模型的基类
 * @param { Object } args 参数
 * @param { number } [args.rotation=[0,0,0]] [x,y,z],绕各坐标轴的旋转角，弧度制，正北方向为0，右手坐标系，默认值[0,0,0]
 * @param { number } [args.scale=[1,1,1]] [x,y,z],缩放比例，默认值[1,1,1]
 * @param { number } [args.speed=0.0] 速度，m/s, 标量，默认值0.0
 * @param {string} [args.name] 名字， 默认值 空
 * @param {any} [args.color] 颜色，默认值new THREE.Color(1.0, 1.0, 1.0), 可以接受0xff0000,"rgb(255, 0, 0)",
 * "rgb(100%, 0%, 0%)",'skyblue',"hsl(0, 100%, 50%)"等格式
 * @param {boolean} [args.colorChangable] 颜色是否可变，默认值true
 * @param {boolean} [args.movable] 位置是否可变，默认值true
 * @param {string} [args.modelType] 模型类型，轿车，公交车，自行车等，默认值"car"，可选参数（car,bus,truck,bicycle,pedestrian,traffic_cone）,
 * 如果是自定义的模型，可以自己命名，然后配合modelUrl使用
 * @param {string} [args.modelUrl] 模型链接地址，目前支持gltf格式数据，默认值 null，如果是自定义模型类型，该值必须有
 * @param {Object} [args.text] 文字，可以在模型上添加文字，默认为 null
 * @param {Object} [args.labelOffset] 注记偏移量，默认值THREE.Vector3(0, 0, 1.0),可以接受[x,y,z]或者{x:,y:,z:}或者new THREE.Vector3()
 * @param {Object} [label] 注记几何体，{@link Label}
 * @param {string} [args.encoding] 编码规则 默认-1, 0 为LinearEncoding 线性;1为 sRGBEncoding 非线性
 */
export class DynamicModel extends TrafficObject {
    constructor(args = {}) {
        super();
        // 航向角，弧度制，正北方向为0，右手坐标系
        this._rotation = getVector3(args.rotation);
        this._scale = args.scale || new Vector3(1, 1, 1);
        // 速度，m/s
        this.speed = args.speed || 0.0;
        // 名字
        this.name = args.name || '';
        this._geometryType = 'dynamicmodel';
        this.color = args.color ? new Color(args.color) : null;
        this.colorChangable = args.colorChangable === undefined ? true : args.colorChangable;
        this.movable = args.movable === undefined ? true : args.movable;
        // 透明度
        this.opacity = args.opacity || null;
        // 模型类型，轿车，公交车，自行车等，可选参数（car,bus,truck,bicycle,pedestrian,traffic_cone）
        if (args.modelType) {
            this.modelType = args.modelType.toLowerCase() || 'pedestrian';
        }
        this.modelUrl = args.modelUrl || null;
        this.models = [];
        this.text = args.text || null;
        this.labelOffset = getVector3(args.labelOffset, 1.0);
        this.label = null;
        this.loaded = false;
        this.onLoad = args.onLoad || null;
        this.dynamicType = args.dynamicType || 'dynamic';
        this.animations = null;
        this.mixer = null;
        this.boundingBoxHelper = args.boxHelper || false;
        this.animationAction = [];
        // 是否展示，用于记录策略上的显隐
        this._display = true;
        // 是否开启LOD策略
        this.enableLOD = true;
        // 最小像素占比
        this.minPixel = 64;
        // encoding规则  LinearEncoding 0   sRGBEncoding 1
        this.encoding = args.encoding || 1;
        // 接收阴影
        this.isReceiveShadow = args.isReceiveShadow || false;
        // 产生阴影
        this.iScastShadow = args.iScastShadow || false;
        this.init();
    }
    /**
     * 初始化
     */
    init() {
        this.initModel();
        // this.initLabel();
        this.renderOrder = 3;
        this.rotation.set(this._rotation.x, this._rotation.y, this._rotation.z);
        this.scale.copy(getVector3(this._scale));
    }
    initModel() {
        const that = this;
        if (that.modelType) {
            const key = that.modelType.toUpperCase();
            if (Utils.MODELS[key]) {
                this.loaded = true;
                this.setMeshs(this.dynamicType, Utils.MODELS[key]);
            } else {
                if (!that.modelUrl) {
                    console.log('未使用给定的模型类型，需要输入modelUrl参数');
                    return;
                }
                const url = that.modelUrl;
                Utils.loadDynamicGLTFModel(url, gltf => {
                    if (!Utils.MODELS[key]) {
                        Utils.MODELS[key] = gltf;
                    }
                    this.loaded = true;
                    this.setMeshs(this.dynamicType, gltf);
                });
            }
        } else {
            Utils.loadDynamicGLTFModel(that.modelUrl, gltf => {
                // MODELS[key] = mesh;
                that.loaded = true;
                this.setMeshs(this.dynamicType, gltf);
            });
        }
    }
    /**
     *
     * @param {Object} meshs 赋值样式
     */
    setMeshs(type, meshs) {
        const that = this;
        let clonedScene = null;
        if (type === 'dynamic') {
            clonedScene = skeletonClone(meshs.scene);
        } else {
            clonedScene = meshs.scene.clone();
        }
        clonedScene.updateMatrixWorld();
        clonedScene.isClone = true;
        clonedScene.traverse(function (child) {
            if (child.isMesh || child.isLine || child.isPoints) {
                that.models.push(child);
                // if (child.isMesh) {
                //     child.geometry.boundsTree = new MeshBVH(child.geometry, {maxDepth: 20});
                // }
                if (that.colorChangable) {
                    child.material = child.material.clone();
                }
                if (child.material && that.color) {
                    child.material.color.copy(that.color);
                }
                if (child.material && that.opacity) {
                    child.material.transparent = child.material.transparent || that.opacity < 1.0;
                    child.material.opacity = that.opacity;
                }
                that.setEncoding(child, that.encoding);
                child.receiveShadow = that.isReceiveShadow;
                child.castShadow = that.iScastShadow;
                if (child.geometry) {
                    if (!child.geometry.boundingBox) {
                        child.geometry.computeBoundingBox();
                    }
                    child.updateMatrixWorld();
                    const box = Utils.computeTransformedBoundingBox(child.geometry.boundingBox, child.matrixWorld);
                    if (!that.boundingBox) {
                        that.boundingBox = box;
                    } else {
                        that.boundingBox = that.boundingBox.union(box);
                    }
                }
            }
        });
        // this.boundingBox = Utils.computeTransformedBoundingBox(this.boundingBox, clonedScene.matrixWorld);
        this.animations = meshs.animations;
        if (this.mixer === null) {
            this.mixer = new AnimationMixer(clonedScene);
        }
        if (type === 'dynamic') {
            // 所有的动画 播放
            this.animations.forEach(animation => {
                that.mixer.clipAction(animation).play();
            });
        } else {
            // 裁切动画
            if (this.animations.length > 0) {
                for (let index = 0; index < this.animations.length; index++) {
                    this.animationAction[index] = this.mixer.clipAction(this.animations[index]);
                }
                // this.animationAction[0].stop();
            }
        }
        if (this.boundingBoxHelper) {
            const box = Utils.computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);
            const geometry = new BoxBufferGeometry(
                box.max.x - box.min.x,
                box.max.y - box.min.y,
                box.max.z - box.min.z,
                1,
                1,
                1
            );
            const boundingBoxHelper = new Mesh(geometry, new MeshBasicMaterial({color: 'red', wireframe: true}));
            this.add(boundingBoxHelper);
        }
        that.add(clonedScene);
        if (that.loaded && that.onLoad) {
            that.onLoad();
        }
        if (that.loaded && that.onLoadAnimations) {
            that.onLoadAnimations();
        }
    }
    /**
     *
     * 修改编码值
     *
     * @param {Object} mesh 几何
     * @param {string} encoding 编码值 encoding规则  LinearEncoding 0   sRGBEncoding 1
     */
    setEncoding(mesh, encoding) {
        if (encoding > 0) {
            if (mesh.material.map) {
                mesh.material.map.encoding = encoding === 1 ? LinearEncoding : sRGBEncoding;
            }
            if (mesh.material.emissiveMap) {
                mesh.material.emissiveMap.encoding = encoding === 1 ? LinearEncoding : sRGBEncoding;
            }
        }
    }
    stop() {
        if (this.dynamicType === 'dynamic') {
            this.animations.forEach(animation => {
                this.mixer.clipAction(animation).stop();
            });
        }
    }
    play() {
        if (this.dynamicType === 'dynamic') {
            this.animations.forEach(animation => {
                this.mixer.clipAction(animation).play();
            });
        }
    }
    // /**
    //  * 初始化标签
    //  */
    // initLabel() {
    //     if (this.text) {
    //         this.label = new TextSprite(this.text);
    //         this.label.position.copy(this.labelOffset);
    //         this.add(this.label);
    //     }
    // }
    // /**
    //  *
    //  * 显示标签
    //  */
    // showLabel() {
    //     if (this.label) {
    //         this.label.visible = true;
    //     }
    // }
    // /**
    //  * 隐藏标签
    //  */
    // hideLabel() {
    //     if (this.label) {
    //         this.label.visible = false;
    //     }
    // }
    /**
     * 改变模型类型
     * @param {string} mt 模型类型
     *
     */
    setModelType(mt) {
        mt = mt.toLowerCase();
        if (mt === this.modelType) {
            return;
        }
        this.dispose();
        this.modelType = mt;
        this.initModel();
    }
    /**
     * 改变标注
     * @param {string} text 文字
     */
    setText(text) {
        if (text === this.text) {
            return;
        }
        this.text = text;
        if (this.label) {
            this.label.setText(text);
        } else {
            this.initLabel();
        }
    }
    /**
     * 设置标注的偏移量
     * @param {Object} lo 偏移
     */
    setLabelOffset(lo) {
        lo = getVector3(lo);
        this.labelOffset.copy(lo);
        if (this.label) {
            this.label.position.copy(this.labelOffset);
        }
    }
    /**
     * 修改模型的颜色
     * @param {*} color 颜色
     */
    setColor(color) {
        color = getColor(color);
        if (!this.color) {
            this.color = color;
        } else if (this.color.equals(color)) {
            return;
        } else {
            this.color.copy(color);
        }
        if (this.models && this.models.length) {
            for (let ii = 0; ii < this.models.length; ii++) {
                this.models[ii].material.color.copy(this.color);
                this.models[ii].material.needsUpdate = true;
            }
        }
    }

    /**
     * 修改模型的颜色
     * @param {*} name  名称
     * @param {*} color 颜色
     */
    setNameColor(name, color) {
        color = getColor(color);
        if (!this.color) {
            this.color = color;
        } else if (this.color.equals(color)) {
            return;
        } else {
            this.color.copy(color);
        }

        if (this.children && this.children.length) {
            const model = this.getObjectByName(name);
            if (model) {
                model.material.color.copy(this.color);
                model.material.needsUpdate = true;
            }
        }
    }

    /**
     * 修改模型的可见性
     * @param {boolean} visible 颜色
     */
    setVisible(visible) {
        if (this.models && this.models.length) {
            this.visible = visible;
        }
        if (this.label) {
            this.label.visible = visible;
        }
    }
    // 获取世界坐标系下的最小包围盒
    getBoundingBoxWorld() {
        this.updateMatrixWorld(true);
        if (!this.boundingBox) {
            for (let ii = 0; ii < this.models.length; ii++) {
                this.models[ii].geometry.computeBoundingBox();
                if (!this.boundingBox) {
                    this.boundingBox = this.models[ii].geometry.boundingBox.clone();
                } else {
                    this.boundingBox.union(this.models[ii].geometry.boundingBox);
                }
            }
        }
        let box = this.boundingBox;
        let transform = this.matrixWorld;
        let tBox = Utils.computeTransformedBoundingBox(box, transform);
        return tBox;
    }
    /**
     *
     * 获取采集动画
     *
     * @param {number} index 第几个动画
     * @param {*} start 开始时间轴
     * @param {*} end 结速时间轴
     * @param {*} fps 帧数
     */
    setFrameAction(index, start, end, fps) {
        if (this.animationAction.length > index) {
            this.animationAction[index].stop();
            this.animationAction[index] = null;
            if (this.animations.length > 0) {
                this.animationAction[index] = this.mixer.clipAction(
                    AnimationUtils.subclip(
                        this.animations[index],
                        this.animations[index].name + index + start + end,
                        start,
                        end,
                        fps
                    )
                );
            }
            this.animationAction[index].setLoop(LoopOnce);
            this.animationAction[index].clampWhenFinished = true;
            this.animationAction[index].enable = true;
            this.animationAction[index].stop();
            this.animationAction[index].play();
        }
    }

    onBeforeRender() {
        this._visible = this.visible;
        this.visible = this.visible && this._display;
    }

    onAfterRender() {
        this.visible = this._visible;
    }

    raycast(raycaster, intersects) {
        const tmpIntersects = [];
        if (this.boundingBox) {
            const _Box = new Box3();
            _Box.copy(this.boundingBox);
            this.updateMatrixWorld();
            _Box.applyMatrix4(this.matrixWorld);
            const _isIntersect = raycaster.ray.intersectsBox(_Box);
            if (!_isIntersect) {
                return;
            } else {
                tmpIntersects.push({
                    object: this,
                    point: _Box.getCenter(new Vector3()),
                    distance: raycaster.ray.origin.distanceTo(_Box.getCenter(new Vector3())),
                });
            }
        }
        for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            if (child.visible) {
                child.raycast(raycaster, tmpIntersects, true);
            }
        }
        // TODO: remove this once the bug has been fixed
        for (let i = 0; i < tmpIntersects.length; i++) {
            const I = tmpIntersects[i];
            I.distance = raycaster.ray.origin.distanceTo(I.point);
        }
        tmpIntersects.sort((a, b) => {
            return a.distance - b.distance;
        });
        if (tmpIntersects.length) {
            intersects.push({
                object: this,
                point: tmpIntersects[0].point,
                distance: tmpIntersects[0].distance,
                target: tmpIntersects[0].object,
            });
            return [
                {
                    object: this,
                    point: tmpIntersects[0].point,
                    distance: tmpIntersects[0].distance,
                    target: tmpIntersects[0].object,
                },
            ];
        }
    }
    /**
     * 释放内存
     */
    dispose() {
        if (this.children && this.children.length) {
            for (let ii = this.children.length - 1; ii > -1; ii--) {
                if (this.children[ii].isClone) {
                    if (
                        this.children[ii].isMesh
                        || this.children[ii].isSkinnedMesh
                        || this.children[ii].isLine
                        || this.children[ii].isPoints
                        || this.children[ii].isSprite
                    ) {
                        // this.children[ii].geometry.dispose();
                        if (this.colorChangable && this.children[ii].material) {
                            this.children[ii].material.dispose();
                        }
                    } else {
                        // if (this.children[ii].dispose) {
                        //     this.children[ii].dispose();
                        // } else {
                        this.children[ii].traverse(child => {
                            if (this.colorChangable && child.material) {
                                child.material.dispose();
                                child.material.map && child.material.map.dispose();
                            }
                        });
                        // }
                    }

                    if (this.children[ii] instanceof Skeleton) {
                        this.children[ii].bones = [];
                    }
                } else {
                    Utils.disposeObject(this.children[ii]);
                }
                this.children[ii].children = [];
                this.remove(this.children[ii]);
            }
            this.children = [];
        }
        if (this.label) {
            this.label.dispose();
            this.remove(this.label);
        }
        this.models = [];
        this.label = null;
        if (this.mixer) {
            this.mixer.stopAllAction();
            // this.mixer.uncacheRoot();
            this.mixer.uncacheAction();
        }
        this.mixer = null;
        this.animations = null;
        this.dispatchEvent({type: 'dispose'});
    }
}
