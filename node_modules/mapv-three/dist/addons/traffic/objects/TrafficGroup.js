/*
 * @Author: wangchen35
 * @Date: 2021-08-07 16:54:31
 * @LastEditors: wangchen35
 * @LastEditTime: 2023-01-12 17:33:02
 * @Description: file content
 */
import {
    Group,
    Vector3,
    Box3,
} from 'bmap-three';

export class TrafficGroup extends Group {
    constructor() {
        super();
        this.needTrans = true;
        this.point = new Vector3();
    }

    afterAddToEngine(engine) {
        this.engine = engine;
    }

    onBeforeScenePrepareRender() {
        if (this.needTrans) {
            this.point.copy(this.position);
            const [setX, setY] = this.engine.map.projectCoordinates([this.position.x, this.position.y]);
            this.position.x = setX;
            this.position.y = setY;
            this.needTrans = false;
        }
    }

    raycast(raycaster, intersects) {
        let boundingBox = new Box3();
        const tmpIntersects = [];
        this.children.forEach(element => {
            const _Box = new Box3();
            _Box.copy(element.boundingBox);
            _Box.applyMatrix4(this.matrixWorld);
            // !boundingBox && (boundingBox = _Box);
            // boundingBox && (boundingBox = boundingBox.union(_Box));
            boundingBox = boundingBox.union(_Box);
        });
        const _isIntersect = raycaster.ray.intersectsBox(boundingBox);
        if (!_isIntersect) {
            return;
        }
        for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            child.traverseVisible(obj => {
                obj.raycast(raycaster, tmpIntersects, false);
            });
            // if (child.visible) {
            //     child.raycast(raycaster, tmpIntersects, true);
            // }
        }

        // TODO: remove this once the bug has been fixed
        // for (let i = 0; i < tmpIntersects.length; i++) {
        //     const I = tmpIntersects[i];
        //     I.distance = raycaster.ray.origin.distanceTo(I.point);
        // }
        tmpIntersects.sort((a, b) => {
            return a.distance - b.distance;
        });
        const firstIntersect = tmpIntersects[0];
        intersects.push({
            object: this,
            bindObject: firstIntersect?.object,
            point: tmpIntersects?.point,
            distance: tmpIntersects?.distance,
        });
        return intersects;
    }
}
