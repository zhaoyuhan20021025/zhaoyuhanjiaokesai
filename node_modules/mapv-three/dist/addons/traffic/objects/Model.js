/* eslint-disable max-len */
/**
 * @file 模型类
 *
 */

import {Object3D, Color, Vector3, Box3, TextureLoader, LinearEncoding, sRGBEncoding} from 'bmap-three';
import * as Utils from '../utils/index';
import {getColor, getVector3} from '../utils/MapMath';
// import {TextSprite} from './Label';
import {MeshBVH} from 'three-mesh-bvh';
import {TrafficObject} from './TrafficObject';

/**
 * 统一作为模型的基类
 * @param { Object } args 参数
 * @param { number } [args.rotation=[0,0,0]] [x,y,z],绕各坐标轴的旋转角，弧度制，正北方向为0，右手坐标系，默认值[0,0,0]
 * @param { number } [args.scale=[1,1,1]] [x,y,z],缩放比例，默认值[1,1,1]
 * @param { number } [args.speed=0.0] 速度，m/s, 标量，默认值0.0
 * @param {string} [args.name] 名字， 默认值 空
 * @param {any} [args.color] 颜色，默认值new THREE.Color(1.0, 1.0, 1.0), 可以接受0xff0000,"rgb(255, 0, 0)","rgb(100%, 0%, 0%)",'skyblue',"hsl(0, 100%, 50%)"等格式
 * @param {boolean} [args.colorChangable] 颜色是否可变，默认值true
 * @param {boolean} [args.movable] 位置是否可变，默认值true
 * @param {string} [args.modelType] 模型类型，轿车，公交车，自行车等，默认值"car"，可选参数（car,bus,truck,bicycle,pedestrian,traffic_cone）,如果是自定义的模型，可以自己命名，然后配合modelUrl使用
 * @param {string} [args.modelUrl] 模型链接地址，目前支持gltf格式数据，默认值 null，如果是自定义模型类型，该值必须有
 * @param {Object} [args.models] 模型几何体
 * @param {Object} [args.text] 文字，可以在模型上添加文字，默认为 null
 * @param {Object} [args.labelOffset] 注记偏移量，默认值THREE.Vector3(0, 0, 1.0),可以接受[x,y,z]或者{x:,y:,z:}或者new THREE.Vector3()
 * @param {Object} [label] 注记几何体，{@link Label}
 * @param {string} [args.encoding] 编码规则 默认-1, 0 为LinearEncoding 线性;1为 sRGBEncoding 非线性
 */
export class Model extends TrafficObject {
    constructor(args = {}) {
        super();
        // 航向角，弧度制，正北方向为0，右手坐标系
        this._rotation = getVector3(args.rotation);
        this._scale = args.scale || new Vector3(1, 1, 1);
        // 速度，m/s
        this.speed = args.speed || 0.0;
        // 名字
        this.name = args.name || '';
        this.color = args.color ? new Color(args.color) : null;
        this._geometryType = 'model';
        this.colorChangable = args.colorChangable === undefined ? true : args.colorChangable;
        this.movable = args.movable === undefined ? true : args.movable;
        // 透明度
        this.opacity = args.opacity || null;
        // 模型类型，轿车，公交车，自行车等，可选参数（car,bus,truck,bicycle,pedestrian,traffic_cone）
        if (args.modelType) {
            this.modelType = args.modelType.toLowerCase() || 'car';
        }
        this.modelUrl = args.modelUrl || null;
        this.models = [];
        this.text = args.text || null;
        this.labelOffset = getVector3(args.labelOffset, 1.0);
        this.label = null;
        this.loaded = false;
        this.onLoad = args.onLoad || null;
        // 是否加载整个场景
        this.isLoadScene = args.isLoadScene || false;
        this.isReceiveShadow = args.isReceiveShadow || false;
        this.iScastShadow = args.iScastShadow || false;
        this.isBloom = args.isBloom || false;
        // 是否展示，用于记录策略上的显隐
        this._display = true;
        // 是否开启LOD策略
        this.enableLOD = args.enableLOD === undefined ? true : args.enableLOD;
        // 最小像素占比
        this.minPixel = 64;
        // 修改的贴图
        this.maps = args.maps || [];
        // encoding规则  LinearEncoding 0   sRGBEncoding 1
        this.encoding = args.encoding || 1;
        // 粗糙度
        this.roughness = args.roughness === undefined ? null : args.roughness;
        this.metalness = args.metalness === undefined ? null : args.metalness;
        this.needTrans = args.needTrans;
        this.init();
    }

    /**
     * 初始化
     */
    init() {
        this.initModel();
        // this.initLabel();
        this.renderOrder = 3;
        this.rotation.set(this._rotation.x, this._rotation.y, this._rotation.z);
        this.scale.copy(getVector3(this._scale));
    }
    initModel() {
        const that = this;
        if (that.modelType) {
            const key = that.modelType.toUpperCase();
            if (Utils.MODELS[key]) {
                this.loaded = true;
                if (!this.isLoadScene) {
                    this.setModels(Utils.MODELS[key]);
                } else {
                    this.setScene(Utils.MODELS[key].scene);
                }
            } else {
                if (!that.modelUrl) {
                    console.log('未使用给定的模型类型，需要输入modelUrl参数');
                    return;
                }
                const url = that.modelUrl;
                if (!this.isLoadScene) {
                    Utils.loadGLTFModel(url, meshs => {
                        if (!Utils.MODELS[key]) {
                            Utils.MODELS[key] = meshs;
                        }
                        this.loaded = true;
                        this.setModels(meshs);
                    });
                } else {
                    Utils.loadDynamicGLTFModel(url, gltf => {
                        if (!Utils.MODELS[key]) {
                            Utils.MODELS[key] = gltf;
                        }
                        this.loaded = true;
                        this.setScene(gltf.scene);
                    });
                }
            }
        } else {
            if (!that.modelUrl) {
                return;
            }
            if (!this.isLoadScene) {
                Utils.loadGLTFModel(that.modelUrl, meshs => {
                    that.loaded = true;
                    this.setModels(meshs);
                });
            } else {
                Utils.loadDynamicGLTFModel(that.modelUrl, gltf => {
                    that.loaded = true;
                    this.setScene(gltf.scene);
                });
            }
        }
    }

    /**
     *
     * @param {Object} meshs 赋值样式
     */
    setScene(scene) {
        if (!scene) {
            return false;
        }
        const that = this;
        const newScene = scene.clone();
        newScene.isClone = true;
        newScene.traverse(function (child) {
            child.updateMatrixWorld();
            if (child.isMesh || child.isLine || child.isPoints) {
                if (that.isBloom) {
                    child.layers.enable(1);
                }
                if (child.isMesh) {
                    child.geometry.boundsTree = new MeshBVH(child.geometry, {maxDepth: 16});
                }
                child.receiveShadow = that.isReceiveShadow;
                child.castShadow = that.iScastShadow;

                that.setEncoding(child, that.encoding);

                if (child.material && that.colorChangable) {
                    child.material = child.material.clone();
                }
                if (child.material && that.color) {
                    child.material.color.copy(that.color);
                }
                const loader = new TextureLoader();
                if (that.maps.length) {
                    that.maps.forEach(map => {
                        if (child.name === 'img' + map[0]) {
                            child.material.map = loader.load(map[1]);
                            child.material.map.flipY = false;
                        }
                    });
                }

                if (child.material && that.opacity) {
                    child.material.transparent = child.material.transparent || that.opacity < 1.0;
                    child.material.opacity = that.opacity;
                }
                if (child.material && that.roughness) {
                    child.material.roughness = that.roughness;
                }
                if (child.material && that.metalness) {
                    child.material.metalness = that.metalness;
                }
                if (child.geometry) {
                    if (!child.geometry.boundingBox) {
                        child.geometry.computeBoundingBox();
                    }
                    child.updateMatrixWorld();
                    const box = Utils.computeTransformedBoundingBox(child.geometry.boundingBox, child.matrixWorld);
                    if (!that.boundingBox) {
                        that.boundingBox = box;
                    } else {
                        that.boundingBox.union(box);
                    }
                }
            }
        });

        that.add(newScene);
        if (that.loaded && that.onLoad) {
            that.onLoad();
        }
    }

    /**
     *
     * @param {Object} meshs 赋值样式
     */
    setModels(meshs) {
        if (!meshs || meshs.length < 1) {
            return false;
        }
        for (let ii = 0; ii < meshs.length; ii++) {
            const model = meshs[ii].clone();
            model.isClone = true;
            model.receiveShadow = this.isReceiveShadow;
            model.castShadow = this.iScastShadow;
            if (this.isBloom) {
                model.layers.enable(1);
            }
            if (model.isMesh) {
                model.geometry.boundsTree = new MeshBVH(model.geometry, {maxDepth: 16});
            }
            if (model.material && this.colorChangable) {
                model.material = meshs[ii].material.clone();
            }
            if (model.material && this.color) {
                model.material.color.copy(this.color);
            }
            if (model.material && this.opacity) {
                model.material.transparent = model.material.transparent || this.opacity < 1.0;
                model.material.opacity = this.opacity;
            }
            if (model.material && this.roughness) {
                model.material.roughness = this.roughness;
            }
            if (model.material && this.metalness) {
                model.material.metalness = this.metalness;
            }

            this.setEncoding(model, this.encoding);

            if (model.geometry) {
                if (!model.geometry.boundingBox) {
                    model.geometry.computeBoundingBox();
                }
                model.updateMatrixWorld();
                const box = Utils.computeTransformedBoundingBox(model.geometry.boundingBox, model.matrixWorld);
                if (!this.boundingBox) {
                    this.boundingBox = box;
                } else {
                    this.boundingBox.union(box);
                }
            }
            this.add(model);
        }

        if (this.loaded && this.onLoad) {
            this.onLoad();
        }
    }

    /**
     *
     * 修改编码值
     *
     * @param {Object} mesh 几何
     * @param {string} encoding 编码值 encoding规则  LinearEncoding 0   sRGBEncoding 1
     */
    setEncoding(mesh, encoding) {
        if (encoding > 0) {
            if (mesh.material.map) {
                mesh.material.map.encoding = encoding === 1 ? LinearEncoding : sRGBEncoding;
            }
            if (mesh.material.emissiveMap) {
                mesh.material.emissiveMap.encoding = encoding === 1 ? LinearEncoding : sRGBEncoding;
            }
        }
    }

    // /**
    //  * 初始化标签
    //  */
    // initLabel() {
    //     if (this.text) {
    //         this.label = new TextSprite(this.text);
    //         this.label.position.copy(this.labelOffset);
    //         this.add(this.label);
    //     }
    // }

    // /**
    //  *
    //  * 显示标签
    //  */
    // showLabel() {
    //     if (this.label) {
    //         this.label.visible = true;
    //     }
    // }

    // /**
    //  * 隐藏标签
    //  */
    // hideLabel() {
    //     if (this.label) {
    //         this.label.visible = false;
    //     }
    // }

    /**
     * 改变模型类型
     * @param {string} mt 模型类型
     *
     */
    setModelType(mt) {
        mt = mt.toLowerCase();
        if (mt === this.modelType) {
            return;
        }

        this.dispose();
        this.modelType = mt;
        this.initModel();
    }

    /**
     * 改变标注
     * @param {string} text 文字
     */
    setText(text) {
        if (text === this.text) {
            return;
        }
        this.text = text;
        if (this.label) {
            this.label.setText(text);
        } else {
            this.initLabel();
        }
    }

    /**
     * 设置标注的偏移量
     * @param {Object} lo 偏移
     */
    setLabelOffset(lo) {
        lo = getVector3(lo);
        this.labelOffset.copy(lo);
        if (this.label) {
            this.label.position.copy(this.labelOffset);
        }
    }

    /**
     * 修改模型的颜色
     * @param {*} color 颜色
     */
    setColor(color) {
        color = getColor(color);
        if (!this.color) {
            this.color = color;
        } else if (this.color.equals(color)) {
            return;
        } else {
            this.color.copy(color);
        }

        if (this.children && this.children.length) {
            for (let ii = 0; ii < this.children.length; ii++) {
                if (this.children[ii].material) {
                    this.children[ii].material.color.copy(this.color);
                    this.children[ii].material.needsUpdate = true;
                }
            }
        }
    }

    /**
     * 修改模型的颜色
     * @param {*} name  名称
     * @param {*} color 颜色
     */
    setNameColor(name, color) {
        color = getColor(color);
        if (!this.color) {
            this.color = color;
        } else if (this.color.equals(color)) {
            return;
        } else {
            this.color.copy(color);
        }

        if (this.children && this.children.length) {
            const model = this.getObjectByName(name);
            if (model) {
                model.material.color.copy(this.color);
                model.material.needsUpdate = true;
            }
        }
    }

    /**
     * 修改模型的可见性
     * @param {boolean} visible 颜色
     */
    setVisible(visible) {
        if (this.children && this.children.length) {
            this.visible = visible;
        }
        if (this.label) {
            this.label.visible = visible;
        }
    }
    // 获取世界坐标系下的最小包围盒
    getBoundingBoxWorld() {
        this.updateMatrixWorld(true);
        if (!this.boundingBox) {
            for (let ii = 0; ii < this.children.length; ii++) {
                if (this.children[ii].geometry && !this.children[ii].geometry.boundingBox) {
                    this.children[ii].geometry.computeBoundingBox();
                }

                if (!this.boundingBox) {
                    this.boundingBox = this.children[ii].geometry.boundingBox;
                } else {
                    this.boundingBox.union(this.children[ii].geometry.boundingBox);
                }
            }
        }
        let box = this.boundingBox;
        let transform = this.matrixWorld;
        let tBox = Utils.computeTransformedBoundingBox(box, transform);
        return tBox;
    }

    onBeforeRender() {
        this._visible = this.visible;
        this.visible = this.visible && this._display;
    }

    onAfterRender() {
        this.visible = this._visible;
    }

    raycast(raycaster, intersects) {
        const tmpIntersects = [];
        if (this.boundingBox) {
            const _Box = new Box3();

            _Box.copy(this.boundingBox);
            _Box.applyMatrix4(this.matrixWorld);
            const _isIntersect = raycaster.ray.intersectsBox(_Box);
            if (!_isIntersect) {
                return;
            }
        }

        for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            child.traverseVisible(obj => {
                obj.raycast(raycaster, tmpIntersects, false);
            });
            // if (child.visible) {
            //     child.raycast(raycaster, tmpIntersects, true);
            // }
        }

        // TODO: remove this once the bug has been fixed
        // for (let i = 0; i < tmpIntersects.length; i++) {
        //     const I = tmpIntersects[i];
        //     I.distance = raycaster.ray.origin.distanceTo(I.point);
        // }
        tmpIntersects.sort((a, b) => {
            return a.distance - b.distance;
        });
        if (tmpIntersects.length) {
            intersects.push({
                object: this,
                point: tmpIntersects[0].point,
                distance: tmpIntersects[0].distance,
                target: tmpIntersects[0].object,
            });
            return [
                {
                    object: this,
                    point: tmpIntersects[0].point,
                    distance: tmpIntersects[0].distance,
                    target: tmpIntersects[0].object,
                },
            ];
        }
    }

    /**
     * 克隆
     * @param {boolean} recursive 递归
     */
    clone(recursive) {
        return new this.constructor().copy(this, recursive);
    }

    /**
     * 拷贝
     * @param {Object3D} source 源
     * @param {boolean} recursive 递归
     * @returns Model
     */
    copy(source, recursive = true) {
        this.name = source.name;

        this.up.copy(source.up);

        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);

        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);

        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

        this.layers.mask = source.layers.mask;
        this.visible = source.visible;

        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;

        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;

        this.userData = JSON.parse(JSON.stringify(source.userData));
        this._rotation.copy(source._rotation);
        this._scale.copy(source._scale);
        this.speed = source.speed;
        this.name = source.name;
        this.color = source.color ? source.color.clone() : null;
        this._geometryType = 'model';
        this.colorChangable = source.colorChangable;
        this.movable = source.movable;
        this.opacity = source.opacity;
        this.modelType = source.modelType;

        this.modelUrl = source.modelUrl;
        this.text = source.text;
        this.labelOffset.copy(source.labelOffset);
        this.label = source.label ? source.label.clone() : null;
        this.loaded = false;
        // this.onLoad = source.onLoad;
        this.isLoadScene = source.isLoadScene;
        this.isReceiveShadow = source.isReceiveShadow;
        this.iScastShadow = source.iScastShadow;
        this.isBloom = source.isBloom;
        this.maps = source.maps;
        this.encoding = source.encoding;
        this.roughness = source.roughness;
        this.metalness = source.metalness;

        if (!this.isLoadScene) {
            this.loaded = true;
            this.setModels(source.children);
        } else {
            this.loaded = true;
            this.setScene(source.children);
        }

        return this;
    }

    /**
     * 释放内存
     */
    dispose() {
        if (this.children && this.children.length) {
            for (let ii = this.children.length - 1; ii > -1; ii--) {
                if (this.children[ii].isClone) {
                    if (
                        this.children[ii].isMesh
                        || this.children[ii].isLine
                        || this.children[ii].isPoints
                        || this.children[ii].isSprite
                    ) {
                        // this.children[ii].geometry.dispose();
                        if (this.colorChangable && this.children[ii].material) {
                            this.children[ii].material.dispose();
                            this.children[ii].material.map && this.children[ii].material.map.dispose();
                        }
                    } else {
                        // if (this.children[ii].dispose) {
                        //     this.children[ii].dispose();
                        // } else {
                        this.children[ii].traverse(child => {
                            if (this.colorChangable && child.material) {
                                child.material.dispose();
                                child.material.map && child.material.map.dispose();
                            }
                        });
                        // }
                    }
                } else {
                    Utils.disposeObject(this.children[ii]);
                }

                this.children[ii].children = [];
                this.remove(this.children[ii]);
            }
            this.children = [];
        }
        if (this.label) {
            Utils.disposeObject(this.label);
            this.remove(this.label);
        }
        this.models = [];
        this.label = null;
        this.dispatchEvent({type: 'dispose'});
    }
}
