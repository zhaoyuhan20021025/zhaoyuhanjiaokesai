/**
 * @author wema
 */
import {Matrix4, Vector3, BufferAttribute, Euler, Quaternion} from 'bmap-three';
import {getColor, getVector3} from '../utils/MapMath';
import {disposeObject} from '../utils/index';
import {TrafficInstancedObject} from './TrafficInstancedObject';

/**
 * 实例模型类
 * @param {Object} geometry 几何数据
 * @param {Object} material 材质
 * @param {Object} count 数量
 */

export class InstancedModel extends TrafficInstancedObject {
    constructor(geometry, material, count) {
        super(geometry, material, count);
        this.unused = new Array(count).map((v, i) => {
            return i;
        });
        this._geometryType = 'instancedmodel';
        this.used = [];
        this.sizeAttenuation = false;
        this.size = null;
        this.geometryScales = {};
        // this.initInstanceColor();
        // this.initInstanceMatrix();
    }

    /**
     * 初始化实例矩阵
     */
    initInstanceMatrix() {
        for (let ii = 0; ii < this.count; ii++) {
            this.setMatrixAt(ii, new Matrix4());
        }
        this.instanceMatrix.needsUpdate = true;
    }

    /**
     * 初始化实例颜色
     */
    initInstanceColor() {
        if (!this.geometry.hasAttribute('instanceColor')) {
            this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);
            this.instanceColor.array.fill(1.0);
            this.geometry.setAttribute('instanceColor', this.instanceColor);
        }
    }
    /**
     * 根据id设置位置
     * @param {Number} id 物体id
     * @param {Any} position 位置,例如:[1,1,1],{x:1,y:1,z:2},Vector3(1,1,1)
     */
    setPosition(id, position) {
        const index = this.used.indexOf(id);
        position = getVector3(position);
        if (index < 0) {
            this.take(id);
        }
        const postMatrix = new Matrix4();
        this.getMatrixAt(id, postMatrix);
        const newMatrix = postMatrix.setPosition(position);
        this.setMatrixAt(id, newMatrix);
        this.instanceMatrix.needsUpdate = true;
    }

    /**
     * 根据id设置矩阵
     * @param {Number} id 物体id
     * @param {Any} matrix 矩阵
     */
    setMatrix(id, matrix) {
        const index = this.used.indexOf(id);
        if (index < 0) {
            this.take(id);
        }
        this.setMatrixAt(id, matrix);
        this.instanceMatrix.needsUpdate = true;
    }

    /**
     * 根据id设置颜色
     * @param {Number} id 物体id
     * @param {Any} color 颜色
     */
    setColor(id, color) {
        const index = this.used.indexOf(id);
        color = getColor(color);
        if (index < 0) {
            this.take(id);
        }
        this.setColorAt(id, color);

        this.instanceColor.needsUpdate = true;
    }

    /**
     * 根据id设置缩放
     * @param {Number} id 物体id
     * @param {Vector3} scale 缩放,例如:[1,1,1],{x:1,y:1,z:2},Vector3(1,1,1)
     */
    setScale(id, scale) {
        const index = this.used.indexOf(id);
        scale = getVector3(scale);
        if (index < 0) {
            this.take(id);
        }
        if (this.sizeAttenuation) {
            if (scale.length() === 1) {
                delete this.geometryScales[id];
            } else {
                this.geometryScales[id] = scale;
            }
        } else {
            const matrix = new Matrix4();
            this.getMatrixAt(id, matrix);
            matrix.elements[0] = scale.x || 1;
            matrix.elements[5] = scale.y || 1;
            matrix.elements[10] = scale.z || 1;
            this.instanceMatrix.needsUpdate = true;
        }
    }

    /**
     * 根据id返回缩放
     * @param {Number} id 物体id
     * @return {Vector3} scale 缩放,Vector3(1,1,1)
     */
    getScale(id) {
        const matrix = new Matrix4();
        this.getMatrixAt(id, matrix);
        return new Vector3(matrix.elements[0], matrix.elements[5], matrix.elements[10]);
    }


    /**
     * 根据id设置旋转
     * @param {Number} id 物体id
     * @param {Number} angle 旋转角，弧度,例如:Math.PI，默认值：0
     * @param {string} axis 旋转轴，x,y,z,默认值：x
    */
    setRotate(id, angle = 0, axis = 'x') {
        const index = this.used.indexOf(id);
        if (index < 0) {
            this.take(id);
        }

        const matrix = new Matrix4();
        this.getMatrixAt(id, matrix);
        const tempMatrix = new Matrix4();
        switch (axis) {
            case 'x':
                tempMatrix.makeRotationX(angle);
                break;
            case 'y':
                tempMatrix.makeRotationY(angle);
                break;

            case 'z':
                tempMatrix.makeRotationZ(angle);
                break;
        }
        matrix.multiply(tempMatrix);
        this.setMatrixAt(id);
        this.instanceMatrix.needsUpdate = true;
    }

    /**
     * 根据id返回旋转值
     * @param {Number} id 物体id
     * @return {Vector3} Euler 旋转,Euler(0,0,0,'xyz');
     */
    getRotation(id) {
        const matrix = new Matrix4();
        this.getMatrixAt(id, matrix);
        const quaternion = new Quaternion();
        matrix.decompose(new Vector3(), quaternion, new Vector3());
        return new Euler().setFromQuaternion(quaternion);
    }

    /**
     * 取用
     * @param {Number} id 物体id
     * @returns Boolean
     */
    take(id) {
        const index = this.unused.indexOf(id);
        if (index > -1) {
            this.used.push(id);
            this.unused.splice(index, 1);
            return true;
        }
        return false;
    }

    /**
     * 释放单个物体
     * @param {Number} id 物体id
     * @returns Boolean
     */
    release(id) {
        const index = this.used.indexOf(id);
        if (index > -1) {
            this.used.splice(index, 1);
            this.setMatrixAt(id, new Matrix4());
            this.unused.push(id);
            return true;
        }
        return false;
    }

    /**
     * 更新所有的几何，根据相机位置计算缩放比例
     * @param {Number} pr projected radius
     * @param {Vector3} cp camera position
     */
    updateAllByScale(pr, cp) {
        const parentPosition = this.getWorldPosition(new Vector3());
        let needsUpdate = false;
        for (let ii = 0; ii < this.count; ii++) {
            const matrix = new Matrix4();
            const position = new Vector3();
            const quaternion = new Quaternion();
            const scale = new Vector3();
            this.getMatrixAt(ii, matrix);
            matrix.decompose(position, quaternion, scale);
            const distance = cp.distanceTo(
                new Vector3(
                    parentPosition.x + position.x,
                    parentPosition.y + position.y,
                    parentPosition.z + position.z
                )
            );
            let tempScale = ((this.size || 20) * 0.001 * distance) / pr;
            let maxScale = 1000;
            if (this.maxScale) {
                maxScale = Math.max(this.maxScale, 1.0);
            }
            tempScale = Math.min(maxScale, Math.max(tempScale, 1.0));
            const isScaleChange = Math.abs(scale.x - tempScale) > 0.05;
            needsUpdate = isScaleChange || needsUpdate;
            if (isScaleChange) {
                // matrix.elements[5] = scale || 1;
                // matrix.elements[5] = scale || 1;
                // matrix.elements[10] = scale || 1;
                if (this.geometryScales[ii]) {
                    // matrix.elements[0] = scale * this.geometryScales[ii].x || 1;
                    // matrix.elements[5] = scale * this.geometryScales[ii].y || 1;
                    // matrix.elements[10] = scale * this.geometryScales[ii].z || 1;
                    matrix.compose(position, quaternion, new Vector3(
                        tempScale * this.geometryScales[ii].x,
                        tempScale * this.geometryScales[ii].y,
                        tempScale * this.geometryScales[ii].z));
                } else {
                    matrix.compose(position, quaternion, new Vector3(tempScale, tempScale, tempScale));
                }
                this.setMatrixAt(ii, matrix);
            }

        }
        this.instanceMatrix.needsUpdate = needsUpdate;
    }

    /**
     * 释放所有
     *
     */
    dispose() {
        this.used = [];
        this.unused = [];
        disposeObject(this);
        this.dispatchEvent({type: 'dispose'});
    }
}
