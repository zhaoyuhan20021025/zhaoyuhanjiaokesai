/* eslint-disable */
/**
 *
 * @file 资产工具
 *
 * @author
 */
 import {
    MathUtils as ThreeMath,
    Vector3,
    Box3,
    Matrix4,
    Euler,
    Quaternion,
    AmbientLight,
    DirectionalLight,
    MeshPhongMaterial,
    PlaneGeometry,
    TextureLoader,
    Mesh,
    CubeTextureLoader,
    Object3D,
    BoxHelper
} from 'bmap-three';
import {Model} from '../objects/Model';
import {TrafficGroup as Group} from '../objects/TrafficGroup';
import {DynamicModel} from '../objects/DynamicModel';
import * as Utils from '../utils/index';
import {updateMaterial, setDirectionalLight, setAmbientLight} from '../utils/assets';
import {debounce, throttle} from 'lodash-es';
import {
    combineDeviceUrl,
    combineMaterialUrl,
    combineModelUrl,
    getAllData,
    updateDeviceInfo,
    setHost,
    deleteDevice,
    queryDeviceByRadius,
    connectAssetsSync,
    checkAuth,
    setHeaders
} from "../service/assets";
import {TEMPLTE_MODEL_CONFIG, TEMPLATE_POINT} from '../config/assets';
import SnowflakeId from 'snowflake-id';
import jsSHA from 'jssha';
import humps from 'humps';

const snowflake = new SnowflakeId({
    mid: 42,
    offset: (2021 - 1970) * 31536000 * 1000
});

// InstancedMesh里记录的_device_info模板
const TEMPLATE_DEVICE_INFO = {
    x: 0,
    y: 0,
    z: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    scale: 1
}

export class AssetsScene extends Object3D {
    /** @private */ _options
    /** @private */ _assetsInfo
    /** @private */ _allModelList
    /** @private */ _assetsInitParams
    /** @private */ _assetsModelsList
    /** @private */ _viewChangeListenerCall
    /** @private */ _viewRenderCall
    /** @private */ _viewRenderOption
    /** @private */ _viewQueryStatus
    /** @private */ _viewRenderSwitchStatus

    /** 所有资产模型 */ models
    /** 当前场景模式 */ mode
    /** 当前编辑模式 */ editMode
    /** 引擎核心 */ engine
    /** 资产项目ID */ projectId

    /**
     * @param {Object} arg - 配置参数
     * @param {string=} arg.host - 配置资产服务环境,默认为线上
     * @param {number} arg.sceneId - 配置场景ID
     * @param {Object} arg.auth - 场景服务鉴权
     * @param {Object} arg.auth.ak - 鉴权ak
     * @param {Object} arg.auth.sk - 鉴权sk
     * @param {Object} arg.auth.appid - 鉴权appid
     * @param {Object} arg.auth.url - 鉴权服务地址
     * @param {Object} arg.renderOption - 可选：场景渲染配置
     * @param {number} arg.renderOption.minZoom - 最小生效视野等级
     * @param {string=} arg.renderOption.anchor - 区域加载锚点 mapCenter/cameraPosition
     * @param {function} arg.renderOption.anchorGetter - 区域加载锚点自定义获取方法
     * @param {number} arg.renderOption.radius - 区域加载半径 单位m
     * @param {number=} arg.renderOption.debounceTime - 区域加载防抖时间 单位ms
     * @param {string=} arg.renderOption.expireHandleType - 区域加载失效物体的处理方式 hide/dispose/show
     * @param {number=} arg.renderOption.reuseNum - 转换instancedModel的数量下限
     */
    constructor(arg = {}) {
        super();
        // this.engine = engine || null;
        this._options = arg;
        this._assetsInfo = {};
        this._allModelList = [];
        this._viewRenderSwitchStatus = true;

        this.models = [];
        this.mode = 'readOnly';
        this.editMode = 'device';
        this.projectId = '';
        arg.host && setHost(arg.host);
    }
    /** @private */
    afterAddToEngine(engine) {
        this.engine = engine;
        this.setLight();
        this.getAssetsInfo(this._options);
        const authInfo = this._options.auth;
        authInfo && this.checkAuth(authInfo);
    }
    /**
     * @private
     */
    checkAuth(authInfo) {
        const {ak, sk, appid, url} = authInfo;
        const length = Math.ceil(Math.random() * 10);
        const randomNum = Math.ceil(Math.random() * 10 * length);
        const ctime = Math.floor(new Date().getTime() / 1000);
        const str = `ak=${ak}&appid=${appid}&ctime=${ctime}&random=${randomNum}&sk=${sk}`;
        const sha = new jsSHA('SHA-1', 'TEXT', { encoding: 'UTF8' });
        sha.update(str);
        const sign = sha.getHash('HEX');
        checkAuth(
            {
                ak,
                appid,
                ctime,
                random: randomNum,
                sign
            },
            url
        ).then(({token}) => {
            if (!token) {
                console.error('请传入正确的ak,sk, appid');
                return;
            }
            setHeaders({Authorization: token})
        });
    }

    /** @private */
    setLight() {
        const light = new AmbientLight(0xaaaaaa); // soft white light
        light.name = 'ambientLight';
        this.engine.add(light);

        const directionalLight = new DirectionalLight(0xaaaaaa, 1);
        directionalLight.position.set(2500, 2500, 2500);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -5000;
        directionalLight.shadow.camera.right = 5000;
        directionalLight.shadow.camera.top = 5000;
        directionalLight.shadow.camera.bottom = -5000;
        directionalLight.shadow.mapSize.width = 2048 * 5; // default
        directionalLight.shadow.mapSize.height = 2048 * 5; // default
        directionalLight.shadow.camera.near = 100.0; // default
        directionalLight.shadow.camera.far = 10000; // default
        directionalLight.shadow.bias = -0.001;
        directionalLight.shadow.autoUpdate = false;
        directionalLight.shadow.needsUpdate = true;
        // this.directionalLightHelper = new DirectionalLightHelper(directionalLight, 10, 0xff0000);
        directionalLight.lookAt(new Vector3(0, 0, 0));
        this.engine.add(directionalLight);
        this.engine.scene.directionalLight = directionalLight;
    }
    /** @private */
    async getAssetsInfo(arg) {
        const { sceneId, host: sceneHost, renderOption = {} } = arg;
        const result = await getAllData({
            sceneId,
            bearer: '',
            host: sceneHost || 'https://ace.apollo.auto'
        });
        this._assetsInfo = result;
        const { modelList, deviceList, materialList, mapConfig, resourceUrl, projectId: project_id } = result;
        this.projectId = project_id;

        const projectModelMap = {};
        modelList.forEach(model => {
            const {project_id, combined_id} = model;
            !projectModelMap[project_id] && (projectModelMap[project_id] = {
                combinedModel: [],
                normalModel: []
            });
            combined_id ?
                projectModelMap[project_id].combinedModel.push(model) :
                projectModelMap[project_id].normalModel.push(model)
        })
        this.dispatchEvent({
            type: 'getModelList',
            modelList: projectModelMap
        });

        const assetsParams = {
            deviceList,
            modelConfigList: modelList,
            materialList,
            sceneDeviceList: mapConfig.sceneDeviceList,
            modelMaterials: mapConfig.modelMaterials,
            staticResource: resourceUrl,
            reuseNum: 50
        };
        this._assetsInitParams = assetsParams;

        const { sceneConfig } = mapConfig;
        const { directional, ambientLight, plane, back } = sceneConfig;
        // 修改平行光
        setDirectionalLight(this.engine, directional);
        // 修改环境光
        setAmbientLight(this.engine, ambientLight);
        this.addPlane(plane, deviceList[0]);
        back.map && this.loadSkyBox(back.map);

        const {radius} = renderOption;
        if (radius) {
            const [x, y] = this.engine.map.getCenter();
            const { deviceList: radiusDeviceList } = await queryDeviceByRadius({
                x,
                y,
                radius
            });
            assetsParams.deviceList = radiusDeviceList;
            this._assetsInitParams.deviceList = radiusDeviceList;
            this._viewRenderOption = renderOption;
            this.openViewRenderSceneModel(renderOption);
        }
        const models = await this.initModels(assetsParams);
        this._assetsModelsList = models.map((model) => {
            model.visibleInScene = model.visible;
            return model.name;
        });
    }
    /** @private */
    addPlane(params, devicePoint) {
        const { map, mapRepeat = [40, 40], mapSize = { x: 400000, y: 400000 }, color } = params;
        const material = new MeshPhongMaterial({
            opacity: params.opacity,
            transparent: params.transparent || params.opacity < 1,
            depthTest: true,
            depthWrite: true
        });
        const { x, y } = mapSize;
        const geometry = new PlaneGeometry(x, y);
        const plane = new Mesh(geometry, material);
        let setX = params.offset[0];
        let setY = params.offset[1]
        if (devicePoint) {
            const [x, y] = this.engine.map.projectCoordinates([devicePoint.x, devicePoint.y]);
            setX = x;
            setY = y;
        }
        plane.position.set(setX, setY, params.offset[2]);
        plane.renderOrder = 3.0;
        plane.receiveShadow = params.receiveShadow === undefined ? true : params.receiveShadow;
        plane.name = 'plane';
        const that = this;
        if (color) {
            material.color.set(color);
        }
        const setMapStatus = (typeof map === 'string' && !!map) || (typeof map === 'object' && !!map.url);
        if (setMapStatus) {
            let setMap = '';
            let setRepeat = mapRepeat;
            if (typeof map === 'object') {
                setMap = map.url;
                setRepeat = map.repeat;
            } else if (typeof map === 'string') {
                setMap = map;
            }
            const textureLoader = new TextureLoader();
            textureLoader.load(setMap, function (texture) {
                texture.wrapS = params.wrapS || RepeatWrapping;
                texture.wrapT = params.wrapT || RepeatWrapping;
                texture.repeat.set(setRepeat[0], setRepeat[0]);
                material.map = texture;
                that.engine.add(plane);
            });
        } else {
            this.engine.add(plane);
        }
        return plane;
    }
    /** @private */
    loadSkyBox(path) {
        const skybox = new CubeTextureLoader()
            .setPath(path)
            .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);
        this.engine.scene.background = skybox;
    }
    /** @private */
    preloadModels(configList) {
        const modelList = [];
        configList.forEach(modelConfig => {
            modelList.push(this.addMesh(modelConfig));
        });
        return modelList;
    }
    /** @private */
    async initModels(config = {}, callback, needAddScene) {
        const {
            // 点位列表
            deviceList: myDeviceList = [],
            // 所有模型的列表
            modelConfigList: myModelConfigList = [],
            // 所有材质列表
            materialList: myMaterialList = [],
            // 使用InstancedMesh的阀值
            reuseNum = 20,
            // 额外预留的InstanceMesh数量
            extraCount = 200,
            // 场景中对模型的配置（批量）
            modelMaterials = [],
            // 所有资源的前缀
            staticResource,
            // 场景中单个点位的材质和显隐控制
            sceneDeviceList
        } = config;
        let modelConfigList = myModelConfigList;
        let materialList = myMaterialList;
        let deviceList = myDeviceList;
        if (staticResource && typeof staticResource === 'object') {
            modelConfigList = combineModelUrl(staticResource, modelConfigList);
            materialList = combineMaterialUrl(staticResource, myMaterialList);
            deviceList = combineDeviceUrl(staticResource, myDeviceList);
        }
        // 用这些数据包装点位生成模型参数
        const modelExtraConfig = {
            allModelList: modelConfigList,
            allMaterialList: materialList,
            modelMaterials: modelMaterials,
            // 场景中单个点位的材质和显隐控制
            sceneDeviceList
        };
        this._allModelList = modelConfigList;
        this._modelExtraConfig = modelExtraConfig;
        const meshList = [];
        if (!Array.isArray(deviceList) || !Array.isArray(modelConfigList) || !Array.isArray(materialList)) {
            console.error('参数不合法');
            return;
        }

        const context = this;
        function checkIsTargetStr(str) {
            return !str || str === '[]' || str === 'null'
        }

        function genModel(params = {}, onLoad = null) {
            let model = null;
            let _resolve = null;
            let promise = new Promise(resolve => {
                _resolve = resolve;
            });
            if (params.material) {
                params.onLoad = function () {
                    Promise.resolve().then(() => {
                        params.material.forEach((v) => {
                            updateMaterial(model, v.name, v.materialConfig);
                        });
                        onLoad && onLoad(model);
                    });
                    _resolve(params.composed ? model : this);
                };
            } else {
                params.onLoad = function () {
                    Promise.resolve().then(() => {
                        onLoad && onLoad(model);
                    });
                    _resolve(params.composed ? model : this);
                };
            }
            model = context.addMesh(params, callback, params.composed ? params.onLoad : undefined);
            return promise;
        }

        const maxCount = reuseNum;
        const countMap = new Map();
        deviceList.forEach(v => {
            // 没有贴图，没有材质，也不是组合模型
            if (checkIsTargetStr(v.images) && !v.combined_id) {
                if (!countMap.get(v.class_type)) {
                    countMap.set(v.class_type, [v]);
                } else {
                    countMap.get(v.class_type).push(v);
                }
            }
        });

        // 使用InstancedMesh
        const reuseDeviceList = [];
        const keys = countMap.keys();
        for (let key of keys) {
            const tempList = countMap.get(key);
            if (tempList.length > maxCount) {
                reuseDeviceList.push(...tempList);
                const meshConfigList = tempList.map(v => this.genMeshParams(v, modelExtraConfig)).filter(val => !!val);
                const instancedModelList = await this.getInstancedModel(meshConfigList, needAddScene, extraCount);
                meshList.push(...instancedModelList);
            }
        }
        // // 删除不用的instanceMesh点
        // const instanceMeshList = this.viewer.scene.models.filter(v => {
        //     return v.isInstanceMesh && !deviceList.some(item => v.name.startsWith(item.class_type));
        // });
        // instanceMeshList.forEach(mesh => {
        //     for (let i = 0, len = mesh._device_info.length; i < len; i++) {
        //         mesh.setMatrixAt(i, new Matrix4());
        //         mesh._device_info[i] = Object.assign({}, TEMPLATE_DEVICE_INFO);
        //     }
        // });

        // 正常加载模型
        const normalDeviceList = deviceList.filter(v => !reuseDeviceList.some(t => t.uuid === v.uuid));
        for (let index = 0, len = normalDeviceList.length; index < len; index++) {
            const deviceConfig = normalDeviceList[index];
            const params = this.genMeshParams(deviceConfig, modelExtraConfig);
            if (params) {
                let model = await genModel(params);
                meshList.push(model);
                this.models.push(model);
                this.engine.add(model);
            }
        }
        return meshList;
    }

    /**
     * @private
     * @param {Object} params  模型参数
     * @param {Function} callback  点击回调
     * @param {Function} loadCallback  组合模型加载回调
     */
     addMesh(params = {}, callback = null, loadCallback = null) {
        if (params.composed) {
            const group = new Group();

            // 根据点位里的modelInfo去整合children信息
            const subDeviceInfo = JSON.parse(params.modelInfo);
            const subModelInfo = JSON.parse(params.children);
            const actSubModelInfo = [];
            subModelInfo.forEach(v => {
                const modelConfig = v;
                let subConfig = subDeviceInfo.find(item => item.point_id === v.point_id) || {};
                if (!!subConfig.deleted) {
                    return
                }
                if (subConfig.model_id) {
                    const newConfig = this._allModelList.find(item => item.id === subConfig.model_id);
                    Object.assign(modelConfig, newConfig);
                }
                const config = Object.assign(modelConfig, subConfig.model_config || {});
                config.configs = subConfig.configs || {};
                actSubModelInfo.push(config);
            });

            // 更新组合模型的boundingBox
            let boundingBox = new Box3();
            let current = 0;
            const allCount = actSubModelInfo.length;
            function modelLoaded() {
                boundingBox = boundingBox.union(this.boundingBox);
                if (++current === allCount) {
                    // 先返回再执行回调
                    group.boundingBox = boundingBox;
                    group.loaded = true;
                    loadCallback && setTimeout(loadCallback)
                }
            }

            // 添加主模型
            const tempDelta = JSON.parse(params.delta);
            const temp = Object.assign({}, params, tempDelta, {onLoad: modelLoaded, bindItem: true});
            temp.uuid += '_main';
            const mainModel = this.genMesh(temp, callback);
            mainModel._device_group = group;
            group.add(mainModel);

            // 贴图存在点位数据里，在params里不在children里
            const allImgs = JSON.parse(params.images || '[]');
            // 逐个添加实际的子设备
            actSubModelInfo.forEach(item => {
                const temp = {};
                Object.keys(item).forEach(key => {
                    temp[this.line2Camel(key)] = item[key];
                });
                const {deltaStr = {}, point = '', pointId = '', configs = {}} = temp;
                Object.keys(deltaStr).forEach(key => {
                    if (configs[key]) {
                        deltaStr[key] += Number(configs[key]);
                    }
                });

                temp.uuid = '' + params.uuid + point;
                temp.isClick = true;
                temp.isVisible = true;
                temp.classType = temp.classType || temp.fileName.split('.glb')[0];

                // 选择目标贴图，贴图模型名称都是img1
                // 主设备是数字1,11,21，子设备是point_id
                const tempImg = allImgs.find(v => [pointId, point].includes(v.point));
                if (tempImg) {
                    temp.image = [[1, tempImg.url]];
                }

                const model = this.genMesh(Object.assign(temp, deltaStr, {onLoad: modelLoaded, bindItem: true}), callback);
                model._device_group = group;
                group.add(model);
            });

            group.uuid = params.uuid;
            group.name = params.uuid;
            group.position.set(params.x, params.y, params.z);
            group.rotation.set(
                ThreeMath.degToRad(params.rotateX),
                ThreeMath.degToRad(params.rotateY),
                ThreeMath.degToRad(params.rotateZ)
            );
            group.scale.set(params.scale, params.scale, params.scale);
            return group;
        } else {
            return this.genMesh(params, callback);
        }
    }
    /** @private */
    bindClick(model, params, bindStatus = false) {
        params.isClick && this.engine.event.bind(model, 'click', e => {
            this.dispatchEvent({
                type: 'click',
                assetsInfo: params,
                model, // 点击模型
                device: bindStatus ? model.parent : null // 如果点击的为子模型 此处会为主设备
            });
            ['edit', 'add'].includes(this.mode) && this.editModel(model, params, bindStatus);
        });
    }
    /**
     * @private
     * @param {*} transformModel
     */
    createBox(transformModel) {
        if (!this._box) {
            this._box = new BoxHelper(transformModel, 0xffff00);
            this.engine.add(this._box);
        } else {
            this._box.setFromObject(transformModel);
        }
    }
    /**
     * @private
     * 使模型进入编辑状态
     * @param {*} model
     * @param {*} info
     * @param {*} bindStatus
     */
    editModel(model, info, bindStatus) {
        const transformModel = (bindStatus && this.editMode === 'device') ? model.parent : model;
        this.createBox(transformModel);
        this.engine.selection.attachTransform(transformModel);
        const control = this.engine.selection.transformControl;
        control._listeners.mouseUp && control.removeEventListener('mouseUp', control._listeners.mouseUp[0]);
        control.addEventListener('mouseUp', (e) => {
           this.updateDevice(transformModel, info);
        });
    }

    /**
     * @private
     * 更新模型
     * @param {*} transformModel
     * @param {*} info
     */
    updateDevice(transformModel, info) {
        let deviceInfo = {};
        if (this.mode === 'edit') {
            const {deviceList} = this._assetsInfo;
            deviceInfo = deviceList.find(device => device.uuid === transformModel.uuid);
        } else {
            deviceInfo = info;
        }
        const {position, rotation, scale} = transformModel;
        let pointX, pointY;
        if (position.x > 1000 && position.y > 1000) {
            const [x, y] = this.engine.map.unprojectPointArr([position.x, position.y]);
            pointX = x;
            pointY = y;
        } else {
            pointX = position.x;
            pointY = position.y;
        }
        transformModel.point.x = pointX;
        transformModel.point.y = pointY;
        transformModel.point.z = position.z;

        if (this._box) {
            this._box.update(transformModel);
        }
        const updateInfo = {
            ...deviceInfo,
            x: Number(pointX.toFixed(6)),
            y: Number(pointY.toFixed(6)),
            z: Number(position.z.toFixed(6)),
            rotate_x: rotation.x * (180 / Math.PI) % 360,
            rotate_y: rotation.y * (180 / Math.PI) % 360,
            rotate_z: rotation.z * (180 / Math.PI) % 360,
            scale_x: scale.x,
            scale_y: scale.y,
            scale_z: scale.z,
        };
        this.dispatchEvent({
            type: 'update',
            model: transformModel, // 更新的模型
            deviceInfo: humps.camelizeKeys(updateInfo)
        });
    }

    /** @private */
    genMesh(temp = {}, callback = null) {
        const params = {}
        Object.keys(temp).forEach(key => {
            params[this.line2Camel(key)] = temp[key];
        });
        let model = null;
        const tags = params.tags || [];
        if (tags.includes(1001)) {
            model = new DynamicModel({
                name: params.uuid,
                modelUrl: params.extranetUrl,
                isReceiveShadow: params.isReceiveShadow,
                iScastShadow: params.iScastShadow,
                color: params.color,
                modelType: params.classType,
                rotation: [
                    ThreeMath.degToRad(params.rotateX),
                    ThreeMath.degToRad(params.rotateY),
                    ThreeMath.degToRad(params.rotateZ)
                ],
                encoding: params.encoding || -1,
                isBlur: params.isBlur,
                onLoad: params.onLoad
            });
        } else if (tags.includes(1007)) {
            // model = new RoadText(params.text, {
            //     name: params.uuid,
            //     color: params.color,
            //     rotation: [
            //         ThreeMath.degToRad(params.rotateX),
            //         ThreeMath.degToRad(params.rotateY),
            //         ThreeMath.degToRad(params.rotateZ)
            //     ],
            //     encoding: params.encoding || -1
            // });
        } else {
            const mImage = params.image;
            let imgs = [];
            if (Array.isArray(mImage)) {
                imgs = mImage;
            } else if (mImage && typeof mImage === 'string') {
                imgs = JSON.parse(mImage).map(item => {
                    return [item.point, item.testUrl && item.testUrl.split(',')[0]];
                });
            }
            model = new Model({
                name: params.uuid,
                modelType: params.classType,
                modelUrl: params.extranetUrl,
                isReceiveShadow: params.isReceiveShadow,
                iScastShadow: params.iScastShadow,
                color: params.color || null,
                rotation: [
                    ThreeMath.degToRad(params.rotateX),
                    ThreeMath.degToRad(params.rotateY),
                    ThreeMath.degToRad(params.rotateZ)
                ],
                encoding: params.encoding || -1,
                isLoadScene: !tags.includes(1002),
                maps: imgs.length > 0 ? imgs : [],
                isBloom: params.isBloom || false,
                onLoad: params.onLoad,
                needTrans: !params.bindItem,
            });
        }
        model.uuid = params.uuid;
        model.position.x = params.x;
        model.position.y = params.y;
        model.position.z = params.z;
        model.opacity = params.opacity;
        model.visible = !!params.isVisible;
        if (params.scale) {
            model.scale.set(params.scale, params.scale, params.scale);
        }
        if (params.scaleX || params.scaleY || params.scaleZ) {
            model.scale.set(params.scaleX || 1, params.scaleY || 1, params.scaleZ || 1);
        }

        this.bindClick(model, params, params.bindItem);

        return model;
    }

    /**
     * @private
     * 如果没有该classType的InstanceMesh则新建，否则则更新
     * @param meshConfigList
     * @param needAddScene
     * @param extraCount
     * @returns {Promise<Array>}
     */
    getInstancedModel(meshConfigList = [], needAddScene = false, extraCount = 200) {
        const meshConfig = meshConfigList[0];
        const {classType = ''} = meshConfig;
        const instancedMeshList = this.models.filter(v => {
            return v.isInstanceMesh && v.name.startsWith(`${classType}_`);
        });
        // 如果存在把老的diff隐藏，新的diff填充空位置展示
        if (instancedMeshList.length) {
            let oldDeviceList = Object.values(instancedMeshList[0]._device_info);
            const unusedIndexList = oldDeviceList.map((v, index) => {
                return {
                    index,
                    uuid: v.uuid
                };
            }).filter(oldItem => !meshConfigList.some(newItem => newItem.uuid === oldItem.uuid));
            const newItemList = meshConfigList.filter(newItem => {
                return !oldDeviceList.some(oldItem => oldItem.uuid === newItem.uuid);
            });
            const indexList = unusedIndexList;
            instancedMeshList.forEach(mesh => {
                // 隐藏老的diff
                unusedIndexList.forEach(v => {
                    mesh.setMatrixAt(v.index, new Matrix4())
                    mesh._device_info[v.index] = Object.assign({}, TEMPLATE_DEVICE_INFO);
                });
                // 新的diff在空余位置填充
                const basicPosition = mesh.position;
                const length = Math.min(indexList.length, newItemList.length);
                for (let i = 0; i < length; i++) {
                    const item = newItemList[i];
                    const euler = new Euler(
                        ThreeMath.degToRad(item.rotateX),
                        ThreeMath.degToRad(item.rotateY),
                        ThreeMath.degToRad(item.rotateZ)
                    );
                    const tempRotation = new Quaternion().setFromEuler(euler);
                    const tempPosition = new Vector3(item.setX, item.setY, item.z).sub(basicPosition);
                    const tempScale = new Vector3(item.scale, item.scale, item.scale);
                    const newMatrix = new Matrix4().compose(tempPosition, tempRotation, tempScale);

                    const index = indexList[i].index;
                    mesh.setMatrixAt(index,  new Matrix4().multiplyMatrices(newMatrix, mesh._rawMatrix));

                    // 更新deviceInfo
                    !item.meshName && (item.meshName = []);
                    item.meshName.push(mesh.meshName);
                    mesh._device_info[index] = item;
                }
                mesh.instanceMatrix.needsUpdate = true;
            });

            return Promise.resolve(instancedMeshList);
        }
        // 新增。追加预留的个数
        meshConfigList.push(...new Array(extraCount).fill('').map(() => {
            return Object.assign({}, TEMPLATE_DEVICE_INFO);
        }));
        return this.genInstancedModel(meshConfigList, needAddScene);
    }
    /** @private */
    genInstancedModel(meshConfigList, needAddScene) {
        const meshList = [];
        const meshConfig = meshConfigList[0];
        const tags = meshConfig.tags || [];
        return new Promise(resolve => {
            Utils.getInstancedModelByUrl(
                meshConfig.extranetUrl,
                meshConfigList.length,
                tags.includes(1001),
                (imeshs) => {
                    const offset = new Vector3(meshConfig.setX, meshConfig.setY, meshConfig.z);
                    if (imeshs && imeshs.length) {
                        const radianPerDegree = Math.PI / 180.0;
                        for (let jj = 0; jj < meshConfigList.length; jj++) {
                            const position = new Vector3(
                                meshConfigList[jj].setX - offset.x,
                                meshConfigList[jj].setY - offset.y,
                                meshConfigList[jj].z - offset.z
                            );
                            const scale = meshConfigList[jj].scale || 1;

                            for (let ii = 0; ii < imeshs.length; ii++) {
                                const imesh = imeshs[ii];

                                // 记录原始的模型旋转，以防止直接修改旋转时出现偏差
                                let rawMatrix = new Matrix4();
                                imesh.getMatrixAt(jj, rawMatrix);
                                imesh._rawMatrix = rawMatrix;

                                const tempRotation = new Euler();
                                tempRotation.x += meshConfigList[jj].rotateX * radianPerDegree;
                                tempRotation.y += meshConfigList[jj].rotateY * radianPerDegree;
                                tempRotation.z += meshConfigList[jj].rotateZ * radianPerDegree;
                                const newRotation = new Quaternion().setFromEuler(tempRotation);
                                // 模型隐藏
                                if (!meshConfigList[jj].isVisible) {
                                    position.set(-9999999, -9999999, 0);
                                }
                                const matrix = new Matrix4().compose(position, newRotation, new Vector3(scale, scale, scale));

                                const meshName = `${meshConfig.classType}_${ii}`;
                                imesh.name = meshName;
                                !imesh._device_info && (imesh._device_info = {});
                                imesh._device_info[jj] = meshConfigList[jj];
                                !imesh._device_info[jj].meshName && (imesh._device_info[jj].meshName = []);
                                !imesh._device_info[jj].meshName.push(meshName);
                                imesh.isInstanceMesh = true;
                                const oldColor = imesh.material.color;
                                imesh.setColor(jj, oldColor);
                                imesh.setMatrixAt(
                                    jj,
                                    new Matrix4().multiplyMatrices(matrix, rawMatrix)
                                );
                            }
                        }

                        imeshs.forEach((imesh) => {
                            if (meshConfig.material) {
                                meshConfig.material.forEach((v) => {
                                    updateMaterial(imesh, v.name, v.materialConfig);
                                });
                            }
                            imesh.position.copy(offset);
                            meshList.push(imesh);
                            this.models.push(imesh);
                            this.engine.add(imesh);
                            this.engine.event.bind(imesh, 'click', e => {
                                this.dispatchEvent({
                                    type: 'click',
                                    assetsInfo: meshConfigList[e.instanceId],
                                    model: {
                                        instance: imesh,
                                        instanceIndex: e.instanceId,
                                        instanceGroup: imeshs
                                    }
                                });
                            });
                        });
                    }
                    resolve(meshList);
                }
            );
        })
    }
    /** @private */
    genMeshParams(deviceConfig = {}, extraConfig = {}) {
        const {
            allModelList = [],
            allMaterialList = [],
            modelMaterials = [],
            // 场景中单个点位的材质和显隐控制
            sceneDeviceList = []
        } = extraConfig;
        const temp = {};
        Object.keys(deviceConfig).forEach(key => {
            temp[this.line2Camel(key)] = deviceConfig[key];
        });

        function genMaterialList(materials = []) {
            const materialList = [];
            materials.forEach((v) => {
                const materialConfig = allMaterialList.find(item => item.id === v.material_id);
                if (materialConfig) {
                    materialList.push({
                        name: v.name,
                        materialConfig: JSON.parse(materialConfig.json)
                    });
                }
            });
            return materialList;
        }

        const modelConfig = allModelList.find(item => item.file_name.startsWith(temp.classType));
        if (modelConfig) {
            const {
                extranet_url,
                tags,
                coordinates,
                children = '',
                combined_id = 0,
                bounding_box = '',
                delta = '{}',
                coordinate_type = 1,
                id = -1,
            } = modelConfig;
            if (coordinate_type === 1 && Math.abs(temp.x) < 180 && Math.abs(temp.y) < 90) {
                // WGS84坐标系
                temp.rawX = temp.x;
                temp.rawY = temp.y;

                const [setX, setY] = this.engine.map.projectCoordinates([temp.x, temp.y]);
                temp.setX = setX;
                temp.setY = setY;
                // const { x, y } = Utils.transformWGS84ToUTM({
                //     x: temp.rawX,
                //     y: temp.rawY
                // });
                // temp.x = x;
                // temp.y = y;
            }
            temp.extranetUrl = extranet_url;
            temp.tags = JSON.parse(tags);
            temp.composed = !!combined_id;
            temp.children = children || '[]';
            temp.boundingBox = bounding_box || '[]';
            temp.hasBoundingBox = !!coordinates;
            temp.genMeshParamsboundingBox = bounding_box || '[]';
            temp.delta = delta || '{}';
            temp.coordinates = coordinates;
            temp.modelId = id;
            if (coordinates) {
                const coordinatesArr = coordinates.split(',');
                temp.x = +coordinatesArr[0] || 0;
                temp.y = +coordinatesArr[1] || 0;
                temp.z = +coordinatesArr[2] || 0;
                temp.rotateX = -90;
                temp.isClick = false;
            }
            // 应用材质和显隐控制
            const material = modelMaterials.find(v => v.id === temp.modelId);
            if (material) {
                temp.material = genMaterialList(material.materials);
                temp.isVisible = material.visible === undefined ? true : !!material.visible;
            }

            // 场景中对点位的特殊设置（材质和显影控制）
            const specialConfig = sceneDeviceList.find(v => v.uuid === temp.uuid);
            if (specialConfig) {
                temp.material = genMaterialList(specialConfig.materials);
                temp.isVisible = specialConfig.visible === undefined ? true : !!specialConfig.visible;
            }

            return temp;
        }

        return null;
    }
    /** @private */
    line2Camel(name) {
        return name.replace(/\_(\w)/g, function (all, letter) {
            return letter.toUpperCase();
        });
    }

    /**
     * 改变场景状态
     * @param {'readOnly' | 'add' | 'edit'} type 场景类型
     */
    changeSceneMode(type) {
        this.closeEditor();
        this.mode = type;
    }

    /**
     * 切换编辑模式（主子模型）
     * @param {*} editType 'device' or 'subModel'
     * TODO: 子模型模式暂不支持，待开发
     */
    changeEditMode(editType) {
        if (this.mode !== 'edit') {
            console.warn('请先打开编辑模式');
            return;
        }
        this.editMode = editType;
    }

    /**
     * 关闭编辑控制器
     */
    closeEditor() {
        this.engine.selection.detachTransform();
        this._box && this.engine.remove(this._box);
        this._box = null;
        this.editMode = 'device';
    }

    /**
     * @private
     * @param {*} deviceInfo 
     * @param {*} modelConfig 
     * @returns 
     */
    genModelInfo(deviceInfo, modelConfig) {
        if (!deviceInfo.composed) {
            return [];
        }
        const newModelInfo = JSON.parse(modelConfig.children).map(v => {
            const pointInfo = {
                point_id: v.point_id,
                point: v.point,
                x: deviceInfo.x,
                y: deviceInfo.y,
                cid: snowflake.generate(),
                configs: {}
            };
            return pointInfo;
        });
        return newModelInfo;
    }

    /**
     * @private
     * @param {*} point 
     * @param {*} config 
     * @param {*} option 
     * @returns 
     */
    async createModel(point, config, option = {}) {
        if (this.mode !== 'add') {
            console.warn('请将AssetsScene切换到新增模式')
            return;
        }
        const context = this;
        function genModel(params = {}, onLoad = null) {
            let model = null;
            let _resolve = null;
            let promise = new Promise(resolve => {
                _resolve = resolve;
            });
            if (params.material) {
                params.onLoad = function () {
                    Promise.resolve().then(() => {
                        params.material.forEach((v) => {
                            updateMaterial(model, v.name, v.materialConfig);
                        });
                        onLoad && onLoad(model);
                    });
                    _resolve(params.composed ? model : this);
                };
            } else {
                params.onLoad = function () {
                    Promise.resolve().then(() => {
                        onLoad && onLoad(model);
                    });
                    _resolve(params.composed ? model : this);
                };
            }
            model = context.addMesh(params, null, params.composed ? params.onLoad : undefined);
            return promise;
        }

        const [x, y ,z] = point;
        const deviceInfo = {
            ...TEMPLTE_MODEL_CONFIG,
            x: Number(x.toFixed(6)),
            y: Number(y.toFixed(6)),
            z,
            classType: config.file_name.split('.glb')[0],
            composed: !!config.combined_id,
            name: config.model_name,
            uuid: snowflake.generate(),
            ...option
        }
        deviceInfo.modelInfo = JSON.stringify(this.genModelInfo(deviceInfo, config));
        const meshParams = this.genMeshParams(deviceInfo, this._modelExtraConfig);
        const model = await genModel(meshParams);
        return {
            model,
            deviceInfo
        };
    }
    /**
     * 开启新增预览
     * @param {*} info 模型表信息
     * @param {*} tile 路网3DTile
     */
    async openAddPreview(info, tile) {
        this.closeAddPreview();
        const {model} = await this.createModel([0, 0, 0], info, {
            isClick: false
        });
        model.opacity = 0.2;
        this.engine.add(model);

        this._previewModel = model;
        this._addPreviewEvent = e => {
            const [x, y ,z] = e.point;
            model.needTrans = true;
            model.position.set(x, y, z + 1);
        };
        this._tile = tile;

        this.engine.event.bind(tile, 'mousemove', this._addPreviewEvent);
    }

    /**
     * 关闭新增预览
     */
    closeAddPreview() {
        this._addPreviewEvent &&  this.engine.event.unbind(this._tile, 'mousemove', this._addPreviewEvent);
        this._addPreviewEvent = null;
        this._tile = null;
        this._previewModel && this.engine.remove(this._previewModel);
        this._previewModel = null;
    }

    /**
     * 新增点位
     * @param {*} point 点位
     * @param {*} config 模型信息
     * @param {*} defaultEdit 是否默认开启编辑器
     * @returns {Object} 新增信息
     */
    async addDevice(point, config, defaultEdit = true) {
        this.closeAddPreview();
        const {model, deviceInfo} = await this.createModel(point, config);
        this.models.push(model);
        this.engine.add(model);

        const submitDeviceInfo = humps.decamelizeKeys(deviceInfo);
        defaultEdit && setTimeout(() => {
            this.editModel(model, submitDeviceInfo, false)
        }, 300);
        return {
            model,
            deviceInfo: submitDeviceInfo
        }
    }
    /**
     * 通过参数更新点位
     * @param {*} deviceInfo 模型表信息（通过点击回调可以获取）
     * @param {Object} info 调整参数信息
     * @param {Number} info.x 经度
     * @param {Number} info.y 纬度
     * @param {Number} info.z 高度
     * @param {Number} info.rotateX x轴旋转角度
     * @param {Number} info.rotateY y轴旋转角度
     * @param {Number} info.rotateZ z轴旋转角度
     * @param {Number} info.scaleX x轴缩放值
     * @param {Number} info.scaleY y轴缩放值
     * @param {Number} info.scaleZ z轴缩放值
     */
    editDeviceByParams(deviceInfo, info) {
        const {uuid} = deviceInfo;
        const device = this.engine.scene.getObjectByProperty('uuid', uuid);
        const {x, y, z, rotateX, rotateY, rotateZ, scaleX = 1, scaleY = 1, scaleZ = 1} = info;
        device.needTrans = true;
        device.position.set(x, y, z);
        device.rotation.set(
            rotateX * Math.PI / 180,
            rotateY * Math.PI / 180,
            rotateZ * Math.PI / 180
        )
        device.scale.set(scaleX,scaleY,scaleZ);
        this.engine.requestRender();
        const {deviceList} = this._assetsInfo;
        const originDeviceInfo = deviceList.find(device => device.uuid === uuid);
        Object.keys(info).forEach(key => {
            originDeviceInfo[humps.decamelize(key)] = info[key];
        });
        this.updateDevice(device);
    }

    /**
     * 新增/更新点位信息
     * @param {*} deviceInfo 需要更新的模型
     */
    submitDeviceInfo(deviceInfo) {
        const deviceList = [humps.decamelizeKeys(deviceInfo)];
        const mappingList = [];
        const data = deviceList.map(item => {
            !item.project_id && (item.project_id = this.projectId);
            item.is_tips = Number(item.is_tips);
            item.is_visible = Number(item.is_visible);
            item.is_click = Number(item.is_click);
            item.is_bloom = Number(item.is_bloom) || 0;
            item.status = Number(item.status) || 0;
            item.lod_max = Number(item.lod_max);
            item.lod_min = Number(item.lod_min);
            item.x = Number(item.x);
            item.y = Number(item.y);
            item.z = Number(item.z);
            item.rotate_x = Number(item.rotate_x);
            item.rotate_y = Number(item.rotate_y);
            item.rotate_z = Number(item.rotate_z);
            item.layer_id = 1;
            const temp = {};
            Object.keys(TEMPLATE_POINT).forEach(key => {
                temp[key] = item[key];
            });
            temp.uuid = temp.uuid || snowflake.generate();
            const mappingArr = JSON.parse(temp.model_info);
            mappingArr.forEach(v => {
                // 映射关系表不存configs和rotate_z字段
                delete v.configs;
                delete v.rotate_z;
                v.uuid = temp.uuid;
                v.project_id = temp.project_id;
                mappingList.push(v);
            });
            return temp;
        });
        console.log('submit', data);
        this._assetsInfo.deviceList.push(data[0]);
        updateDeviceInfo({deviceList: data, mappingList});
    }

    /**
     * 删除点位
     * @param {*} model 需要删除的模型
     */
    deleteDevice(model) {
        this.engine.remove(model);
        console.log('delteDevice', model.uuid);
        model.uuid && deleteDevice(model.uuid);
    }
    /**
     * @private
     * 打开视野加载
     */
    async openViewRenderSceneModel(params) {
        const {
            anchor = 'mapCenter',
            minZoom,
            radius = 500,
            debounceTime = 500,
            expireHandleType = 'dispose',
            reuseNum = 50,
            anchorGetter,
        } = params;
        const {
            modelConfigList,
            materialList,
            modelMaterials,
            staticResource,
            sceneDeviceList
        } = this._assetsInitParams;
        this._viewRenderCall = async () => {
            const currentZoom = this.engine.map.getZoom();
            const anchorInfo = {};

            switch (anchor) {
                case 'mapCenter':
                    const [centerX, centerY] = this.engine.map.getCenter();
                    anchorInfo.x = centerX;
                    anchorInfo.y = centerY;
                    break;
                case 'cameraPosition':
                    const {x: cameraX, y: cameraY} = this.engine.camera.position;
                    const [x, y] = this.engine.map.unprojectPointArr([cameraX, cameraY]);
                    anchorInfo.x = x;
                    anchorInfo.y = y;
                    break;
                default:
                    break;
            }

            if ((minZoom && currentZoom < minZoom) || this._viewQueryStatus || !this._viewRenderSwitchStatus) {
                return;
            }
            this._viewQueryStatus = true;

            const queryBody = {
                x: anchorInfo.x,
                y: anchorInfo.y
            }
            if (anchorGetter) {
                queryBody = anchorGetter(this.engine);
            }
            const { deviceList } = await queryDeviceByRadius({
                ...queryBody,
                radius
            });
            const originModels = this._assetsModelsList;
            const hasDeviceList = [];
            const newDeviceList = [];
            const delInstanceModel = [];
            const delModels = [];
            deviceList.forEach((device) => {
                const { uuid } = device;
                if (originModels.includes(uuid)) {
                    hasDeviceList.push(device);
                } else {
                    newDeviceList.push(device);
                }
            });

            originModels.forEach((uuid) => {
                if (!hasDeviceList.some((device) => device.uuid === uuid)) {
                    delModels.push(uuid);
                }
            });

            if (expireHandleType !== 'show') {
                delModels.forEach((uuid) => {
                    const index = this._assetsModelsList.findIndex((modelUuid) => modelUuid === uuid);
                    this._assetsModelsList.splice(index, 1);
                    const model = this.engine.scene.getObjectByName(uuid);
                    if (!model) {
                        console.log('无效模型，未删除', uuid);
                    } else {
                        if (model._geometryType === 'instancedmodel') {
                            delInstanceModel.push(model);
                        } else {
                            // model._geometryType === 'animateobject'
                            //     ? this.viewer.scene.removeAnimateObject(model)
                            //     : this.viewer.scene.removeModel(model);
                            expireHandleType === 'dispose' && this.engine.remove(model);
                            expireHandleType === 'hide' && (model.visible = false);
                        }
                    }
                });
            }

            const addModels = await this.initModels(
                {
                    deviceList: newDeviceList,
                    modelConfigList,
                    materialList,
                    modelMaterials,
                    reuseNum,
                    staticResource,
                    sceneDeviceList
                },
                undefined,
                true
            );

            addModels.forEach(model => {
                model.visibleInScene = model.visible;
            });

            this.dispatchEvent({
                type: 'sceneViewAdd',
                models: addModels
            });
            this._assetsModelsList = this._assetsModelsList.concat(addModels.map((model) => model.name));
            this._viewQueryStatus = false;
        };
        this._viewChangeListenerCall = debounce(this._viewRenderCall, debounceTime);
        this.addEventListener('camera_changed', this._viewChangeListenerCall);
    }

    /**
     * 更改去预加载开关状态
     * @param status
     */
    switchViewRender(status) {
        this._viewRenderSwitchStatus = status;
    }
    /**
     * 改变区域加载策略
     * @param type 'debounce' or 'throttle'
     * @param callBack
     */
    changeViewRender(
        type,
        option
    ) {
        const { callBack, time } = option;
        this.removeEventListener('camera_changed', this._viewChangeListenerCall);
        time && (this._viewRenderOption.debounceTime = time);
        this._viewChangeListenerCall = callBack
            ? callBack(this._viewRenderCall)
            : type === 'debounce'
            ? debounce(this._viewRenderCall, this._viewRenderOption.debounceTime)
            : throttle(this._viewRenderCall, this._viewRenderOption.debounceTime);
        this.addEventListener('camera_changed', this._viewChangeListenerCall);
    }
    /**
     * @private
     * 打开場景同步
     */
    async openSceneSync(
        syncInfo = {},
        host,
        option
    ) {
        const { scene, assets } = syncInfo;
        const { reuseNum = 50 } = option;
        const updateDeviceList = async (deviceList) => {
            const { modelConfigList, materialList, modelMaterials, staticResource, sceneDeviceList } = this._assetsInitParams;
            const addDeviceList = [];
            deviceList.forEach((deviceInfo) => {
                const { uuid } = deviceInfo;
                const device = this.engine.scene.getObjectByName(uuid);
                if (device) {
                    const modelInfo = this.genMeshParams(
                        deviceInfo,
                        sceneDeviceList,
                        modelConfigList,
                        materialList,
                        modelMaterials
                    );
                    const { x, y, z } = modelInfo;
                    device.position.set(x, y, z);
                    this.dispatchEvent({
                        type: 'sceneSyncUpdate',
                        models: device
                    });
                } else {
                    addDeviceList.push(deviceInfo);
                }
            });
            const addModels = await this.initModels(
                {
                    deviceList: addDeviceList,
                    modelConfigList,
                    materialList,
                    modelMaterials,
                    reuseNum,
                    staticResource,
                    sceneDeviceList
                },
                undefined,
                true
            );

            addModels.forEach(model => {
                model.visibleInScene = model.visible;
            });

            this.dispatchEvent({
                type: 'sceneSyncAdd',
                models: addModels
            });
        };
        const delDevice = (uuid) => {
            const device = this.engine.scene.getObjectByName(uuid);
            // device._geometryType === 'animateobject'
            //     ? this.viewer.scene.removeAnimateObject(device)
            //     : this.viewer.scene.removeModel(device);
            this.engine.remove(device);
            this.dispatchEvent({
                type: 'sceneSyncRemove',
                id: uuid
            });
        };
        if (scene) {
        }
        if (assets) {
            const { ws, connect } = await connectAssetsSync(host);
            const that = this;
            ws.heartReset().heartStart(connect);
            connect.onmessage = function ({ data }) {
                ws.heartReset().heartStart(this);
                if (data === 'ok' || data.trim() === '') {
                    return false;
                }

                const assetsInfo = JSON.parse(data);
                const { type, msg } = assetsInfo;
                switch (type) {
                    case 0:
                        that._assetsInitParams.modelConfigList.push(msg);
                        console.log('新增模型', msg);
                        break;
                    case 1:
                        updateDeviceList(msg);
                        console.log('新增/更新点位', msg);
                        break;
                    case 2:
                        delDevice(msg.uuid);
                        console.log('删除点位', msg);
                        break;
                    default:
                        break;
                }
            };
        }
    }
    /**
     * @private
     */
    onBeforeScenePrepareRender(engine, scene, camera, renderState) {
        if (renderState.viewChanged) {
            this.dispatchEvent({
                type: 'camera_changed',
                engine
            });
        }
    }
}