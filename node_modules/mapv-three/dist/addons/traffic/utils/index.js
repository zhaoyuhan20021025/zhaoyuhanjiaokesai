/*
 * @Author: wangchen35
 * @Date: 2022-12-15 18:52:11
 * @LastEditors: wangchen35
 * @LastEditTime: 2022-12-19 19:23:15
 * @Description: file content
 */
import {GLTFLoader} from 'bmap-three/examples/jsm/loaders/GLTFLoader';
import {Vector3, Quaternion, Euler, DynamicDrawUsage, Box3} from 'bmap-three';
import {InstancedModel} from '../objects/InstancedModel';

// 模型
export const MODELS = {
    BUS: null,
    CAR: null,
    TRACK: null,
    BICYCLE: null,
    PEDESTRIAN: null,
    TRAFFIC_CONE: null,
};

export const loadGLTFModel = (path, callback) => {
    const name = path.split('/').pop();
    // Load a glTF resource
    const loader = new GLTFLoader();
    loader.load(
        // resource URL
        path,
        // called when the resource is loaded
        function (gltf) {
            const models = [];
            gltf.scene.rotateOnAxis(new Vector3(1.0, 0, 0), Math.PI * 0.5);
            gltf.scene.updateWorldMatrix(false, true);
            gltf.scene.traverse(function (child) {
                if (child.isMesh || child.isPoints || child.isLine) {
                    // child.material = new MeshPhysicalMaterial({
                    //     color: child.material.color,
                    //     map: child.material.map
                    // });
                    models.push(child);
                    // TO FIX RoughnessMipmapper seems to be broken with WebGL 2.0
                    // roughnessMipmapper.generateMipmaps( child.material );
                }
            });
            // gltf.scene.updateMatrix();
            const uuids = [];
            models.forEach(model => {
                const position = new Vector3();
                const quaternion = new Quaternion();
                const scale = new Vector3();
                // const originQuaternion = new Quaternion();
                // originQuaternion.copy(model.quaternion);
                const rotation = new Euler().setFromQuaternion(model.quaternion);
                // const quaternion1 = new Quaternion().setFromAxisAngle(new Vector3(1.0, 0, 0), Math.PI * 0.5);
                model.matrixWorld.decompose(position, quaternion, scale);
                model.position.copy(position);
                model.rotation.copy(rotation);
                // model.quaternion.copy(originQuaternion.multiply(quaternion1));
                model.quaternion.copy(quaternion);
                model.scale.copy(scale);
                model.updateMatrix();
                uuids.push(model.uuid);
            });
            callback(models);
            // const items = models.map((model) => model.toJSON());
            // localforage.setItem(path, items);
        },
        // called while loading is progressing
        function (xhr) {
            const percent = (xhr.loaded / xhr.total) * 100;

            if (percent % 10 < 0.1) {
                console.log(name, percent + '% loaded');
            }
        },
        // called when loading has errors
        function (error) {
            console.log('An error happened', error, path);
        }
    );
};

/**
     * 根据模型数据的url地址，设置一个实例几何体
     * @param {String} path 模型数据的url地址
     * @param {Number} [count=2000] 数量
     * @param {Number} [isDynamic=false] 位置是否动态改变
     * @param {Function} callback 回调函数
     */
export const getInstancedModelByUrl = (path, count = 2000, isDynamic = false, callback = null) => {
    loadGLTFModel(path, function (meshs) {
        const imeshs = [];
        if (meshs.length > 0) {
            for (let ii = 0; ii < meshs.length; ii++) {
                const mesh = meshs[ii];

                const imesh = new InstancedModel(mesh.geometry, mesh.material, count);
                imesh.name = mesh.name;
                if (isDynamic) {
                    imesh.instanceMatrix.setUsage(DynamicDrawUsage); // will be updated every frame
                }

                mesh.geometry.computeVertexNormals();
                imeshs.push(imesh);
                mesh.updateMatrix();
                const matrix = mesh.matrix.clone();
                for (let ii = 0; ii < count; ii++) {
                    imesh.setMatrixAt(ii, matrix);
                }
                imesh.instanceMatrix.needsUpdate = true;

                imesh.matrix.copy(mesh.matrix);
                imesh.matrixWorld.copy(mesh.matrixWorld);
            }
        }

        // imesh.instanceMatrix.needsUpdate = true;
        if (callback) {
            callback(imeshs);
        }
    });
};

export const loadDynamicGLTFModel = (path, callback) => {
    const loader = new GLTFLoader();
    const name = path.split('/').pop();
    // Load a glTF resource

    loader.load(
        // resource URL
        path,
        // called when the resource is loaded
        function (gltf) {
            gltf.scene.rotateOnAxis(new Vector3(1.0, 0, 0), Math.PI * 0.5);
            callback(gltf);
        },
        // called while loading is progressing
        function (xhr) {
            const percent = (xhr.loaded / xhr.total) * 100;
            if (percent % 10 < 0.1) {
                console.log(name, percent + '% loaded');
            }
        },
        // called when loading has errors
        function (error) {
            console.log('An error happened', error, path);
        }
    );

    // return mesh;
};

export const computeTransformedBoundingBox = (box, transform) => {
    const vertices = [
        new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),
        new Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),
        new Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),
        new Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),
        new Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),
        new Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),
        new Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),
        new Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),
        new Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),
    ];

    const boundingBox = new Box3();
    boundingBox.setFromPoints(vertices);

    return boundingBox;
};

export const disposeObject = obj => {
    if (obj.dispose) {
        obj.dispose();
    } else {
        obj.traverse(child => {
            child.geometry && child.geometry.dispose();
            child.geometry = null;
            if (child.material) {
                child.material.map && child.material.map.dispose();
                child.material.alphaMap && child.material.alphaMap.dispose();
                child.material.envMap && child.material.envMap.dispose();
                child.material.lightMap && child.material.lightMap.dispose();
                child.material.normalMap && child.material.normalMap.dispose();
                child.material.map = null;
                child.material.alphaMap = null;
                child.material.envMap = null;
                child.material.lightMap = null;
                child.material.normalMap = null;
                child.material.dispose();
                child.material = null;
            }
        });
    }
};