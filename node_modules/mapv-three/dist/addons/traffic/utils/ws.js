/**
 * @file websocket相关方法
 */

import qs from 'query-string';
class Ws {
    // 构造函数
    constructor(arg = {needToken: true}) {
        // 三维视图
        this.lockReconnect = false;
        this.connectNumber = 0;
        this.ws = null;
        this.maxConnectNumber = 10;
        this.beforeReconnect = null;
        this.disposeStatus = false;
        this.needToken = arg.needToken;
        this.bindObj = null;
        this.recentMessage = null;
        this.timeout = 5000; // 3分钟发一次心跳
        this.timeoutObj = null;
        this.serverTimeoutObj = null;
    }

    reconnect(url, params) {
        if (this.lockReconnect || this.disposeStatus) {
            return;
        }
        this.lockReconnect = true;
        this.connectNumber++;
        setTimeout(async () => {
            console.log('重连中, 请稍候', this.ws);
            this.lockReconnect = false;
            if (!this.ws) {
                return;
            }
            const fn = this.ws.onmessage;
            const connect = await this.connect(url, params, fn);

            if (this.bindObj) {
                const {obj, key} = this.bindObj;
                obj[key] = connect;
                if (this.recentMessage) {
                    connect.send(this.recentMessage);
                }
            }
        }, 2000);
    }

    connect(url, params, msgFn) {
        return new Promise(resolve => {
            const token = window.localStorage.getItem('v2x3DToken');

            if (!token && this.needToken) {
                console.log('token不存在，请刷新页面');
                return;
            }
            const tokenObj = {
                ...params,
            };

            if (this.needToken) {
                tokenObj.token = JSON.parse(token ? token : '').token;
            }

            const paramsUrl = qs.stringify(tokenObj);
            const fullUrl = `${url}?${paramsUrl}`;
            const ws = new WebSocket(decodeURIComponent(fullUrl));
            this.ws = ws;
            ws.onopen = () => {
                console.log('WebSocket=>onopen');
                this.connectNumber = 0;
                resolve(ws);
            };
            ws.onerror = () => {
                resolve(ws);
                if (!this.maxConnectNumber || this.connectNumber <= this.maxConnectNumber) {
                    if (this.beforeReconnect) {
                        this.beforeReconnect();
                    }
                    this.reconnect(url, params);
                }
            };
            ws.onclose = () => {
                resolve(ws);
                if (!this.maxConnectNumber || this.connectNumber <= this.maxConnectNumber) {
                    if (this.beforeReconnect) {
                        this.beforeReconnect();
                    }
                    this.reconnect(url, params);
                }
            };
            if (msgFn) {
                ws.onmessage = msgFn;
            }
        });
    }

    dispose() {
        this.disposeStatus = true;
        if (!this.ws) {
            return;
        }
        this.ws.onclose = () => {};
        this.ws.onerror = () => {};
        this.ws.close();
    }

    heartReset() {
        this.timeoutObj && console.log('reset', this.timeoutObj._id);
        this.timeoutObj && clearTimeout(this.timeoutObj);
        this.timeoutObj = null;
        this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);
        this.serverTimeoutObj = null;
        return this;
    }

    heartStart(curWs) {
        this.timeoutObj && clearTimeout(this.timeoutObj);
        this.timeoutObj = setTimeout(() => {
            // 这里发送一个心跳，后端收到后，返回一个心跳消息，
            // onmessage拿到返回的心跳就说明连接正常
            console.log('ping!', this.timeoutObj);
            curWs.readyState === 1 && curWs.send('ping');

            this.serverTimeoutObj && clearTimeout(this.serverTimeoutObj);
            this.serverTimeoutObj = setTimeout(() => {
                // 如果超过一定时间还没重置，说明后端主动断开了
                // 如果onclose会执行reconnect，我们执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次
                console.log('close!');
                curWs.readyState === 1 && curWs.close();
            }, this.timeout);
        }, this.timeout);
    }
}
export {Ws};
