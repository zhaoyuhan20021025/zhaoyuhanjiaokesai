/**
 * @file 地图的基础计算函数
 * @author wema
 */

import {Vector3, Box3, Color, Vector2, Quaternion, Matrix4, Euler} from 'bmap-three';

/**
 * 获取Vector2
 * @param {Any} position 坐标
 * @returns {Object} Vector2
 */
export function getVector2(position, defaultVector) {
    if (position) {
        if (position instanceof Array) {
            return new Vector2(position[0], position[1]);
        }
        return new Vector2(position.x, position.y);
    }
    return defaultVector || new Vector2();

}

/**
 * 获取Vector3
 * @param {Any} position 坐标
 * @param {number} z 默认z值
 * @returns {Object} Vector3
 */
export function getVector3(position, z = 0.0, defaultVector) {
    if (position) {
        if (position instanceof Array) {
            return new Vector3(position[0], position[1], position[2] || z);
        }
        return new Vector3(position.x, position.y, position.z || z);
    }
    return defaultVector || new Vector3(0, 0, z);

}

/**
 * 获取Box3
 * @param {Any} box 坐标
 * @returns {Object} Box3
 */
export function getBox3(box) {
    if (box) {
        if (box instanceof Array) {
            return new Box3(getVector3(box[0], -1), getVector3(box[1], 1));
        }
        return new Box3(getVector3(box.min, -1), getVector3(box.max, 1));
    }
    return new Box3();

}

/**
 * 获取Color
 * @param {Any} color 坐标
 * @returns {Object} Color
 */
export function getColor(color) {
    if (color) {
        if (color instanceof Color) {
            return new Color().copy(color);
        }
        return new Color(color);
    }
    return new Color(0.6, 0.6, 0.6);

}

/**
 * 删除重复点
 * @param {*} points 点数组
 */
export function removeDupEndPts(points) {
    const l = points.length;
    if (points[0] instanceof Vector3 || points[0] instanceof Vector2) {
        if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
        }
    } else {
        if (l > 2 && equals(points[l - 1], points[0])) {
            points.pop();
        }
    }
}

export function convertToClockwise(vertices, holes) {
    let vertexCount = vertices.length / 2;
    let start = 0;
    let end = holes && holes.length ? holes[0] : vertexCount;
    if (area(vertices, start, end) > 0) {
        // reversePoints(vertices, 2, start, end);
        vertices.reverse();
    }
}

export function area(points, start, end) {
    // Signed polygon area
    const n = end - start;
    if (n < 3) {
        return 0;
    }
    let area = 0;
    for (let i = (end - 1) * 2, j = start * 2; j < end * 2; j += 2) {
        const x0 = points[i];
        const y0 = points[i + 1];
        const x1 = points[j];
        const y1 = points[j + 1];
        i = j;

        area += x0 * y1 - x1 * y0;
    }

    return area;
}

// 判断两个点是否相同
export function equals(arr1, arr2) {
    return Math.abs(arr1[0] - arr2[0]) + Math.abs(arr1[1] - arr2[1]) < 0.01;
}

export function getMatrixFromCameraParams(
    translation = new Vector3(0, 0, 0),
    quaternion = new Quaternion(),
    scale = new Vector3(1, 1, 1)
) {
    return new Matrix4().compose(translation, quaternion, scale);
}

// 从相机的四元数转换成欧拉旋转角度
export function getEulerRotationFromCameraParams(quaternion) {
    if (!quaternion) {
        return false;
    }
    if (quaternion instanceof Array) {
        quaternion = new Quaternion().fromArray(quaternion);
    } else {
        quaternion = new Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
    }
    return new Euler().setFromQuaternion(quaternion, 'ZXY');
}

//  屏幕像素坐标转换到-1，1
export function fromSreenToNdc(x, y, container) {
    return {
        x: x / container.offsetWidth * 2 - 1,
        y: -y / container.offsetHeight * 2 + 1,
        z: 1,
    };
}

// -1,1 转换到屏幕像素坐标
export function fromNdcToScreen(x, y, container) {
    return {
        x: (x + 1) / 2 * container.offsetWidth,
        y: (1 - y) / 2 * container.offsetHeight,
    };
}

// 判断两个盒子是否相交
export function intersectsBox(box1, box2) {
    return box1.intersectsBox(box2);
}