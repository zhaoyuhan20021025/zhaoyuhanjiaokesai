// import {Utils} from '@baidu/v2x-maptv';
import {
    Color,
    MathUtils as ThreeMath,
    RepeatWrapping,
    Matrix4,
    TextureLoader,
    CubeTextureLoader,
    Quaternion,
    Vector3,
} from 'bmap-three';

/**
 * 修改颜色
 * @param model
 * @param value
 */
export function modifyColor(model, value) {
    function recursionModify(object) {
        if (object.isGroup || (object.children && object.children.length)) {
            object.children.forEach(function (child) {
                if (child.isMesh) {
                    child.material.color = new Color(value);
                }
                else {
                    recursionModify(child);
                }
            });
        }
    }

    if (model.model && model.model.length) {
        let tempArr = model.model;
        if (tempArr.some(item => item.name.includes('body'))) {
            tempArr = tempArr.filter(item => item.name.includes('body'));
        }
        tempArr.forEach(child => {
            if (child.isMesh) {
                child.material.color = new Color(value);
            }
        });
    }
    else if (model.children.length > 0) {
        recursionModify(model);
    }
}

/**
 * 修改透明度
 * @param model
 * @param value
 */
export function modifyOpacity(model, value) {
    function recursionModify(object) {
        if (object.isGroup || (object.children && object.children.length)) {
            object.children.forEach(function (child) {
                if (child.isMesh) {
                    child.material.transparent = value < 1.0;
                    child.material.opacity = value;
                }
                else {
                    recursionModify(child);
                }
            });
        }
    }

    if (model.children.length > 0) {
        recursionModify(model);
    }
}

/**
 * 修改缩放
 * @param model
 * @param value 目标值
 * @param delta 目标值与当前值的偏差值
 */
export function modifyScale(model, value, delta) {
    const regex = /img\d+/;
    function getTargetValue(model, delta) {
        const tempScale = model.scale;
        const {x, y, z} = tempScale;
        const targetX = x > 0 ? x + delta : x - delta;
        const targetY = y > 0 ? y + delta : y - delta;
        const targetZ = z > 0 ? z + delta : z - delta;
        return {targetX, targetY, targetZ};
    }
    function recursionModify(object) {
        if (object.isGroup || object.type === 'Object3D') {
            const {targetX, targetY, targetZ} = getTargetValue(object, delta);
            object.scale.set(targetX, targetY, targetZ);
        }
        else if (object.children && object.children.length) {
            object.children.forEach(function (child) {
                if (child.isMesh) {
                    const {targetX, targetY, targetZ} = getTargetValue(
                        child,
                        delta
                    );
                    child.scale.set(targetX, targetY, targetZ);
                    if (regex.test(child.name)) {
                        // 缓存初始值
                        if (!child._initial_position) {
                            const {x: _x, y: _y, z: _z} = child.position;
                            child._initial_position = {
                                _x,
                                _y,
                                _z,
                            };
                        }
                        const {
                            _x = 0,
                            _y = 0,
                            _z = 0,
                        } = child._initial_position;
                        child.position.set(_x * value, _y * value, _z * value);
                    }
                }
                else {
                    recursionModify(child);
                }
            });
        }
    }

    if (model.animations && model.animations.length) {
        model.scale.set(value, value, value);
    }
    else {
        recursionModify(model);
    }
}

/**
 * 修改模型X坐标
 * @param model
 * @param value
 */
export function modifyPositionX(model, value) {
    model.position.x = value;
}

/**
 * 修改模型Y坐标（WGS84坐标）
 * @param model
 * @param coordinate 数组或者这个结构{x: 116.474402, y: 39.127744}
 */
export function modifyPositionXByWGS84(model, coordinate = []) {
    // const {x} = Utils.transformWGS84ToUTM(coordinate);
    // model.position.x = x;
}

/**
 * 修改模型Y坐标（UTM坐标）
 * @param model
 * @param value
 */
export function modifyPositionY(model, value) {
    model.position.y = value;
}

/**
 * 修改模型Y坐标（WGS84坐标）
 * @param model
 * @param coordinate 数组或者这个结构{x: 116.474402, y: 39.127744}
 */
export function modifyPositionYByWGS84(model, coordinate = []) {
    // const {y} = Utils.transformWGS84ToUTM(coordinate);
    // model.position.y = y;
}

/**
 * 修改模型高程（UTM坐标）
 * @param model
 * @param value
 */
export function modifyPositionZ(model, value) {
    model.position.z = value;
}

/**
 * 修改Z轴旋转
 * @param model
 * @param deltaValue 目标值与当前值的偏差值
 */
export function modifyRotateZ(model, deltaValue) {
    model.rotateZ(ThreeMath.degToRad(deltaValue || 0));
}

/**
 * 修改X轴旋转
 * @param model
 * @param deltaValue 目标值与当前值的偏差值
 */
export function modifyRotateX(model, deltaValue) {
    model.rotateX(ThreeMath.degToRad(deltaValue || 0));
}

/**
 * 按照x,y,z周顺序旋转，避免顺序差异导致的错误
 * @param model
 * @param x
 * @param y
 * @param z
 */
export function modifyRotateXYZ(model, x, y, z) {
    model.rotation.set(
        ThreeMath.degToRad(x),
        ThreeMath.degToRad(y),
        ThreeMath.degToRad(z)
    );
}

/**
 * 修改Y轴旋转
 * @param model
 * @param deltaValue 目标值与当前值的偏差值
 */
export function modifyRotateY(model, deltaValue) {
    model.rotateY(ThreeMath.degToRad(deltaValue || 0));
}

/**
 *
 * @param {Object} model
 * @param {String} value
 * @param {String} name
 * @param {String} type
 */
export function modifyModelMaterial(model, value, name, type) {
    if (model) {
        model.traverse(item => {
            if (item.isMesh) {
                if (name !== '全部') {
                    if (item.name === name) {
                        modifyMaterial(item, value, type);
                    }
                }
                else {
                    modifyMaterial(item, value, type);
                }
            }
        });
    }
}
function modifyMaterial(mesh, value, type, needUpdate = true) {
    if (type === 'color') {
        mesh.material.color.set(new Color(value));
    }
    else if (type === 'roughness') {
        mesh.material.roughness = value;
    }
    else if (type === 'metalness') {
        mesh.material.metalness = value;
    }
    else if (type === 'reflectivity') {
        mesh.material.reflectivity = value;
    }
    else if (type === 'opacity') {
        mesh.material.transparent = value < 1.0;
        mesh.material.depthWrite = value === 1.0;
        mesh.material.opacity = value;
    }
    else if (type === 'map') {
        if (typeof value === 'string') {
            if (value) {
                const texture = new TextureLoader().load(value);
                texture.flipY = false;
                mesh.material.map = texture;
            }
            else {
                mesh.material.map = null;
            }
        }
        else {
            if (value.url) {
                const texture = new TextureLoader().load(value.url);
                texture.wrapS = RepeatWrapping;
                texture.wrapT = RepeatWrapping;
                texture.repeat.set(value.repeat[0], value.repeat[1]);
                texture.flipY = false;
                mesh.material.map = texture;
            }
            else {
                mesh.material.map = null;
            }
        }
    }
    else if (type === 'envMap') {
        if (value) {
            const texture = new CubeTextureLoader();
            const CubeTexture = texture.load(value);
            mesh.material.envMap = CubeTexture;
        }
        else {
            mesh.material.envMap = null;
        }
    }
    else if (type === 'castShadow') {
        mesh.castShadow = value;
    }
    else {
        mesh[type] = value;
    }

    if (needUpdate) {
        mesh.updateMatrix();
        mesh.material.needsUpdate = true;
    }
}

export function updateMaterial(model, name, params) {
    if (model) {
        model.traverse(item => {
            if (item.isMesh) {
                if (name !== '全部') {
                    if (item.name === name) {
                        setMaterial(item, params);
                    }
                }
                else {
                    setMaterial(item, params);
                }
            }
        });
    }
}

function setMaterial(mesh, params) {
    Object.keys(params).forEach(key => {
        modifyMaterial(mesh, params[key], key, true);
    });
}

/**
 * 更新InstanceMeh中uuid的部分显示或隐藏
 * @param viewer maptv.Viewer
 * @param uuid 设备的uuid
 * @param status true：显示，false：隐藏
 */
export function toggleDisplay(viewer, uuid = '', status = false) {
    if (!viewer || !uuid) {
        console.warn('参数错误');
        return;
    }
    let index = -1;
    const instanceModels = viewer.scene.models.filter(v => v.isInstanceMesh);
    const meshList = instanceModels.filter(v => {
        for (let key in v._device_info) {
            if (v._device_info[key].uuid === uuid) {
                (index < 0) && (index = +key);
                return true;
            }
        }
    });
    // const instancedMeshList = viewer.scene.models.filter(v => v.name.startsWith(classType + '_'));
    meshList.forEach(mesh => {
        const tempMatrix = new Matrix4();
        const tempRotation = new Quaternion();
        const tempPosition = new Vector3();
        const tempScale = new Vector3();
        mesh.getMatrixAt(index, tempMatrix);
        tempMatrix.decompose(tempPosition, tempRotation, tempScale);
        if (status) {
            const deviceInfo = mesh._device_info[index];
            const basicInfo = mesh._device_info[0];
            tempPosition.set(deviceInfo.x - basicInfo.x, deviceInfo.y - basicInfo.y, deviceInfo.z - basicInfo.z);
        }
        else {
            tempPosition.set(-9999999, -9999999, 0);
        }
        const newMatrix = new Matrix4().compose(tempPosition, tempRotation, tempScale);
        mesh.setMatrixAt(index, newMatrix);
        mesh.instanceMatrix.needsUpdate = true;
    });
}

/**
 *
 * 修改平行光配置
 *
 * @param {Object} viewer  视图
 * @param {Object} params 平行光参数
 */

export const setDirectionalLight = (viewer, params = {}) => {
    try {
        //   投影
        if (params.enabled) {
            viewer.renderer.shadowMap.enabled = params.enabled;
            viewer.scene.directionalLight.castShadow = params.enabled;
        }
        if (params.intensity) {
            viewer.scene.directionalLight.intensity = params.intensity;
        }
        if (params.color) {
            viewer.scene.directionalLight.color.set(params.color);
        }
        if (params.x) {
            viewer.scene.directionalLight.position.x = params.x;
        }
        if (params.y) {
            viewer.scene.directionalLight.position.y = params.y;
        }
        if (params.z) {
            viewer.scene.directionalLight.position.z = params.z;
        }
        if (params.visible) {
            viewer.scene.directionalLight.visible = params.visible;
        }
    } catch (ex) {
        console.error(ex);
    }
};
/**
 * 修改环境光
 * @param viewer
 * @param params
 */
export const setAmbientLight = (viewer, params = {}) => {
    try {
        const ambientLight = viewer.scene.getObjectByName('ambientLight');
        if (params.intensity) {
            ambientLight.intensity = params.intensity;
        }
        if (params.color) {
            ambientLight.color.set(params.color);
        }
    } catch (e) {
        console.error(e);
    }
};